<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Scientific Fish Collection - Permit Application" />




<meta name="author" content="Al Irvine" />


<meta name="description" content="Scientific Fish Collection - Permit Application">

<script id="pandoc-meta" type="application/json">
{"author":"Al Irvine","biblio-style":"apalike","bibliography":"references.bib","knit":"pagedown::chrome_print","link-citations":false,"links-to-footnotes":false,"newpage_html_class":"page-break-after","output":{"pagedown::html_letter":{"css":["style-pagedown.css","default","letter"],"self_contained":true}},"paged-footnotes":false,"params":{"gis_project_name":"sern_peace_fwcp_2023","repo_url":"<a href=\"https://github.com/NewGraphEnvironment/fish_passage_peace_2025_permit\" class=\"uri\">https://github.com/NewGraphEnvironment/fish_passage_peace_2025_permit</a>","report_url":"<a href=\"https://NewGraphEnvironment.github.io/fish_passage_peace_2025_permit/\" class=\"uri\">https://NewGraphEnvironment.github.io/fish_passage_peace_2025_permit/</a>","update_packages":false},"title":"Scientific Fish Collection - Permit Application"}
</script>

<title>Scientific Fish Collection - Permit Application</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">
body{
font-family: Helvetica;
font-size: 10pt;
}

h1{
font-size: 12pt;
}

h2,h3,h4,h5,h6{
font-size: 11pt;
}

a[href^="http"]:not([class="uri"])::after {
content: "";
}
@page {
size: 8.5in 11in;
}
@page:left {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
@page:right {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}


.date{ 
font-size: 12px;
color: Black;
text-align: center;
}


.page-break {
page-break-before: always;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Scientific Fish Collection - Permit Application</h1>
<h2 class="author">Al Irvine</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img role="img" aria-label="logo" src="data:image/png;base64,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" class="logo" alt="logo" /></p>
<p><br></p>
<div class="from">
<p>Al Irvine<br />
New Graph Environment Ltd.<br />
<a href="mailto:al@newgraphenvironment" class="email">al@newgraphenvironment</a><br />
250-777-1518<br />
Date Original: 2025-07-15<br />
Date Revised: 2025-07-28</p>
</div>
<p>Ministry of Environment</p>
<p><br></p>
<p><strong>Re: Scientific Fish Collection Permit Application</strong></p>
<!-- Please note that permitting to Fisheries and Oceans Canada is requested for inventory purposes only.  PIT tagging is NOT proposed for salmon species. PIT tagging is proposed to the Provincial Ministry of Water, Land and Resource Stewardship (WLRS) for provincial jurisdiction species only to monitor fish movement and growth over multiple years.   -->
<!-- <br> -->
<p>This permit application can also be viewed online <a href="https://NewGraphEnvironment.github.io/fish_passage_peace_2025_permit/">at this link</a>. A summary of sites proposed for assessment, including historic fish presence records from FISS, is provided in Tables <a href="#tab:tab-sites1">2</a> to <a href="#tab:tab-sites3">3</a>. Fish species known to occur within each watershed are summarized in Table <a href="#tab:tab-fish">4</a>. An overview map showing potential sample locations is presented in Figure <a href="#fig:map">1</a>. A KML file (google earth) and GPX file (for garmin gps devices) of all sites is attached to the application with latest versions downloadable <a href="https://github.com/NewGraphEnvironment/fish_passage_peace_2025_permit/raw/main/mapping/sites_peace_2025.zip">here</a> or <a href="https://github.com/NewGraphEnvironment/fish_passage_peace_2025_permit/tree/main/mapping">here</a>. The KML includes detailed site-specific information accessible by clicking on each location in google earth, with brief summaries of background reports where available.</p>
<p><br></p>
<div id="brief-description-of-projectactivities" class="section level2 unnumbered">
<h2>Brief description of project/activities</h2>
<p>This work is a multi-year collaboration of many groups and an initiative of the Society for Ecosystem Restoration Northern BC. Funding for the project is through the Fish and Wildlife Compensation Program, SERNbc and the Ministry of Transportation and Infrastructure. Fieldwork is being led by Al Irvine, R.P.Bio., of New Graph Environment Ltd., in collaboration with field and office teams from McLeod Lake Indian Band. Previous reports are linked below:</p>
<ul>
<li><a href="https://newgraphenvironment.github.io/Parsnip_Fish_Passage/" class="uri">https://newgraphenvironment.github.io/Parsnip_Fish_Passage/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_parsnip_2021_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_parsnip_2021_reporting/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_peace_2022_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_peace_2022_reporting/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_peace_2023_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_peace_2023_reporting/</a></li>
<li><a href="https://newgraphenvironment.github.io/fish_passage_peace_2024_reporting/" class="uri">https://newgraphenvironment.github.io/fish_passage_peace_2024_reporting/</a></li>
</ul>
<p><br><br><br></p>
</div>
<div id="rationale-for-sampling" class="section level2 unnumbered">
<h2>Rationale for sampling</h2>
<p>Rationale for sampling is to inform fish presence/absence, species composition/density, abundance estimates, movement, growth, and survival as part of habitat confirmations and effectiveness monitoring related to fish passage restoration at barrier culverts. Habitat confirmation methodology information can be referenced in the above reports which builds on the <a href="https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/land-based-investment/investment-categories/fish-passage">Fish Passage Technical Working Group Phase 2 protocol</a>. Presence/absence of fish, species composition/abundance, distribution limits and fish movement can be useful for prioritizing which crossings are a best fit for fish passage restoration and inform baseline as well as follow up effectiveness monitoring.</p>
<p><br></p>
</div>
<div id="methodologies" class="section level2 unnumbered">
<h2>Methodologies</h2>
<p>Sampling methodologies will be dependent on the site, fish species suspected, type of habitat encountered, risks to aquatic organisms potentially present (Table <a href="#tab:tab-mitigation">1</a>) and ongoing communications. Sampling methods may include minnowtrapping, electrofishing, and dip netting upstream and downstream of current and past barrier culvert locations.</p>
<p><br></p>
<p>Sampling is proposed at streams included in Tables <a href="#tab:tab-sites1">2</a> - <a href="#tab:tab-sites3">3</a> where we will be performing habitat confirmation assessments and follow up site visits related to past habitat confirmations/fish passage remediations.</p>
<p><br></p>
<div id="pit-tagging" class="section level3 unnumbered">
<h3>PIT Tagging</h3>
<p>As part of this permit application we are proposing PIT tagging. When time allows and tagging is expected to improve knowledge of a system, our study plan is to electrofish small sites both upstream and downstream of priority culvert “barrier” sites and implant <a href="https://www.youtube.com/watch?v=9CKZ9yaS5o8">Biomark APT12 PIT tags</a> in the abdominal cavity of select fish over 60mm in fork length. To anesthetize fish prior to PIT tagging, we use a clove oil solution at 0.1mL/L (1:10,000), which provides effective sedation with minimal residual effects <span class="citation">(Fernandes et al. 2017)</span>. The solution is prepared by dissolving clove oil in ethyl alcohol at a 1:9 ratio before mixing into water <span class="citation">(Fernandes et al. 2017)</span>. Site location (UTM), fish length and weight will also be collected. In addition to providing information on abundance upstream and downstream of potential culvert restoration sites, the study will also provide information for monitoring programs to document fish movement, growth and survival at sites over multi-year time frames. Main objectives are to:</p>
<ol style="list-style-type: decimal">
<li>Determine if fish are moving into restored areas</li>
<li>Determine if before any remediation is conducted - fish are moving through sites where stream crossing structures (culverts) likely cause connectivity issues<br />
</li>
<li>Evaluate if productivity of the systems are increasing following bridge installation and/or if fish are moving upstream/downstream of where replaced/removed structures are located</li>
</ol>
<p><br></p>
<p>Dependent on how relevant tracking information would be to inform restoration actions, we may wish to tag select fish over 60mm in each site sampled. We would like to apply for a permit allowing a maximum of 600 fish tagged with a maximum of 150 fish/stream. Although we are requesting a maximum of 150 fish/stream, we have listed 150 fish of each species per stream because we will not know the species composition of the sites until the sampling occurs. In general, only salmonid and burbot species will be tagged with likely species present being rainbow trout, bull trout, and burbot. Based on past assessments in
the same and similiar systems in the region, the number of fish tagged per stream are very likely to be much less than 150, however we are requesting the maximum number of fish to be tagged to facilitate permit application procedures and allow for flexibility in the field based on actual sampling results.</p>
<p><br></p>
</div>
</div>
<div id="risks-associated-with-projectactivities-and-associated-mitigation" class="section level2 unnumbered">
<h2>Risks associated with project/activities and associated mitigation</h2>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-mitigation">Table 1: </span>Risks and mitigation
</caption>
<thead>
<tr>
<th style="text-align:left;">
Impact
</th>
<th style="text-align:left;">
Mitigation
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
High Voltage Injuries
</td>
<td style="text-align:left;">
Use the minimum effective voltage. Avoid contacting fish with the anode. Avoid electrofishing directly adjacent to metal culverts.
</td>
</tr>
<tr>
<td style="text-align:left;">
Disruption of Spawning
</td>
<td style="text-align:left;">
Avoid electrofishing during highest risk periods in likely spawning habitat.
</td>
</tr>
<tr>
<td style="text-align:left;">
Physical Stress on Fish
</td>
<td style="text-align:left;">
Quick/gentle handling and release of captured fish. Use of clove oil to anesthetize fish.
</td>
</tr>
<tr>
<td style="text-align:left;">
Injury from PIT Tagging Surgeries
</td>
<td style="text-align:left;">
Shallow insertion of tags and use of fresh sterile syringes every approximately 10 surgeries.
</td>
</tr>
<tr>
<td style="text-align:left;">
Mortality in traps due to predation and starvation
</td>
<td style="text-align:left;">
Ensure all traps set are retrieved within 24 hours.
</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>Please note that the sampling will be completed before October 31 (end of August till early October) however the end-date of the sampling period is listed as Dec 31 on the application to allow time outside of the busy field season for the data to be processed, QA’d and organized so that required reporting can be as informative as possible when submitted. An example of how we have been presenting results and methodologies from past assessments can be referenced in reports above.</p>
<p><br></p>
<p>Please do not hesitate to contact me if you need more information or have any questions or concerns.</p>
<p><img role="img" aria-label="signature" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAyADIAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCADUA30DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD6pooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoopCwBwSAaAFooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooo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/ero02PVuT9MAU8ah8RFhx/Y2ltJnqZR0+m8U+V/01/mDaX9M9Aorz1r/wCJDEquj6Oo7OZf6bjSm4+JAXiy0UtjpvPX86HFr/h1/mLmX9XPQaK4EN8RpHX5NDiXAJ3Mx5x04zST23xHmKiK90O34+Y4Y/llDUq/b8itO/5nf0V56dM+I+BjWtIyDz8vX/yFUa6D8QJJi8/iCwjB5xGHIH4bRT5ZeX3iuj0aivPl8LeMHfMvivZ/1zjb+WalXwd4jOTJ4zvQ3osXH/oVHK+oro7yiuItfB+tK+bnxhqMq91RNv8A7Mac3gBJ2Jvtd1e4PYmUBh+OKVn3/r7h3R18t3bQkiW4hQjrucCs+bxJo0Od+pWvHXa4b+VYln8OtCtx+9+23JxjdLcsD/47itK38G+HYDldItXP/TVfM/8AQs0W7sL+RSufH2ixsUgea4kxwsadf60yLWdf1gMum6U9jGQMT3XH4gEc/lXUWtpbWiBLW3hgUDAEaBR+lT09AMLRfDy2dwL2/ne81E9ZXPC+yit2iikAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB/9k=" style="width:50.0%" alt="signature" />
Al Irvine, R.P.Bio</p>
<div class="page-break">

</div>
<div class="figure"><span style="display:block;" id="fig:map"></span>
<img role="img" aria-label="Location of potential sample sites." src="data:image/png;base64,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" alt="Location of potential sample sites." width="100%" />
<p class="caption">
Figure 1: Location of potential sample sites.
</p>
</div>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites1">Table 2: </span>Potential sampling locations.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Watershed Code
</th>
<th style="text-align:right;">
UTM Zone
</th>
<th style="text-align:right;">
UTM Easting
</th>
<th style="text-align:right;">
UTM Northing
</th>
<th style="text-align:left;">
Watershed Group Code
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
125000
</td>
<td style="text-align:left;">
Tributary To Parsnip River
</td>
<td style="text-align:left;">
236-738000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
577541
</td>
<td style="text-align:right;">
6038215
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125179
</td>
<td style="text-align:left;">
Unnamed Tributary To Missinka River
</td>
<td style="text-align:left;">
236-614900-20900-03300-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
570307
</td>
<td style="text-align:right;">
6052836
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125180
</td>
<td style="text-align:left;">
Tributary To Missinka River
</td>
<td style="text-align:left;">
236-614900-20900-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
569665
</td>
<td style="text-align:right;">
6053046
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125231
</td>
<td style="text-align:left;">
Tributary To Table River
</td>
<td style="text-align:left;">
236-450800-15400-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
549962
</td>
<td style="text-align:right;">
6065137
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125261
</td>
<td style="text-align:left;">
Fern Creek
</td>
<td style="text-align:left;">
236-358400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
534601
</td>
<td style="text-align:right;">
6067771
</td>
<td style="text-align:left;">
PARS
</td>
</tr>
<tr>
<td style="text-align:left;">
125749
</td>
<td style="text-align:left;">
Unnamed Tributary To Airline Creek
</td>
<td style="text-align:left;">
237-625800-53700-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
374238
</td>
<td style="text-align:right;">
6102796
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
125755
</td>
<td style="text-align:left;">
Glaucers Creek
</td>
<td style="text-align:left;">
237-671800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
359563
</td>
<td style="text-align:right;">
6116606
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200034
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-792500-61000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
357257
</td>
<td style="text-align:right;">
6160917
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200384
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-528900-57600-16500-2290-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
403312
</td>
<td style="text-align:right;">
6145393
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200412
</td>
<td style="text-align:left;">
Gillis Creek
</td>
<td style="text-align:left;">
237-528900-57600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
400259
</td>
<td style="text-align:right;">
6152248
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200939
</td>
<td style="text-align:left;">
Nation River
</td>
<td style="text-align:left;">
237-000000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
325553
</td>
<td style="text-align:right;">
6152065
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15200985
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-077300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
458491
</td>
<td style="text-align:right;">
6137652
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201007
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-062300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
459777
</td>
<td style="text-align:right;">
6140085
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201341
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-449000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
408422
</td>
<td style="text-align:right;">
6121011
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201343
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-393200-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
417680
</td>
<td style="text-align:right;">
6121619
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201728
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-897400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
330395
</td>
<td style="text-align:right;">
6149308
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201740
</td>
<td style="text-align:left;">
Fish Creek
</td>
<td style="text-align:left;">
237-673600-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
355086
</td>
<td style="text-align:right;">
6123605
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15201834
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-688000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
362065
</td>
<td style="text-align:right;">
6124875
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15202084
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-124500-19300-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
460163
</td>
<td style="text-align:right;">
6130113
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15202950
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-713900-19200-08800-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
361739
</td>
<td style="text-align:right;">
6134520
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
15203146
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
237-877600-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
334061
</td>
<td style="text-align:right;">
6150367
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
16400428
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-906900-15800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
488458
</td>
<td style="text-align:right;">
6112359
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16400714
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-910500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
469038
</td>
<td style="text-align:right;">
6148922
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16400738
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-905500-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
491471
</td>
<td style="text-align:right;">
6131967
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401519
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-907800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
486512
</td>
<td style="text-align:right;">
6124976
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401530
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-907400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
486724
</td>
<td style="text-align:right;">
6116602
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401533
</td>
<td style="text-align:left;">
Dastaiga Creek
</td>
<td style="text-align:left;">
230-909100-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
479617
</td>
<td style="text-align:right;">
6141422
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401545
</td>
<td style="text-align:left;">
Blackwater Creek
</td>
<td style="text-align:left;">
230-913400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
456256
</td>
<td style="text-align:right;">
6156862
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401547
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-910000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
476480
</td>
<td style="text-align:right;">
6147560
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401699
</td>
<td style="text-align:left;">
Gagnon Creek
</td>
<td style="text-align:left;">
230-905800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
491234
</td>
<td style="text-align:right;">
6125187
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
16401990
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-908900-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
480206
</td>
<td style="text-align:right;">
6138995
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
198668
</td>
<td style="text-align:left;">
Tributary To Mcleod Lake
</td>
<td style="text-align:left;">
230-906800-71800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
501971
</td>
<td style="text-align:right;">
6087814
</td>
<td style="text-align:left;">
CARP
</td>
</tr>
<tr>
<td style="text-align:left;">
24718358
</td>
<td style="text-align:left;">
Buth Creek
</td>
<td style="text-align:left;">
230-906600-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
499574
</td>
<td style="text-align:right;">
6115412
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
62623
</td>
<td style="text-align:left;">
Suschona Creek
</td>
<td style="text-align:left;">
237-372000-61800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
422422
</td>
<td style="text-align:right;">
6108185
</td>
<td style="text-align:left;">
NATR
</td>
</tr>
<tr>
<td style="text-align:left;">
6559
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-906900-02100-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
489968
</td>
<td style="text-align:right;">
6112333
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
<tr>
<td style="text-align:left;">
6564
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
230-906900-19500-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
486579
</td>
<td style="text-align:right;">
6112299
</td>
<td style="text-align:left;">
PARA
</td>
</tr>
</tbody>
</table>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites3">Table 3: </span>Potential sample site details
</caption>
<thead>
<tr>
<th style="text-align:left;">
Site ID
</th>
<th style="text-align:left;">
Stream Name
</th>
<th style="text-align:left;">
Species Upstream
</th>
<th style="text-align:right;">
# Fish Tags
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
125000
</td>
<td style="text-align:left;">
Tributary To Parsnip River
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125179
</td>
<td style="text-align:left;">
Unnamed Tributary To Missinka River
</td>
<td style="text-align:left;">
BT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125180
</td>
<td style="text-align:left;">
Tributary To Missinka River
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125231
</td>
<td style="text-align:left;">
Tributary To Table River
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125261
</td>
<td style="text-align:left;">
Fern Creek
</td>
<td style="text-align:left;">
BB;C;CBC;DC;DV;LSU;RB;RSC;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125749
</td>
<td style="text-align:left;">
Unnamed Tributary To Airline Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
125755
</td>
<td style="text-align:left;">
Glaucers Creek
</td>
<td style="text-align:left;">
BB;CC;CSU;LSU;NSC;RB;RB/CT;RSC;SP;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200034
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200384
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200412
</td>
<td style="text-align:left;">
Gillis Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200939
</td>
<td style="text-align:left;">
Nation River
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15200985
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201007
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201341
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201343
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
CCG;LKC;RB;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201728
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201740
</td>
<td style="text-align:left;">
Fish Creek
</td>
<td style="text-align:left;">
BT;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15201834
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15202084
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15202950
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
15203146
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16400428
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
PCC;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16400714
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16400738
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401519
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
LKC;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401530
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401533
</td>
<td style="text-align:left;">
Dastaiga Creek
</td>
<td style="text-align:left;">
SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401545
</td>
<td style="text-align:left;">
Blackwater Creek
</td>
<td style="text-align:left;">
BB;BT;CC;CSU;DV;GR;LKC;LSU;MW;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401547
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB;SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401699
</td>
<td style="text-align:left;">
Gagnon Creek
</td>
<td style="text-align:left;">
BB;BMC;BT;C;CAS;CC;CCG;CSU;LKC;LSU;LW;NSC;PCC;RB;RSC;SP;SU;WSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
16401990
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
198668
</td>
<td style="text-align:left;">
Tributary To Mcleod Lake
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
24718358
</td>
<td style="text-align:left;">
Buth Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
62623
</td>
<td style="text-align:left;">
Suschona Creek
</td>
<td style="text-align:left;">
CSU;LKC;LSU;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
6559
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:left;">
6564
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
</tbody>
</table>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-fish">Table 4: </span>Fish species recorded in the Fisheries Information Summary System within the freshwater atlas watershed group areas where the potential sample sites are located.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Scientific Name
</th>
<th style="text-align:left;">
Species Name
</th>
<th style="text-align:left;">
BC List
</th>
<th style="text-align:left;">
COSEWIC
</th>
<th style="text-align:left;">
Carp Lake
</th>
<th style="text-align:left;">
Crooked
</th>
<th style="text-align:left;">
Nation
</th>
<th style="text-align:left;">
Parsnip Arm
</th>
<th style="text-align:left;">
Parsnip
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Catostomus catostomus
</td>
<td style="text-align:left;">
Longnose Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus columbianus
</td>
<td style="text-align:left;">
Bridgelip Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus commersonii
</td>
<td style="text-align:left;">
White Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus macrocheilus
</td>
<td style="text-align:left;">
Largescale Sucker
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus eos
</td>
<td style="text-align:left;">
Northern Redbelly Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus neogaeus
</td>
<td style="text-align:left;">
Finescale Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Coregonus clupeaformis
</td>
<td style="text-align:left;">
Lake Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus aleuticus
</td>
<td style="text-align:left;">
Coastrange Sculpin (formerly Aleutian Sculpin)
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus asper
</td>
<td style="text-align:left;">
Prickly Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus cognatus
</td>
<td style="text-align:left;">
Slimy Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus hubbsi
</td>
<td style="text-align:left;">
Mottled Sculpin
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2010)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus rhotheus
</td>
<td style="text-align:left;">
Torrent Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus ricei
</td>
<td style="text-align:left;">
Spoonhead Sculpin
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1989)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Couesius plumbeus
</td>
<td style="text-align:left;">
Lake Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
DD
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Culaea inconstans
</td>
<td style="text-align:left;">
Brook Stickleback
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Esox lucius
</td>
<td style="text-align:left;">
Northern Pike
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Hiodon alosoides
</td>
<td style="text-align:left;">
Goldeye
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Hybognathus hankinsoni
</td>
<td style="text-align:left;">
Brassy Minnow
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Lota lota
</td>
<td style="text-align:left;">
Burbot
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Mylocheilus caurinus
</td>
<td style="text-align:left;">
Peamouth Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Notropis atherinoides
</td>
<td style="text-align:left;">
Emerald Shiner
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Notropis hudsonius
</td>
<td style="text-align:left;">
Spottail Shiner
</td>
<td style="text-align:left;">
Red
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii
</td>
<td style="text-align:left;">
Cutthroat Trout
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii lewisi
</td>
<td style="text-align:left;">
Westslope (Yellowstone) Cutthroat Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Rainbow Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Kokanee
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Osmerus dentex
</td>
<td style="text-align:left;">
Rainbow Smelt
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Perca flavescens
</td>
<td style="text-align:left;">
Yellow Perch
</td>
<td style="text-align:left;">
Unknown
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Percopsis omiscomaycus
</td>
<td style="text-align:left;">
Trout-perch
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Platygobio gracilis
</td>
<td style="text-align:left;">
Flathead Chub
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium coulterii
</td>
<td style="text-align:left;">
Pygmy Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium cylindraceum
</td>
<td style="text-align:left;">
Round Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium williamsoni
</td>
<td style="text-align:left;">
Mountain Whitefish
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Ptychocheilus oregonensis
</td>
<td style="text-align:left;">
Northern Pikeminnow
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys cataractae
</td>
<td style="text-align:left;">
Longnose Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys falcatus
</td>
<td style="text-align:left;">
Leopard Dace
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1990)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Richardsonius balteatus
</td>
<td style="text-align:left;">
Redside Shiner
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Bull Trout
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus fontinalis
</td>
<td style="text-align:left;">
Brook Trout
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus malma
</td>
<td style="text-align:left;">
Dolly Varden
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus namaycush
</td>
<td style="text-align:left;">
Lake Trout
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Sander vitreus
</td>
<td style="text-align:left;">
Walleye
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Thymallus arcticus
</td>
<td style="text-align:left;">
Arctic Grayling
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Chub (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Dace (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Lamprey (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Minnow (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Northern Pearl Dace
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Salmon (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sculpin (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Smelt (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Squanga
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sucker (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Whitefish (General)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
</tbody>
</table>
<p><br></p>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-fernandes_etal2017efficacyclove" class="csl-entry">
Fernandes, I. M., Y. F. Bastos, D. S. Barreto, L. S. Lourenço, and J. M. Penha. 2017. <span>“The Efficacy of Clove Oil as an Anaesthetic and in Euthanasia Procedure for Small-Sized Tropical Fishes.”</span> <em>Brazilian Journal of Biology = Revista Brasleira De Biologia</em> 77 (3): 444–50. <a href="https://doi.org/10.1590/1519-6984.15015">https://doi.org/10.1590/1519-6984.15015</a>.
</div>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
