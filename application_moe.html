<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Scientific Fish Collection - Permit Application" />




<meta name="author" content="Al Irvine" />


<meta name="description" content="Scientific Fish Collection - Permit Application">

<script id="pandoc-meta" type="application/json">
{"author":"Al Irvine","knit":"pagedown::chrome_print","links-to-footnotes":false,"newpage_html_class":"page-break-after","output":{"pagedown::html_letter":{"css":["style-pagedown.css","default","letter"],"self_contained":true}},"paged-footnotes":false,"params":{"update_packages":false},"title":"Scientific Fish Collection - Permit Application"}
</script>

<title>Scientific Fish Collection - Permit Application</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">
body{
font-family: Helvetica;
font-size: 10pt;
}

h1{
font-size: 12pt;
}

h2,h3,h4,h5,h6{
font-size: 11pt;
}

a[href^="http"]:not([class="uri"])::after {
content: "";
}
@page {
size: 8.5in 11in;
}
@page:left {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
@page:right {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}


.date{ 
font-size: 12px;
color: Black;
text-align: center;
}


.page-break {
page-break-before: always;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Scientific Fish Collection - Permit Application</h1>
<h2 class="author">Al Irvine</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img src="data:image/png;base64,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" class="logo" alt="logo" /></p>
<p><br></p>
<div class="from">
<p>Al Irvine<br />
New Graph Environment Ltd.<br />
<a href="mailto:al@newgraphenvironment" class="email">al@newgraphenvironment</a><br />
250-777-1518<br />
Date Original: 2024-08-21<br />
Date Revised: 2024-08-26</p>
</div>
<p>Ministry of Water, Land and Resource Stewardship<br />
and<br />
Fisheries and Oceans Canada</p>
<p><br></p>
<p><strong>Re: Scientific Fish Collection Permit Application</strong></p>
<p><br></p>
<p>Please note that permitting to Fisheries and Oceans Canada is requested for inventory purposes only. PIT tagging is NOT proposed for salmon species. PIT tagging is proposed to the Provincial Ministry of Water, Land and Resource Stewardship (WLRS) for provincial jurisdiction species only to monitor fish movement and growth over multiple years.</p>
<p><br></p>
<p>This permit application can also be viewed online <a href="https://newgraphenvironment.github.io/fish_passage_fraser_2024_permit/">at this link</a>. A summary of sites to be potentially assessed (including historic fish presence information available in FISS) is included as Tables <a href="#tab:tab-sites1">2</a> - <a href="#tab:tab-sites3">3</a>. Details of fish species known within each watershed is presented in Table <a href="#tab:tab-fish">4</a> and an overview map displaying potential sample locations is included as Figure 1. A kml file of the sites is included as an attachment to the application and can also be downloaded <a href="https://github.com/NewGraphEnvironment/fish_passage_fraser_2024_permit/raw/main/docs/sites_fraser_2024_20240826_kml.zip">from here at this link</a>. There is an extensive amount of information contained in the kml file (accessed by clicking on sites) including brief summaries of background reporting data (when available).</p>
<div id="brief-description-of-projectactivities" class="section level2 unnumbered">
<h2>Brief description of project/activities</h2>
<p>This work is a multi-year collaboration of many groups and an initiative of the Society for Ecosystem Restoration Northern BC. Funding for the project is through the Society for Ecosystem Restoration Northern BC, the Ministry of Transportation and Infrastructure (MoTI) and the Provincial Fish Passage Technical Working Group. Al Irvine, R.P.Bio from New Graph Environment Ltd. is leading the fieldwork with field and office collaboration with teams from throughout the study area. These sites were selected from 177 sites assessed for fish passage in the 2023 field season or through <a href="https://www.newgraphenvironment.com/fish_passage_moti_2022_reporting/">past effectiveness monitoring work for MoTi</a>. Although incomplete at time of permit application, background reporting for 177 sites assessed for fish passage in the 2023 field season can be viewed below:</p>
<ul>
<li><a href="https://www.newgraphenvironment.com/fish_passage_fraser_2023_reporting/" class="uri">https://www.newgraphenvironment.com/fish_passage_fraser_2023_reporting/</a></li>
</ul>
</div>
<div id="rationale-for-sampling" class="section level2 unnumbered">
<h2>Rationale for sampling</h2>
<p>Rationale for sampling is to inform fish presence/absence, species composition/density, abundance estimates, movement, growth, and survival as part of habitat confirmations and effectiveness monitoring related to fish passage restoration at barrier culverts. Habitat confirmation methodology information can be referenced in the above reports which builds on the <a href="https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/land-based-investment/investment-categories/fish-passage">Fish Passage Technical Working Group Phase 2 protocol</a>. Presence/absence of fish, species composition/abundance, distribution limits and fish movement can be useful for prioritizing which crossings are a best fit for fish passage restoration and inform baseline as well as follow up effectiveness monitoring.</p>
<p><br></p>
</div>
<div id="methodologies" class="section level2 unnumbered">
<h2>Methodologies</h2>
<p>Sampling methodologies will be dependent on the site, fish species suspected, type of habitat encountered, risks to aquatic organisms potentially present (Table <a href="#tab:tab-mitigation">1</a>) and ongoing communications. Sampling methods may include minnowtrapping, electrofishing, and dipnetting upstream and downstream of current and past barrier culvert locations.</p>
<p><br></p>
<p>Sampling is proposed at streams included in Tables <a href="#tab:tab-sites1">2</a> - <a href="#tab:tab-sites3">3</a> where we will be performing habitat confirmations and follow up site visits related to past habitat confirmations/fish passage remediations.</p>
<div id="pit-tagging" class="section level3 unnumbered">
<h3>PIT Tagging</h3>
<p>As part of this permit application we are proposing tagging for provincial jurisdiction species only. PIT tagging is not
proposed for salmon species. Our study plan is (when time allows and PIT tagging is expected to increase our state of knowledge about the subject system) to electrofish small sites both upstream and downstream of priority culvert “barrier” sites and insert biomark APT12 PIT tags into the body cavity of select fish captured over 60mm. Fish location (UTM), length and weight will also be collected. In addition to providing information on abundance upstream and downstream of potential culvert restoration sites, the study will also provide information for monitoring programs to document fish movement, growth and survival at sites over multi-year timeframes. Main objectives are to determine</p>
<ol style="list-style-type: decimal">
<li>if fish are moving into restored areas</li>
<li>if before any remediation is conducted - fish are moving through sites where stream crossing structures (culverts) likely cause connectivity issues<br />
</li>
<li>evaluate if productivity of the systems are increasing following bridge installation and/or if fish are moving upstream/downstream of where replaced/removed structures are located</li>
</ol>
<p><br></p>
<p>Dependent on how relevant tracking information would be to inform restoration actions, we may wish to tag select fish over 60mm in each site sampled. We would like to apply for a permit allowing a maximum of 600 fish tagged with a maximum of 150 fish/stream. Although we are requesting a maximum of 150 fish/stream, we have listed 150 fish of each species per stream because we will not know the species composition of the sites until the sampling occurs. In general, only salmonid and burbot species will be tagged with likely species present being rainbow trout, bull trout, and burbot. Based on past assessments in
the same and similiar systems in the region, the number of fish tagged per stream are very likely to be much less than 150 however we are requesting the maximum number of fish to be tagged to facilitate permit application procedures and allow for flexibility in the field based on actual sampling results.</p>
</div>
</div>
<div id="risks-associated-with-projectactivities-and-associated-mitigation" class="section level2 unnumbered">
<h2>Risks associated with project/activities and associated mitigation</h2>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-mitigation">Table 1: </span>Risks and mitigation
</caption>
<thead>
<tr>
<th style="text-align:left;">
Impact
</th>
<th style="text-align:left;">
Mitigation
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
High Voltage Injuries
</td>
<td style="text-align:left;">
Use the minimum effective voltage. Avoid contacting fish with the anode. Avoid electrofishing directly adjacent to metal culverts.
</td>
</tr>
<tr>
<td style="text-align:left;">
Disruption of Spawning
</td>
<td style="text-align:left;">
Avoid electrofishing during highest risk periods in likely spawning habitat.
</td>
</tr>
<tr>
<td style="text-align:left;">
Physical Stress on Fish
</td>
<td style="text-align:left;">
Quick/gentle handling and release of captured fish.
</td>
</tr>
<tr>
<td style="text-align:left;">
Injury from PIT Tagging Surgeries
</td>
<td style="text-align:left;">
Shallow insertion of tags and use of fresh sterile syringes every approximately 10 surgeries
</td>
</tr>
<tr>
<td style="text-align:left;">
Mortality in traps due to predation and starvation
</td>
<td style="text-align:left;">
Ensure all traps set are retrieved within 24 hours.
</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>Please note that the sampling will be completed before October 31 (end of August till early October) however the end-date of the sampling period is listed as Dec 31 on the application to allow time outside of the busy field season for the data to be processed, QA’d and organized so that required reporting can be as informative as possible when submitted. An example of how we have been presenting results and methodologies from past assessments can be referenced in reports above.</p>
<p><br></p>
<p>Please do not hesitate to contact me if you need more information or have any questions or concerns.</p>
<p><img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAyADIAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCADUA30DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD6pooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoopCwBwSAaAFooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooo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/ero02PVuT9MAU8ah8RFhx/Y2ltJnqZR0+m8U+V/01/mDaX9M9Aorz1r/wCJDEquj6Oo7OZf6bjSm4+JAXiy0UtjpvPX86HFr/h1/mLmX9XPQaK4EN8RpHX5NDiXAJ3Mx5x04zST23xHmKiK90O34+Y4Y/llDUq/b8itO/5nf0V56dM+I+BjWtIyDz8vX/yFUa6D8QJJi8/iCwjB5xGHIH4bRT5ZeX3iuj0aivPl8LeMHfMvivZ/1zjb+WalXwd4jOTJ4zvQ3osXH/oVHK+oro7yiuItfB+tK+bnxhqMq91RNv8A7Mac3gBJ2Jvtd1e4PYmUBh+OKVn3/r7h3R18t3bQkiW4hQjrucCs+bxJo0Od+pWvHXa4b+VYln8OtCtx+9+23JxjdLcsD/47itK38G+HYDldItXP/TVfM/8AQs0W7sL+RSufH2ixsUgea4kxwsadf60yLWdf1gMum6U9jGQMT3XH4gEc/lXUWtpbWiBLW3hgUDAEaBR+lT09AMLRfDy2dwL2/ne81E9ZXPC+yit2iikAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB/9k=" style="width:50.0%" alt="signature" />
Al Irvine, R.P.Bio</p>
<div class="page-break">

</div>
<div class="figure"><span style="display:block;" id="fig:map"></span>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA0gAAAJYCAYAAABYRsb0AAAEDmlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPpu5syskzoPUpqaSDv41lLRsUtGE2uj+ZbNt3CyTbLRBkMns3Z1pJjPj/KRpKT4UQRDBqOCT4P9bwSchaqvtiy2itFCiBIMo+ND6R6HSFwnruTOzu5O4a73L3PnmnO9+595z7t4LkLgsW5beJQIsGq4t5dPis8fmxMQ6dMF90A190C0rjpUqlSYBG+PCv9rt7yDG3tf2t/f/Z+uuUEcBiN2F2Kw4yiLiZQD+FcWyXYAEQfvICddi+AnEO2ycIOISw7UAVxieD/Cyz5mRMohfRSwoqoz+xNuIB+cj9loEB3Pw2448NaitKSLLRck2q5pOI9O9g/t/tkXda8Tbg0+PszB9FN8DuPaXKnKW4YcQn1Xk3HSIry5ps8UQ/2W5aQnxIwBdu7yFcgrxPsRjVXu8HOh0qao30cArp9SZZxDfg3h1wTzKxu5E/LUxX5wKdX5SnAzmDx4A4OIqLbB69yMesE1pKojLjVdoNsfyiPi45hZmAn3uLWdpOtfQOaVmikEs7ovj8hFWpz7EV6mel0L9Xy23FMYlPYZenAx0yDB1/PX6dledmQjikjkXCxqMJS9WtfFCyH9XtSekEF+2dH+P4tzITduTygGfv58a5VCTH5PtXD7EFZiNyUDBhHnsFTBgE0SQIA9pfFtgo6cKGuhooeilaKH41eDs38Ip+f4At1Rq/sjr6NEwQqb/I/DQqsLvaFUjvAx+eWirddAJZnAj1DFJL0mSg/gcIpPkMBkhoyCSJ8lTZIxk0TpKDjXHliJzZPO50dR5ASNSnzeLvIvod0HG/mdkmOC0z8VKnzcQ2M/Yz2vKldduXjp9bleLu0ZWn7vWc+l0JGcaai10yNrUnXLP/8Jf59ewX+c3Wgz+B34Df+vbVrc16zTMVgp9um9bxEfzPU5kPqUtVWxhs6OiWTVW+gIfywB9uXi7CGcGW/zk98k/kmvJ95IfJn/j3uQ+4c5zn3Kfcd+AyF3gLnJfcl9xH3OfR2rUee80a+6vo7EK5mmXUdyfQlrYLTwoZIU9wsPCZEtP6BWGhAlhL3p2N6sTjRdduwbHsG9kq32sgBepc+xurLPW4T9URpYGJ3ym4+8zA05u44QjST8ZIoVtu3qE7fWmdn5LPdqvgcZz8Ww8BWJ8X3w0PhQ/wnCDGd+LvlHs8dRy6bLLDuKMaZ20tZrqisPJ5ONiCq8yKhYM5cCgKOu66Lsc0aYOtZdo5QCwezI4wm9J/v0X23mlZXOfBjj8Jzv3WrY5D+CsA9D7aMs2gGfjve8ArD6mePZSeCfEYt8CONWDw8FXTxrPqx/r9Vt4biXeANh8vV7/+/16ffMD1N8AuKD/A/8leAvFY9bLAAAAOGVYSWZNTQAqAAAACAABh2kABAAAAAEAAAAaAAAAAAACoAIABAAAAAEAAANIoAMABAAAAAEAAAJYAAAAAHRXjz4AAEAASURBVHgB7L0HlGXHed/5vZw69+QcMMAgEgBBACRIIjGAUYmS1mvJFo9k6ay8e6Q9XlvSHh97j71OOtJq17Jl77FWpo4CbUkUMyGKEkkQicg5zmBmMDl07n457f9X993u269fd7/u6UnArZnX775761Z99dVXVV+qryJNJQtTiIEQAyEGQgyEGAgxEGIgxECIgRADIQZCDFg0xEGIgRADIQZCDIQYCDEQYiDEQIiBEAMhBkIMeBgIBaSQEkIMhBgIMRBiIMRAiIEQAyEGQgyEGAgx0MJAKCCFpBBiIMRAiIEQAyEGQgyEGAgxEGIgxECIgRYGQgEpJIUQAyEGQgyEGAgxEGIgxECIgRADIQZCDLQwEApIISmEGAgxEGIgxECIgRADIQZCDIQYCDEQYqCFgVBACkkhxECIgRADIQZCDIQYCDEQYiDEQIiBEAMtDIQCUkgKIQZCDIQYCDEQYiDEQIiBEAMhBkIMhBhoYSAUkEJSCDEQYiDEQIiBEAMhBkIMhBgIMRBiIMRACwPxEBMhBq40DDSaDfvCS3+xJNiRSNRyibSV6xUrVyu2PjdsW/o2uuvx4oQ1I02rNetWq9esUC1a4yKfl5xKJC0bT7s2NM07qzmiXw19avWqFavlFcEUiURcexOxhEpbePYzd1Ix1RnLuufFWtHKjbJF9K9co76SpeJJyyRSDqaL9ScdAwdNGytPWUX9tKqkvo5FI9ZoNGypc6/BS6PWMHAVj8fdB1qq1Wqrqna5l2KxmPokY1HV156agrVQK1tV9LeyJJ1WXThraOpOToG6rlJUOEqL5qCPCvRVKbn36vW6AWfXifrUnGQsLti98QMNRWPzdW2US+r0DJjrjbo1G+7C1qWHrbeYsYce/K59/LMPWE9/j6PFaDViX/n612zP/j22fdcOmxydEH2m7chbR6xnuNduvOUme/z7j6mWpn3g3g/ai8++aOdOnLU9e3bbm28csJzy7L16rz39gx/ars1bbGj9ejv+9ht2y237rdhI2d9+94e2ecsmG94wbE98/3G7ev/V9uGPftge+s4P7IlHn7APfeTDtuOWXXZo8pjGyOpoMxqNGh/wsRRtOmSt0R+HV3CvMbGaBK30pLLWm+y1RMRjETrNKZ3Kpr/PFEY0nxQ7Pb5i72WSaUtGE5o7FjahpHHMHLqa/o2JNvpTfdaTyKpsj1aOPv+WvXfvzbZn125LJBKWLxbtT774p7ZB9Ltp/UZbv2G9bd2yxdLptFWrVfvuQ9+zifq0WUbjeF3MqtELQ2usWel4iuE/mwpapypLjI1ka03x34E+oCVwVdEcwJxf1zp8IdJQpt/R8GrLBta7d9xuscgK5sfVVha+d1liIBSQLstuCYFaDgPHi6ddFn/CbVSbFo1rGm7NxNyPR+NWqVQsnozb/p6rbfLUhK0bWmdbtchMzExaOVG2H5x4xjGL3sInRs9diNkW4+xxn16B/IVxmE3i7Zjk/UUxeB2Na6EL5p19ae4iUopYKimGNZKQ4KJhqHqdYKTFtiKm2S937o2lrwC7t9GjBSzpFqCFuSOWED76UlW3oM1UZ5TPSwgWk/pdK9YdTD2OqQ+0dWFh532nqf7JAGusYUW1+UThrBMW6LfFEoJNTGdbp+IJZYlJmKwLz7oSE8d9Ic2qakupXhIu2xZdNRZhmEbDzOeaGWvWolbqgpFzzKHIgW/Xr4uDOA/0WDRmfY2sw7uPaz8D/VsVgzBdyTvBzr/fzXezJtgrwxbNjIlu2trZVgAwg1OE355I1urVhuUrBYdrn2a7bVMwf6QZURlVCVdRJ7QgLDmhhzEhwQeagkEHB36X8r7rX+EPuBp15RH4qXTGeqNpe/voUfsv/+n3NW5jNrhu0D792U/blm2b7Btf/obgrtsdH7jd3ve+2+l6a6iMul6uO2aQa1FDtCGmq2pDm4Zta6NkD379r+zbX/2G3Xb9Prvlxg/ambEpK2pcTzTjNrBuyHoGc/bNrz8oJjRqyWTKdu7bZZIgLZaNWiQZsXqiaaeqo3Y0f7IrZQXto018kxCMSODBb7e7cQH/zOKeGjUfunpXUV+0JIFazPBAuk9MZo+bS+kzl/Q1e91WdsWN5VNSTFXbnlzZP3uaWUvHJBy0jX3wyziY0piC/leTThbP2nBm2GDoUdycGjll0xt2aexEnYCU0th673tvtfHpSdWTt4Fan8UTcfesJgHj1KmTZjsz1hgQbVdGrdqsrbrfO8FPX8clJPRazuJSzARRwPxVWkSxBbWwHmVrac25DNq6lHJSSDUqwpk3X7TXxzvM7+lo0o0fFJco7yoN2tR9AuaR6rht7d1iWSn9WkNy2QLoT96tCVaNZm8sr6TiZWsIM1xJGIhoMm/NelcS2CGs72YMMGn++aFvuYlsqjCtRWPGeuNZabVlARGzxfJ9bmbMxsuTtkELz/q+Ybuqd6f9f7/5+3b/3Xdb73C/feNb37Bf/F//J3t+5CVp/xqWEYNUljbszMw5Z1na3LNJ95K6V9VkWXNM5VhhgqK9SXOxUaPJlMWrm8REjEAGgx8VE8WkzCK7GqYGRnQglVM5i2u7YISzwlOxVlAbxZzOAukt8nlZlSpqL9rS3mR29umFuUBgk4UllbF8uWQnp88uWQ3MWo+sBzEJk0ktnjVZBmvO3ubx38HuwEIyVc7PMqquYGVA24qQlUwmrCeZc8zOgnwtKOgbiufbaeSFrCCzvySwesh7MPo54TEtunTltb+kKspi6GcqsmCq37tLwKPyShssmpDWOAlNLi3MxoWz3qQsWYJnRnjJl4rOagQuVpLAg7MMCW7aAz31ZLPOSpbX2CmISdRtl6eTkqBZ1/tqJxYrhAbKiKmMzT0b7YbBfdaQEFSv1WFLBJYE6EzKwVwultXmhqX4LQEGYQlBqCYBKVqPuX6uNiWsqT0pMbGOLvSspyxhSWNrOI0QPmpn6hkrxtfZaHXK8o28bUgOWaIOw6e6UtB8zvL5gn31K1+zWrVmdzxwpx1rnnW02TWuPNBXgta1zdvCP4MbRcBq5pIgQPQxY48PuMUKnRA9MRacYN3KjMBcFuN7TtajyZLo8h2WsKh1EpD8ZjKGsSShWFsNzpkLN/Zs0HzYY+cOnLDykSn78G3vt+uvv8lSok1ngaQyrX1OUaQxNDExag8/8ogdOHvEhm/YavlY0SbrM1IbBed2H8LVfTNGmT965O2QFA24AR4oarI04yzSgVsLLlEUuPEDbWotbalJFuRjXYe2+rSOodykLnDJ3FjSeC/I6h20Ni2HZ8rrVVlbezdpblh8XQwCUhV85VpJAlzFzUM/d+3ntE6hkAvTuxED3XFy70bMhG2+rDGQPikGW0LNDVdf7RjY/IyYPvGJI+fGtZjLYrRzn41OnXOLzonDJ+zcmCwUsiahtd+5Z4d9/JOfsPWZQbsqsctZMU4dP2l7duy2vQM7NIk3rMeyduzgEduxbYfnqjJo9pisTZOFmVmNuJugNe/CKDjt8QoXR97XHC5hRYuGmE9+uzJXgXlcnmBa4M8WSyzehWpBE3/7AuotTL2RnFViVdliPMaKxfHCJSwocm/UolcWYwH+lmJCWThh8GlDqY77zhxz3w4li2tSn5IWOYdPZXAWQb1CHSx4SdFIQzhHS9tubXI6IwlHThhoMZq+NWAl+GCBrgveRZPKTgnOhhiPvLSkzaXyBguRtSSC9SS/zWIJudktksALAkhWgiU4KYiJK5bKjsehbTA+oJF+dnjSNYxEJ024w0kL0b7rVhxri3AJY1iScA25gGe04IHucdDxvitXefiOS3ChL8DRqfxZGytNSsEx5x7aQJgaldY4pv5CgaC81UmxfrwruGGUcM+JSjisVWpWKpWkURfznkpaozJtN8bH7Lp1w2K4Mvby0RP2gtwS67kdcjMcs+nyjITSgh2JH9dcAeMXt6FGv22oDNkzf/u0nTx+3O75xP3WyEVsYmRx/HZEu3B4SRN9iLZ+jeDw5oyi6LPoimQcJEQjcQlKafUXTDNCE3Q2KTdZrJOQyRpVf0lROa/yFu3Pu9f6wdiBdisw1RIUV5NYlyZKU6Lrmg3t3mATmoMffPS79ugPn7D33nyLXX/dddbXP6DyTRajU/bUs8/bwbdet2Zf1LbcstsmT47aiekzltoqa19a428JeLuGT01BMM7JDRrFVHuh3a4PWJPn0sIVzi8HZVmGupzyhDXKU6JERHOZSMqSqZhVNL8wf6C0ZP5mHnBN7bB+MGegEBqNjduG3DpvfWnhxa8TuKgHd3vczrGAsj6GKcQAGIDqwxRi4IrCANrkb/3lt6wo3+xNWzbYr/9vv2a/+we/Z88884xt2rzJjh582z7/S3/fPnL/x+y3//1v2wtPvqC9BpvttedesQce+Ji99sJr9p3v/K3ddM119lv/7Lfl4iMmVRNnPj9j//Lf/kuLaBL+F//0X1g0JZcK1VWYKdg/+re/7hgzJk9fgIgksP7MaabELq4ajwuXjdUU1amU4FKAUWTxyR9hIRuVO0Lr32ogWOk7WAKKYiyWSgigiGxzKXg9d9e/AgtOoAkYZRBA0agjRCbl1w/DjmsfwrCzjLQYb6qBcW9GvZWU/EsJbn6dC789GGHo5/dAW07VBROCpJyX5tIJIm1Z5v9U6yISqKUtrpXWm01dZfGBN9SGhbSHXSkpd5WEBICK9kg4Dazg8akE5gL6xdIFo5sQnumPTgISMMAsg4tY3KsL3NSVH0EUgcY907325NovsvPbhrUBAc0vh/oK9YLNqC9mBVGhH16zWcFdD5iliFC9TjiTpyRlAI+zOMmiVBUcM6PT1jwry5EMGIX1UXu7dMIOC7VH4tssnROulKareTF7cqkTXmD6wXlOLjgwU9lsxu64/057/0c+YJPNaXtj/LCjkdX1v6tu9g9t9/HuGjP75AJceKS3pgX7RcLswkKWtO8k7256Y40R6vpDNDXbzjWF4NIWRtuCyR/TtJXrhIRS9vc1tK8TC+hKcYACKKkyYPyl+rAN+7bY4M71NnbinH3vtcftkacfty1Dm22mMGXRyjlL91Vsy53XWxIlgMZFTdbSnlTR6riZt4SAILwrvaZNCH098jjAu6FTodD0kgqgLiqljLjaPZju12fQU4RoPqnIIownQMOnJ4GAkIZfg14RdPrXqr+m74bwhms6+Asmxu6EPEnIn5HreEou7bj7xbXWRTX30U8od/CeoAxQx1xZUv1UtAaoDIITXl9hGAgFpCusw0JwPd/+z//y5+2Y9iz8we/8vo2MnLOiLEjXXne1ff5//gX70p9+yZ559Fm7cf8N9swjT9k//Xf/zHp7e+1f/e//WuYauduUK9rwrUlTE2B+ctJ+9O/+rO2/8Tr7d7/xb+zQG2/Z6WOn5MqTtF//P3/d3nrjoP2/v/l74g4bjrl2+iYtGM5NSJPvhUpM7PxrX5gXq8/5gQsuGBXa5U/t7DtKaaHrvMQtLM1bEC5cu9prhO/wYW1/5v+GeYUBWS6fn59u8QTXVjv43WLqWexZAIsNCRgIR25xFRDAIaHIZ4b5dhYWv9AVflMzZbN5Ox4ty69eTDj3OpQDvPjqI891u7m9GSvJupK38sR1EuRHLZIepQHzSvcXe8qvVMRwyMWQBB4ROoEpg9VFViDc00piSHApXSzRnmAwBixvvvXNtyp1fFeAzBO69BsYYLY9gUhMpgRYPjCXCDAewep3izGlLezvQQnh6lKbgIfk3PkkINYma3bzhv0KrnCHPfvq0/blc6/b+v3bZCke0j6JslxuZ9z+hgZWJwldvI04By4IwvCmBCKkMjTWME0IAeeTfPgog7bRpiXxdD6VXeR3/XFCtfSjr3hhznrnJm8GSsjFl4AN0Cr7Rn23L/ZuonBhT9JKE5ZUZ0Fuio5h9CMai/okt2Rsw4YtVhor2qmxaRvsLdjHNkvRk6jby7mY3Oo03zNmBjLyqEgrCM350ewc3N6YDPbz3DNveDI2gzQefL7ctf9eTi5w6yUYZWQ9QulBSsczlrSUhD3tKZSwVK0rmI0brwipDCL+65/mLNa7pO42mwm5j2tPpxQezHNeT1Eac0/DRhWYKVrCLufNH/Qfa4Sz/Em5UpF7KL8RsMD/rODXmmO8ksK/7zYMhALSu63H3wHtZUH+r7/3BTE22sMhYacuxgnGd+vuHZbNacJdv84mjmlz9YljNjQ8bNt2btO+i4Kt3zgshqvFBOtd5j7yb5bVqUff/QP9ctep2tnTZ+2GW260TG9a76y3XG+fMsvcKkHDcytaqCVfS7SyoR63KAXak++1NLVyjVqO8WBBKGgvjwM0AAzMX0XlZeQGcz4Mf6DINb/0F8tOBaubHBNNhKdOief0KYtm649j2MpoADsk3DLYKxFM1B/VRv3FmIFg3pVewzyxP4E9X0RVxBImaBcmLfYJuZOVanpOe5ZJEblCxjIjVp3aZ9XRmyy5+VE1f772lCKov1CSIBOI1IfAhIDfq30VWI8AqEo+WVRc3Q6XcwC4e/AmSivFkWNUED5bbeIbV1cEI1zxmkkJvgDULFlUQkk9SpRFwcfgDrznKtcDJ1SJFhwcEnQQKuvk1TaB3kTJps8etKefbNrZwqgNb99sW/s223hx2s4VJ90YQjBijwECm99MH9tEu5zRPIFbH9ax2Qyu8pX9oZ1ETPTbjWC0UtytrMbV52ZuIapnZ8Jcfbn+m8xB4CHItPrPrpTvoADImIpHZY3QnNqIS0jSv7qY6gRzrISn0fyYs4AsN2cH2w49YglBDVSRQODc9Rx1i0o1PlLDWctskFKjLmG/csA2ay1K1+TSGOsV/cfs5KGSc3FMb5C7o+ay80/eOomCDfezhcThzVP+2OmmPkcBegFPBazm/aleF8EP919/nFAO+cAdgSESEpYacoNl3CJ4VptE/vQCKPj4dTA4NGlOk5A6qTm+XUhlrAu9wqjaov9VKa4Y4Ew9Xo18k7xS/bLPaxLwCgz/XsEYCAWkK7jz3q2go8X+5X/yyzYt689v//PfckyT5lQ3AbqFWNdMcAMDfTYzNaPN+YrOpuANVQk/7cm58ehmcIJOZ9N25twZBXxQ0AOVUw9oBC8sk4OrRtJN8jCQTPxp+V7XpBlDwz03abe3wvvt5nrlCibaRchwrCZZ7dnKaKN1a1UIZrtk1yyGzkowH+xZeMABGkAWSBZrn8kCFyx2RTG17GFyApTK4D7l4cK1SJGBsildCzauW95KOftsrS48eJpiakqOTrMKlsAeDr8dfj3kQx86lzzYvN8LW0LrI6kxRSpTwI3SJosXFbQhd0yEPF94h34JFUzgjRntn6NUcEWkKCcc6TcCZkl7oKoSomZd3OYAcVdOoBCO+LeipApd9ED/Jf12+4sUBIHxOKCoW7vjM7YvroAK6Zi9LGHu2eo2q8V61Jb5Ap/DGUKTmPkGTJZCG++rnrKNpv1HasPG3VmbmJywh089Z5kd19j2PVud1eisgqtg6ULGrlc6uzwScpigD86k5MN6Ht/QE4IWVi+QjpBwXjSmMlz7WzR+HqAteBXY6FaNGjeHLsiwqhtEEaXNEmKdFdBjeoPz7KqKvUQvYQlORCsuUAN4wuKA5ZU+1U4suWx6gViI+oeb6mRhErFpReOFPZnOMoWw6o3Uea2FlvKaIw7LQrJegWaS5VOWV3S9fKPPpsYHNGYUzY73GKIUcR6Jce6C3ShKHcq6TqmOxIEWo0Py5zfK4ZpvBMpcIqcAORL2JMg4JYgWYD9vh2JcM3iXuZ99pXXTXkLhCQGSPmBdCM5I0Bu/l0PB/LFIDWEKMbAQA6GAtBAn4Z3LHAO4qzz4pW/Z0cOH7fiRY9bUwqFt3GJAmYi1Noihxh95786rLNuTs3//r37HNu3YbM9oL9KnP/lJWYnEWothItWl5WUW5j20gCxCt99zp/3zX/tn9of/+Qt2+u0TNnZ2zGnc3QsX6A+LBFH4/Ghj/qIBw5qTBg0rme/KsVIQaBtCw0xZlqgU4bW9Bc+vY6XlrWV+liY0iOWmrDqLrFIISFhhsMD4CxsMb1HhvNEmuj53Wk5Bph/dLncuX4c6HV4cTbjCzru5VAEb4Z+lQ4RAvx3Bwn1GkntNBB2F847ALMXYdCPhHn6EBiqcdbPSZ7Xx66xelt++7tbzWy2ahUGan3gFP36EobQEZM4toe5ZayLCkZgN9ic5Rnn+605xwJgAJ4vhq+2VBT9990ZAJ5JdRAJpspS3W5Jn7c6BrA1l16l0MZ2KYHd3X9L6x07bI9Uhm4kPMarnynPdIeFI9DCk8Nt36ByoG7VxPa32aOCKUVTIY4WNz8olqa93WGfDFOx0fkI0omAP5BEy2mke/KBNlmOUE6Kc5Yh8wkunPpoDZvErhysxfr6wOeteKBBWmyjT9QNzHNYoCV+d+ms15TtXKZAjVHNNu1fbduqHTrzz2KTYEO4dPsD/FZx8RRMyAWdx+cKR16Q5qsLlazgtYUUKrWkC4oBPCL+LhKIHCmV+JjCJs+q1vQcaz8X6NGZnbF0zb4caEzY5skNjX14Qw2dlPRp3dN722qp+AndJ1laCmLjzsGgGA0bJ7UFzgWW83/x1/ax3CNiBhRr6dC64msPWZ9YrCqmUQ7g6y/LrMNYqa66Epa/IjvgTcy6OBGrJCg4FntE4d7KanoNv5664dFHh0xADXWEgFJC6QlOY6XLCAJPr9MSU3XL7rfa+D9yhgyX77N6P32PNTFRa6bLtv+Fa27RpEyHC7B/+439o3/vrh6w322u/+uv/i+25+irnXvOjiR+xdCZjP/GzP2EDQ4MSqur2wI9+wnZv32kbFdDhH/zKL9qBV9+0nXt328HXDzqG6ULhgIkfDSShVGFk55Zbxw471z7OcpiRCxQLQDB1u/j67+CuR31NMXBYYHISypYKDe6/d6G+WfAJDrA0Q+a5TEyiLWzxGjAsjoltAcYhqDzE/xx3mJXiZV77hCBCSasQt9Cvxb4Rj7fgfA1pP/UJhv5mceesj6Jca7yFXjfYi1DYKiHoesdQRKS9jmbOya3urNVmtlijvEHC0ZBcPhWRICoXPlmQ4vodSY+4/MH2sNeKzePgmP1cbIr2g0+gSKBuiILgFR5c2rNE8AUJUzDlCCSuf4IGrmAFuqYvKAP6RDDw+5Nv/5oMTussgWR9vGy398cUwjhjT4+dszdjg3JJU2jt+ITdNjBsfTMT9rxC7pcI6S6LG6muDdbS49uQFexORZjbme6xt/KT9pLO7JmJSIkgt6dpuRxZtEdWtWkn+GEVm6vfFTPvD3AHz+whL4ypvx9iXuYufsziS0IMOAYXTlASbs4nOTyqTGgyiF+/TId//ViqrX7e9u9ZZhUi1fTiyhLKVzeGUHgQbVIWOY1Xmk2x74REe4h+WJTQgGIGQSjJvBPoW3CJtQMFRKSyspYzhNhLyph00RU1TuOaGwkmQKJsnctihcSQnauO2TYJLpmS6Hdyq1Wm1XEK0hBJyl0YOlmjhHIK5QlKLA0NN38Qqa+I8KdnJGpjDSGSKtEp2S+KJQdhpplAucK+IgWL0XPaOA9h/FxhcvSqsmlmVkIX8z194rc60B0rLDnMHmJgPgZCAWk+PsJfVwAGYBA+9gufdhufq2L8jtROWnNbylkUHj3xnK3rH7J0f689ePghyyky1T1/5z44By1qZTtdH3VeSL03rLcXR1+z9TdtsiOVE5YvlGz91UOWlMXprUMH7Qd/83277uab7IUnnrF9117t9idVp+fvXTlfVDGhx7TwpKWRTGuBYXN458m96fLA3HpuDbglwIzC3Iqp1rW/OCwHE9q1mbLOq9FbLLxZCUi827ne5Upbm+cx+dPDTCI8LMWUsYnZW2Dn14vwyEIJFqpRbW6WJQGXmJVob+eXqJK0+jpGGa5gjRJtg+HA3ZHNwTAQbD5GS4tG1mdyaQcCUbzniCwucg3VHqNYUi49fYcskpiQ0CKmTLSSGHpRh5qeUR7hbuw9VpvebQmCNXRInI0ieXiWaYeJARZCdFfFlKWEwxzuf/SD8FxU2Gz20PDPZ869wBcdCtctX7CINuRSJUsQye3lgblroRDXunJJm6FV5oa0zihJZO21fNGezF5vM1h0Y3X7m9q03TZ52m7rzdl1WbktwWS7Toctkkgv4SUW71Ef1+xJBWZ5vrHRprP9DpeuUuWN61lBDDrt8+t2z5b54xhQcM9Lq+x2H1cMKCxHziJFWassD5D98e0ErUXaAMy+8mQ1QlKwWIdvULcKRps5ij0rPi37zXY4dW25lDNNsJWrv4auJhSWnrEzpOhrveneWfqjnURULDmr5OoUNQgenClWFPIYcwhbCB5YcjgQu659OadKMZ0NK2uVotqlUwWbKuatoIOQ433KIcUg+PdxvvqWem/STtPeH9eXmndU+GyRjBlc8BDosBy5ecBRLHSrsSq4OT8K74i5t2ZfP+8LiUmyuGXd2sH6Qbu7Pi7hvGsPC3inYyAUkN7pPfwObB+T4GPHnlbLmIL9v95yAJNwfEYCk6bzurTHWqu1B8OLXFOXe4rHvMFkefd4C6EBkePI5DHb1nPG3rPxervn4/fba8+/Yjfdfot96L677NDUUZ1SPi2hYgk1+gpxjYDSryg+bFpdfvFoat+IGONAajS1YKoMwlUvJ1wEXnOX3vKp1q+hANBeR7e/YapwO5sWUzDrjtTly5mWcOS3g701CeElE9W+Lbntwai4/TPe8t5VqZQ16xbW1Rsry4Rvf0FWGwQkDor1Ngy3l6G+iZUtOfCqxbTXKKrrSPqMMklDP/C6NMmv6xIuVmyLaDna87bVpvZaoqq9Owmd1SUtbzBB5wS5A9fuTCnVDt3gdgkNZXUYJZpvxk9BVthyuRWuGFygDZ9fXLDo2WvqULGuPA5a1U517YsQpTlGW4xzSdGlNNZymYRtUJjyRixnZxsR7aOgKZ5QhQXocR3eemriuA3KUsR+LeKFCTCnTSfMBU5bh3Vm16H4Jh38KndFwQyA7N9g87cXkU/7E+Q62G2iz3kfIYT+mI1i1W0BrXy01Q/3T1vPN2FZBvXsT/E19h3LJJOqc9HyVm39AY1eR/vfHeta4qYvpHXK4oo+f5R0KvqS3GPf3mkpYwgXP6Qz9ZiLSCitiG7H6uTGxAqh89+DfBA2cVNrRkoK0JBwB09DXyOxfivosOOrUuM2OfQVy/Sss2pcigKNLb2hd/h4e25BOXMNtL3S+RXQXRs8shCBtXegHmiMsoaRvBXZXcqBQ8GB4jlnWWp/y8tx/n+pj2AOHIA+XZ3R/CZ3eyl5yihpAI0/YQoxsEoMhALSKhEXvnZpMbBwIfamZiZEbw6XECQtOaGb4RVhVpgqo2ycbglKBHtg0fCmUO+94zNntLA0bOd1W+2eG7aJ4WjYm6WjdnjiGLP/miZvZwdFAsHyhbfnwI2BRZnNq3ntx8E9w2tLZzD9xQscYcHIEXpaZbSX2/ntC3cXmNGS9klImlqBkJQR85iT5SjIzNEWfhMhLSZBKS2rhAtfLWHAWRQuXDO6LtlFllM7id7GFqPFkzAjS1Ks56jIAyx5vev+uj9iSvQ+zpJEtGsoWEN9RofHDr2q+55bzvyyWwyb+hwBDdcZZKxMRoelih7QvOJuVtD+IKc0EHxYQJxLHhYnMWrdMFjgHwGTs1mqEoqwkgIu7ybTaWmci7ZeDH9JMJ6qE8igjlzlEvlKOtz1tfjVTvDhN2MX4QDm32u2+6snBO2VPCjtdErugZxxAh3hUliXVc4hR3+XS4wLxgHCFZY1xbFz1oHzEXAo0zFnPqjLAdH2HIYT2gYuDhFeVDhS//PMzYfQgqMpVbrKenkPuINjqg20Vf0UWEqUS3+uqojL7yW1BdxzQG5J3gm9Sbl2SuGBGzNWJNf/K4AaFDFW9GKrT0GUt37B9DPWWTNiGkczyfV2tDhm18t1/IFc1M5MH7NTxSk7U+qzseQ6ueENWkXzKYoFDRzRNbYWCf+Cl307uPFROnWeb1rM0JiSVQm3O+q5kImxlpKVCqUGHiXrNX8gvHLGGfu6uA/drbQ/LiTMYdlXBgZCAenK6KcQylViYN5Cr0kShsN3VXHa1kC5brHQbH6qcNbOFEeU11s+YLi8q0DmtbjUxI1Pe5+sSPPgXGHZCII9kYxzw2A/STCYA4sC7cBaBdPlWw+SWnDBw4VevLptCvj1+2X5dxQRSQKQx0Bi++uc6D6sIzl9aK9noZJEcAGT349LMdf+Qr20cOQDqUYs1kA/C9/RgoSkk1bL77JY9Yikhrze0/QeeJd6EXyKYuBIMHdsmkbI5hkCDOHwCQiCxAJd9WVybv8BLosVAml0mbCkJDKyeJblclT03EBTEsQSyYjlxJwNKRTxhJiX6dgwVc1L0AJ7LWbZN+hXDB57QCoSuBDU2GeRy2atN5N1CgIEOVwiyyq7LGaVNtAmmKduEq5LSKsFuToSTGOp/luuPIQVglGoeidg8r3S5LkrKUS/BFaY7vbE3EX/OTj9Jqoe8O7TYPs73fx2764C3uXKpjsZj+8Y4aitwTDiuMqyd8255q6i03G1zjilFYjyrEeuf0WXvpIBIYeim7LOvJraY2dnjtn22LidO1603kbSPrRHrmyxMTtdPmunZUU5FVOwk/QmWWulDBPy05rzk4oQifWYCKDsFYN8VtvlqBeJVji/DPZhyZKvD/cvRmKcE9wirfOTgKlfbo8oOpkLcFecqRW8PZVOWFptay9GS8I6LicMhALS5dQbISwXFQOe68/CKh1jpcXE2++zyOLh3JvESOK3xCeYeIZbEItZ+7NAPhYPmD4YU7eBNfBspZcIF9moNOASAIst1yInDOm3t9GXZYN/SuJUWFAu1uLVTVuABeadz3IJ4Yj9K4vv2WorQY3GypBRuPS8rCYXquXgFjc1mHUX+KANjAv3U/0ql0ICNEQK26x08l6L9x7WfoRD4tAl1LS52wEHOGDjdQ/7jqTlBe9YIDkLyPFgopG4hCd+sCepJAvlSgimRWmWSGl/GS6ugiGWkCVJjNmgFa1P1pFjebnyiSF0Vh8xaosJ7P7oisR1JWaxMaO9ahpeuFNywC6MNxpxBBvC//qWQsfsL09OblSwR4tIiViXV9RQkBlIMLTNGtiFqRX+3IALZFjiEngRjLAS8M+FMsZVq0MbmLtglhEWyUsCf90rGZYAJPCIfqRMmuHOw+kASyD7vEuHCwmKCIwI23xoo2P65+V8Z/xwNC9E+bS/klYxBrOiZRR4DtkqR6cqqQgw7/fwXIm4lVZlKTnZc42d0WCYGhi1bOmclWembEcmYtsVwOQqlVeu5u1w/kV7NbHRxlNbhX/cZRXpUUoR9h1i+eKsvaX6xEGgfmxXKAJNxh1boEPIAgkSwaLj2hK4fzEuwb0jUf1xVthY1u2tHGpo1pEAO64DY6fLUh7RqDCFGFgGA6GAtAyCwseXKQbEKHVi/C4stKpTiwusST0vrVxF2u/0WX20MT6qPRfMzNLiNcoDeqYQxUntHUmP6b7P4i2EDuaBQzqlb9NDCji/lOB8Gy223vyv5UIXwVK96+Cd86tvrd4GXlwhllqoWdWIhkS4WISjlaWWG0aCc6Fwv+ouOXiErm4062AVywauf1zj5nExUzRWsljuqII1fNjK5xTlrtJvqXXPdRSSYF5wq4NpJQw2gRqwZgI3TDpnJ+HCiWCEwOEJDnOtcSwbeIHSPGKbexi4chY8WXkYruwHi6jO6VpMGt287R8YsvzEYXupsd3OnJZr0tsKUYxeYYnyorm4pTb1SvhLOgUGwS1g3MsSjIggF0yzbmfLwMg7WGO6SiBoCfhcVaKBpel4YU2MW1xl6QssRk3tzarJXaiTcOS/jZAEfl34byF4rYUj6qGfwaOjFTHsVQRQAbUUCnz4ghYu9n66yIDI3O+GBIJc53WDKQKueuMtiFhIbf7s7W7M+4M4QFS5Xh1obrbB3pCy7S0JAunytK3Ln7Xd0ZLtHVhn27VP6pXp5+1gaocV0xtUTdONt/Fj56zoLLwE1phXtPeDe7LeZvcMKHy+IkSSqdUkXFIR6vzf/tvugFcppEgI+yReWY3g6F4+jz/+OGS+4/wlgklkdTzAWEGH+WqsuXn9PMoPX31nYyAUkN7Z/fuObV2zKrc0txl9pYzyHEo8vdzctA2DwYTqT6pzOXUFh1dVtJziVqtP77TqzHbN/nJNihUsnj3lnUGjiGP1gvaBSDiKSChKbvihNs0uDLs8r1z9IKoZi013S2n72wt/Byd9b3ny8nDd0AIavMcT6iVMK3piDyfc7S75LiUut9+A9gq6Kgr3L5ZTzzUq+Ao95FzBYnLRQvhD6ltFwtWQBR0XRHC+aBL84AE6IJIbCGJPU7cJwSK+Shi7rWNhPgGpg06xImE9qoxeb7XJq5VNguG658XkEIlqbqzQNvYbEc4bRpZ2YskEbMYBbncIrIT6bk+ORrQHGjwijC+WELRyBCFRoXkFg8CSqYgTdqI5ZN8u1uyD9RG7VecVld44ZbWz2+wTt3zS0tlcx+KgAejj2Im37dWzB60oy1gpKeGupMNtVX6Q5FzfofFuMXNYcnjfwd2x9OVvUhaf5bTi1OPOKNJo6iZRHrjm3CDctNi7QmMcrMFGLVIYY+FCBhShWtqNNSupviNoREVCKQKzgxGy079OCeFb9nFneaAM6CUqGlzt+O1Ux+V4DwVaoyxhQoc4E43Sm2EXh5T9RQjIK8ULeCfKJKL9xMlRZ03sXdev0P8Kh5/aYNNyrTtaz9vWybftxkTFbhscsJ3l0/Z6YcRePCqX7JG03bfnA4rQOrgocNSRVyj9h5/5ofqxbNlt/ZpGHIFqLl146Dg0kZAng+fWHZX7X49JpLYpWakK+ixGK4sCsIYPRIJO+TOUkbAnQWlUkQjz5RmnYIE+HWwaT52peQ0BCYu6YjCw+Op2xTQhBPTdhgHO8CmfvM8SGx7TvotzWsFXp5bk4NGoNHdSkDmmhJDLmOEXJi1EpQFtgN+lPRX9Wu+0CPQe0bcWPwQnmCEd6okVKZY7abHeo1oYFaWsw5k0C8v23OwQXJxLTqcMa3QPZrfQ3j6Bz5IQExKSEkDSYnhh2hzzs0S9hHNOlIU7hZhuCAcNHdDZjCPgKIaSvlee0IQufA/mwYVBFwPZzgivuA71M25JhKXFXYTziFzH66+/LDpGTm5L/CaIB8yuGkWGrpLPCBYlfFyKFBXdxXrfspjOUKqXBiUkXePA8ISk+e52BGVwLo0IO6I/2kjfI4Tyiepep9EAPmoKMe/jbLF2OuZdDAfMNVHYCCMOXelUFTua3GLf1iGXe08cs8nJdXbfXffajTfcsGyZ1+2/xiKPxOzp0VfMBjTmBMsCD0LuwQ0p+W5uy9HzYm3w70MvlNkkKh+IWqPkmGNZjohCiTXM7f9q9UNXVdDMDuB4re/4qKti2zOBTqxHCMTsh+FgXfZZIVjTz856JTjamXxfSHJcfHuh79DfzYgiDtZy1pS7K6H6La6okp06qdV+hGO3B24F+HDjSPTCIc+ISBNT09bUGXDNnIStpmdld1Ep5YZ3tOc6O1sZsX3jR+xahc//oCzwx0+P2y13/ZTtv+Z6WYs9a89i1VMX5z1956VHLLdTLq0oiyCIDnTH/JpSexglfQqasjPdp+ApMXeI8+ulCRvXoa5rOX4Wg3nJ+wI9o1DpW3Ipq0pYAoclIncS9VRrZF1j0QvsQAP9kbRkieHDdygGQgHpHdqx7+xmyf2ksNGaZz5k6S1/q8PxJjWPdS8kMeETMpuzc3CJ4jDJvHyx0Yx2TtIcJ2csMviyBB+fiWeB8K/nT6NOnw3X5ubX5TXJYjPEQEobL8YD2NY6USKTPsIf7lIOLC1wQWZGKFD7ZxRBTJHfhBtcPuZCt86HCOEoWUxKOPLahn4+JrcpK0tY0vvNjBYZCUwrSTCfbo9D4CWYW8J/w6zThjXBjJg5OSFaXzqnTbzSb6te2U7E/HGwpSI7gRf1nd8PMHgrqRjNOmF+63LfuPgJmhOtKvRvVIxZvSRtr6ycSwlJMCsNaFrykWt7XPiRBhrminZjWUR495MTEsQY857DDcS0SKK/qhIU2QyONSmpTw0Q9YG5Phfps7OJvZYVzu7o6fPKW6Qs/3YqndW+h6wTdP2Ooa8oj83xuJxB1wi2/OP/+SbajPDuyjvfwtreB/aKNOsEl3AKghaho6UPjs+217yfyuu/47vXASPXbi+TYF7ebbVjyR1vIkwzV5L8ehgrCNe40DkYRDbteHJCkqxHi+357FjZlXxTVrJY5oxVJvdqXtcZRv0Kyy/3107E6MaF5jcNja4SuK1KOcF+OcLRQz/c69vS52QWXTpLUll7Et0YdrXKEpwctpeSA3a0dMr2FuWGW9e5Z7LWJlKe54JPa24OYIC2pT6dLaiq+O/Gb9tj9xNYnCsmc4cSeb0XFNpf68n1mWE7IDScURS9hTWQ+cInb4+rhzNqY29qUpaw/lSfs6SzBmBVdyHS1Sl4A4Tp3YuBUEB69/b9ld1yFoLiOiufvlt7Eh5aUkhi0p9Neo/FgMPrmNBnpDki+hBnJC05aUsruGDdmFds8O3WdeD5bP2dLmZV4N2+0KmQpe9RMosDBi+YKqf5FRPpmFw986Hn/IxpmFotcmyCRxuI4BZMUYVm9oWj2futAmCYqMMVuILmOPjcPhAfEtZW3V2A9NkaV3+hKtB0JrXp3xeGGnGCFJTdmSZoZB2T7WNlDqRl68RSotcvaHJ4cahpCXKBa0g9yiGz2otUn94hV5+hgJCk6H/sSdJhun6iLATRbCYj5gbLAO/DcqmPJWwQoarSEpBcvcrghAUEkCX7RrkFDO/yjeUhLnpCcMTNCqsStBeVq0sz7jHdlUrFXn3lJfur7/ytbdu21e675257+JFH7OiJUyqjbrfd/B678/b3e/XShzAv+gZWhCOEPO3g8coV3GuVfKaR+pZu88prdPu/OK9N8Lt2qD9weVy2LporoZ4hEiV4RSvRR5wdlZW1joFIUBKCV6xVonzw4Tbs0wcclSC8OAuk644Og8XRZAt3HR53hE3v+Djp+Pxyv6kxFus5ZjV5HTTr2oPnBKSFQONaxzhzhLzwccc7KNP84BzQDDRZLUhYUr/EdA4Sw5Jw13VZktgPRHJKO815k+lt9mxsUOcondI4Vka9w37Omfy0/bf//mf22c/+iE2Nn7OvfPWbLrjKj/3Yj9uObdsdnXUCBnrwysdyRCAcQtPTyRGblEVmVHsYN0ayaqPWXNHJ/tSw9IqjdqbhRdLsVOaFugesgxKE1uvMKI4FYA0cK43bSGF81mKENQ8hTxEyXOqWXC8UzGG5lxYD8zmfSwtLWHuIga4xgG93s55UWONNZqfvsdTm72lP0pQmcm9B8AtisuMclyDzwYIAMzilCD9luSV40zlrhbfwo+nsjhFam+mTE9IJPuAtNT7ka/ft2qfFyTEy4iLdZnbd9LXO7TWBKxiefEVWJ+EZV0TCz7qkRTUW2MvS/i6/o3K7sxW62SGUCP2uLzqVeaHuOcYamFVzRu0kzagnwMHlmFjk5eSkRX7Y9gzukDAQtXMzY/bWxNvqs4Zt6d1ouwe36VpubImCvXFo0DGzDVmS2DtX7zkut59jYsLFzTp8R2ww0283r7vWkk1FvWqW7FD+bXf2DpHdGBMugIHyIhjxG6aYvSj0GbTEWPEZJR9nKCCuGdxl2/q3io7y9vb0cYVZz0szKw2tLErQelJMSkrjtR4pMPjs9OnT9sijj9n1115jUzMF+95DD9n9995n4+MT9thjj9r0TF7CgGjLpxN1kd9PjFnHtGMMw0VSQQ6ci6Rj1nyoVvdN2Qh1tBFc0N7u5ofl6wNmBy8taQmdjMsly1f7GZ+8G5HFrz2vHITcv6hwC575rCU1Ux+4oH5oAnjBtT+WOrXaCTvd9oUAhk4Q3J0lbU2h7wTdBbiHFUnjrF7YYk25ZTe1NkWkZAv2RFp7z9xZdMJftwm8o2Tg2y8L+syPTFu9XLO+HQoOlI4rT8Mpe5i7E4pc5+vg6LmG9gg1dM9/n7q//rWv2Rf/5E/twx/8kD3+xJP24bvvthPHj9lXv/JV+/zP/RxZlLxa+ct8CR1gAYvJlS6hNYyDYYNlQhunKjM2LCUIh9sCcVJt3ZkesCmF6y+iTLpICZg3ZhSsoneTvfz0S/bqi6/bxm0b7I677rRcX0bzkw6XF7zs0xSGRNdeGy8SeGE1lykGuh+Zl2kDQrDefRggTGl66/fk9pZX46U9m9koS9I91lTUrqDbG5hBo48rVUSaNNzG0KjFtTjATFYq0qRrkfeZFJ/Za2c4vGVBRXe7wK+gS9C2wUxquVnBWyvPio87LnO0hU3dcUIuL9MeYOKgXEI/wxi7BJiyIKmYjonHMKcrTSygHNLJLia/aCewunq7K4/3XMQ1GPlWOX5Z3cADOhCSXAjxZXDTTXnBPA4eGErhc7aBwQzdXqtBBIzYlJL19OiMvfzt52yLDo3cnNsgd8Sc7c1ttTMvnrCDD79gV21WdKs+7X9QW9DgRnRorhwZBQPhyLVPQQEUelJZbVjO2OTpCfvWF79m5Umdp5LsdbTBnpiKFAgJnaeUaOgsqdZBrIPZfhtI9br3cqoTRpYPGmT/M5wdsFwtaz/8q0ds8siYbe3b7GiI/YNJKQM8LbMnmPpNZ5xWxdhdfc21tn3LZjt14rRt2rRZzF7VMtmM7dq1R8oOFAler7ox0yINrp2QhCWJ/+BaZc3SrV9Jl9+8B4NHWZQNgz9bpsoOJu63QAreXvbaldeiB9rEeHTCmISNJcem2uyEqEWseDDH4BLXUcbvqoBbBnqnXBEc4BiadgKQ8NQx6TZWEmhksSyd3lstXjuVdSnuRRRIJJY9qYimA1LmtRRM8wCBsuZYMLC3CAZn34JOOJcP+vTzgqfscI/1bu63qELq+7RIIBoO3i61An/MFtJ2ceDgATt99qztvepqCbox+8nP/ZT19vfZwYMHbfeu7ZZMemG8gZYocH2JXuuVJWZAgk6fvpl30lGUSz5EXgUIUZPNsk3IiuS8F/QbasyyBvsSWxssF+InOEN429a30b70x1+2P/3Cn8hiVLYffv9R+39+8/+2RDFu1wzssRvXX2PvWbfPbtxwjV07tNeuG7rKKRUvBExhmVcGBkIL0pXRTyGUbRiI5Y5Zcv1TOvPlbsdM1GY26/suS2JJ0kZ1WC8SCwkMflFRtFiMYBhgQmBA3IZol0tTu7KjnWYRgP1hqufaHa4qF7OYGLOYyuKMIQ5vXJvkMYswjPNZrrUpfV4pahBRhxAgOHtpJYl9DAiauNvBf0bZe9RaC4NLot+GiKwT3Pd/d1WXXsggKKojwC/95EX36m5fFgswe6xg6qm73Xec/iY4Q0p9uRRcyuaCQqgAKyhMt2OSu2rA4pmgQccMi5mELNG2n2+CAX7l6Rfti1/4b/arAz22+459dnZ6xPLnCvaF3/uvlk6n7bYPv98+dJOE20rCamWYtayNNNZJcxu3fYN7BIq3NTyZTNqJ14/ZyWMnxfFG7Jrhq2x7z1Yryz0LQ1NSzEWtKo2+mC988/syPRpX2gfIBnEEEeXBCoIQRuIro3Oq0tW4zWwft/7BfhuS9ja7OSuNhehCq86IImkdmTpulXKpRY8RGxjot02bN9kX/ugPnWVs3eA6KTEqduTI25ZRqPB9V121JNqccCFgsGw5q4YUAksKGh1Kc4IRDKj2NNFX/lwB0fjCLQyX998TwijGCSyt9ncoduEtykOQF/4QLnA37ApWV7X+CMe+e2x74cDHnjr21yEmMY+teVKRwIuFx2PWl66DvAkJSC6wg2OTl4BIRTFGcIGKSTBf68AYS9S8po+agj2WOyEL0oAGiASImNzKmEBbifFTlyVWajv1mPpMbqR+dE0stFIjzFp+eAUMM3e3z0ngP56VEKPv9q5mXE4389aQYJPS/O8rJlx56pNCoWDf+Oa37KYbb7KDbx62ifFx27VTUVo1903l81Yq+cox9hfpcO54j7MWUaefvKu538H7rATuX4s8+Krqj9u+urJlyC92Vd8JrfnlQtke+d5D9lM/89N2/z0ftUlFsfvd3/odK07nbXPvZvvml79pr7/6ht3yvvfapx74mD382GO2554d81xYV1V5+NIVi4FQQLpiu+5dDrgYtHjvIUsNSZM+epMWBi0uM1stNnaDJdY/7dYKH0MwOURecm4pmse9M13QZbGeaLaW0o3N6C5amjTrnDJOCGS062kJBaRma3MyGnJC8QbWB/f8fP6waCxcXs6nxIXvUgcbUnM6B2ia825W0AAWZDavOt9sldPQgauxsvYdiDmqy22krGh+7OXJNuR/Lnw2VxigAWiBj30qPeonFnP2nESlaew2wRQjCM8xD17/+u/DgLDAIyAtl+Bz6Wd3QOp5nmVEvfCDzo1KBTsmmMaeRwI+GOu4NLvpXNpefv4Vu/Wu2ywlJumFZ5638dExu/bG661f+1BGjr1p3/jS79rMzKTtv/Za+9RPfly43m7f/+vv2+M/eMwGhwfsE5/5hA33DDqrIgzsq8+8Ym++9IZ97nM/rrLG7Y//6As2NTltt91xq33mk5+2F597yR57/DGbnJjWsGvYj/7Uj9mWDRJsvvBHNjWFm6vZ5s0b7YFPPWBnj5+z/t4hS5Si9vA3H7IXnnjOtm7fYh/57Eft2vX77JmJ5zQexSmpTYMKN/yZT37KdopBe/qpp2zfvj12+O0jNjY5addcfbVlZUWqVRfnqhwjxr46uZbhTuqIagV4dpYQgj1obPDP7U/TtcfgqVy080r+2HHCjfrBufJpjuk2UbarC+FI/9x+oy7fd4K2xqMT3JZ4x4vEBazzx0G3MHaTz1mRWhndPKprcOPOPBLW2BvlC318x9whpXKr6mKyAye8z3imH1bal93Af1HyxEsWySrSah2lAm52KNc8WsEShDKIb9YUrh1dCEEJKXrYR4bXw1zbpdRz87ZHNz7Oob/Jo+PWkBKjZ8uAIunPWZFoIzST1/5KVT7nKg0UUiAUi3k3B7xx+JAd0Of5F561w4cP2r333GeffOCT9p2/+Y59TMoVl2YtgF10oF6Q+G87YjkbUnRUD1aEwKYdKI97Vi2v1BX9Ze6DgFDQrCRJ1rZEJmXvufVm+/M/+TMrFAt2+/tvt3/0G//Yhnr67T/87n/U3DVjd9//IfvzL37Jhvr6be/2XU5BupJ6wrzvLAxoFQlTiIErFQPSMCqyXCx7RnOmZ/0pj1+jCHdbNfsvZKRw8XCuZfDIbs3VtC0ffhjzTDLtDiBl8nWaYi1aZGKhbipCk1uStC5oL7/n070ClEWAJRDxbu5V6tJHpV+cNBe9b8X1CUSWJLTdlaQO5syWbSo9ZScj52zEJmwsOmXFTMmqCblJJaV1XHEFrRdUCVpOBFqfueqmKGwhuJ7RT50SgSaSYjY6P134hrf8rgFzqQrdBnZV4ZhEmIw1SLQDK9FmuaLNTEzZibeOW0QK6ldfetV2X73HcrK4VGbK9trLr9qu/Tvtgc/+hL19+Jg998hTduzNI/bY9x+xj33mY7Z3/1X29T//ho2cGxF8MXvxhRftm3/xdduza5cCPNTtK3/5Fdu0fZN99qc/Y4fePGSPPPyonTh83N46cMg+KGZieNN6++uvPmh9/f32kU/eb++/9y5nFSpIKxuRK+bLz75io8fP2LNPPmtvvPSa/eTP/KT1yVL04F88aLlIRmNJh+qKaRKv5tLI+Kg998Jzrl13f/hem5gct42bN9jV+67Wc41X0YbHbHn52/86xprCvA6c99gJPjCYHYjAPWMsiiH3aYh77rfuk7yavTmB8tkzhLsqwoqfnADju50tVpfKc8IrufDTAABAAElEQVQVz1vlLNUmv2zmJX/vUac2+Pn4xuqLtZgqLmSaxXerEtc/6iMUFsFEsA9vL+gKWA7hZsWWuWCll8M1ViQdJt7EZNLwlG1BsIh4OaN9Ol54aQ9n0AKWIhRZMzrg1QmJegm6rCuCHdbyYIJOY0nZg1OtaHjzH7usCMrzaEzvNFXH8PB6+x9/+u/YL/zs37fPSKHxgISinCzN//n3/4s9+O1v2N0f+pAUE7L8isYjUkB5BrA5eg/CEbwG1qwsz5vkfpdQ39Oyguo7oKAI5xTquzWkgq8seR2VMi6qaJuVStQKedwVOzRykRJot8RQZxX7+V/+efuRn/6sPfrQo/Zrv/JP7Ntff9BOnTplP3zkh3JH7rGyLGZR8QPPPfucbdu01dHfIsWGt98FGFhenfouQELYxCsVA2JWEtOWXPeMXO3ukyAjZquu8M0j77HollEJPxyOuXAyh1l2BzKq2SzACEc5WS1YlMYL016EN40M3mzKRQERxp+PWd5htIkkxCKwXGoUN1ojv92isnZ1OhfJheHVahFksvwyHYOmDbnB5NgLCW0RueSsNmW1OV72Hp2JVHRM1LyFs0OhbMT1zrbwHuJWo/AWNiO3RR8HDVl8iliS5EkynzXqUOAFuAVjxt4yxRrvWHpG53gQ9taHt2OmwE16dvneDbzQ4dLVBenA0Phk6H93yL+yWypT/3v7e23L9s321GNP2o233GjjZ0ftlttusUNvHLJsb9bec9t77PFHn7DHH/6egh2cs3NnRqyYr9imbZvlgne7VYpl++AH7rLieN4OSwB67rnn7OOf+qi9/yN32SvPvmzPPvu8rFHXyT3lBRsdGbUDbxywndqXcP1NN9gtd97i2vbYdx/W2Vd127l3l7199JgsslH78Z/7H+RahJuXgn3IVYf9DKOnR+yVF16xE2+fsLHRUZvW2S1xMXVFRfw6eeqE7dy923Zs3W6f/3s/50K7E2781vfc6nCHEoM0KYFpTK6ENVkpUwHBZDncuf1IcGUaQG4vTNsL9JHrJ/+++gmammXQEcwcyvWnldy4cQPSv6NvfksfgnuYSyoHDb9vbZlXj/9M42vZRN3QEdVDQ3wuh9QBDlz/nIuiD6vgxHqEuzIfHzWXA/gXBQYd0hyJS3uhfUhNrp3yzkMcwo+f2lGJm3GxQYRVL2AFlqbZowgCBICwndugMN8UsIjkAd6de53y4H7ckMLu9LnTtn37dilaFPFQhPUPfuHnFTglZRs3bLT3KVokwn9vb687xPbo8eO2KzFhmyeftJHh97pADxHosT21GsHYIFjIocqkZWppRbNs2JRc/Th7rtNr7cUEf9cV9GdmOilr9rBNjq3X+hKxfftfs2wOT4h2rAXf9K4RKAfiiiSocl5/8zW75yP320c+9lF75aVX7D/+X79nQ4PDVi6WbPzcuL1efdP27t1t7739VgmcCwXahaWHd97JGAgFpHdy776D28YE7JhiCSvRfmnoKi9a6fRtmv3lrqDIQbHx6y0uVzstzQuwgCbWRbmSC0fObVKHqxfTrz0sTn8MJ6QDWxqazDkENcgpN8Uo4aZVl+abPSqOSVpQg39DT+ViUZ3ZIeZd1q70udmi3HuKmMMCiWCWkmVhIfOuXFoAHGOkdQBtLW4RaPPOL0koJLqR6qTNhAFeqh1pCRds3vUS2k3vHA6+/fdYKqs6z0WObOcHWuBtr+w5rPh1kYW7/PafUn9CGn1n8WtbgQndmpY2088bqGLxS6EYxuO8kl4nGhd0uhhjfj7lQxc9Pb12zfXX2pe/+GVpVvO2Y+9ORWfabIdee0sL/ph96y+/aUm5lrz/w3fYcz980TGuDbmpsd8uqmhWsaisOLm8FcfyYoRitnHjejt65JjeHRV9cEZIzDZv3WiD/QN21b69tn3zNu1VOOjAduNI5IgVKKWyXn/jVXvkuz+wT33u0xLA1kvgOqIe0tASHqsacwPDg7Z+4zobGh6S5WnY0tJMR4uCY1PS/uqp79qJ06fslvfc4pg2hCOS/z0zM2OvH3jdnn7+GTvVHLX0nl44PXXS8n0EnM6yo7EmNtGVG/zj6MIXZPXAueSyJ0jjDMY+JcskbXB745apD5p0hwurGocfjV/X/60KndAlgWk2OhsI6iYpH+/C2HrzQLcvdlP4GucRaG5/lLoG3AJvQm0GYjeXrXF1l31xmuejRFiV8k7YELiSoFeQKppDmk5R5s157a9Cp4VRBSySp0NqKOcE8gV5hH0XTlx9gqto7zXr7PvPPGxvv31UY+5mHRi739IpBCVNVVpj1q1bJ4IzO/TWQXvyqSfs4Mk37XM3121vj9mR8UftQO59VtIhsJGAgMcYI9y405BpLo4nonaW4zHiij7JmtWFMLMAbq2/RQVROHdqs+ULfdoTpQh8EjSPHdtie/YekddAl7hEaK817Q/+w+/b/Z/5uN17/72W7elxezPXDfbZRlnCd1y9wz7zIz9ib7yuCHdqf0XBJWQHY0S3gxX+fpdgIBSQ3iUd/U5rJpM4iy3BA2D4Yr2vWqKwwaqTuzXDa1/M+H6L5E7L/U4abXaFtxLvOB95MRtsNicwAMk/KJapEJYrk9ThcfF+ae90gKzOc3CTpN5xDI4YpozmZRauoJBAOS6pAJgjBBlCj8f73xSMimTkM2cwDoKpqShfkeSElksV5lfsl6FvVSfQxUDKiqUVxglH/mS9ImY/UObcpXc2TY/OqIhLUCpoQz5l+uX7+fgdlxDaH++1YrOqja3TOnlcG+th/B3Qfk7ZbuQDP2MFF1wBqxN4XE3iPYItgBTCwiIUgk+sVGif1YPEYlNUNfYUeQfagj7CzcKMYbUIJjSnTrAM3lzmmvI4TJjDa11fLpO//TF0xmeW2aYz1zIJSfSBNtzY5h3aeyem54mHn7Rf/Y1fkVvalNWrckcpVmRRGrM91+nASuHz6JG3bOPwLS4QwkOPPmSvPSf3t9MKBf6ywvre82HbunO73f2pu+25p56z//4Hf2Y/+VM/Ybt27NYYqNu1t95ghw8clpuKt4eCPVX0j/h1hcDW4Y/HTttffvEr1j8wYINDw3bq7dOWkksROEhn07Znz247fvyYbdu7y0oS5CbHJ51AhnVlaNs6m+yZsCdOvmrPPviybUlvsBuu2q9odtdZtVS2l19/Ve6BB1TXMatu07jculMMpyxPck9CobFcYq5wY2w+Wcy+5gtP3Aj2F3vuOEyanptxbkG4rHn1BYWe2YICF2jp42pbp8S4We79Tu9B29rPz9vuX6c8l8s9174WyTMXgI+C+ov5Ggyu8Wi4XJq9OBxYkJj/JSy5iX3xnB2fePjqjDVwXZnWWNA+2WS/3OFY7tqGBdEfPRFV4pnGbv/mQbfnb/TtSfvKd79hgw8/ZFcrCMpNN97s+ubVN16z119/086Oj1jfniHb+9H32TEbs6HKq7anp89S40/Z8303WjWzQeVqEhBotZLmyrw8K1odTLBTkiPb3qTF07S/cxu8nAv/YiHq6Slbbt8RCUZaF0ry9KgmFfI/I3c7hbfoQkBi6i2UCxZfl7Cf+cW/Z1/586/ZQ9/+npVkPb/no/fZ9TfcZJ//xV+wP/7DP7KnHnnaMumU/dIv/5J9/RsP2t/98Z+eVdIshC68807HQOz/UHqnNzJs3zsLAzDyPzjxpP56qwACT1NuC/GUDnwrbZPgIYuQDsmzao8EJ+3NkMDkL8k1LSKwF+xFSshthzI4zDIvf2/uoykmbOnW7CbnSheXFh0mkAMoEXhiijhHguFOSrCAUYeB5F2XBBJWIefSo7JhDqJaHJuldRLWTutFZfCz1gakbZYLhZhwrDlo+DzWJ/BXs3tSFhw27MKwIQS4XUuumEC+OQg8OIBxwcfLP5tBFwgPhHx2p67rupPAxz1wNF2ecofqOsbfb0SwMIdLNhuLCVLlhFR3bh3z8iz/A9cNcDpdnXFlYeEqKeJTWWFrKwisKp9FHo2+c9lQvSyCJX47wWquDloMg5yWsLOSBNPhGDvhmTpWmnjf1Y3mHODWMEG363UqfaamfhNt3HTzjWIierTZetDuvPsuucMpiqNo8H3ahBxJxmTVecSOHT5qm7ZutV279tgdd96hTdvT9u2vPKhAC6N2r9xNdks4GpsatxtU1s7dOxRi+6QOa91uNyjYwyPar/To9x5zNHLrzbc4gZGzVnZfJeFJ55k0paAY3jBkTz/9jIsU9cYrYqxOnLGdO7aLthu266pdtv+Ga+3MuTP2na/+tZ3Wwa97rtnrmLSx0oT6UdG8ZKBMDqUtviFj49I4v3H0kD371DP29BvP2oHqUdu6ZdI+fk1UAljKxuXH2UzkRCMafQEN9lIo9vvDfdMfrS5xc4gYL8rhGW5FjDd/pLB3hsNcy0TsY29Ryz/MCSsdupXDlXOK4JeUxlpTSdfwLQX77DPAFox8Ln5iwoER5rv9AzSdYUL5EhO9Ev2QwDcOz4vkvfhtusg1ao2KoE3QfLWWifk4lZMVV8KRC4zRhl+8BbKa/xBUsKCmFc0uF8+5vUX9m4ZsaPd6BdmL2FtHjtgTjz9hzypQwxntBRzatcF237DXNqzf6OaZYrbHRqIKJT510LYPb7C+mTctr/WomBhUjVqVpJRp6rOgfbrV1LiJKngECojVpIhojn1IqVTV0pmi9ev4gkSiu3mZsexcfeUSvmfnLrvrg3fZze+92e772L12s9yEz5ZH3F7K9/v3P3qvjhfYaEPrh2x9vw62vSTjbTVYCt9ZawyIF2mpxNa65LC8EAMXCAMssv/mqf/kSod867JcaBaTNknMTH6vVU7eLS0WLmHapzD8vKLaPasZWsKPGBw/mhgCEu/CPDOh+6MA3/kt2Q1uAXHMk/fUymLMxX47BaCruPWHMgqKeleUu93sUNL6x4SMSZ8gEDEJII3yoLTecoOIoknUIgE8pY0SkPRbgl1SliwvzDXQCHK4Ky0KGe2N6pMbIACWxKghrMB0Yj0oy6Ij9kOlwcx7jBPXJGBfsAyrDP7FtVIi4Pl5yc81rn4zEhRhBueeAYdWOMLt1hWlTmd7IIwunxSJSYtyj3PlQ6hbAM2SReA3PlGeVjsRPpdOlA3D6upoq4Z2cIhhf0q+IStM9CfC0XQpv2L4V1hV19lpIwc/7tIBrHv7JKCIBirauJ2UmxvreLle1nPPktYQQ0EvR2vCTUPWsOI2KQJ0plDfWbkcig4aEjQUebCeLCgi4aQjvKrKqqrMXCwruhVdibnlAMqmxg7ubnIYdfmglYgiluRiGUtLYOHA2rM6sJbAAFCkC3qSzupAyLznxqkDaPsTPWKi1FTBWYmW7fjMKRuRgDRDOHGVF0yMy5TCkbNJnchXuxvn7L7ehpXUtifrvTYaX68w5IK7SwEpWHbwmj5mTuAbwTMnmGEiC7jbCib2KxE5rCa8kYd/0JQL0KBntIUE2bHPIyeLE4qMkuaDooT1bgU4V0jwjwpc8myhYN4Lfa25qllT39V0PpYO53bWbywhdY1r7R+LZc7oTLqJFhRzo9UFxRGOnJUfi3qYLggGYOBrJY1RjQX2zTAPuCQayiWzNpDpnaXblNYZd6BrKxNf0C40zRivQuf63V/KWbJX84i87lgT65NydUtVrCaHi6YUZTeMPm97BhI2U8vbC43dNt4vK7Xc62rTWh80ThYk3YpldNZdH/OUD+CCXBf0hshYa58ipWpNkupO7YxoTS3rU3KKR+4zX7L2eIrCpt277S7nYXFBAQsLv2wxMOd7dNmCGAIWYmBpDETEnOHzXpeFIZI6pEl4q1XGr0NdZtWJ/QoHfkTBA0ZdISwEzj9ev5iog5M51z3pnPXJhcCFluUNFhAJK1HtSWKfRUmbZivaa0M5/O9N9uiMFzFsxWkbLbSYBN3HGtSI+y45aM/GXP3uJVcuVg9pzsvrZPkakwtUVZpqz63MyyhWTDO62FsxXAoqIYGIyFCuXi02FXGavtWL9YZ8rIy6nE3zlin3w7tDwIX12SEnCMHwkfiGweuRpSpej8vlToIbglBNDHRJh3yKGYqlR+TyxxlT3SS5fahN0yq+R0Y32uDV1M27dJ3wrcW8Jtem5RKtDvbjcvlX8hy8+zhayXsXKi9txe3vkM4QOjFz1tEwAUew1kEFCDjqKTHw2gwv2BEcOYi4pmAh0yc2W6kspic+IC1yQsJ3ThzDtNUHXrZGWueKRVLufRQJIjARsaI+ylLUL4sqrozjovFphQVG4EQAysoNFQsBm8cRhHC/Y68aQgYaa8LlTxdnrCbtcU1ClwtbrPdgQLRFwdFzJ+HI4Q6iTqi1Esx7FBb4qqTOX1JPHK5G5eiDAOJF9zpfPDMHOCWJqgM+tO1EFIPZhF4RBHGxhAZ8OnDfQg/fbr9RCwjGPPemK9qMLtrvlNy7FKz65o/WudzMNwhtwBUsfy7HxbwSsE0dbaD5tKp9nbTaoor0pQA4nPODm3Asc1pKqGda0URbjXM5YTQlfIbC0QXtMKwyM2cmrV6pWf/2Ic3TYuvUDQj8HOrcK2vrXK+I8ALJl2UQxhmUiXTL0q5x5p5Bp0lRaoo1UHNMQmusDpJ+bd2dVp560vZnU3Zb+ajC9ZfsdGKv6qF8amtLul1X0JZYRWPfebXPh6Mt9wX5SROJAjhZnpmFUCuH6mJOrdp42RuzHmS6zxw0m/OCgBQWepljIBSQLvMOCsFbGgMwOL7Aw0TX1AQY6X9KE/GQ1QsbxdiLwVcUuURmxDEczjDTMvM7NzhWAc2DlAFD0iP3GDSfPsPt9ieIYURRnRBTieUpL+GhXPcOnoXRQ8MMI4oQgBuJz/g4xmsWfCbitoSwMa29STntc5BGHavSXPJKQQiKq40sdn65uNjhboam2yUV7TFe7m/rll+f/9ZcybyLQIaFoOavkK3HtD2j+iqVmBVH9khbKB/z1FmLDRyUxWBGFbXqnCtu0Stag2uNWHDLNbPa0+O5Jy76QvCBXk6pT8rC6/lYCXyGlO+FmAhWuPAa7T8L5+WYcEEsNKBBlnhZumTZ8a/VuyJKr7U8w7ppEuqrae2py79HAksftlCbEh3FxPCkMmVZAPRcjCzWouJbU5abEi3HNZb2yu1tU9RmGto3pAiPLmqUNMo5qZYR2Kd1kOuUhKByRWVo/GTjomVxInkJMAhTBQ5ohtHQf6yTRWlsORgZIR3L66L7u0SXVdFNQ/n3RWfsennNnpRF6bVqyqb1flTtp8y1SG6cqiznSilcIYAGh4X/3M0XTCBKfpv8+gGlprkHa7az/voPAt+zc4lwv9TZSf7c4wRVFTx/HgkUeLEu1eRYVsJ4UqHb41MKKT0toBCQFLwiv81qM3usOqaz6JocuSA3YrWPzlm0by8W3O+SeqCXzEDWrVkReVE49KsLiPyYltKDvlh2qHhkPYex4G9dRxVwIVZt3VR9dVmT3xp8v41PPmu3KDLfrbFRe60wbgfsBpXBPB8sYK5YnzaCdy7F9Rw+Ol0Bke4v1oRLAXBY5yXBQPfcziUBL6w0xED3GGA+c9NdbMbiQ49qMdfeHzH01ZntEpS0UOghZ+X4yWmGWwwPjCTaY9zJimLumBxr0shVpVWCUUFLxyeuf33SqPcl0cxJmJLWuKD8aJyTcv/xmRu/jiW/YTL4Vxl09XbKC5Nedn5JAglNtuCtSuiAQV4sEca8V64VWLcSEjKoI5hg7gpyGeQg1E6J5wRmaOr09+jAqxYbflGabLkHrkA4CpZbF/5mqtKqB4TH4PPFrr0IYiuMPtehsBX1Set93vFcGTvjqEM1F/UWLI/P9nS69pd990z9yVggWEiy75izjjqZhUz60N/8g04ahZptag7Yz/3oz9iHb/iAFY4pKIeClOAu5saX8sPcc6ZNXbRIcI+KzkeBiceq1CcLLBnzEoyKeuYECVeNp8jwhQ2UCkv1C88qlbptLI3Y9Rm5wmicvSQdwnh8UHuhvHDRa4pwwcy4YixX1Z72MYMCBCWKmwfAV2s+CMLgBKDWfOLfpxzus0/S7ZVUuxwisUBxHUj85h/4ZS8U3+Rtzxd45SJcqsPlVhvrOWyJwRct3vO2rAljoidFJktOap591VJbvmOJgdedC16j2jcLE8qWMF14DEBfyb609iBJOQHNkNRtWO+Ywxjb55siOmCc7VOxhlc++0SJ6Hpu4H32Uk17mKRwu6k3anurj4veJUB3SEARlcu5A67D8/BWiIHLDQNz3OLlBlkIT4iBVWBgluVIntGi/aJVRu7QXp9hfdZbNHfc7aXxi8V9hcUFpg2hIi2tNs40eUVqq+ucFdmLvKya0+NJWXC0IMDAMMGz0RUnISw87kwkCS9J3JkkWJS1b8VnDP26On1H2NuT0rlL09vk632yUxZ3r6rAEk0tLCwtJTFv0+W8Cw4Bk9op4fbE3iUBIauWBDhp6oMuP5wJlJJ2cdEkS1YjKleqDU+pTh+j1L765DF/K3xfVQJnSXtocMtaLnl94+cCXu0rUX9kJfiunEmQuxrudV3U69d4Ib6p3xfk3aGk6tPVJs4M42DlaGlQBiXtyWoryuFIdDaaH7WHvv8dO1ec0Pld2oMkAdftxxEtMV7Yi0R/lMplK5QIbqJDa+Vu16dN3KBrRi5med2fTcoAs5zDfU1jA3qusWGd8bQIfmtYbQszdl26YRukvX5GOouj0WHBrH0MGqtJKTqwhBLAY62Sa7/gX4zSgJc+IEM7PUF7zi03gFPXd3Iv9Ns4S5/K4/YXub7ExU+Mo9wiCQiBEdm502o+ufTudW2Y9RUkQQSBC1kQYrljYqDZfQYD7bkt8quhNkIrAbS0FRr+PF8MIEhPHR93QRJym/tk4fNoFKVdnuiLssQm5fLqnRO3gtrQDUkP15DF2KrqU/U/hz/7jguURAS7U0P7rZxP283l1+2963oseu45Oxi5Q7TMGhkkFt64xJTgV98OFqCFKcRAGwaW4JLacoY/Qwxc7hgITHpuHux92ZKVTfKV3mX1qZ0WzUpACiQWDfbdIBwl9eEbZhQ/5WJtShrcfreoEEI5KPDAJJZ0yGpeVpE61h1xNbi9kVIx+etrYZplhgL1LbgUkLHEpJUn91pMm6AjMZhKfwafy40mcEoR3bISetiQzwF8wNop8TZWJ2+Dt8+YZhxzSn6vdP4urIfn3GfTqnc2knfH3V2CmZ3LtdSVxzotlaP9GRBG1U4CSnBg72IQ8x6WPPbGgHmX1Efwn+CMc5C66g/vzdZfb08WG+5XG+p7XnGr+AFj7T6C3lk+l0LAsuXrZQnkkfik20vWqOgcIWgWtbA22jvOXHfi2jBW2ddjz585qrC4SevbOiTc6z2Qqf9eMAy9KZosSfAGJISjfu3DA/W40RVK8/ep8Sp9Q3S4ilz4GCl+23S5INGDTQk/g/VpuzYXsWPa/3coovGR6BeDVnF7ANFkw/BVdc7KqgMhLKh5+RsIRowt5gDnAtd6hd8gw7cycZs2doLNWaMkMHquhinRp5xlxXyyr9C5HWr8XnlJmEHhQ+8KD+wfrMsiBw6gkTBdQAwwYCSXagpUErb5rcRXVS6quJ0TeKUnrqiu3Vr1NC80CrJ8lrUeqshaQv0qK1JDisP2FJVL6njPLntchqNbS2/ajUSanHzLzsWvETQA1QKo/cWL/JsxKlAdPNJlai4EVyF1XuRuuKKq68xlXVFNCIENMTCHAcKcOqZEWq9IRC4+fa9ZZGq7Iuxss7jcP9w+Gk3bMHw9rYhT7m23rjCBwixqQdDNgnbP9Ge06RXNeWuSZ6qPwvi4f5ptWXBgIF2ZWkM082Z0GjmHyC6fBGNC7oByVXHua8zVHdYS6i7LcoQVCIYD3/LFknudP3xac78Xaru7hcATDj3Glzpg5nA9JKqPxxB3Vw7vzk8OQ7rVoYHzM877RQACF3lw3t2FP7CKYTXz+4kcDlL1c/Dewjc734E+CG7AXhlcyQg4QPsvdgKOxYTh1cASibPJGnoTdhyCYGjBkEc0/E0NZnTgpMJX8TzAD9GD7p4yEWodS0dKeO9PexEC3R4jWZXm7T3RK7hKZlNy1xQtUYZjVETHzoWsQyOAJSMX0Pem83Kty+p0e1kRMxsVdU+b/vUeCm36IqkQ/FhLKxp/FyshFAUFI79eYMaCBK0SWRI8Ef2rPTnXPFmuwRsR77Aa4W5YkFKCs7+IAgjaL8c02/8CztHLwuY5sLHwsb/xYvbL5YiviwUT461n04A6ZX6HsFZAWzoqTWO1ojPqZiQk5dQ3i68fPszljFZA3LgJNER0gxZRtlXhZ5fupW7F3t12YLSgcTtp1yRGbKK21WqxOZfL2cwdLnzIu6V98neb11WnzHWd01TLaw1lytPvaFZHfeRwm5W05APQAbbw1rsXA9jDwxRi4IrHAIsBMyYaMj7wf9xqJo5bvO+owmwPWL24SXmcCknzIY4HTJTKqP8kNOX4VeNyR9hsDpcsilHDVYFENiwKfTpIDm08vjHk5dDKqNyOIvpExfhgjXLMhHtr6T+E+U5seNr59Dugl8ju2rjEc/8RrncwoytPcivTQgeTR0LDPSjmNy3tP1as9jZ1Cw9lcaYQ1rqVrENsdodp9Jh3SumcEACxILmu1B/61OvXVsd2fm35u5CG4IYJz8lKAkPrFtPl31yQgzb47egWB7PtWFDaedyQCjWKpTImRUCL8IELHHJ+z1BmwFndsM5EGgvxxx0UEFg7oIeUlAHgZFrW1JICNdQlNAUTdJjS+GDcIEDQJvrVuQ124Lb0SKCV7erIiN3Y32NvliM2ktqkPki5cQjugIHIeQjPcDYroXW/D4IwdrqmjewZcsJeq8N8mHF9c9pnx1cF+1UZ9Z/xgxCIMNRCsauC3wiFaeEMd0Mn3BFGXi6JHKLalXBEFcJbt+3o1LbV3nO1uknVU5y4sbCQRNw4R6GCa92lgHO17bv074HMDghdBjDoqjyuACgSToIRA6HhufD5uAxLSFJYbnfAdIcy6S/3jt6r6ezAugK41LVeQv6u27lYIkXV52cH9tmBfNE2D66zbfamcrN2BtrUoQxusd66c+eWKD/4yK0nKnfF9OXq11tqUD2vozLGFJxG366BwQrC6xADwsDyqoQQTSEGrgAMwHhh6SHBMDWkNmuIuY4qEEKs71WryYpUG9/vfOWJGMeE35DrgcQA9w5/XLhw/Ow1n3MqeURMd0XR6spiarIKzJDVfhasRzMKZ1zReRGOAZp9O3DhM0YdFoNALu8S7Zxiis1bRNoy0R7HaqhucgeWm7acaruert7ioEVDjCeLh2NkqU945UwnPrMJ3CkfgJCvm+TgV0YYcVe+rpdGjxZ9uYdgNYMRXyrhvEeUv6XLW6qEZZ6pevaIZOVqCY0RFQ7ryUoSCzqufsBJH3E2TFFM8XIJXGGxcLS9NBqWK8p7Lnpz0ciiYnwI28u+gkbCRW/coPO/UnI7hQYIWDBSHFf4bvnNBOoFx8CuwQNSxP4wHgoK1OBZXucBAd7U7rTCZ/MtccP1JUyboy/axZ4eJUfZIqmG6t1Un7L3ZbV/QkLaYdOehqQiPWqs+gYZ8iJsOaG9A/15dKA8/NNzaA6hjPFKOHSsv+yrcnXOA9iDA8sPOCc/eZwFE7pVGY52dZ/2ICTBUHLfF6QcbKqXfPQZwpSzOikfwnaKQzolaPM+Zy1BSwh7oDiA5jaoAj/JRAP5dPVC4N01unR4g+9VAr/ut/fT+6tnVc0X3ji/REAG4blSrhVdsqlz8iIKo76SRB+UphT2Xgc2J3oUel/bTx196It+YCeQ1wtY9VS2aCenf0FPBMbIcGrAemTppTwSUS2nSlMSqghC5G4t+yeiNfLt1DW2pXzYru2p28j0CUWd3KrxKqVdWmOmTW+HUDagsOHbezY6xeJYZdpO5M+4sd2pMiDbmtto6xSRE1f2o1MnbVpCn9/CTu/49yLay0j9eq2FH1GuIvPV8MzQAbeJfilxLtWg8oEMvy8rDLSR62UFWwhMiIEVYcCf2HkJhlS6ZX005SVOaW/FWasVtlhd53lEot7q7oIr+CuJX5NmYIQjx+g4Bkll6TsrXUJeIY3HCnmb0uZxHYnnv7EG396C1KmgrCKDDaZ7bYCPDjvN6TfM1WLrVVTWDu/MocVydKrFu8di5bSLLXA4pJWAEGyG9xdInxnq5Ga0eMnw03JTk8BTkKsgDDghlb2zZjrDCePJgbV+fZ3K5hm4wL0u2Ped8q7JPeGFIBw5GH7huZvkw4g7J9EPM2KQcd3L6jflLLUe+8IR30vhoRs4vDwIDKL92LSiSXH4rZhbHfwZa/boIN1eWQrloqjuAKfszxsUE8LeofbkPG7ERJEPS1JJ9EFqh5E+ycjylpJFFaGoQZ9L+PB73F3ph2uf7ldFbwkJnjsjeZ1H1m8vTCvyoVzrwLQXOltliC4aYmaclQa8tD4OgNYfLJW4W/amcs79D6GPuqKyiA2lB3QG2LCzaM0CEnjZF44cbOpvLJO47ZKcMERJLUGJ98EBghDh/8nHXrFUSkJQRgoVMZvO3UzPOSKAvVqMX3GLsrgV3HEBnmU2AMByl6oTYYzxR9svVQI/7l8HGEoat0tF2bxUMF+29WpMNsoKJETgFAnvLe69a3Chh56Niqq6bUB7WkW0LbLAu8E7HmKuKAQAzvHLByxJ0BHh+bdlN9nIm+fs4A8P2Fv62EjVrhm6ytantQ9RRSAKszT4/c6czi/u8XG/tdep3LPFDkgOy2Z7bV/kTSkVi4qCqDmFQ2JbSgfySq2gj9lwbsBOvXXa/urLf23ZpvbkaW71y2zV5uokN+NpMNFr3/nq39jIkXNS7BCAR4KPK2mOJhmr88pQfTLcWlPeH03NA9GWJ4nLpHc53qChM5qoL0whBnwMLFz9/Cfhd4iBKwUDmtOYGr3/YoS0MHiJezCEClPbLyvS9CarTMqKRKhaHXrqmDZNnGjP/NSQJpx531mHdJ/9E+WaGBpZeRxTpgleS4AyzL3jv+t/swjxz8Hk31zhN++j4cuKmcaVxbVIC0e8qTNktPeirEWOAy3bw7i6tiwO2pJQAO/88mBavb0m3mLDvpykzSiE80qZMxdRiTNxhFuEC+qCgXYMpn5nVW4wmEJF1j/qBg/tiXu4UaZb7oyUcb6pUz1emQJ4NtGnYmbEkHhqyNkHi15QLgt+Qky63xR8+sHjQLrPhckeKeigYKwygeRoh2pEjOcbvS5QrC5F77jXuTOt1um3LIQ1Hbwq4bXPMWdebuBOC+ZeaXfHZEnqmNQ1Pnba6YHh4QSCFOcieX1In0VlhSNUPiwNifcagUhvCTEuvcZZRD02FRsUrBJupAWHoUJIQjjhVVzV/HLbYaPkqMYprqaUj6DvLEbCO6Ht0ZQnFJL/bGHE7WWa9z6k5POorcaBC+dWpzJh/J3FCAbs/2fvPcDkuq47z9OxqrqqcwLQaEQikCBIikEiKQaRsrJMiVa2HMYz+3lmx2EcZr1jfx55PPvZM7OzzvJ6bEley5Ys2aJkWaJEWaRIimLOEDORMzqH6srV3fv/nVevu7rREWhSINAXqK5X7913w7np5FNSGeR98tA/iDHU55iTGUmIYAb4c73L2sR2ytVYVU4AvJn7BOXMm9SeUH2PPD5HdIIv+M68ha0+OCcgIOJoMievkskN8hh5QHs9+8ACc2CeRvsW6NoPwbvssczDqM6KsDjmJOvB543KCb8pkrWSlWrcp/+fT9vWbVtE9Ffb5z/zebvtw7fZTe+5RQwF7VcxOXnQPyRLx5IndVVpa+rbXPKDSjvnAmqjlTozB8QoSCmk844dV1llRkGjJZ1OROp8XaSw58yl9Vv2UKp3baLD7u/db0888rhd/2M32Np4hwdtpnwYCEdHTzpDbX19h/ajuPalOnvqiaesta3Ndq3fZa2JVrVFklr1A8JoBC+0eq+1TgSjGBw4NTo6PGAvH4rZ4KkObQ4Fa5PafX28X+3N6x2xYNhrZaNUWYsn29W0CoEAAqsE0upMeENCACSVzR7kIEBYp7tRARdNaVwqB8K6tXmKRoppQ68bkBSpXRHhr7DajgekhiejTW2kuJJ2XIjyhMS4B7gSkYXTgoK420WpR+GFKyN1g6IOtfmQEmrOCbEPCA1acWaJ9iAJgjiizBKupvYFh1llRVQHE4gtzhtEvDkspBahunEQgRrPchNwdFiWXvQDtFQxyF2jpFhtkUbrGx+wYQXvRGVoRtLJMlGCzVzIq8NM7ecQIzlyrOMIda6ipHZ1SBt0EJOQNs1OtAf7rpj65rABMgDnLBPIN6ondJU2hkWGxCZ3BBm1U5ILSUxQiXJu6SL10l5mHwb5bn+lehhJYkzVyVi6RshLZUSIhGLv5KXKEsLM4V6C5dl7rzu9kZO4ZY4M2/iYapJ6XTHVaanUqOUjRZ9TXr9eqxRy0SCpJd4acRIyBZiyIsttHhhPTyIGsLNpkP0aklwS8ArczSugbHlBeiWcDwH05S4f9T+N/0Ql3OGgTPJAbAAjZ4CEg+Slz/zDmh7XGsB+jWyo/2FPJPGO9yVeiDlyBsLYlx7wGF3hqDuxrVPRYxapbt9jWHRK1A3TYkISaCeSNCeqQK5KbYEog2OPiivSz6zmNbD0ea65k9VHhYTZHTYQVdNJ+4za7nOrBBfq9Hmh31NSMxF6fm8BGEyXuXp1TkNAEtyimHYeW6oWL6bM9+UNLOth9NSQjStuWEN3s1XHtL+IsQYTJiyqtirqtoWcbWgJsPewJ5UnmAi1Unn96E9/3HZu2Wn/+OUv22MPPWbvfs+7XRp6z1332OEDh+2qt1xtV139JmciPvbIE/bME0/b2q519sEff78dOnJYLv5TtuOSiy2ZGraHH9ljN9x4vY3kJ+wbX/6WjY4m7eZbb7Ldu3bbY489aj29vZYaTlljY4MTT0jZscX93re+Z4f3H7ar33KV7b7mcpfKHj141P75W1+3xqYGGxoY1nlcbR3xdnvgoQfsmaf22OYtGy0WjdlNN92I6Nfu/d599upLr9qbrtxtF19xrb2SarJ0BthW2LFMk/IOWUvjMWuI9wkWIpTyUs0f1+LXu6tpFQJAYOYKWYXJKgTeIBCA6wyqAScZ1RY2fv6RQvUT8gQHjia6VIoIlFmhfPmRbonU27VPQsiUHUggI0KiqjAoLzs8cPOczCVtND8mpCs7VY9Xxh/K4KP3CYaaFXJ25lts0AfaTRDOURlwB5IUtnWhi6pnEvsoPQcZS8iwvl6qWgSE9aaU3sO2YXltCGw6IASoB1UGiKyEAs6iClYv4igh9aBRqWbUROW8IaYDLYSRwAzyBteOdx1589Ys7Q/vYOOUFFdxODcm9Q9JEFReeQIqEIQEwEWysVIIIggpwUGTGtsx1Z2UDvyof8ZsRL9HsmM2rM+oPk4oSJ1sqepDIL8JSVDwhBcSD3BXY1JnIT6TZqrDK+C6ah4LYYeTiyQNwohvZVjxBLnn3hxRM5kUMi838yOHb7Dhvg7BdSbc4RwTcHg57UCyV6+Asdj7sCyyIipHpKrJnJxNWLJuy5NoDOEnktLC+dWH7rtNFOp5+ucEzCIwYT4pqxP72AoWsrJjU0NACJHqDIsYhYCJay51xNukilevN6YL9XEQ/Kfmd6mBvr+oXJ7D+XbipvRa2DY41th9ZFAl1RxmL3LiDNpoRi3qZ2mNoTrbIG46aoGUzXswDDRMM+COVNvV+IQYMj9cilbW7nI4XqjXPkZvoM4Xhi+RBLVGDLwerT1sj6bn4VK7wd5SExdB1CgdMmF07dFma401OwHDnGO/Iag5hHttRa0IJa5ZWzPr0rJTjLIJe/m5l+yxJx+xZ5951i7ZtculNl/6m7+3F555ztZvWG9f+Nzf2uFXDtqTDz9hd3/zLkmJdtjjjzxmX7vj6zbYP2T/+HdfkdfYnO158ZDddfcDlkkX7C/+6NOWHE1ZPB6zv/rTv9JeM2jfvfNu+8ZXvmFxSZZgPMCQ0ulrf/lnf2HPPb3HNm7aaF/8my/a84/usczQmP3Z//gjX0vpVNZOHD3mto2PP/yofeEzf2etTU327OPP2t9/7u8lkZu0O9SGpx570jZt2mRf/vwd9upzT9plW0dF6CGhkzRa0rZ0us2On9pth05cYcOjayVp4lSdxhmWCv/VfOcvBFYlSOfv2J7XPSMYXrjBg1RUygDT7WfA+UIbAUEAYUWAsAv5VDT4YnS73H026wHqBiBRbJggq2Vp5rnhD4T+a3MOjEHDesM3JkCE9C8nLjWG9yEyHD5f8rdHKdchV6V6aJ/+wbknsCYc+VohX5BBQpOmCDh13RoUryk3ITWtMpW0dF7qbHqIzctSkAbaLLTMm0p+JGDVuoekJirCKCZEOSdEdxwVRIhRAAv8hADyQQVpIbWnpcKAMQwJwvAd2hMQR3KLDLFBxSuQ6DNSBhD3KcSkrOjpeoKbs8d9riaQk+kD8RqHEHInBMGEQiKDp7iouLmUzT/UPHH13Kw4QpQfEpfo2+OgAunSGc+nuRpI+xTjpFLcavTwJ0Qg0eBiIWK5fCApK+ebgbQQaBdioVy6OFfRtB37mwYRRxDYEL14Z4MY4V36i1qaA6hUwGyYQsjUSIl1XM5RCtaoNzAWV+wviG+Vv5xEnUURSMTQqlS7VIDP2zHFFItkhZRGpKYpTjsIpQSfLkmijSTqCqoTTDTX3XYqVO8TLJjrsxPEEUwE3I9D5GTF4HBmTanMGflVjSNjKgaQZLWuUiIiWetk9/q1pqbgozzsc+UpnBcLwkVlhRI6CKyp8soLOhevgY/mgs8VnzLzjz2EKkwTAJcX3JFI+1wrn2jnZB+1n8ePW7VU66wG6dGZJc67WFudGDEROTxoEHEk1TLN0Rq5x2duQRSFoAjn95w1acJnFcPs0YcesbpYzPbv3WdvvvZqGxwZsMclSbrlPbda94Zu2RbV2SMPPmof+PAHZNdTY8PDI5aIJ+zgvgP2/ve+x+7IfdVO9vbY008+addee63tPXjI9r76in3k2ist0dhi93znXtt/aL/Wxrh96JMftve97V12v6RA7DGHDx+yg5Ic/Yff/BXbftFF3u4HH3zIMrJHjMXr7Sd/9ietrr5OkqGXfYzv//4P7Lqbb7CPfPTjdrLnmP3ZH/65jSZH7AHdf+utN1rX+nUucXrikafsY7s3W2fXkB06tF5zi30PaEAotVsm02JxSdHXVB61pubh0tqfE0qrNy8gCKwSSBfQYJ9PXZ3roA/VX+gnz2MNdd7lKWSmWkhhZEAEUmsJFHhKK1h0IoinouN4kTTzkCb/pBCbjMpI52RvIM95oUrRIgXN/VjtKI7ssKqmV8ThD4gkMoLojUltQbu6kO6oDMDrvH/UjzWHMKAZxJG/oz8QSSC4qK0teDDygpKsKBwJc3UmIbdZ2V6hyx6DkFD/CB7LoSI9OjL7B6RtUgEE3Zi9hMCFCJkXegZ/yqFMuyGOEpJirSRxRLMqhRVXo06hKPFgEpNSl0LC6GmWJCW4ufhf4I1qS0yIcjWwmXoFmx7UXspiNelhUSqc9HGmqpVoZOavI332GhBJ4iJUpuS8REhZTrHBHOAi7ieRkOZV77TEi3WEHR4ED4SOj/tUn6YvHKEXAg5iliafykH9DkLbJW4iQCAa3J6qVAiInUtXSsXAv61S/hoRGiJp9AmkmhCKS5XahS0CuS4WRFjpUyP3+xD5kGjEtILYGspIpVEMiURVoIqKvcMUQj5VCIwT1NkC4o5xgsDztcTAliYqv1kHEL/xmoRzwetk5yWZo+W0jshH2XzKiRlvo2DizkuyGe8j8IYB4TZPGhjKBvYUgiRbhYStCxhB1C2Yl5cbZqB8CDRlccnTXHtmmPdc+2YP8barYe7psATr09qp+77etLaAQUx7MPaZGc0/mC3A75ztt/aYyuhA2ZjO18nTej3jBuOfPDUs19y11rIhERDEGvZaEUyzE/DgH//Zy/HO6b/1k/VYn6izn/rXP23bJRV64vEn7Ctf+JJt3bLFRkdGbe8Lr9qxQ8eto6PTLnvTFfb8c8/Znd/4ll159ZVONOUzsmOsa7Cdl+6whx942FXkPnzbB+3lva9KhTdvzz/2mE1KanvZ5ZdZp8pASwObvVztuBiBUqnWXpwaS7vqXCJeJ3Zd0draWu2H2ZwlRfQ0NtZbrbQXWGusadZCTnW2tbfKM6fUA6NiTogxNaa1hCrf/lf2Wc/xHhFITbbr8t3qa7WtXXdSanY11ndqnfYDX20OByCRHG2xipMFq29M6lyAWXhm4zEb5qu/37gQWCWQ3rhjd0G3nM08RMTLEYSQy+oIW4D5lcEJYoIpP41kEK8DN6boPosvPHVYlL007yXEEQbXY9m02hIgKmezp07KtqGYV8C/oYutuv3J6Xq1Tzshoj4nsVcR8lAv1S2IF1yc5mT0Sv2zEQGQUyQQMqESEoEKw/z9A1R1klLhcSwnmPAujhNQywAxmwBpU54Qcnz7UStphHtlE+EGko8KE6qBcyFs0x1a2hXlvxaSI69diC4qFqO962WjIsUOBeytqBXnMDIiycKgzkYho8tIwCMgRuXlDscE+hfCimI4apG68S8cJ56D+NPP8B55pxIInxA/Ei6hF5PgTL234IW3RAS4xggiPKv5BgEg1/fjlcM+l2KyjypPED3YTcnpevnt065Zh3i9k4KgI/hIAouKjYTXOfoYOpvgWmBw4sivy0qidaBsRc11Oel3+zokAmeSvL465iXBWFWhko+L1gq2hIOqozqGYwVJWVVx+fwO65tUcOnJ8YgIjDHBaERjKMRJhNWk1hJznPZXStrbIDW9Zjl/qNSzvKRABVTsVCfP2aucOCqX4Ki+cH1CCPCP5OWpbGDJeo2KWEUVD+cOEJxT80QgJC//T0u65/NKDI5JpIWSdq3EejytntfwRrin+x5PN9l/9G92Ir4WjIewf0jJooqZVSsnHFnZleB8BBVNYDXX+7PLe91/+/id3q9ltUOvT2isJ+TgAQZHVAyKwJYTiTDnJLa2gTo5Dk+4Zt4wLyLASoRVmDhHilpvea3b/p5ey2byVt8gD6qtrfbmG661W2+5RRKh/bZp3Xr79B/9uXVv3GDvvu199g8ipI6PnUD2a9e+9Vr7vd/5PduybbO1d6xxgqW+sdE+8ZHbbO2Wbnv6pWMiVNZp29Gs9zXCdgBDY9zWrO10KeqRw4dtzbpOe+rJp23dmjW2Zcc2u+u791jvyV6rU3t6elBJrFQ5HfbCD1+wm99+kx08KPunsTFrVl2dne12pSRW737Hu9wuKiap14Tc8uPBdv2mA1qf1TbU3x6sY4DhiYkWQmL1exUCMKBX0yoE3oAQmMF5RgqgBALhSIP+jstl57g4z9Wyh6gW1wluk+Mgk9OHAe9waKLGNqbNFsNWP5j9btmhxWXZxkkdE+JM8+1qfbKBoglndgCXChaSigejSnncy+GKPH5KTiWOqN7pJcrhTwBPXCuPSs8aLjO2OjRvvrrdVfd4UsiCEAnBAicHEDLkD2AFFILEPaRwEEU8C5EOSgf5Fyvb4TAJZ1bNdqRPz5Ca4YgA9cKMDtbp98KSl/dN3UiksMdJSOKy0pIj+pPNxC0z2iYVkbRV1csFfPWQEPiMGgrHv2ywl9h0xsCBApzmSD5XXAKg4kt5iMOFE5AFk4pDfQhkOjOBKuAKJeZa7Ygas04FMpckuamRk4YSQVZeS4Co17oKWPn98utwLmFDAJGU0jxIi3GA1EjgniKO/B2BN1S5m1mGkDbdEEkg3rFKEpKL8wxW9XKTE2vOFEApVRJWCFHBENg7I0S3IeZH8qPWUdvqbvSR5qXkfpu57UNUIdulmmG9ryDTqU1qNINxVKemPGCqLLzxuac/EUcN8vZXLUKpoH2BAlgb/IP4QYpVLVXLqgi2c1JV1Lskz0NlSsAYNV5gxboGwY2JYYGtCOsKNUNf48BO74dE1xThVTbvKKtKzmkmNaYgvKGdF+0hzbdX+MNz6A9jxT5Asx1Ws4gkCF/38imYzU4g/zyrHQ88NEI4UMb5mJhj9Wsb3WskTIF0UXHJIAzprz4Q38HYB3/D8efsYh0yV0i4qq+WZObzf/l5X68ZhbT40Mc/Yls3brNP/vQn7I6vfNXul3ocUPylX/739s73vdP+6n99xn7nNz6l/TRta9avcXvO7du322ZJna678TrLifGyYdtGu/HHbrb//ief13qRFkRbu+266BJraGm2qKQ+DF9UTKXGJhE2kizd/pHb7atf/Kp97Uv/bFW1Ffbvf+F/t41S7btKkqo//P0/sIbmRp3tWlNq9+0f/An7gz/8A/vd3/qv6uuEJE0Z94D3k//qk/bFv/uSPXzvg76ufupf/ay1N7VrPdDPcVvbfchy2TpLJxNiIgCR0twom0uQ1KvpwoaAVL7P013jwh7X87r3IIv/10N/6gc9yAQGywR7m8gFuucFcaw5NEAiIvGoRcRFnhSCVCwICel9lxXH1ltsw10eNFZYxBSsQCzwRIWYvlLImS79YNEZou8AuUJtSniHb6hwuTHgF9PYudRTBS31Ara13HbThol8XM4X4pYf3WnjyW6rrjtu0a77tZtPq9ottdj58nE8gnDUitBBLQXVHYLhnskOABcSw3s8H0F4gSgm5eY1L2TOPa/N14hF7tM+YuegZuWEXBnit8iriz52xIAzT2chY0rRBcXtSLkjjABpXbSQRTJge0T8nblULam/RnCHu03fQIipO0RcFyoa5x9jUplcrqrZ3GWqRnmvGx+5xLI91wgQQvbreq1985PW1YT65jRRzvsgWDg26Bnrm7u4srv0C+KkIIS0kBdSD5IrpC0kCsnKkQPhxPoMEwGJq6QadfHkKXtHosKOKx7KPRXdku4yLtP5wvxL/WZNu8dDfQND6vYYVLKrQsLFb4gbDMUhQkbkjCVw4iBCX/+CBLxqbSLdJVfAbVITOmqVsRPWKHWijoTcHEuKgQcx9hzeKYiB0Z8dtIGxocAGSoWgGlQvOw3iS6HWS1u8dJ+LgnCJuQOsaDMOOnDTDOxxn4zTBiesAEUZOHxNi5EAQRAm3oe4crsc5UWCota55ACGyWyX8uF7b7RvnMjQz/K5NbsPpeUuIjPvyDt2cdPjOjv3G/M3jLPcSFZzptJamludGGdeLNZP8qCGl5DEOCENiu0NGy3ZPyomlxgbmjPNLY2SsEbFRBhzu6bMcEZSl0Fr7WixWL2k5Jp3I71D7h68oVVMBDECYrIP0uZneTlSiEit9US+F+rf1inGUuboXhPPwZraG6y6pds90VXHxIxTOZqcUpeT99X6hDMIRvuGbXgkKSlSh+XFuOG8qa9OWM+xHovJPop10tnabqPDUqU7dMASkhC99PLL9sA9D9h//r3ftnhjnY0Mjlhfz4i1tDdbRDGYDiaPaT/hPBWTRJLV0eEGO7Bvm+XSIpJEfE9OiCFXP2Q7Ln1BNs06eotj9v6t73WG4RtzZqy2+mwhMPMkPNvSVt9fhcDrBYGSCtSENrtcCpUWIRBwq8uQBw5OootPUQBChibkVtUzzSElAAERHRXY81TgBa6kkiZEDlqGskGC4EBHhcAgaeAgEe7h9kehWsiSQSCOc3HkIrkdv0zlqjxt0JO6R7nFbIcVh3ZZTfvj5V1actGnZ0QiJDRJ5aeGm20svVGcflOAwb1SMaJPql81lYHv9CLK7kDIEFywKEUovJWB4MVEcNVFCQZY6fYqHrU9QAPL3lz4Eq4wxNtSkJ6FS/LhUrukAiknDEjAHGHQOOIlTUB2bmIOTqvGdCUS0INjz5zwGDyzoMlzOLtS/PG5RXuWCnEkh8RTWhkCie5rPkhtrEIxQbC9qqqW7VEtUhu5sS5NghDBYr5HhDEwvxnnhRL2PdL3CQRxwFzI0WljKfCDxLvE5MqlagAAQABJREFUhMKUr1LvXGT9dou0+7K1jfaCzKPSqs8LWqjCRZ6xppEeeBtYv4I4TjmwfWiNt8jmiT4FY4ZnQbx/JWriNqDYT3g0ZDyZKxVS16qUkxeL9oqRUSeYxYVwp21UtkyN1Q3BZCu1pSBJVGY88MQIEVglCXPgEl/MFzFzkNDqjq8RV4VTHtqHZ7wQVqgVjsDh157me0xpTKhi9pwJJUSl6tXmIMgyDBCIN4hWUlHqxalJAXbhIfS8Toz51cw/Pic0fv4989GCvyBEgT3JpdH6pgyXcJXdX2q5MCKAJSkYo6DcYA0GhCr7t6oo5RGDDGktGzlzP3wQPH5D/2XOZIbkJVJEen1CxAcMiSX0jzyoMMPMQRVx3+gRi4iQH6tJaa4UrCc7ZClJZBi7+pSkpArQWtVRYUcnem24PykmlggyOTipqqu23nGpJStsRirZ68R4QoTXeEbEvdYBe8aYiK54Y4VdlHrROvJV9uShJy3beKm83eHlMqezQyEP6Mdoj8ZCUiYFWq6sq7ETxT4byYgRp32FGEi1bXLhMiFGkSTL0YmIDY+NyA7qThE5GRseGrGP/uSHbSJSYU8cOmljgxu1frba0UKP1RZeVj+R1geMhAlJgxuaRq1LkqRD+3aoPDEkRBx1rj3uqnhNI/tt98Q+7Q/v0juraPIbeoGcReNXR/4sgLf66o8IAjrkir3vlsMFcaeqTmrDPKlzT0aeEBelDTBsGcgPHyRDwnKcS6SXxAmW7UXdsTDbjG8/XHSWTyEi2rhL56znc84/xJiS68arPXi5ciN0if1DJMczzPOHslGpq27Y503ODVwuxEsG47pHzUiVcsM7rCLWJy9H+9XuM1mqKkfSAU/FeknOuhT7ZosOpQ7hnRHL6sDIZRMW7XxKqg5JIcGy1xCxE7a/vNdTsCj1hzwxqWNMClHx5oIYi3Ool2WvUeNe3JJScww45eXQKxUwzxcINhzu+RxLgGLlJC0MpAKLlKvMxInCfmN2TjWTwZvRCsoO7/ANocfBXA6HGS/M8QM1rkBtDoJzvhQQRrNhOl9u7tNepApIH0BYzjZhnWCoFEqlU64dJVUcl8QC4mhSUi1xkPUcSRfSQIeF1g4uv/OTJWKj1ABHfNXnMJGX1vm60JoD6T8tKcNU39UxpLtdk8N2c51QaLkUfyQ1bqdimzXQwp5WKNEvYIgKIFKZwcywEMqsx3mCIEJdLmwTEtGOCkmGRCwOZUckZQwkYfTNhDxWCG5cM1f7U4M2Hp20ZnkPC+cJw1OhvahWQSfHnchj/NRPPQAhRertqoPYZpWII9x3h+97l1UGXHP2FVLYNv9R9of3QgKo7LZUb6WSKasxiBK8JKoFTpCharhYcgmUbAqRdnmfy14A2YX4Q/q2nNQiz2pr6zt9dz42ekoqwkmaZF2JNSJUm6TmXLCjyRMu5VmsXOBEkGXCG0C0A6GCPIjm1C6XDkoiwrqHwIW4hBjuaJI6rQjGXsW96h2Tx09JjmfAe7FKz+HnjEm8vV7zS8SiiD/mWbiHL9RsxhnGCwuDd1KC3zAhDnKj2gdK84RFIwjn0nnrr5BDCU+qKPjvNq5I8nTC+njihZKLQRFYPnf4qZSWV8oxMQArJFna8/Qxe7FP7vBb0rbpqm3uCQ+1cX/T39e+rT2bVE7KEmZDG5DfZ8fJDB2zLWu67Bf/4y/YyaOnJPFqsfqWuO0fOWXPv7JJjhokDef8EyOvqThqGzul6aA9lDJJk9r/W9oHpVmyX2eWWbO819XIkVPz6PO2q0LfmpdLgaMXtvrnvITAmWBd5yUgVjv1RoKA4uYktwrZ36q9WBux7EcqYofMIj8UYjYspEJIWbAHCgEBCRFHEe4sW6MIEKRO49m1shl4cXmdVpmI9mcnkByQrkkZymIbNVulqDy/EyBw1XUTpG1csS+qG16Uc4A+Kw5cYYWxjezc3v7JYsQKA/K+E+1zbn9AAJaXNvs6ODzgkDphNB6T7USnVIPWizjqlhpQvSqVOk6tkLwqeT0qNlh+aJvfL3Y8ZlnZPVWi8gdiqwMviK0k6QL9FuHkUhgdmPwLEDZdQXgqVYQqPoIFaUnSNCfe9H4ZoQLnGjsQYOMqQl5a8AdkJyXj+oIO8rjViUDTwVzqclk2v+Q2hEpWKn+gnqelsvfoC30CgYoJOQ6JRO7Byc/osHbJyGmFnH6D9hBIdj6E9vQ3lnaHgxoJEtI6EPazS4KHYF8hd/KVtZKSjEetprYoYgbnBQqwKmSGHrikq4j0gzEyEVAReVGc6RkLgm22AwngFs6L+dqJJNYRMyeOBuxdMUl1pJr4YDJnJ+svcXse5ltpOs1XzLLuO7dcMAzdjqc1l0D2RyVJa4o0yD154GqdMXRVSane4Z2SOQQM3NmB+gYwmD70cVwEzHB2WOtGgZQVzwiphe8zrEFtFUiLgsz6KWS+QXM2L8InCF6rMRBeeRpxNFUDlej1eSY57WGdhYlrkF7WEEgz/cxLbZFCaHXALArmJnfIM6MMNZl3OxUb6qKmTfJeKSmAxsclPnpGr2nr8Wyv7R2WDYdL5oLuhW0Ivh06ugzgBIG2tXmDVQ5MWgIPnJISvihX6zHZF26t32DJ40O2oXOtFWJ5O1g8Fth1Ct5Bq8OVRJlB6qhrtctbd1jMom7fRb/r5H1N1ptWqUCf44rBU5Gosr3Jw9aT7rc2SQWbC42Kf5ezrS1SI5Oqak6e0YIU1ML4sueEvfHap9pQynqufqnZlQp7odHTeaLx1W81fcEEVHH+ERLX9BeiN61x4Zmv+akSVNiM8oLf3MpqDbkNqghqd+Ffysj0n5H0Wz4S7FW51M7Li9ztH/hxu++B+2zk1Ki1bQi8ygZVBH/Dd2f+4m5wh1mflSTp1ZEj1qC6a9ZEbKRizE6O9On8kO1xJK/9TPaLkgxNFOotl1xnkx0hgReU7nDS5ZquHvVYxKLmxe7eh61LNk6TCg/w1PC4Xa1Mp5/4wfurf89/CKwSSOf/GJ+nPRTnkB1OYvbJ8bVWkRN3MrbBalq/r1snpQ+tA09IGAc+hAsaZBiiV0V6dIDKxWemVe8JoakWJ9MlT2cOphCB1C7rSNHMwyUol229ThzPmFQPwsOG7HgMwktcrnpQErHvW+XQDqncXa5NPer5ipl2IRZvstqOh3UKBt68wkMDDthU6VzLrsTjO0gFyAmiVLdU9ZpFIEpPX8/xXFbT9KpVN72ga6kpSI1vcmydFQWP3PGbbKJtj4LpSqIlxImaFF/TES7spHgXNTyQPKKw1wrRdIRMdwOkotQWIY0csCAbzskMO1tqqeeVql+FyiQeVYVUuwjiOwmxxDjoA/c7NZ6W+p6kGkKiXJIjOCULKXkIk+1KvkWuWiXtqpcL5BoQwJmJlgDbrN7BXi1AgWbmKf8FAoh0pE4HLapxYeI9gndG9EFScFpXwoxl3yAmYRBG4LCSCeQbicxK2ZDALKioEle2okXIxoD1ZXokRcTtNT0PxpM+hAg6yPdsGEQkZYJIgkGwlERZLhURoJAcrR/vE3GkAI6xVvv+SMaOxndaXPML6clc62gpdczOQx/wdNYkAggJXzGLDFgccg0P7UlKYgZMUYNrEJHjSd2PSELaUJeQq25iOcHhFuLIOgtA4zBCew1ip2ek1/K1kkgRVFdUXaViSo0LyYIx41IefSdk54Sfh4H0aEB0CZzOTAkLLGu422epfawx38NmUYqzJUfkIwQA5A8EPX2pEgFVoQrH1TeYC+4wo1RHOKaMhZdfWq/ABCnMyDEF8vzeI3b4wCF5e8y4o5Tmtia7QTFntr9lpyOnA+kRd2cP4UnzUF2tQXosoKQknUMCxXrKymEHUoa7/uVb1rWuyy6+8VLb1rbZvZUVs3n76hfusHfd9m6r2Vxn3fXrZLAf0d49LjjJcYokHHWyZYmIONdg2alknwjZRhs+MWJ/87d/7W6hGdNEU4N94ic/ZmvXrrF/+odv2ptveou1rmv0dzvq2+2lR1+w5x79od1w+9tsTbzV1iRatbdVaT+RyqvGdkg2dtjhNEoyxY6GhHFAnzeCzRJE7ugxtVVq5pXdgf0ZLq0XSqxvxsnXo2YNwY3T7K+sg4Ve1DPeDdZnwDxBcsf+iT3rwkmTROOYHMvINkj2QEN91tSGLaLsb6thTnAuLG0f8Xq0Fjk/B/QpbzN78JZtr2reSuKd01wSo7FKZw4Scdbw7MQ5OiFiMZHab2vkKKKYG7RnJrutt22bzqWF4Ti7rNXf5xcEVkf//BrPC6M3Yk9FOx8R4iy7jMmEFaQmlk22S+e5yyZ73281LY/KAcOrQsSEFOjkRpJQLZU1x++QxlRKgaigeBGZNiHZoysCMzfQlqgFL3CzEwdKXIe8u2xm9y4lrlD/qNWeDQKXV+yUdJukSbJzKA5eJSJnnXLI4H14s4xGR0RAyXvWhBBYbJXE9UdNbrIomyrdG9e1e7wTx2xyQoiS1PXY+J0wqhJ3vuGwVTa9LGlUvw4ykEO1NXHIJuNHZIyq90UsmQzQx8c2C3aHgzxqIGWMy6nFpMqtajgob29pR+6qddhUqr+owiFxCVTLAklagJAJ7uXqPBBAHE4Qb5lumxjZrO92J7yqpUZYIaN32lYpd9vCLh3dzuRkN1AtdTvBKCOD/5ycV4yPblSkdBnK1w3LkkdBFpt6fVxLIPX3cNiREec8L8NsYD9f4rAE6cdNeTyiYKjKW3588hwbJdShkBaESOV85VEXHFnU/+Y6iOd7b6n3QX6B7YolEdyVkVErJoUoSv1ysD9lkUSvxSLjPq4gWeXwmKtel4IuB6lRIRCtwoBtHcRRZEhBJtfaQ8OjdlBBnBNC8plFwHKlCCTGpFmI77qE5riQ7HpJUAlgm5ELfFe1Yp1oHuACmTlLfqQrdN5VthT4dlwqYXONP+1EDRGCKzkpQl/DU631iWfMIk4q5LUL1UiC7WJbN5yRCpMQUdTsmHu8H5Y71V/Vy/zhGfMO1+HjvmaDEQAhDjn/3GH9UX5E9bg7cPWRtlN6EI8rUCukTzAdUFHNS/pDcgKp1Ff/rReJSbOxa63d/lMfsqOHDtt9d91v67rX2jve+w5rSTRrr1FsqdhWq2qVR02pXuFpkj6OymHN8LCM9uUsZ9uGTTY0OCRD/EHb3r3R1euq1I+07El6D5yyFnkw69qw3gop2QASHFfg3tW21TJjWTtyUFKB5ia7bO0OEV5S/UqlVNag7FISFm+IWUH7d3Is6cTRbR99v3Vv6rZ/vuOb9q1/utN+9l//jN3y7rcbxFx9fYMdP3HcTp04IZsZqUqq3601zXaRjPYP7z8k6dO4dTaucYP+ynbtZ5qXR/cfc5uxLet324HkETswctS9hjIW52pi/tRE8UCncVYzkXbj5EaTesEmM1dC1/1MGZ2WC/aS0pTNCfC01g4EMMGwCVAb2NgtWJ0T4k3tjZba0mLfe+g7dnVH2q7pknrl2BN2ROfCqUS35SNrnAGxHEJprl5WyR6qoQEVXT5qt9Z4kMLv0s/SFztOQmr6VVpvz+erraf1Ij3hLKfHq+lChcDp2NyFConVfr9hIAAau2Gj4iCoxXA/i+KCDg0lLNW/VSpqWyzf+zZJSjpEEDwu5EX2AiAYeMOS55qKmkEhJ0IOZHcxmWsxa9h/dnug9k/nMoJkoUMwR0KiAAE014Hl269ec8cP4q6h5pVpHLJ05D6rGr5YKnC7FIw2Jm9jb9brEDYiRtRz3vPa+DN7D+dgpD1VOsTqj3jg2SoRhoaRqktp/E2/9isRPdX1h+Sx4bAAqnaWF6g6K2Oy8+q/ygojO62m8SVJmQ4JYZOdShEOrJBsKE8lxiJMpRpUp44e1Tkuid14arN76CtC4KCPTj1OnEmSJFW/isiY1MV7pC4iaVpU4yTkGc5+Pin7KUnDOP3rmk5aInFAkiONq5xLlDcViOSlIoa3N9qyGFLDc1TWsDkB/nMRNeQB3osl3gUOqGaBsK50AgnCLgCCf8WSxqaqJunTsjC2QTBeZ3nBPZuQsXbjCcE5LdgI6QK5mEIwZtYejPnS2uR9QLVOVETnxJC9PZK0ROM6e3Awaa/EtknCkhAMqUtIughcd6E/s7pl/2JcUBcVSeGECCMZBakrSZRAwL1KwXWioE9eaKLgXJRUiPbi9jgqVbOxiTGZP4h4Yq7Pmg4QNlWoOAlGY7L8IfbQuLgeNYoxE9oYEdhyTEhlUl4LmVMhgePquSJQuBfuH9SrZus/bROBJOlQMP5SidM1BFKY2FtcwkIsGzGO6E/wJnY5gdTLpaAiYAKGkshsmEaSHno1tFXSmnDu8/bJdK8cRIzZ+oY12j/k5Uzqa7EGEYnS0N3fd8ieuPtRa+totbe9+1Z77KFHTJ6cbW1np33723fZUHJYhvopETIJIaj11t83YO2KofPLv/RLbv9x/3futyZx6YeHh+39t7/XbrjhJq2ZiDwC1luyJ2lf/P++YGN6f2Rk2D720Y/Z+u519hef/gvP/54P/bhtvGaz9gWkYiICZOPV3tFuW7depECgu+zx+x61/t5++/ad37YPfvh2O7L3kH3xb7+kOV5jp46ftA3dG6xRUqK7/vEue/gHD1tc/Tp+5Lh9VK6sb7jlrfblL37Fjh075p7Rrrj6crvhfW+z4VjSelMDIh4W30/CMXm9vxnPug5JR6lY1xBIOiY0oxZO5fs1OZmDLglWQcw7/oVziSvKTaGCm5fUX88bZXcHA4E9L8hLKQskb6DsznZtsKrt66wpvdeG8sesWy6+2+rkoKGwzw7377WD9dssG1mrOtgrSi8tUOx8j6aJovlyhPe1HqUq2FSZ1fquF5rQoaWk/eI0PcEw/+r3hQKBVQLpQhnp86yfvvlr76yUCLxGthPxxgErRo5b1dhhKwxeps8VOrjbrbZREhkh+AR6JFXUpiWlSMr+Rjp3NZIenfn+OwVRVxnSgTQfYowOPgfKUqpChSouNaca2Valan4oadJJebq7VDglbsC1XIWsmfTs/QQU2keh7vnOjyhq0EcbfW3j4YAwkm2TO34oqa9NNXrGhaAZNk7vzjxadfSJgKppfdYme24RoXaTVY9ul92UVPVEKFVWCiH0RpQfkYyOPnIsMZ5ZI6mP1GnkInmiEHdiyctDoiXiNT9ysQhAEau1YxZpe8qqYr1CUuUqVv2czDerGLVHGFh18wuK8yFPRkh6hKQ60RK2eaovuK0luK2kRyDiCyRHnFVOrYgjiNIQQZz9CuqPU1z52Q/n+F0OhTken8UtbATwQrhwv5ZTQWDArPUgNUdxC4QUiThAiigCNi8HIfl4nyVaT8m7E5I95oXgDou6lEDaw094b95v8oLviODtGB+xdygGU0djmz050GsvR3eKOFIcodIaQd0HNbEA2Z+3xCU9YDwYQ6SAqFyGhHAwdZDiBP1BAirywiVHqCpBIEELwVNHrRRj9pwQw6ICTYZES7mdVWB/ETSJ59Xi6FeBZKnPqJmBXIZBSz2XGsBYui0WjZmmeaZgSjme9OWSJDWI73COQWRB6EHkU4QTUepD0Df91r2CpDPjsikbr1XgZ+XlKY4aJnD+oHJ5Z+oF5adK4JWSlItgutWTcucMINRW1gGBp8fGIIAChDyXyWh5Kq5YOmvNrS12620/5ip53/yHb9h7P/heBRhttr/+489ZX28fmrt2zQ3X2Ltvf5+99Ozz9sT3n7CLL9qpfVOSaLXtvm/fK4I5YR/7N5+wPU88a88887SrCcYScbvtp2637ZfusP2S6qCCiwRuZGjYvvON79pjDz9hTz76pN14w1s1V+vlHnrUxlJp+96d37NdV+y2d/z4O+zh+x+04/tO2ElJk557eo998GMf0LNd9pk/+ayrxD724BM2JGLuoz/zMcvlcvZPX/ia7XrTpRZtV2w8tU90xzmbmBPpXjmkkCp5rC3m6mITklwG3jqX1mxmGmskzbpTZ1HPREsA1+HYKsEIYz4wn5h37bJTQ2XVGQ/lE2hJ1WmlyZb3SNMldqywxQ7Kpq01edC2SAV+Z9sa6xp71V5K7bNT8UusKDvA1z5pRRVGFO1MyxBGgu+zyFpXntH12vdltYaVhMAqgbSS0Fwt63WDACos2KZwbrG5Q5zU6NCcrN/rEo/xUXlrG7zcsidvkRrRiEtSKuPH9KxXEoohq8y0COlD/M7bZ54cwVARbow9TzFV4rAF9SztlAUhiUhlhjIzzQOWrbtXhxbIlog6WIM4UlBclnGpJSAJs3HZNkjP2qRa58FmGw6I0Djm16FdzzxNm+P2XPDQASICs6btEdVzo9RiZLeU6bQqSZQqIcAIZgvh5lIGEC55Q8Oduto6IccQxJChHcC7RpKq6sZXXZ0OoqQyftzdnJtUHv19SbmqEyfULhBqsEZ9xMlDla++Bq9EwZjP0XC/BTIDIuhc1AW4jyCZjmDqQKSuuRJji33Ccj12zVXW2d5D/cvdFJ9tQVPvM86Cf2TAImvv1gJSIM1cq+V6rtfYyTi/mLD0cL1lRzbZcFS2Jg2S3DWftFrZC1VIfSUYa009CIsF4BxWB4QJXCkFS3uTJIWdDR321MApezayzeJyFVyjcSMPamA4fSi3lwnLONNvCC1siBhL1IHmGu2QGIE4KogQglKorVXsI4FpNDUqlTw5DhFxxD6DFCfMP2+bVAlzDNqCLYY5VK5yCsxCNT7WAXm559/8RrWOevSPxHV5gmuPyi4OO0aE0NMePl7HrA4ieUyXpKqsD1TaqNudQ1CPGhkS3tQHQoxUNVCdUv2l8viazVR3OKhMUkzx5urq5T4lXif1uXXW0tmmuDLYeSLBl32MsjW3i2kVrbINWzfakz94Sup4mneqM6dYT0eOHrVDhw9K/e2IpaVWt75bKrWyOawX0RNVfJ3nhl6xo6Mnrbu5S6rVQbOQeLz64itidETs2huvl6MPEYGak/lsVup8Gbt8Y5fejVpja5sNHB2wQRFVDQ2N1tHVKWl03GP9IIk6vO+QvfLyPjv5p58TrMWMkJog/Q4I6KB/3slz8A9jUMhqTAVj1K1d4BsO2iLtZbyBYUpqlTgjCedBQURShVTOKgrMd+VBKlWaB63ySNgilVUmNnN32ak0dhWag5Pa14ekWjcY77b+sVO2fWCPda3ZaW/WGdI78KQNjsrTJh16DYeAHlTL5rWx8wrtbXFrmXjEdvYfUJ1aG5tu4emyu7j6wvkBgdWRPz/G8YLrBRs2LkUdcdBGBjGRwLg4p+2+Km1VLc+LEJKdyolbFUC2yTL6VA7uUEDMfm18iHu0+btU6cx3XldVEbcJRGO+DRwUBxWfKSxjySMFF0/qM5V1FpWaW16IEMawGMeGSdoxSjqi1H/vBRxrHSYVHu9Bd5AarVDijMKbXrTrXlfFmpBdUjG3RoSSdMZ56AdlcFg6qusN4rbaI5uPWqltVTZiAzWg9oFgAxkNQ1y2RxG5Ssb9eP8Vlu+7RmMkb3p1R61C31WSXkXEbXTiaBaSOF/XaqQbH4MLLqTLEbhZGTnUQQpRT0JlKmj1rEz6CfKPvcaPPGme59WW14JQq5B9WkUd0iHkJxoTebWzlAhRfknaGk30yd4E+w0Zgg90ikCKu7S2Rg4JgBszT9NvCnmaF1bKVCvbkXVSzdwWjdoRIa9P18ipipwz1AoBoywIhLRsY3B6sNwUjimEA+WUw4p5NiaJyGRq0j2a1YnQno3YQZBMai0X5FjBiQetPaY1KnPD8uyFuh82F6zJ8F2fW2p4+Hu+NjshNOsh7/IBOSXR5jAFe1oA2/Ae3wG8uQqIJyRb4+P6aC9cLFE+zhJAgMdle0N/Sd4OyvMxDMrFOQV2eRAHQa7p0mH2VGqvdQJOsMD5A8vZM/o+EPTFe6M6g24FLUcyURRjKyr4p0aPqh3yNOZEoCS/Cg4dj8bs2puvs1veeatVS2UxUVVng6fkHEVUKhI+PCy6B0eKU1kNTfV263t+zBqbG+z//R9/rqCfB2zHxdu9L9XE9NK+MTYixo7UDytEaAEniLh0Rk45RJhVy6EEgXOBSUTBRy+WhOrdP/E+axdhl5EEKt5cb88Ny5Z1uvvn5BVSyAY5pPB2+jgu3OJgVFnvYhxof0OyGdikTY+251Ex5BKIPDHPawWzekl7VzJxjlPzsBx07BGBmzy1x9YpOGyb5kObjrDMOMFdV7LG2WWpcDEbstI+UdQmqXvWWqOvKaDwmlY8uyGrv88xCKwSSOfYgKw2Z2kQ8K2cA5gDuoS0gBzVi0gaFbeXA7UycdxqW16wbO81QgTggNXKRqlLFYj4kFQJIulME0jPhOyaQmPr+cpByhUEDQ1zQMzhBShAjMK7832DpFTKCLxGHDXsmHA7nVKgy2mkSJv41B6u9jhgpg+6+cpdzv3Atkbe03RSjtcoVkTTkE1KClRTaHAVukm5Ep8U53JCbZxE/Q9vevogzaqVNKuyfp/sBobVNvUZJKqccIOA0jhUN7wk4umUpEk7haBKjS6vuCUVCTmXkIqXEPWlGAGX9ykqz1o5Ob2YhlP50wCfqxSBtFACiisLyYVqm/+ZcEFJP3Kav1MDPX/mZT9hPEovyWatKnZKYyi1w8a9sks7IgcK8kAmDruWE6vG8zLHeAXkGlfsoBHYJsC0WCjFZRK+2+Rqt6bNnksKSY23S520RKCqbznFQsHFuNvlsH5FvIaI/ELl0hakgUhUkPCASIcJpA71N77HZP9TUB0t0Sb1SbGPlJc+hKlK/ZQ8Vgih6tY3TIl0EZVceYgTYYjb+7wIJdrHezG3GZRjBHHekU5Rx1zJ7zv8dKV3XTKkPYD+uZ2DKoPwAo4k/1ZRILA0D7VAJ0iUn/nMPEDlieqcwFGmpcwNbwfvqG7yQyjRnqKkZnzXKkhordxwR+V0AbVgh43yu/qh8kMk1tXHLNFQZ48//LgdO3TUXn3uZbvmqqutYq1UaGkv+dUHiCG94j3yucOc0Y37vnWf9Z7qs31799muSy+RlKlV+4bQcH2uv/U6+8cvfcVV3NIiUHZu226bujapvGCvpNygROrQP6kJFrQu2lTGlddeaQ8/8JC1NjWrbjnXEHJ9meyI7v3efXb0+DF76ekXrK2lzbollWqVTdQdX7zD1ty3xh77wWO2cc16e8tNb7YX/uoF++6dd1ksHsfgxt7+gXdKwkGfgpq9+nPwD+NUkMtRYFKtMXT4O9C1Xqent7ecPMydvOYRwWDdI6Z3b1bGWf10eAsODVJ5Q5r/WqQKMbXytS32auP1Urs7aTEciYgLmF2AibWi7QiHmWOhdDS8S3vEKpK8olB+QxWmtX+Or/43FDhXG/t6QACO32df/PKcVbHNp8WZhGPMCY1Ht2L/lSKMNge2LY76CJGTnUq0/Wm3bcGRwAykfc6Sp286UiF1BhANPFgtlEDcmqIYnweIIAglSBxegM40ZYSQEZn89UkV4hgGnopAgHOSYOHZDc4raIonsDjFnhLqJ8yIk0WEEupxkhhUyIV3hWNN8x3AlBE+C67xiEUQyMAgPnwWVLWcvwGcgHN48gVvc9gzBrhdxrMYv+dKjHNKOvl4O1ssLbXMxcqZ/ZztGaQc4/7XdqsWDES4Tip2FthBRbXs8zSuSBISGv8QeZ/dPv+tVyFKcI4xVxKKKSRz3HZO9Nk74wV7Vd4J7yl2CBlvldRX9mf0UchaMpu2vKu3BQRDldbWYkQXcEd6XCdihbYS+yd00gETgzEEgSx3bCDUXwSJJCH6B5HTHGmUVEOkkaba9GyTjYsCZrqBvsoJvBxWal8RYYc0SXMUt/20Ly3JDI4dFkr00dtTsv2hPSGBFMI2nIfcp/zykADsIyFzxF0shy2lwXNP3xnNoX4+TvToSQgbVNiKUierlLQlgoqcOPi45IZgwe31hhrFJ+qXi/+YpDEiliGCWhV0ev+e/ZZMjkpFrdm2bd5q9fEG6x2VC+7WRq+359gp69rc5TZ+Lz33il224xI71d9rp3p77YRU6WIiYK68/ipraWyyH+55QU531stzXaPtlxTohWeet2gsYtdfe73cv8fswOHDVr+uwZ4f22s9qX7b2NhlW2rkdfF4v7V3d1q2piBkutZ6Dp6ynRsvskPHj1jXxm55ZIzYM489ZSfloKGlrc3a2lrs0p277eTgKQUrfVb7d6Xdf/f99uZr32LvFjE00D9oTz/2tBVEMO6W/VFVe609P7RX80BS1XM4MZeGDvbLdrBoDRtaJJXV/qngx7ODaaNm6lI4zV/mDPMtnHsLdY/zlj2ZddJc1yTGAuyD6ZWy0Ltn/ExrltaRpq/mLo3pH66dIP9SenV6WeEyKu/Zj2+8xfeX03Ov3rkQILBKIF0Io3ye9XEhAomuovYxnFUATLhopWPAFCyumFXQ1KRUw9LdcngghEhujiPyYlfd9rTUiUaETC1M7JSDEW4qSEuIcJQ/K78G2WlUAMxqHTCodIH4g+AQrPBME4jOiKKKwwk8s6NgqTVjPC2pnBClsJ/QOhhxZyTFwqB3Zv3hEaPypxC38uOGepUHgpQMuCaHuFKw3DAhMasXvHBZXFZa+HhZ38BpWMgNCG15OykXDjn1EMOl/HAtr4D34bAmcwSupc0LJ5DaBrmELq9r4TcWfwonfqyYkoMASQxmg3Lx15eZowRxxoRh0tvEn0nUonK3cEKyARGHlDFMlDah+V8p4qmr0G83xotWL/h8czBrPbGN4kYHrq9xGpCUi+gMtjTCvYilgyoP67hcpZRxcocoKpd1BT2O1BgX13zTYp+XSFjVDvI6USDbRNZqeSemx1wu+EUQdMjoHG9vJMYPgmcgIzfVmRERTxEnwGAK4KQAYg5iDJfAGXG53dHCYgDykgVWzSmIE+qAwcK64h+MFoh11IQTqJuJkYLNVr/2sazWOXsHBD+MFYiXJSdlZe6GziBceiV4UC/EY0HqjEjCscOpksdCwhQgIUDSxvO1co3eGlOcLNV7fKzH1bHwbge8IDAh2vCsqK54e8e0LwFr7ACHc7rWOAWezoLxFAA0vkHAY+IMgQQzfkjgkupra7xJhKfWkAocyYsw0RjWVshORXGKTiRPKf5STntSrW2oF0GlmFOjytOT7rN2BY9tVrDfmNqOOuqoymKcWmQvg2pkQeOE98LO2mb7+pe/7q7DGc8Dr+yzj/3cJyyxudnjXcXUFhwPJLVvHB49Fqx9kYWM0bmaGMvcmNaO1lFVXO3X76js5xLVWrfMMf1DNXE0m3IJ5FL7wTwLzizZagmOMBNcA2CpBbwO+VjH9C8iNUqXwqrNWY37DCbCWbTjtk1S9xQDZjVdmBBYHfkLc9zP616zaZYjQH60yWNdDV7r6uXAILXBcidvcCIpO7TdanIyEm97xqoSh3QALI07Nle8o7mASjuK2rSxs8DoOa9DGWSgPIVH72y0h/tO4oFQ6UegZqbDTi6QXfdfB8NrmfCCBKLDgRu2DQ05pC8gPRVChFwSFj4sb8/UPbVQBBHqdbj2npRa3kRWQXoLcu2t8ahKHFUGMgd9AflZCeIogEugxhRcT/+lJqQIzsGf6tn08/AKxAM1LFQk87iJnyfRehDBqJB6Duvp3szzwlJvqyAQmzzG16/tUJdaVKpE9TJvgQ/9AlbT62nuxjMnQKzzUpGjsaCUUbmK7i702aWKar9ZHHxhu7ZHcXKGY/KCqF+ommKDA+KPfQzIXK3sX0DEQM5ykxjwqzECvX5q/mgO6YJ8qKZhv0KdEEfAnXcgBpw4EtKuhvt9xlEXMxL5w8Qc7kvLHbWQbIIF8wjkGckdhBLEQkHMEwgiV3lVwTg+YE5A7JQVFRY59R3C0eca7dM/EDm6Vf4e5YzLCQSEe1x9igrhGxbBOSriXKSexSsCmCDBWVJSNuoK/k+3kf5UIeWFXlR/cD8+IXf5SCEomXZk5NGQ/nHj8OhxOyLHCOjOOey1AewfOmoHh+UEhvzeGN7kE8CUfCrcVdN8/Lj257rPBkJujQmqa1PP/drsaOqUF5o6Piz3/lLvXN8kxy6Ks8M7+se4wRjaO3Qg2A+pS/dHRYyxScLA4ZsJw+WhkSPc8LkBoXR5+yV2wztusJeffclGJQG7+dYbLaFYPC/IAUR/VmrXpTqYS7xPKp8rwZ1z6y/wrpXdTAB3b7AzhQpypiIfhxojBQ8u2Z85eBZpvo+zYNggBlKLHKjEJWl3NVWH9SIvv46PaWeVmFJbGtaLCVlvOallVsu5SEVthR0YOiIX4poTztgK5lwwh4IG+nzUvHSYlbWZ+4EjII1/OAHKnq9eXlgQWCWQLqzxvoB7G2ySIGnV8YMK3CFPRydvEvdUKngKWDpx4mbZK3XIucMene2SaJTbyZwF1NiA8UDGaZuVm1RUckAqpjZrHURwOj2gKwc8H69PhJAIKewykFZxF0SdyPKouMGxD3OeRfMWeFXEkTj8NULWplGF6exwoiXn0Q249rIbmes0QVIkW6SJLEF8ZaeU7pQ6T6tixogwan3OquTCfNrCWzibCK6YkJgy6ExXeKZXgudcCYQVZHexxHig6oTN2HzqXpQCso4xOJIFJGzlko/F6pjvOcjsclyMz1fOcu8z3swtvJnV6jPX+FMmljrYpzhWKnhWqe+1QrZrckO2tdhnl8vJ4lqpYBXkXORIasT2W8J6ErstJvfBzG3cl6CelpUzDVKtpChxSatYLGmpyKL+hRQDJJ72FBgD1adVoByBFAkON8/4F8SJUqs0FhBHIPsuRQK512chgjgl1bnKtEoRkYQUgYC8BanrMReRQBIEFhsnDNSZ60kh5BO6r8fzJz2Ds02/cE2N+t9UKnsP+LKe8TSHPVO/pFaNignFHIJ4ZF0QHJX54B2fKmT+C9939Jh5GTBzkFwJagCurG4nkjQeSD8DxoRcdmu8coI92YCrv6T3/Fo//Q77mp5MJ+4GyfOV9oPy67Bi2gSDh1T+nBJYbyP7+217xQZramy05w68ZOMXae9LCPEtEVez3yuVMg2bqbo1B7yRQUvxfPpc34u2Xs4Auq+7yBk99HXP4Cs2IuIIgpL2hD2b7hE1nrsJ4nbkyJB7sUusa/KYXMAXRhxEPYQ+16wdh/c8XfE9XJ1GdbRJdnrEjKoU4yOYSzNHe54iXrfbtIZ1sbVRwYYlkf705z6joMC92isq7V3vf5ddc9N1Ylj16WxVUGPtTUg5uY7BxFKfkIimJY2s057F7xqVBSsIFdoxSbzrFMOsHsJwCWfE69bp1YpedwisEkivO8hXK3zNIcDhXTokT68rOPZqEgetcp0QEHm5m1Sw0gm5os72vsmqM20WXfMDsbeJmyQsawUSiA3tcbsdbdI0zTdebb5ZSQhSZep23A8PMQ40DuvwtxvUytA9yPFaHt+Bah1OIUJkYU4w6PCN6yCRxo7bfZTDHNnAuAjPfN9b5BZ8rZAbqfCIMKpVrKPqhn0CLUSo2NjqTZicO6+Daq46vc+CDbAM4RG+t9A3vOvyxMFKPdgfLKUcxsPVuGS+n5LdV3kfy8uFiOVwpcxq58ZPj1t5viVdq5FIjrAz8zmzpJdWJhOwh5CAGIBABmmYPR70rHKyYO2Zo3ZJUUiJiI+M2itHzoJrla2LJRQnpd3VSPcMDdm+qhYbiWyW9/c6vScGBfNahBdECZxtyiceVaMcIahkG86MyhZJBJRgXyePd6jcpdJpyynWjpomZx7BqLp0qzSOrBUQoJAwZZxcuiOw0J8InGX9Q/owuz9AjjWJiiBIcrO45jAhKDMuGEC8EJepKOZEneyxYnJiEKuIyrvdiMYI2zAVUDbNKB+JGoQWUkXU8EBQaRMfn3dl+ak/TNQJTNJ5OZpQHvLCZ8ipDN9HVLa/H74wzzeET8TV5WSbpTawd6RUZhgUdkYZqgd7FaS3EAy4yEcSQ78hUGkHMMQhzYz3Ztc9Cw6zH/MbYo315xIaB9zpucaTBdty8XrbtHa9HbjvoBDWgJg6Pefy7qhaIcZ5e2VQ0qfSqzQ5ZJQs2LflVfW65mZOEaiYtUEfNUU8oW5azmCZr38MMXt4nQiCRqkpNkp1EQc2Pl/Dwl7XHi1eGW1rkrpufUXc/vN//33bsnWL/Z//7ufsxOHj9sf/7Q+ts6PTdu+6THM+ZQODA9ba2GLNskE7eFDzKTlm27ZsdsZLNoPkutIG+2XDpXm2q3ubJLdJqRQ2WH+PHMpAlIeTZfFmreY4zyCwSiCdZwO62p3gMMeolMB38x0Kk0LOK+NHLbruPrkCv6VkkyRXymPdVqVAs7WdDwWIzwoAFBWptIKd1sKlErIC2cUGnxey6IhQWR2zD6Xy9pdfl72y4peh3UDZWbtgHRBSIFCBrQ5cbnHdRy+2XP+bFOy1SQdQxmqbFauk7VkZjQyLrSvCyImjmcXC9XSvhILTzCREWUhpZ6TDjuVOBMjmEhHF2ciw98kRM54sEdkU1oFXvHEhkHD050qQsrjKHVPehAL9ns1YIYEak2oViOrrnSAG43LD7Abeqnw2/Bxikmp25o7ZDbGiNUU2iACWWpRUeSpE9EDUDEta8uhgr+2v6rTRxEWObOGkoVJEFPMEPwVOCABLXRNnBdskpKMQHLj5RgoUU1DgmAiUtCRMmYyQexnPYycD0l5ZI8JV9UEqIZlxIkTET9BiEUdqQ1B2UA5xfSh3dn9C+IY4EMwK7IwCNVJJxCRBhTDGDgGbl1pJWwgii70S7RuS5GEoOxwQsmEhKhREFRVVb5v6iXQrtIlyOyAyzJf0qHz+YIs0Qd9m3Z/rdfoHXFiTEDxBsFC9qE0HdVEpCwaSmLLqgVVREqqiVLJQAeZ3SByxHwFHdCJDNauFYlR53+YhpCB0o9qXcaLj5c7VAd2Lrk/YXY/fYxVjWlUbZZMlZx4rltTvIOzCipX4Iy+I9ZDobHBcnv3Tx6vUqoXgTD6kTw1iXDRFG11yxPr0M8j3yB951xZsAGre+17Za2OjKfuJj39IjjhabUP3evvV3/516+rqspefe9H+7//5Bypjwn7t13/FvvX1b9mjjz/m67dV8bh++7d+0x7+3kN25ze+aXG5jD968Kh94EO32c98/JN2xze+bl/8/Bfsn+/4mtXVIdVeTRciBFYJpAtx1M/zPqPCUS9VnVQB9QJUCzjh50CGhaRXxY9YbN29U5IkbGUKyc1W3fSyXFMrBscKqNoRTyeZSzkyh1pApEaIpMrFoxBtK8NVVmRkAiQwLHWOfi9YSyABQXUJqC01oaKgs1YqdHU2PnS55QZ3OeyqFf+opnWPVdUdA8PSWbXwllMUrNCbn4nIBoa3yYmUuJuNzhXFHXQgUZu/hah/IYEpRzbD3NxnXGqENC6pn0JoUUPKigiaG+mQ7EPzjjxzSV3Cehf91nwIVPRWhmu+aH2zMkAIBA4PZuBZpVwiR2T/tiZ33G6ISgJYHbe7xHntre6wSt0HktVSYU1XK+6YjPtBzlGYZD1GKmIuCQLJzitvhQihsUo5v9A/iBFmK/FY0jl5TGP9SpoEkk8sq6SChoae1moisjmK4EEuqveqJfWRZEljUp5c6kG9UkmNyFgdJwCiwSStXXykyQHRBXHBWOL5i3mGqhE2LDhT0MxxYgVpSGtdi+cdSA/JaUmoakrAVoJvBq7PcRsO4TiVyi6n7i14EawGCCxcclMUMX6Q1vmaUqOZ4/QXL5nYZaFaBcbMXIJwz4gowVGBN7yc/6B3IYYgxlEl9ADLrIhSG2l3+CGfS+UA0hzJ86neudYb8GQckMRNCJ4UMRcYGLu6znqrbVLAU11XRQIVyqUt0jkadQHcQlqY6kuKyTdh0TapxbERL5KQmjUq2GtTTB4cXc1MqoVaH3PvbYsU9iN6TB9GhhXEWlJdYt9lFPPq+aefkzRajoUUDPhw+pDUNBvsN37nP1lXZ6cdPXHcfvU3f83n5+/+p9+1fQf2W2okaZ3r1tiv/Mav2JNPPGXfu/NuO3rzzfaNr37DfuHXf9kiUdTIV9OFCoGFsZULFSqr/X5DQMDdR6ulE3Ip7VIZEHAl/oKUYWSKWkpe+vRuaC0EAM416MbUIX6aJEnqdsU6KyoeT83aB728lSCSQAaoF2TLo7SXWjAXkhBUemZ/6Rdet7AnoEbsNkAgl+7VRxxovUs5AVq21HbIjkK2RtmTV9pEapMMZYclNXreappf0mBIXQjCCHWFBRLIF+MzVypK+pCUN7f6moSQwKgjpQQ5JIggMJ0az9LLzAGQQ5C62Yl+QZjyLCAGgnkzO9/M38E7M+9N/6JncF8pb3lwmy6DK2Zm0OaltGnmu+GvEMmZgZSHDxf49vkpmOYVP2rK/bk3QxJBGe5npaK1fnxIkiMFia2ut4eEkBxr2O0EDsWSFTjwqdccwibLpTyCSzg+2AJFpZ42Xh0Srsqt/9hJoA4Ewg8hAnHC2k2mxqyAGoyQvtqo7usTlZc35jge2GCAlCe3OxJiTd9rhCjhdIE2YOfHyl8sQVewdkC+RsXUgGggYTk4Ks9mERFtNSKSKMoRShE/cUkMa2UjQ8wk2sNaYwwhpiHEmRcgsSEMFmvDXM8hFiiT/o0TzFb1V+MNTt7nCFSNdIZ201caV1C7kF7RhlAixLvu6ctHKKglRIopm/bhwrmovvuOSlEkhkhrd0ryFfa9HKFWHhDzueYcTKF4yXsnKo6Mw0KwcMJIKmOeFh+yIN8F/BeY51MiPBXXKtIsaUcwBRaESGusWR7+WrR2AxXacM9Y8KVz8GG11jhTpEproF9u2n9wz/ftnu/cY7/0q7/kMbHWrFtnzc3SYlDg4Fiizj7z6b/UHl1rI0PDLpGmSxs2bbCoiKwm5YtKpRdCKlYXs23bt/icPwe7vdqk1wkC4Rb4OlW3Ws0qBFYGApOKrp4vCNEq6iivkevXmrkR60BVhk201pFiEBiQHndPGxJLJUlSVJKkfO91sp1ptdzITiFA4qY3v2AV0X41WhjACkiTVEpQln+f/Z8AGafUgLCJCyHERXKIgIBnYGg/Ko49XO2g/vnrdSRf3HLKW05K9m+x5PHdUiMSUiyY1bb+UK7T+wVDlbWI1Ki8HtxER6tPr5t2Yx+BW268ATIeSBgI3olr4RxSiVm9w3008Jl9P4AWSGRRZS016CEcVqF2c0ghqAO4IXWDFDibRPnzEYnBWAucJSISJBbkyO8LZEhjSCCzIMUeo0vNmX4PuKqtpfc884w/2HhNyE5DcMZWRP8mNHap0UbL2KhU707Ztsk+YSOt9sBAv51svExOCILgpcAYggYPUHHFYInJpTL3wrrD77A6d5qg8iGIkLBk8ZzG/BQMXeKKvZc44rl0RqWIOIohORJxpDGvU9lAmiCeNQpMHBJJRamy5tOaByJG6oQMBe6lp484dygBCBYYItrPvIG4KB9q2o/6XaRKrqjrmlW71OdEuEGk4SIbTjNt03B4BYwRjhzwjjdbwhXCYKnfThxpXTA3IEImQQrz2sMglHS/WkQj8yCldqctsF2ibPL7StI3cwJCBdjMSMoQEF/MnYA45R3U8QLpEwSN5r3GifGcQQDxblADF4je5kzAAk+BBTGquKacRRPlraYlQYC13rC+WWMgoDG+i8CuxYmjJmcCTI3fkmo6tzLBINu4eaO8ESbt0IFDdtWbr7JP/ZffsZHBEV+HgAPV1mqd4wf3H7Qv/PUX7dd+81dty/at9qn/41NaC8GEZf/RahIzAzs/2TY11MtxTFbMGUnlWDvBoj63Or/amtcFAtOnx+tS3WolqxBYCQhUWHJwvQLiDVkkJu9Tco+7UAoPAbjCGJ/jKQ0JAkQSnGvUaLCLqMImqXtI0qNLLD+423JDu+VqdrPVKlZSTdNLIpRKRptLOeAXatAKPAPJQMUHKZrwSkdoA1UikNIyxEXXSISIZYPRP0joXAkYwX0GqaTcRc7YqSJAoIeO77DRnu1Soxu0iNylV+IuHaRKB9Oyks52kEnUg9yNuF6e0Q6NGVx61MAgSGhzYAxfJ6kcxFBZ3/RiUeM6d4LYkbqSEEq42UsjaoTI6x1lnwPBdtTRpUdchfNt7roXvstZDHI6OwV9JXZTva2T+hpTcDA9bKdSfWp/lbXUNVpnvbwxCiHoGZXaW7Jf/ZfNjghIV1kT0bKuQXHA1P5+BdscdJfGM2tRkd52pB5p2c2gNjkutbeMYoilB99knc0jtq6p13rFqbaWq+3ajktEdBfk9vmwPK8NKTZOq3UlOtUecXNll5MVwlEtNbjZ8EDasbN+q+1q3e7xal4c3OfxhkBEaANINLF5ID4q1H4IkNqQOMJxhCMsAVFaBcGg5kyqzUhmQRZj4gITBNg98GnMKJfxDhMEAckRHyosS/OtD1qGFHMgOyR4ZCwmpx3VYs5EJM1CikOCQGN+INFhftbLEx3qeH2pQR8L71xZXUu5pK2OpGlNAFfvh5aVE0rqE7DEyx+E5pTN2nRXgyr1bkgY0Q9gRjsDNVOtAQhLbYAF7Y1xBWZNSPJeL/VJJhlSPQKlEng78DxYBjBdBiPmWeftDm3GOcJqeo0goHFAeoSXwuooe0fZGM2qMjwDmU0/yhTOm9l7w1LbRA+R8G5Ys97e+d4fs7/80/9lN739Jif2X9271z7w4dusIGaJe8LULl/fWC8X4JV297fvscm7vmvPPvG05T7+MT3RPqM9DOYOay2nWGxda+UgRITXn/23P7XP/eVnXKq01Hat5ju/IFD1X5TOry6t9uZ8hwCb6oupR8RRlurN/GfBgmAAOQLRDmwN5IbXN0kdLQoeW5U4ZtWxU7K3kLqdYvYUM2utKEKpQoFNq+pkkI5bqQUOIUc+hHTQTpDT1yJBGODFJyaCBrsDVJIc4ZunMvJj3zOXqh2HFYgWbl2RHCwnTYgznRlrFLwGLCKVxMpoj5AvDukz7zdSJNrpUoxZA4x0AewO4/kw0TfIEg66MPEaOHGoIhXeD7/BIckDUYjkZ9GkF1DTmkJCy15gClJGSKCWPVr2JWNIu1z6VYbUq3vuFe2SpousNVdvNlS0jes22FBOngE19le07rTYiPoyVmFr29fYseRJ12iESwqsLmraaF3j7VaTrrTW1lYRVr2OUCEZoJpw7nAN0YgEBWKVmFuiVWxybI2tl5Tn4tZTdjQvNay63XZiz2EbODVgTV0tkpQM2vbEFoun5fkwJ0QtVmmnFMCTchkflguEKLByBwe5WnvmwaekLhcTQV0lAkv2fkogLOQKCYPqqKS4IkBcciTiKFQhUzNdcoTTDJwmTAjBn5CEAlWbRDzhNkoQzDA/yAvhSCBaECYngmiPiBhvEBUvIdEuiDdgMyoCMy0bwmoINxFJVDJRgCmgC5UdqtQxNloiIjSklkhDAIA+TriWiPyFqvb5AHGkcaRMvml3ME/ESJCjiFrZWSHtWYp0hnkalS0QBBVOK4qSQuUzEHaTFlFfILRbI42qJ7DNQ6UQey+kb+4RrdSFqTarT+xz4Xh535nAq+l1gwDE8siRQcsNp6TqqfUkQmC+xBRE3TEiTYNwzc+X97W8j10cDAfao2mtaTP9byn10naPEScGzjVXXm3rutbZgb37LSuJ8+2f/Am75s1Xa9+otY61nda8pkXmkhG7bNelduTAEVu7fo3dKGJq586d1tHZbu3rOuTgoVmMjlpr62i1jRs22mXX7HYJ7VWXX+lrdSltWs1z/kFgedjQ+df/1R69QSEA4rNcZH52VznYSRBK9SIORqSG5siTvKxV1p2UdOpfrGp0u+UHLpN9TYu8sl0hREyuezsflbadOKJzqdypSDj3FP1aHUAcJXCBKd8Rstkdm+c3CNRcCQ9fxJ/hWA0gMleuue9VyftVW9deoaIFcZqFUI9DrJxtChD0EZmk4GyD4Jlhuygb4gkJYCBJCOqKSO2qoMCizAvgQ4L4hagB0Q/vBbn5C2EgokqIpRT1plIwuUcAAEAASURBVMqffj7zirkyH/xm5jz7X0iEiHnl3sLKgAliXBCMv/1P99h937nffvN//pZtEgc1KRXDsZOj9ie/98fWrgP/F//rr9juzh3W3tAmGFVpTkuBJJm379/7fTt+5Lh94Bc/HMwdNTUuAntb6xaX/sCBHsgMeBDQVnm12tjc7VKxMWltHa9J2vqciOA111lnRYdVpGvtqb0PW0V1hbVc1um2DEPDw/Yv33jQ4o0Ju+Xjt7rEAYJ2TSxqW1s2uVQQqR5EZs/RHntOBtXk3bH1Yltb3ynX3pJWifjAxS52Aqj6vTwg6VJ21O1vIIZyWnesV1TLcFud071g8CQp0pog0CwfYEXsKuzTqA9bC/B2xpFnfM5kojoap4ImBFf1xPoEE816a5PaEipsSL5wpEDCkUKl9oiGqjrLVsvZhCS4IIMQrKxdV70LJ7a/sbQ/TihptbrEV7YT2A8F+0DZZJmjKEHACU3cfxewBUKlUTCrieCBMLBdxG4TW6YxjQUSMQgyiDnUJsekYpiRIwooPghZ/68yqJv+hJIzqg731jmacd7eCvajgIh+PTsJ/OtaExoHxQDTnAvWwzwt0HxDWsLgaSX4EkCa9HqPV3ZCa1fEDVJR4MY+hdMVznTW/un79en9IU+vpOjsD2svXWcfueJjvsZRhX3s1DPWXNdknbu77FD6pBw4ZKyre4194pc/Kc+xae37BUm45S2zSWffhOJtDb4sBmGDdV+50faMvOR2hm+9/UZJnVZR5NMhf+HcWR39C2esz6ueotNeU1nvG+LZdozDwdXQ5N7YI7JToEtBxAlvfME93RUG3mT5IRFLQ5dKgCT3v52PiLIiUncZt06HD4eVc3mFePjp440DC1oYefFsS/xDeyeK4gDLBkMOvVTn4mXDTXcXsPO0gxLOAFcLWixutCxwZNgfFVKcWmIvFs7G4YdKD+NcL6StPAHj4ECf7jfIAQh++cEK0lYnDjhSJN4pT+SDyMIVfEatx7kCB3XwflB6eX6vcVYZ4XOeQQhgC4N05Cwg6UXSDtTDchXzqCXpeSabtuce/6G9/2c+YCMjI/bcK89az/FTtnHTRuuMizBKTdr9X7tf8T0G7Zq3vlkxQXbZHjlNwA4tTBDFl7Vtt0iyyr779bu8/9e/7Xp716ab5N1pzJ6490k7uPeg7bx8h11/7Zuso3K3HToxbF+9524bywpuiieybuP6sDiHMTAloC7whihpiTXZxni3HfjhPnvsoSckvWqyd7zrnZJSNLkTBRwyKAqrHXpqn12x+zLraG2zu+7+ru17eZ/tumK3XXbVTjswdkSEm1T2pO41LikNyUdIl6iDunqMJEgQJO7lTrAD9fMxVn8hlGgLKKFAF0h3oFTOIuFuvAIVUhWDVIZ2UD8EeUEuyVH5k3stJ5gqxXBprKn3+TZZGcAFYm8pEp+pJrK3aJ35/NQ17/qcDCChhzPn99R7ZRfYpNHOLISobCwYI9ZIjWyYcFnekWhxgjkjyVJBRB7qivwbFxMEVUkcXmTkVRCic3Z9SDEgOgNJtlRltRaYC2cH5bLGr+Alffa5IRiuZHICmXFYYCh8/FSpz98VqhzpXaSBfYdhWaDyUn2olWO3Gc6gWu0LOL5BtXfxt0uFnMUXbfS5p1UKHFBdRgIqmbCIFryFimiRiifrarH2sFcOS4qORJy8wXzjtDM7NnbKW8nZXlclAn8gbclC0s+DYJDCUeCtSTtmvZ4fbYSg3gq7pHG7z2t/sPrngoNAGXZ3wfV9tcNvYAjAFQ7UxVamE2yJUSEPII0zkpCgiqq0RTp/YLH1/yJR/TEhPVErjuyQKKNROzIbeylpnw3VYKYwAxFQkyKofOuuFGJBflT0hOycTULtaWi4wdJjCSE5ZW2YboojASGC4oirDqLwd3ndHJhwoc82IbGBqx0eL2dbHu9725DIlSXKL0cE6BNzIThkpzNyv0ZOHQjY6Ydy6dibzqHyxSWHKB4WF3IkO+au1ynH61BGRgnYQQC5DVL5y6XrENnyGDJ+NM+RaRm3qH8+mw36UVcXt41bN9mRw0csO5Sx6lyFvfDcC7Z522arjzfIwUjGvvb3d9gPn/mhxRvidsff/oM99MBD7g43bAZqb2sSbVYxMG5f+OzfWXI46U4H/uGzX7b0iaTd98177J5v320tHc127533SDJ0n/WNJOwvPvt1BVs8JilNle19cW9YXPAtgAML4JQVhxbYNdc02KGXD9jXvvxP1q5AjaeO9dgXP/sFq9CQ4myjt6/X/vHvvmwvPvWCS3G/c+d37P6777PWjha771/usd59J61LtlPYQ1F6mBzR1E8nFDAgFKKEpCOQKlc4Yc24FjS+4/pkMgSaFVGivKzRs03UD8ECHHEcwjcEBep+jFGl2lKudobKWkyqeDgVQXIU7F3LawfloyKIhJqyIfwxVA8lm5Q239oDeYdITCm+1kh6zNc7fQBmEHstuHyWfRve71gTlB8m74fuS2AGwFXJ9DPyEMdKRbtkLyo1Jbz8+fj4DAhL+dF/e38FB75DmK1UqwKJ5dxeM8vroO75xqg833KuIU5Hjw/b8CEFO8U+cKFppWcERE5J5dP3TO2b2HWO5Ah6LMmKCPxg11tOC5ael/5P79XT84j7/CMhWRpVEOZRBWyFoEkWtDerfeWfYf0ekj0gH5gSLsGE8PWPpJ6akKGkmPrGVM5ofkR140iG7YK8YR4kWIGE2ZlkZfeX3rPVnOcjBFYlSOfjqF4AfYJrzMYIx3KlNvRJbZpIHOCapiWmZ8NmC/dvPN3JNikWhyslJGtcrsCTWzAMsaqoPHu5xEmPhEdwAHIAg4hVTSqwpOyXiqkucZhT7hGvsnZE+jeK91KNxykIk+mDQj+WlmQrZTV9NjywWzFiGq2h7aiKEZaiD5xBdLwpmYOCXsBFnw8pgDiC4xsXgVhOeCytIdO5OHSww8F4dqUSbc5pnOPYcpTBiXYG46O7usaLHc+5NyPpJ/YrLtXQA3A71CtCBDDMDXyESrsUiPdR6wsxDUaHdiwGG6RRY7K/wUGAjt4Z7aXMpSTUnsbw+AWXfo5EG1CvbGpqtIQCGD71yJO2Rnr2Q72DdsVbrrThk4PWf0oe5o732E//u5+x7s3d9pYbr7XiaM4OjhzyEikDSUJkosYOvHrAek702C3vfbscn4zaoX0H7d577rV9+/bbx37u43b5Wy63rg3r7YE777UN7Z1qW97+7X/8t4HLbYerJvwcCRuqURGchUTBLtq21T76yQ9ZX9+ADUii1SsiKZPN2rBc7T7z1T22savbfk3BHYflfeqBhx+yTdu26LPZ+pX/8L5Dtm1jQkicVL5EEDDHaL9LNwSrMDkyJLgAt7wTRiIcQoJCdjYYsWOPhRSFMsLkKrUaYKS+s6dOmGeh7xpJVrDfI+UlVcPhQUROIqqkmuMqbKijiSHC3GJOVcjrnnzfnT5PF6qEZ2oybaRP4dylfFQMq5wpEax18jGX2VPK1wJ5M0I83ZEEZYEECl6keknO26SOBMd+TGqLRcHK57ry8Y1TiiEhl0hzAxtA3mJVqA7VXTGRsEoxjaJR2QZqzwMJBdHEPvFcSeyDGnhvznz74Nm0dalllu9hZ1PfjHc1FM6Y8/Fk0GY8Pe0H8zBUhA7nCO1PS/qfl7SzXrHmyve/0wo4yxu5iVB6OndBtAlJtxz/T2UIZ1LYteB3eHcq25wXlAfc52Nw8QzGHlAJvKEGxbwmYzVnC1dvnqsQWCWQztWReYO3KynXm488IjW0WemWW24JvC7p/kMPPWQpBYEsTxdffLF1d3eX35rzGi9nuGhe6U0MrnBEHOGMNmcQKTjXeHvyekpqdzRoskrEjry1FYcudmFQZZ3E8yV31iAVznUVt7WiWjYTDeK0i2We73uLTQxeKiNaBY2N9Vh1nTyQxY5ZZWRIJS5ts58GhrheVSLiVPbwqbeKOy6Eec0LKgavY0JyvM1LL5V4KfQVdYQzTfQgImSxbjLmLpGX26P56oVLHiNuDkiOUnBIhkclBx/SxPmRTgKWTqnp6TXsXFIFuZEu45IHbZ1ucYBkzteiue+DZCAdoGV4DQQpW878REVwTJxd7EMWSsyvRsXs2L5rpz30/YfktnazdW+Rat3aNTZwrM/fR+UQ1SmQ4ou2X2STmXEnhigXdUIMtYl1NCY1ucG+QXvwuw8IGa6w7Tt2yHC5w1586RWL18vzYSZlUamK0Zd0JiNvciIIogqgKkIpRLBntxU8FBXBmBOKFbb35b321S99zbbvvMiRfIyn6UNadfccOWlrFcQxk83IBqlgQwODMo7O25AIqWgkYhu2bnJJCVI8AItdFjDl/TC5nYzmLgmpCggR91i/wUdLU5IS3uVTrXUKQkkZEBxnJVGis2pKUcQRKqw1khJBHHGP+eVtUd14hYvoGwZGVCpBvSm5/9bY8Hypib44IacXIHhoP3GFqqoUIFTE6lp5N2RMT6X7xaRIikCZhhF5+VVuU8E9CGWIo3h1nZhCUnHKBhIwmgUDalDeCEckXYVpFLRVfaLJk1LpyrdqQOoVE0vqzom0nEVov9FDYtBBbEEonQuJ9rAThkySH2WblrMfLLWdzIX6dU3qokpHmrpIQuIJgTxXilTKK2NpLc31/GzvMScCb4iLlxSuDZ9upeyw+zyVbp4NPHmXOmJVMTkiienMlPTUJcDBXAdOSz9BSw1c/TqvILBKIJ1Xw3nudGbPnj32+7//+9bW1jajUdddd50TSCAqn/rUp6y+Xu43xdUN08///M8viUBqkFOFs9kcw/rKvwmSiHefqDxntclIvVYcuVOpYRsYHw235bLsQlaqk1bd9LIVBy9RrAVFr5f6nVAOlx6AyDgCpsMLt9XVja/KA16PYrsoVkptWoiE7EumpEelTb+s9CVdChmpqBmy2vbHbezEzUJax902alJIGCUup1SkSCPZlBDnqKuklc6fJTVjZqbAlTrEAoRaeMjNzLO8Xw5HIXNVpQ6B/MPpC6SHslUSIgeRtKS6VEZMSCR5Mdad5ogvr01z5aZMePdufK+ZgLpmoNe/ONICcp2RlMSdDsxVeNk9kHoCpiJl+dqXvmp9J3rt3/yH/836exR3Sg2Ix1WvCN0jkgZdmrjc/vnrX7f6mLj8ms94evv/2XsPKNvSqt537rx37UqnTg7dfToCDd10EyU80CYOLspFQTJIuDjeA3nDB0beE6/DgJjQIYJ6cfAuqE9FUHQIiFfJWWJHmk6c7pPqVK7atXO9/2+uvXat2rV31a5w6qT1Ve20whfm96215v+bc/6/keSgPWHsRq9f4qqqXX7l5fbS179MjE8HbPyBkyKtSPuq8rjQHZH16F7lQ2zPkSOXCYh/xu6T1WmvQNQJET4cvPLIcs3UTCcMkJK2P7PXdu/fZVmRdvyve++wweFBe8nrXm6f/ddP24n7jvs5By47ZE941pPsxIPH7a/+9EP26le/2q4Xs9SeK/bbi171IjsuIgeA72mbckYp8vaZcl1hjC9XcHRtOWho6XvRMeDKutzHgnghLBoSjurIdr5DqMDYYo2gzSTKgrTgwenjinHIy0VtVBbogIABpZWydIhqq/KqYoGTJQmAUpTFZlgMnBOLgXtctM7r1YP2U1/aQN0BYVio/H6jslKaoNg3sFv7TC5Js8vZaV/YSs7jeOLl9hfHDEIOgFZJLH8+aSBZAt7GxSwIvTfJ6+guhVoioXxEgHu/JXKzuuc9pEkgUYCrPrMVxWFxD/VJlqCOgLSw3OXK7Oy3aNzdzpa8M6UxJhYnFzzuLTcq63XLMtitdHe1dMC4eq+7i2pMtAfu6kO2tIUxxLjiXt1v4hwAFZNaXFMB2A3OhtQhL0IWH5v9Zhg5DgBU8ImLAAg1EiJtUG5pxWTlBJqY7DvXYzdS3fjrOZDAsmZ6DgqPi7x4JXD33XfbIxUY/p73vKdrI48dO6YZ46q9//3vd9rhrgetsXG7wREPhxHRZsPWlGP2UzflY/PjNqmZWB4Y6FZhWp5xlnKWmbX0rjusoXViNJVqyeID+tRMse6srqDJbO9J2xJiAkvoeOf99Y3cfrd6C1Yd5OJXOPhpZRvkt9kckSnMYLhHFTOaCcd9Rn8blTXuNbCjoYRiaUAOW0mc3znjyYMWSx/sR2UpqRt6SKo6Wc3ml9XPLBK4nYmWIi+PDdGyncMCSZ117ywPZRZGpZIA5XoJBaE4WHQ3SkDKU255qo2fOGNXP+xad1ErjhTtwJGD2v5k+7sP/J19LPdPdvDQfnvFa19h3/n6d+3279xuv/2L73QF+drrrrUXvuBH7YYbbrDf+MXfsBG57bH+x+ve8Dq75Tm32P98//9rn/nXz9iwFk581StfYo+45gp7wqOvsT/9/T/1Ywmle9hN19NgTyj/THZ8/t8+5/FJWKpuvPlGu+nRN9lnPv1Z+7/e8LMiFcnYwQOHpMmbrGAjAmCX2aMefYP9/Qc/bHfdfZc977/8F/vj9/yJffk/vmhDwyP2wlf/uDV2B9TcXHcoeChYDmw0LrCAFDRWGWJlKfkOgqJCbNWNPvFxqOM419dHEbgAKPhLSiXgIDrWQwDigEKKfyJE6CvyJxZIkwuNOVvQQsYjiuUZE+CA1IDyAKQVkTZAp03eOTH65UXFPKgJHvp7oQVAolmu9z1UgEMrEp+w+nl91TbGU/jd20yGbGvFTBXFfDciKm8mmQakBCIzB0dYHwSOFmXFBByVZGUNE/kkEorPrBzQIRlL7/6e7mUK9FfZWB65PyoKUM6Dij+TFZXEtcArTmdXAvQNcYcNLR6cGdQ6YaK6p7+7J415rEddOoYFmM+m9YhxVtXEVjT1er5QPZ5DkJkA3llPzFPE85h7ATF9G60z1yEudUNireO5H1zzmtrU9yHFTJKnnjit7dHaxt8vNQkkdCPteSldasKI27t9EvjlX/5lO3DggL3lLW/pmumnPvUp+5M/+RP76Ec/2nX/Whu50f6P2/+/tQ7Z0D4eGIMysTOjxLx0Wg+cOQGFY7MnXQEIF4DkQQRTVVvpaJeiW2x1r9VOP86SQ/fJqnSHHlB6CO1kQlslbVO5yARl3NeJ0sOEh1Gvh1lQ8Mp3birM+BOPtJmA9GhuPMxG8pBRrHyq83DzB6nW09gQQPK6NT1Yudc6SdHyN/Odhy6z6czSY5Vb6yYbuNaJRGCNxTS5TecFBB45dp0dye1zpTyVl3LfSLoVLJFWiTUp5LiQKS5OdgWriicdF7q9B7X+kdYSKpfK+r3g4IA2sfjqHrHG4T41fmpcsSdVGxU5QkkOppmEYusqSYGuKRsdG7KRxGnbXz5mldEbRL0tgKHhNrSLoP6a3V8+bsdmHrJH7ZZ7XmrM5ufl3oWyrc4pilDiwO59NjkzZTPTM7ZLLHbQdA8XhkQWMGeLcgld0kLPqboQk3SgsbFdNjk9aROnJ2xodNimU3N26+m7Fag9HygzUvKx/HAPANiwDhCWOvofGm1i79ZK9AuB7FBxc34+r4Wjde1jhcS9hjqHCeUfIEUKwdny5Eh41PKngxLlj+vvcG5YIGTQUk3FRQkcUSZWcwgNcgNaz0myx8LD+lGUvdHxy4Di+vKYJI2NgkDPQS0UPCyAVhFLHfnOKLid42gTTGW4mY5kh3wdJK4liVIvTWJUl9eGwvV0XFTvMAaGCWCYTmittcSwAG5WVjDFyKnfienAAstkQCg22k4bsaJGXfzCvM6HT7+PcC9BNsHbimr55hVbuvw4n9QmNaWpPqRKrIHUeZ/srD0TCkWBoc6xjGWzIFfLs5EY36wFNl+XpUtjhvGCxVxzEm5xDEBOIHksfiVNgEFUw/plva4NXK5H9VwInk0bqzX35hFZfDsnryiLe0SYfuzoLX6/Cn/Hn5eWBGKAdGn194619sUvfrE96lGPEnvUot15551GbNGb3/xmO3z4sNfhve99r8co3XTTTR6LtGvXLnexedrTnraqjr/3e79n3/3ud9vb9x/Yb1e/6tHt31v9AsXpIExnrRsjIGlC6yuc0QtFyl1wdEfvDo7C0nV2dcwas1dZojDu1ODhngv1M3hMSNHnT7OSebGOAZh4uPWXElJYxUgkxXUr8zCDUv4C+uz+Su3nKHzh58ToBXg7m8lnKmWZ5IHcK/UFkHQyckcBHcproVgpEcz05zRuk9KMsEbkZbXDeofrINZEYksgJlgU2J8XUMXPHnASJoCRxxIp4yEp9AlRUC+IPnxKi6AyWTA2oMUTZRWqKb+Rhe/Zs5Pjdip7xL6bf6yNJUZtrj5vp+sTdrp8RgpzXUAjL6vEsNchLGNJCg7xXChlADyRCZswg5MFEG9F3bAGFgUmUJwAC4NS3ohTqgmwoOgzgxwqfYwjgAspI2sUsV64wjDTXFJeAKdo8mtaA5nz+Q64Yi0ppDkoS9ywFCy2zy6KUEJtADSFA9zLEhIMywstTWFdouVEv5MfJB17cF/T+kiu4KkOACR3YZO8sbSx0OX4whmbWpzx64Nz+F8v/3ZZrTzJNyvgcnBon+Q/JOt33SZFqgCVc7B8QVFjBsu4Bwl5HQDSWE8RpZQAb/OMmL4mZDliIVzqTD0CYgstLqsYpwH1CfcCCF0Yb1gImXVf0HeuI6y5RY1H+hpGNCxJW7nu2+08G19om7eRpi/f0SQJHw/rFRksmbDeUTu0X9WHhESXs6x66wMkNd0t/Dz3+B4mxh/APgArkR3hAVv8nNWEAK7RqqGPDdj0uF65JxU0vrK6JhgzAKP1XKa5xoijxOoVbcNGqsi9Kohj7n1WDJB6y+ZS2LP8tLwUWhu3cUckAEHDyZMn3YL0spe9zJ761Kfahz/8YXvTm95kH/rQh6SYDNr3vvc9m5yctOuuu86e/OQn28c//nF7+9vfbu9617uMOKVouuOOO1YQPhw9enTbABIPRI+b0A2XhBqFm1lJClddLgv+8NSzwuOk1nxm6MjchGX2TEgB0bo97mYXKt9rnujlno9vQa1lldBfA8VSDF2kPGvX9JXEaqVjB5CpwMhmEsrWdoMj6oFOyEP2bCbyRwFgRjQty+NWlMVwBJUFJhZZuVWJsYmS4d+lJcy3XKLCMXv/lNbp8hNxUUw4MYUf3PHG8UwIBMdKTdKxkDscmz3hForquAhJvifa3WLCDlw1a4v7SjbJmJDlZ6ypuBsryNIjGl4p2CerirPTH3l6PVplIWkU7iGBuKwADWxpzCj7UV43LUDqKWFTS8TO6AzV3fm2tD9MYd7QUzMOiUODlrqs63UVOAJMCQQ44JCBigB2aLhRJId1DxpWXBazzyhlWELaQKgVwxEABJW9EnOFVVnzE+srFk6aQTt4McESJq+XdNr8EhFfWnRWYEkfQV3Dg8JP5dFeAyncxqfydEDHV8mIomgDs+L7irttrwBaYGXVgfpn/C0BivTikxNk7JHclmxagIq1pkJrllvMJAdcGCHEgfyBvsLVCYAECEOxhdIbNsRA0aXNyf7AkcoG2JFwGfQ+8l879IYs+ENoF3hiDMw8NOkudsOXj1laMbQ+GHq0izYDcLHA5IkXa11f3rea0Epr0mE7E+MGhs+q2EMBR4yxBTEiMh59TGmyCkCdwAKu69DvCXrvleg3Jup4LkRuDb0O77qdPBoC9Usa13GKJdBLArEFqZdk4u2blgA3vlOnTsldZkzMRsEN6N5777XXvOY19ra3vc1e8IJgcUse5liOwvSKV7zC9u7da+9+97vDTf5JrFL4MPUNund+8J6Nu+atyDTyg5kzTPWuREpZYkYXimIUCe7TPIA29gDXE4jAbxE3+JpHSc1Yb5PrW6Tavb/6WkutJz/lbkvZ5IerTcpGB2Rt6F36qj11PfSQJ0C0n8TDiz7Ja1acWKaNyX79EhifLOqKSxbfz1bydkgJYXaU2U4e/GxbkaiL5LKgupwvrF/t+qmTa3NiYbyvZs959DOkxDfti9/6il3/2EfagpjLJlMiCBGNvWwGNiCaZ6wj880FARxZL+Sm1wlYyBfCkpTc95C/Bma7qH6/ID8surh6IVN+L4iSv6x7BNdvODDpV79+lTHXL8e5a53c3VD6h4Z0vWs79yB3E2PWWgo7Y43tYZwP5wGsyK9fRZ5zcGmDLIGYJH6Tov2P617oKjhVmxaNtpjiWsohbaCN/KZ+nLde2QC9vYUxG9aCtH6/kpyj5VE+/cMisXNaX4b4DmL4ADmzpVmbAiCndQZt1y0jJWsxbRiQKyAxGWEqS9HFUofFKBzXtI4+YBvfQ7dEb0dUg9VO5Bjey8NrD7CLGx9/cdq4BACzi5O6l2n8rkfSEM2dcUIcGlbuUPSM/yGNofUsK9F81vtOv87JmllRjB5jekY0/Kxvt5neZnxBpoTldzOudWFduSZZh43rZS2UFVuQQoldmp+xBenS7Pez2mpussQfRdNVV13l4OfEiRO+eWRkJLrbv2M5+tznPrdqewiywh3dFK9w32Y+pUrJ9K9FFzULfUbgyGlI1YbojO/G8g1u/c1m1hoz11lq5E75hovsAavSWU1oIIp5mHm4NRf3ir1L5AWFk3L3O67tm3wcEaigGeIlCCi0YG5DsU5LklVaM2/9MMDxcATsEJdQl4K2nhLEfqcK1+wgiuxGUtDCLiCkSyaslxO6O3XZvS2baAtj1eM5NJ6YhUcOzKLSH1gN2Hd+uyKJzVnXxfhDD1gjJaW+psUok3IVc1VYbYC+3mZtTuM7owmBwaUBO9o4ouupZieap222KStWJDEGtNpUZMtGvwZggQVhkeOC6laWyxzXsLRszywAR8TVCNRICaSugCXARlo05WlZsFD0mzUsowG5QQjC/VxAifoLxdP/QnIGrgX1G6QEbq/hd5fEXmbJITpQqQoGV/yczuG7snWFFPe2iqjNcRPcVRi1nGKplgRaVGW5fs47YG6DI7m3hvXrUpxv4ljcl4jZSLYmREJgxgG0f3ZxTi6LE84uSV18u2JX3I1YP9ICrmna2pBrZX2fLP1l/S57T3MsAJ7YIiY6aA/XPxLASoW7HTFc3DvZGII0zvOkbcRyhqAo3Bx/bl0C3McKY/Ja0Hjsh+Y7LJExMy9gOyQ6fia+SH6/EpBximsG6zYlxi99z6QUpCabzZnzcOXdKDFDZzO4RrEg6Ypzt9HO/fHvWAJIYGMaSCyzWAJ9SOD++++3d7zjHfbrv/7rbcpugNH4+Hg7BukXfuEX7PGPf7y96EUvaucINfihQ4fav9f6kuBhoIf0VhMP+0U99Kdl4WBWG6WCm+d6yZUXlKheDxFlkUjiVpa0yvGnWf7wZ50WfOmsgSRm1lNW1TpLlYnHiU5cFKWpuuX3fVkO58dUjw1c6lJmWPyxOnfYmqVDCgDeJeVNimXhjCUHjtuZ3Lhm4GuaXdZxaie04kgNxShMyDAAB1V31/JFPteQKxKHmhr2POIm+B3JLsy25ydubLiF8aCHZrhnvygHFDuPPaKQs5wCOShGSIqIkx9IkaSO1M+VdNX7vE3qgPSA4nuuyNunbv2qPbxQs/9686Adr9xpC4Vr29UOr5eaqOsnRbqAwjy4VLTdlV02lyAoe7knty5ygR6/7nRd6bottVw3AdO4oQGKYPPiOmaCwxV1jtdfp5us78tIUZLC5mC53SLGdMd9gPtNvSC0uEcTBXJPkjstYGatRGzVyblxm0hOqr9TUsXqTihxRLFCBVnWF8VuV1OMIyQRY3nFi+kPoIebGkQL3I3WjntcLp36YoXMJ/ICZIoUchff5f3zcsUEHJVgfJQ8sBxhUUNefq3ofI9LWjxkqeq1lhsRhXdOViUlZElcCDFvUcpsysR1ijXXFitYB4K8kKtue96esAYuY+1flTQg1rpWVx0fb1glAeQ9e3zaLUgD+0Y0MSbh95m4L5fUr4MiaPDrSr1Gn1bk9UDcWZce6zPn5cPoX+JXp8pTARHNJm8CjEMWImeiaTsSzwEmFIL40E1WajsqEudx3kpgA1rTeduGuGLnmQSOHj0qdqi8ve9973OXunK57Ix1uNM94xnP8NrefPPN9sEPftAe/ehH2+WXX27//M//7GQOxCD1kxbLik3JiwFrKyBJd3+YdAgy5vYYqFHr3yh9Nlo3V1e41qhsAnaugQetOnG9VR58tuUOfM4S+dPSOILZujVO7XOXGiDFzV3o6gNWmxY4OiPyCgGWRKpmGa27lBr6QbC/zxz9MIlgSeAuPXS/2cBJKZyjVp9WG6avscT01VJ+FEibm7eBgUnRyk6pnNOWy5elOAbB9OhBZSlfKFTMOuuny3etKuAPP6iZwYzcfngQck5/KVhbg7gxyqL36gJZQz3WyaJuALeootdfOdtzFCC8KtWXsXYhJOk2VtgzbINPvNoG54paN+cLti8xad+oPmTzhRHNwAZxRGFbaBfr8pSXRLyQGpDrnQL2/ZjwiK1/YiGh/8rqc/pzQCQeeQCHLDJzWtgW5RyWuKji3cnYFdaCY7iOQwsTSn/4Wh64KkRlNhf3qHVaI6UoZdQtJgEQC/Na9anTUEBh1kOJDSyi2qhc8lpQdnBQi7OW5Ioo646X2Rr1Ba2plJNyWifwvt9houPcbVRsfzlZgvJJ4jOCk7FSQrxRWdJi0LKehbIAfLGeFqCsqfWqmnNHReN91IqjE5YfGVc9oewOrJwsGous29XRF4DRnFjJ+KQsd5VrlUlTaBMnAD79e4eAkMl6roMdp8Q/u0kAGcsNFJdN+sw7SR/9Ju620fsRv8sNWTc10dTJ8tZvnv4sVb0AzSXFG01rsWHu0csDqN+cguOoE66AhW10uSZPJsoykJfEKZZAFwnEAKmLUOJNW5fAz/7sz9qv/dqv2Qtf+ELPDBe7P/7jP5ZSHQSAEof0ne98x173utd5nFIul3OShk6Chm41ARRN3PdY23vNVxWLgNuG7sSbSMENEqU6+nhYOyOfCdXDyNeaWPtQ35vMn7L8ZZ+0xvwVVj1zs2V236Z1i+TyttknBbmifNSlnJb2S2nTqzas2WAtnFsZlr+LYka0eGNmlIVp5c6YxOWl/xlFrzRvUnITacgAJKXytSprHxspWpukvAmgzkphXJqQSw9lZrUe1OCElMcHRbWmgOGkFFVfCDeg4ua0Xgnp4zLBrDZ90m9iBn+xLruM3KxQwBgFPNCDhSq758MxPBTPFQVx/yOtXynswHEClLVmyr5fPmSfP33YnnnklF1Z+YGdqD7M5nIaW9ofJtpHHzY1OYA7YSFRsPklCBg2d42G+Yaf5I+bZ1NKf8A6JyVfYAXlcFE05vQr9xIAN2O33+SKuuobutytOA/LVEUuwU2ZTPOTuvY1+ZDMyfIUKFgcGwKAEJSwzUEDViwmLJCL8pmVJfH0woTHJ0G9nlN9qaWPX5UvrOLuaxlZnDyxsyU6mNPcbXANUgNiPepi/duT3C1GMtGwC9gAjhblNgWAWZWUd0LXc6q6X+6HScuOfdvyWsS2qTovyGoU0HUHcVA+F0Pv6sJjkoGKh+1uAx1tc+ss7RBYYnu35JNL2tXtenDyAAHEmlwGAV9xWlsCAOzhI6PBaNd4Cr6sfU50Ly7Q0cuFPgEQEzPUL+03fR2OBcYGYwDL1JzWESRmzVnpQvAcLbzP79QJYob1nyZ9Ztg6zOM+kdkW6raxEuOjLyQJxCQNF1JvXYB1PXPmjPvZd4s5ojkLCwsG693+/VqZvc+blJ4H9vYPla24/1bbd9ntUkBQrFcnFAqCjnslbo7T5bn2jb3XcWzn5o8PPb73zFCvmC1d60T2SaHzl1x0lhpas4V4JDShLSWUKbVbeTbroiqWG5z4pCxR/IEtZc6oPLFiuaWqpV1ttqxGTsrhPmtUBGwbQwJj4qRTG5b02dQnZeB+t9RgNXJiJaTQaAHJdHZKC+jebpnheyQ7+mDtevDwG5Yv/HrHBc0I/MfnNTOJAresZGlmXsH7BB53BVrqQ9wpsRr2SxgRlBe/I4Gm+npYLlq3JB+wa3cdsjumzO4ceJjAsK6NJKBTCrzGOu5dxabGeT1hDzQf8tiY7Zag968uehjxYLJbKAkoy80rm9P6TbIIbTaRr8/G697h1zhDV+1plpkg0MSIKPwHNMaIg4B+HNdJ7iNOTKAh7oHjAJ0eifxRSHfJ+rZHpAoAelzdSNCc1ytaX0j5zTVKNl0XcYNkyzHcf2qQ1ejYjNqYFrjiFoKrL/ej6Ew/xxJkD0EEcW6zusfhTtSzVrp/0ja/ZwgF4arLwaHC63UTKKJena6I7AstQWTReQw08X5f1z6sadTTY7vWuNezmPBQZtDHzUJFC6CuVXcqcIkn5FmZwZratExRtP9hzFyfcsHFk2UuOhOuZ8NZuexp8qpX4t5LHM9kacrdN+lj3QV8XDr40In9Ptd7lRFuZy280P063LbVT9yBWTSZT7+ndGQYkzR0COQS+7n5J8klJqi4uZuTwJ49e9Y8sVgsGq+NpoQUsdIZzWAPnrGRsdMOFqJ5OJ0t/sVrACQe6P6KntjjOw9+wBEzor1mRXucqjKkwfCSa1oipQUYHTD0PLrPHaq8rEOJXFWxAmITGz4hhajoM7/1RlHuNnW3rPSZWe/DVN9k8X69dAjKk/6WZE1wcIZiJde+Zl07GwA1vcq7rFY6YvWFywWq1Pc10c6OfStQvtZoN0BnQUoTi372SnRXQ+2CAIDjeQCH4IiHG7E9A+43z5HLiWM4FmpZFrXsu9OXs4i/Sb6A39nmXvvM1MNsMPEVu3YkZ+XJkzZdvFGTFFgqsR7JfVHHzTcX7Zgdt7KsAD0V8y1I1ftdGaM8L8i1rq5rPVvQDHNoeVknb5R/wIUr7CjrrUqSrzOqwarGZIjG/JLGODGPieyMfgdghuOcYlzWU8gJHExo2DFTzlpBoRtbUA3t8LwoJiBrwOVoqdq0AcUM6aQ28OC8rNzvcrJQJXWdNaH/phqqI4CtXq5r+QGVgVug6u+xkE3lCgNdC3TwiQXgdOmMl8c9jvgiB1MtuQTgr3UOkykcREHeh9S3dSAfnC85dwNHlEWd3aqk+kRBVSQHz3o9l2SOpz9gF8MCgYWQ67rVNSuyi38sS4A+KE2IdVWxd8NXyC2OCYJo/y0f2vVbqjVuOndyTVVkBRrQhFOvRP+cnB+3GVHEe5GtztKoaI/HXududDsEILhgb2RAUA8fu6od1uVO5juu13m5pRZSWntNlugNZb7RBsTHX3ASiAHSBddlcYVRVgoHvmal4z9kM8dvUAzMZxWHwMM5uDtz04YRar2UFnhiBhoffW6kayWUJZQQZks3n1RGq46bz6PjTM8PYgLRSItFDLqEnBSp0K8a94ZQceo4s/+fzCiT9ARsP3cBZ4qlsXRJ6uC4nisCKByjVUAz1d1Wn7jRKlo0t3z6cfo9YNn9X5YiBTjsPRtZUmA66tAArhQ+a4nCzZ+yVX+y5g8uN6F7nCtnerijFKcEXFkIE1e9dh2DKnv/su4HIPdCSrSDUUk7eyqeO9ogxeEI8J6cfaJ9tpa0Fxa+aFcPTdnXKrfbSVFaF6TQ5xRzdKo5bmeaMi9Rd2/B2aukWyzU4z5x0ee1GYIj/5TiTxV9vEVuAV5vfvtkgABPitgmuZzqemOGnJly1qSCXjwKPDpbyj7uRZA0ALwYnOSNYja9JEtyNmG78iNcPu1YJGKD0o2AzAMXuTAlNbaT2oe1CpdCd/PlPICSzOr8jsqb7wCXToIEZAWoWXlfiDQ+LJDPVv7dwBExVbRJeqdeqy3i7Xsl+2ngitpFC1n+jq4OZTjXO2dw9UfbtHxk/C2UAP0/dHBEMhMAyDIZF+5Z/xPZBtZH+n/liexjjGfExgqrXXQv5wA8Tmuh41mBfQ0mHX12E2sTJnQNMAm2XgpbA0NoOxYWyyrLA2hxWZ79tIdaQ0pBSieDpT6i7fQd8dslK4HUrypdsq2PG35BSoCH5q0LX7BqadSqC2JZ0+x1bviUtwX3lcFMUe5wUly0xR/SPHW7JBQEZ4xyq0KXAyKbyGelQhHZuYGvYR7b+eAHILBekK8D06oLTSamhwcXStb2P76QafhqWcjcQqSSAE2DP9CChVo0V254dQV/L1VEO56fkkIlkCR3rCB19It+Qr+NlQdHDfa6BVBK6ZwWQQ3WztEMu0DtgNxC8iJjGNSnLyYrl6JOcEQZBMjPVVix/cKYiQ4e2qq4Gk8s1YAsajA30Z+hywrt2vnECFKfaP2jptY+mpp9uADnuD1MCyM3qpP2AwH0upTlnEB6oSk3H9W3IZnL3qHz6Mmzk8ibayq8rtYrhesuVPZdyZNyCVjgO0p86F4X5CuVEVdB6q8x7ShGBZAHYxQXO8BHNHGfCO452qrTHISJTlzCCixLdCT/fCoxS4+7XDEvqmUsRGK1gwIcCw+03VhKSWEbOY39tAH3tTBRTnhMe1sHOGI/52zkXhYFk2G+5DOg+o4UB92K1gapyFB//LscBMRoE7T9vVyYwjzDT8rjFSaXffgj/uwpAV8+QABZg6A9tnoe3LGD+wrPDgdKPjx99Pu4pz8bsmJmdH9164uOgyClpNhPWBFnFN+23FsdGZ+Fn1gWqWsaS1KPRO0Zk3OaHFyU1wBW5jCxvao8wmueZwqTZ4BLZKcpCH/mBM/ShD1s9MpALmEG8eclJYHlO+wl1ey4sRe6BHJSxnYdvsNO3b3XyuPX20T+hFjX7tV0quIRsgou1Q09wSxkS3Ho1l5u7CjVKNi4X53thzELW0KdyuwzsQFYTFyb6Fa5vrcRvJr2h5crJ5HzcJ1gtXGULGb7diy1XOlSQ/dbQYQRDbnbVWVRWrj/vwoknRaZw4Ny2XtQs52iEYZEgtQ6B7WRGfpFPbRYlyolkAdIQhl1FzqXYYuhTB0YtrnbQxo9C3c8jjnbfett2MJbWEf6DD97wF8Gi4HbBJccAKNkLigGKFTwt1DcJk+VFGVFyey6VUA2bd+e/BHbm/uIXX+4bNNT99ltg4+w2fScDYiF7WBjvx2S/OfFhnXKTttCE8KPc5tc+ZYi5LKWnLG6eFI9QyuL3y80WpbkwotF1hOgnjjCVmozIGqwAmTcgiOlkcT5jN9wLSIUseJA0YaaBV9Ut641pMTnJZa/IHYOt6HJ0iROeU6qgPWoUhZJgtzoaoty31NcVXpAlmEnw1B5AjgZtaGuBW+bikdKZQNiEwd2tEd1ckWXyqDsqp3+F7EYhWNNgvC6r7YmcXKrLWoXbSKRF8AnLxIMJmRgFWtq9r2h2Ex3LZQssCoRh+YKqI6FdYwZfwL2cQ1UblQrTtsoASyCUz844+Nh+LIxuVzLSh90WV+lABpmNYnEuHEQ7WNF9x795sXizmSXSeg5KRIQJqsYt36taEzsZGKiCzY8wBoTgNHS+U49sRhxDGOy233fwVM5aG8AnqCxr9h0RURDynNAFqaimDEHxMIZp0tbAjFAurT7/4JtPY/Zguh2B/fcazMnH2nV8cdK+Zarl1xhFnQDR7lkBh5lYM2kGzwz9MyiASR4QKxKZNFl86rj1thAvEIBS4Bu8CgW+FLjLlaRgtHtJr5GVqt21QV+AECBYrTcYmRUJzYkfHKsOvMsb/Bgb82GD91jBa2f1FjcJ8IHralUG7K61mtqyhqRUtB7Iq9YiTQLii73FTLhl8ciSCHkd0GxGYVWjFGotPVqAefygKxBrKG/8z0B1CGqILie70H76ctAJoxL2s6MPIHrWNrOTZKSnFoU29l3NXYfa18av8UOFASShpI2Pn+3nR56uFWXZm0mOSdAkLWBZMGGqoNAgnNT3VapDlyk7LsSKIUPF7VwDHV+BoABV1pc0bh+usvax5UOQ1kDENF3MMfRZ7PVOY+hoXhggTrVySsyouAmxmiyJmY5TQIAOIi1mVQMBwCY9WKoY1P967PZAkzRWxJlpjJyIwW0qB0Mbb/uVY/Q1c5jqHQSYwbABaBmX2jtokzfrjy4byQa6tMO9zzqzXmhbFDCaWdOdOoDmnThHsY9c1GKKJ8c58BQx3EsifGal/WI5TjDSZrz/0r0ql9Qb8g+OygyHVkqNYSit9ENtcMn0TSsWMxZtvzWuT7Kbba1nplb4n3YBeNrQwVsw8GMH0DNvNb8Gs4N+r2SWyTXHKBtXkCH64ktQc17F+pj33d7g/wbY3lWzHu8GO+hO3fvXOI9F7MEYoB0MffuRd42bpbDe++xhelDCl7eazVotA98Hp1BD2y9RTWLNWSBwsCMKDdebpCcT+LBg1LhAc3trcG+jbyjwBRhCZKeBMkA1UqwVomsBIHb2EZy6zxWizXKujLTmJPyohXGVZaDPLUfFx38tgNhdJ63g78BSoo/Sg0+4C9clRIEoMu33fRSlbUJF6eV7kphDcMHXfgZbu/1yXE8/HxhSxTAXgee4+0MUVw5UCQBz3z3savtITBaUUXtlLOS3O7yPuMbKq8rjtmhH4n0gqV3f9cmT91snzv5FHu+4gAfk63aZxdPWLlwQA0QOE2ITENtop3nMiEnXm1wJLAAYPAUGRxcN4AjFKNg0HAvoCfWbgH7AbWjAyNa8HUXsEqTLgUnSaiIKhuQXxGZQ1EkKvS1KiL5KPZBa0VBXDCrtYTKAktlkU2ItE6LxwZude425ZMMukBaVaAs6pcqBMCHdjmgU5nESToYgmKd+4D+SG7N4SJTio4Z/658XVGE6IF6dSRkAngiPwfxAoGAI+rB5APAJ8wTmfq9R+ID7GO9phawRjqIUt6rS+gosNtP1RH3x7A93Q65lLfR58U9AuYMK8Z1a6xsVibd5Bz2ceB6ttmct+c8xhCTizOVecVGYenK6NGqmEDiAfXXrf79luzjU2Oe5ICx3xPj4y5KCQR3zYuyaXGjLnYJ8MjM5jSTtO9OnvxWnb7O6rNXq9kE8ndXtrvJhJt/RjPzo5qRwprEU5yHDsHQmNxZXHGziZt1UQots8O4o1BP6eyqIow8CsTWDX6LzzOvWk3tJdYG2vKpxVmtfTLr609Q3vmREKo0J17QgvMYg9UPy1Fyvic4itYdpWy9xBEobdOaASxL0QwedeudtTP7V9cfKTDcpJSHCux6VUGJ1x+K57lLlK26i8o9ufdWu6d+xL567Bo7kEvbjaL1Tio+IWgZbTu3NeXaxpWOl8tfAwQlHgsKEyMOACR7JkFCK8myaFvndAg6allhF/0B++JQVkHerZMHxfy1b2CvT4IwbFmHiMVzNYPhcUai97N0VcBDhrWU6NDJZUn1Smfl8jsoZs+RQSvolR3QGkXElkQSZR0e2m+7B3a5O6Zf4soiIELQgdxfOi4Vb3OrjbSb/aE8yNplFIJGNii5PJBTa2xitWTNsbrcg4nZWFwsWaUS3NOCM4J37mkARFxjOYfrkH7oZ8Q6wAozUx1xSd6jdvLZrnO4P/50CQBs50/N2txDU+5md6mIhclL3NTnRd4DGRHjmWsxTrEEtksCsQVpuyQZ53OOJKC1GsaOW2n6uFjTDsuK9BgtxHrKGtnubjG9Kok+geJA0D/ueU2BI/z+M1qTg5vujIBHTdalXskBlW7YPOB5oaxAGzooZQYGoKYAEQ94V6fQd3zmK1AAarrBs32raes5bLUGGz1/YzVG0cJVMZ0IZrCjpdFHzFITo8Os/fmS6PKwlYwDxhguIIF7B5YuVq0XU5RYy2jbahC1uiWuRGqMBeNp9f6d2YLEZc1QTFlzb9K+OXGD7Tl9xq7Yl7H7Fk7a6eJVlhajYV7raM3Jwe5cJJTy6MKvKFS+ThPXHiAhxB2tTqJF/SSfWRYIAVSFpzCjTWzDEiagVhoSSGLGfVwLw+L2S5xDI6d7iA6hbg5ARNCQEl0+a0bhOpfNQ8iBZKXsAXSoUpilPnGxHNJEznB2yN35RuSuOqu4ENyLCFxnKU3+uA6mqzNqb0RpVF4h2OF+5fVoZU59HPhxPGMrkgBPVQGhhmKI6vnAZZe6LSwqAF4U54m8xjXgSzLlEwCXEaiiDaw7hmWJ/GlLLxkzMbVHTIhY8cfFjBa6Hg+qrXtklRttjtqZRTGmOeEKgolTKAH6i/WziFvzybfomAkPukg/l8fqyjF7kTY3btYOSyAGSDss8Li47ZdAKlO30QO326n5vXK1222piZttaeCrKijULDZWJu4h0lr0sMFlJJgTzmoGsyog0/UBr2KId3ElA0VACeamQdZW0LO8GVL16kHmblSuWKEEBQoPSosrEH5mn29SZITC+jz44jgMAMRM4VCu2NYb6Q9FV8iVsOZuSsRjnS9SQUGUyqjZ76xbEujnityNsHCFiTFA0D/ugO461VIsw/1dP32I+VvX3Tu3EemrjQJJlZGM3TZzk129+4t2NF2xKYHAoeaYSBpKJq6rHe8TQEw0zshlwiWj6xM3HPql7VLWz4DRMe7CpvailHlMj8Zj6I4Hq9cZkS3sLe72OCLKo/+LGQV6axmZ4YYsQgr+JvZQ1AsOJNKyzlTF6LhQEeujwEVWNPXk7XVU/RkX5NG+56gOA8oPd2CgBsfldF/aJ3DB7UAnu3WquqgFc6uyRtWTVk7VgjpSoUjiXF7rJmQmMOXryqm9lZKAoFvjNG7l0kQWDcVzuRuyiHNoBxNMEq6vxQRwg5SGNri8u8iaPJyYRG3hXK6RCS08ivshlMy0C+bKA8X9mlA46XT/4QTDuvW/BA4AwA4fVmwnYwX59tGtl4BY4ibGEtiyBMI5tC1nFGcQS+CcSUBAYWBoWiDpTgWpyu1j+hFW0WKWvWJa+qqnnjQJgIwSz5ucrEGhG5RvjLzxsPYZWW1DwYGtbiTHLGoAgvxQfWeGNaGHfvAU04d2oDSHs7qRLNf5qkehFq905jfidqDN9unmi//JCL3ygsAElhdaSwzXdHneg3aZfe6if60jy7O7W93u/Y47JeOkFAFHlBzWl3bNyC2SNWBoh+/TySv+NM5xWYJxsc2k5keeyzfVUGNwKT9jp5J5+8FMwY5mknZgQSQEquuJpdOB8r6DVXSAESFhiBbN9emvSLwNI8mvHHUGrrDh9chWJjSIDyN2iPM8tT5CkBSejKvPZGnaLYQAMBJ5YFEZK7TcxHyrytG9AOLGkiw9UH1jESqIoCEkUqDfYW2kLq3a+VgAYFHHaPL26ii/D3G0drN8k4OgOi1bfV9otyWaUbfvyETMeYUh0ekPi4pcFvW6FiRtYjnS/TEtFr20LF8JyBlUV2SCpR0XZyxmvogu1qo1EuLEYoQVjrXsRnPDPqGABQ7XOvbTFuoMkEpeYhNDa4jOdyGXuhgP64uyIsXGtfXEFe+PJdC3BGILUt+iig88nyWA7rLr4J2WHb3bSjMHrLmohfNqChLO4CPPI3ZrCaUkK0sAzFMoL+2kZz8KDLPLuMwMaXY3LxDErGigFuhoKUIscJeQUrS1RDlaK2XmOqtM3iilBArgk3JxOa2g7Qn9LumlxVa9vapj+Lm1Qs+rs5F1SSxuiwkxgKkfAEpbDczdrgb6OIiMDcYJ9cPyBehhQUIWwOyVUCzrTbVNM+gwMLL4LRAKBYjxhP8MLku4cp1vKZFWjI1YCe+dvsau3HW77a4ft1s1qXBOQKuGPpMRIdgIZYUcsWK4ex3i5LrVtoxcNgEeWV239FepRfmPSyTgCLc22No8v8ilzwVOH4eJLoL9ClIGABETJYxRlPt20uHcqziNuCQsbLDf5USh3KwK4LcWowZsDOWHRLQi+mG595LIZxEX0kbRY3woP5qwJNRFnLAol83p5rwtKuYJV9+mkFhncD1yCOIidfWsq1VTkACb5JMekox0vJ+jzaEMozLFZbShOMNyReVjfWq1H1l3TdqMlQkrPNdyRvfZg8V9DiJDoMl5yISJBhdgR9u75nuJbKQv50/PafzUbfiK3bLoSkaxfC6R3o+beTYlEAOksyndOO8dlQAP4MFiQ68H9IDgISEFcxvAEY2J/8x7AABAAElEQVTg2Z6TC4xW5/E2Bc+fgFEqJ0UqU5AblRRCn/FFcWhZAfzcNYBRqDKQX/jdC1j1JkWjkbfqmceKjOJ6FcD/sDVKYgxj3REBo2RObimizE4OnLKk1hhKZLTCOTTFyOEiSyhdmm/2VkWV1HPZTBRdXIEIYEfJDhMAqeqLfobUueGelZ8ogyicKIolxcA5064rlVLk1xkdK3Pa+V8JMdY1BqbtB1OX29S8AJKuw9TiuNXTY6rMzk5rIyunupbiiCLvstMl4Mp26yIDMOA2m1ef4R4mW41q2bB5gW+sc8QPwhbolj/tqRFjpJeTOXA9699BAvm18uQD8IolkAUqh0T5PVYY0YSJXODoEpVJTBRrGAGWFVruYGpYlpIhATFuGbiIujVa+WNBGs4MO0slMUVh0l3GAQ8L8YbJQYusZkzUDKZF8pAesHK+YiUBsJKAGOuuYWEihWOJ+yWTOqQQxPiPdd4AQw6IVDx5kk8U/NRwdxVIok7tfFsy6pU14x7yh+B+veTAlHOXWxicSZwVlnw3jIWZhQetU0Z4+MX2yXgp7hOLnT6TsuatEtrF1uC4PbEEdkgCMUDaIUHHxeyQBBwQtVjn3DF/e8rlGQzTHYoTs518+ro1emCjLKB08Dj3Z7Ue1MQu9ZOCZ3v4hO91hvIFHJ1+otVkPXKfJbUtULoCpWepqQVoBZYapUNmkwCmmh6WM5YZ/Z6ltbDnxQiSeklrJ7fTc/QDBAtDonFG0UZJxm2q2nKn4zdsS2tZfhg/wSy8AJIUS09tha/9Jdh+3r1Te9U5W7LZVN2+N3XYbrr8Prt8fsruzCgmcL3hfZbag9LuRAod+bMdin1nrNS+8NqtyPoS0u5DpDEj101c4firyQXSFXYp7d5XAhYOwiITML5fSio3AUXeiElxxskZRkQ0MFoYdUtVrVz1hWDnlxatlFh0q8ye/LAd1P4pgbM5AaswHxZ/hQ1uZGlEi8YGdStrTM1ojaU0rmYANSUsR0tCDA7YfEvQJha8HC4MOTHFvOKcZgFuskgJ6rWV6FBGTOiAt6JAp5VV7w8NSyaEOpNbdaPgqPOALr8Z89xXl7KBfMkjmqhXTbGcTDwwgRAmZAXoBOjRLxuqf5jJBf6JDDJaTDhOsQRiCWyvBGKAtL3yjHO7iCXAw5fZXmAQwdmhYkWTW9BoRetRa5dneYMj2BZVKqDEZXFJFooMVO0VWeiHztNaQcvgqKU8dx4mBVXVUwoBk9ybRFiRLO8zON/idHYkgMgZCyjbgCN6mXGCi1wIkCh5LXAU1ozzpNJLfV0mcQj3XQifSa11VS9M2wPz19hN1R/YdYWM3VObVzyM4uXOozEImKXP5hXvhZWmILBE/EtZro1RxRzFE6DEzDwgxJVvv8aC3vDtut6wP6njHNgAUoJ+VF8KPKHUn9G1DdOcaBosU08rhk5gZWlBSxTk7HBxTMQOu6whoNHQpAd51mstUgORHpAvpCQVWWSmytM+jqbKMxojTS3YKndetSWblHuecAoLvgZ3mdZoAbvofNqabwpQNWVZEuCabcp2JYsUo80TxcjaRn2DfmptD/Zu+J32444H4KHbkeO6SYcQhwRQS8jl0VO7ejBU1kXCA4udXMn0R125ppAX+fPy/lm3oIvvAMDh9AMTTvE9JLKGVC62Il18vRy36FxIIAZI50LqcZnbIoHwAb9CKdiWnCOZ6MENRbez2YWuJa3da5WLogUzGcH3HOcqgitPWnBRlqii3G6IadK8bcv1pZtSQuEKip587LLlKFK1db8mNbOaLK172MV4QBSEuvz7UdI2KAjyRTkekIIdpehGUcOFKynFdK2Yo2hx5OUKZai0RndeEN91NSYEJvLzdnp+v907OWKXH5i2AxMTdiw9KCvS8qz/yuag2OoqwNqruJWzmZAxLnMABsgDcAPDLZLrEfILQFJn8nsMlyYARH/huCKv9m/tR0F3ECWggWXHj9N2P1+nQ1iA9YN11cBTAyJuODK0x3YL/OD+1oB4QXmwkHSS7/zrk7HEGIMBbz6xoIV3WXi24WQQE6Z1qFRCXuB8V27EBsSaGQVJnAvwgVShqnggXD9zmmwZUt6MteqS7mv6Q+71uatUvoDj0PcVByV3vq265SpbQJK7/glcumwoqyXHTjmza1YLfwZLIwyqfP55k0z0Ob0oa5xIMBwccTDJd+vtEk+MvZTWIHOQCyiORXKJj4i4+dslgbP7RNquWsb5xBLokAAzuyg1zAAT98GD3h+oHcdt9WfwkCbYnllLZjdxrZGG0TMx21nz2WncdUIFKTycGdIKcQh6pSBZkLLGLLM/1dwlUE+3lvtcszZg9anHWOXMo3xb8OSTcuDKS3Dcef80VDXbrj+quittUtzOVgKYwBoGYKEU7GkEtpcqItfY5nJRgnMZxZ4plqVz7LEP5bWXva93+y9s7SaVEUnB8DEtHrvHrm1O2ZVyuTum+Ctp3WpytG1ITNfR4h5R8++X/+q0CEdOS4EOYvx6y2dzeyiZPgGgODjQ/YNrk3vIfLWk65vaReu3shzO9fHTGrp+XaOMKnEeAIAE+EJRJaG4kjiW7SktAouRpqCJkb0Do4ppzMi6NGsTs7Nyu6v5uB3MD7rrXjQfzgc4UPcKsmwltlNCSZYwqOMHM0UbTQ9ZNpF1wIl1pSp2s0pZq9Hqe1JKNMQNwSLKkrPqkpSVitouCRw1ZgSSNGLTo1p4G1ZMtyiFhflRNHZDKQSLkEfwQobu9tgFKHGPPa01o2ACZOIolJ+L0e+NgSy7VYBWbPf13a2c83Eb/Ty0f8S7i6UpNtpH52Ob4jrFEjgfJBADpPOhF+I6bFgCxAeEs4m5RtZpeFEiWo/xDefX6wQeugnR3K6VAhUD1UIsY5ophukOP/lwe+e5bOdYgr41uSuFSsqLSCVwiWvUhsVdPSx3Cb302VjcFygrtAxgJErvdPEhfdfxlWHFJg1IkQhVcWkvLUXCy0TBgQL8XCZVARm6cqQ2JEUB3UsuW66mmp/P5nwshMouOmxUJFsuo5UB+dMOWqMS9FqpOXortxmQrV13+p5q8Lb1FMov/KSt6/ebjpCFY2nouE00Fm2ivGiPHBmxByaO2QOFqzusSOSmq0DWivriXmuKlj95+NNi4NoG60WX5tMVgA5iwwJ2u6C/UMIhYFhLan4PWKMvQzcvig3lRfyQu9sJLFGuJxVCHCO/Ty9M2/0LD9liWTFBKh9MNaXYomJz1gpaIgCK62Ky6ItMEzME6UNVEymAJOrTELBr4S//DbiYqc7KTbBsY7lRrcFW1L1E9xeBI9qYUPD+TGNWjHizwWQPLZYI0KdTWrcqM3KbANyk7jfEMR4QK+aJdluaqh9rHzmZhdZu2nBSUe5ypzqry9cESoyKkOY+LCcQvTLpTNrkYEufyORSTQDyhfE5uRs2LT+mxYlbxBuXqjzidscS2C4JrK35bVcpcT6xBLZZAqGCSrYELjODCmkC8QRZ3FiUVqqsvmnTb8GDGxcc3GyChzH5YxGqMjsqxQuLURhrwvHrJT8G96LaqFVOP85q7uZCvbUHRZdZXLR7gJHWmskMPWjpse9KeRG1tzJv1getWRkVpfl+gat9wfe6VqVsaq/c61J5Mdnlx4M8kIYLZP16rVfvje5HeXF3G8mKmfizlTKyJA7IdTFUUr2csNnbXCh9h+LJuMOCiSVzRVKbUYRZKHNHEqyN9bw00YUtFRdeV3JEs3wibwOmNYC0vhHxVaeWzthCE5r7tZL2auzOiLb669WMPSc9a//bcNZm50/YdO6gJgKibmywbs1advc3rD4rgMSaXmcp0V9+bfp48AuhXVLP9mgH1+GK8dQ+K/jCGAgBEuPcraVqhoMS/eYvKjDc+Kq1BScWEISyXEHr/ACiiDeSjIlDmq8v+Cu9GCwtQB64A+IeyDpALKSKxauz3hxHHM/p0hlbzJZtOCFlWe5+ALD50pzNifobGvG0JpKoJ/V2YKF6klmy+KAlcoqFbOR0D9ExYuxsytJdlXWrobgoFO9sXi6JuWWCiA5xeJ7ktQqwaBvl4kpJfZAPkyYk7g1quk7TQWFq9dOqfML9OrQbAUe4+1L6REbVBfVVtWE5rVWloNPWvf5SkkLc1lgC2y+BQJPc/nzjHGMJ7JgEwscqQdYVKaQF3J606CKrsq9UhTZZJT3MF5Q3liES+gSKPooTigbxRvyteMCvV5QUhYRWc6wtXGO18cfKGjSkjAFE/h8U4tYAOSKJtjuzS8Bo6AGVLaVCayF5aXJnSompLj10f6DQaPHYRkW0ygJNifyEANKU2K3y1lg4LNrvOSliUm5lUcLitKOJNkloxFKczZQXQA77pd9yUDgH5CLHrDXrD4UAt5/zvf9bADkjKyO/w4SEYUBbKwXHb2jUdMmOXBTrNH9EcWoPt9zer3rfbyaGhJyylrE9qTEbS46oz0R9LdDS0CshFoAhAfIFg246vOK6VKe1t5HI2H3JPfbFxRP2wwJIT8/O2yeqU1bNamxKZkEiH43k3Ixlx76ti+rsUdKjkHdL3geqDoo7TpE0zSWqewdrIDErH5I3BG626i/MPa1Evg6KWr8Z5+2ydFg3Bd/dzrLLY4P1rgDYDQGWgOo6yIwxuSD3P4A2Ez+4cjIZhFvgcg10rJqGRZp/vtd0j5iqzlgtU7NdYsfLJwdsQQp0bV7y1e0jI3KIdFrl61ja2q6j7iuspWZpvXTv4Xr1CQ0VVlcdAUsVsfBBIpHJCShpkdj2uVSZ/CQPH9ErKsjOICG7tNwtowQOAKWULFPsA7Q5gFJmlO3sdNxw49RTArh3DoucwTuAsal+iFMsgVgCW5dADJC2LsM4h/NEAv5g1gO6pEUd5ZBiBblbsc7JVoASCjNsVyH9rzdVDyCtKuJfw0f3mmouwCf61EKRqI1oTaPHOPlCW3dzS1F4qGIBtAhsdvftlht6yJJppqWzUj5yzqyFZcIVOikx4fkJWQ/SAk0GYAJcucIjFai8x6pTNwosSTGC9nvkDt/nDbhI3lCmUq5IrdQOUAAd9IQdFWkvM9CDWsyTmXkUOwAN8Shtmu3IsT2/qrguWatUxY1IscUlCsWaV2eizsRKUT9AdrdjOs/p9nuppkB/gaO6A+GHix3tyzpspRy6nde5jTGcEbAZlmvXjAA1a34taewmZZEsJAYs1whi/TrP6/Ybu0tN7Gq3N/bZ6OyDdv3ImN00M2lfaQ5LqY6eQamSTWp94BU9a6vf6W+UccANSr67JXHJKGMACZbIggCJ953qV2LRU50TBQQ+OSLQEKYQHKDse0yS8ose3z6u9SWt8QZRC5bvGsBHVqLOboOoAeAPS6Jbn3Tdh+VwrNdPCjLl+IuFZgF6SiW52y02TnkZ9GO2iGVIRYTyp376W5n0OzJ0AC2ZrMBQRrJSOQ5e9NkkBrSqa0bXEICvVaTXjWsuidvvyo5eLkZFRAkc2EG+7Tag5KueyPd8dxcLRNUChcst3NlviEtrYKmH5CYZq3Q7K/y4tItZAvHVdDH37sXcNgcTgdKJwsBDPZzZDR76AKVFKycqPvuKsuOzoRuRifIsuVWqukqR0DOpr8Rx9fkrxBJ1mSoYPE6Z3W8sHrRmeVSKBRVHeZHPv/bXS/t8wdfsrttsYPSEDYqyNSWFNdBqgvN5HKNQTYn1aWU99EugKKrgmBaQTY/cpbilY6rHUVuqylKFOxYaSMfZfTXoPD6ol0Lm2xFdRFiAoUFRHjs4ksD8T8dEaZ77a6oUUhQ68g66x09DN8xopnw0rwUcJWvo3pk1R2lF0aT8Yg6aZpRwP0IWymrbStlf2aq1+rK5cEjgSOtfSUuty5KUKuo1eL/q07/FjvajjA8nRUa9VHAXMGHvIKktSSwKAk9YOnAn7TctJgt269I+O1o6bUezg/Yt0TTX0oqziwor2jH9ZryF42grfeAKuPohaqXwbhSYJZYQdzXAUlPxRO3g99YTkzzqFbHPqU9Tsh6GY8+BkermedIuMuxIGZUJMKLvGQdYhRb1wmLUCVgoh9sbQKiqskLLi4OzFqgAbHj5XlZwfFgkILCsCaOgKkF9ulQpPLznJ/kD/ABDzVQL8FMvLOiAzMg1wP3YQVPP3IIdbklTfgwF2un/uh+665w2M3FA/QFfoXzXyXLHduNm7WtRqUQoyOuSgbdBvzv78GxXCjnOnJjwmLPhy8e0WLgGqcQWp1gCsQS2JoEYIG1NfvHZ50gCTTFfJQcgK5BSCDsS06KtJ78/nPWdTx7WCwAlKZ+7tSr9/Xfea1/8x8/a9U++Yc2a85DDaoSitLnEE0rkBAtyfZrdraf9vfoZPrWo6N16Bb+TGa2JsuebUjIUUC3ShVS6bnk1LZ3EYhQepS+t5EBPp06JAQslYt8VB2zvlQd6KyUoyjDmjdwuK9KQaMNvsNTI3YpHCFxpwnwv5E8UKF6hhMO2sM3XuZECg3LJb5TeYjbvFM9RpcZVHLTRvpPKlPLmA6/HaSpOfSglXJ9ZsZZhDWAdGyoaKFJYJdQ9+sNqIXXTKhqr6ycKVHsru6w2/Qjlpz4W0G7WBmUtfLgC/RV7loHwgBFECo4Pvq98RwbUhXV69iS1Jo8U4GJTRAGAaaUqxAvCRHIybdV55fm9flHykho3r3wfWsrbZXLtGi0t2MnMaAdhQ68czu72UEFnTEQTQ0DQR9esJCPgAuGCW23UiW51ElgBFBB/6IBILohpyAta+bhST5Y+NpZzRs6wVuK6h7scMgeElbRALMyXvrj0yqr4yRC+AKJ44d4GYoI0gToNDhRtsKB7hoArfYz1E5fAMmsKqd5uPVV7ADcqbssJIOT04xpXLgMAjJK3uZW7xxRFyqKdtL1n0rF+LUTOoa7nbYyR6sbaVFl5J9Ay7hs1PYPcTdcJetiyLeLuKbLoDsZBYbfiUdX3yZbrZHR//D2WQCyBzUkgBkibk1t81jmWQKpwSgpCoIH4A1lPJFd0og/ZVh15+C7Mzdvvv/Id9vCHPcw+/+nP27WjV67TApQisaKt9WBfMweUKdFAL53UUbx6JEATMR5z4az8gutZbiVaY8FQfyiqbpVKzb70T/9mwlX2Y7/yMsUGZHoVpO1SkojzUAD2kuKfuoiqx7kX7mbaiCJzeHBQwETuh5I3Lk2wzK1Q2nQgMt24ZqPR1aFgd5MWecNgNpbeJaV7ycYrU+7OlxBbWZbgdZ2EJYrFP7Eo1bR+1rpJa9rU5q4UQccetatlERRQWqqIDVFsZOnMvcoXCdAuXSuicrZkd/CVUezRaFJkIWI0m0rN+IRDRscPyn1vvCHqZbGrbW68aKJB0h6vp+xqyX6Pyj+JnM9h4n7grluqRmh17qyOS41qSqwcw6QE56GE8nJhqN9dJuTDd03IhMcGO1bmytEo0VgbUKHrAsJTc2Kek4UnJStQJqv+cRyzUtKAnrrc73BDo+yGqC8ZT7kBgXzc3+TGyZ1QeMiZ7ojD9C5HzvqPWshW1qiPXzrfXT9b+fgZqh7y4LWU0lWEq6LaRVnh/pZk/CdAlP1+fbUOuVA/fHJF4BbLMw2mybQVun9+ZNSPuHhXAaihPM5yY5F/bkQELSrvYpDxWRZXnH0sgb4lEAOkvkUVH3g+SYB5uzD1Akbh/vL8ov32c3/Zfv7nft5+4zd+I9x8UX0+57nPsXc+55fsl//tt4PZ4h6tg+TBrUeyWi1bF3oc3PdmaUyaUU6IOU9qWqA86pvrB/6Gch6A2b6z3OCBKCn8dUsoDVW5wRRzIqxAuVWK6i6chzKDu9RGEqWRN5aE9RJjFFecaVExhwt0Uhdinoa0bhMMXyTiUobk+jen+vRmwNNOybNR2WON2at1VtAaYtAyw/eIsvle0TpPq17IHAVWcU4CTCntT+SJc1ktp4wsEIMJudbJWpESyIJaWqt1yR2uboONopYknaV6m0iyYkh9n1LsXLM2Z4elSN7Gul+ypJzLtN49I1o3t9i2RObASt8bij0CDGXEQsc2FOcewy+alY8z1j0rVeQCPL9gC4uLVhgoyOInohABSAcaK84IAIoDIwEkqLuxWmXzYusEHBEDpII9z5ZbYDi4aWNoJevIsq+fDnw0RgHs7mKoy4PJqLaVQnLwq04MfB73xLBUGzqvQ9qEDB0WcqFdwInJFtwjffxE2hECk6zcapvaj7UaK2SnLCKnbNtX+nj2wSkfG4OHRny9rXAMbFshcUaxBC5BCcQA6RLs9Eutyd/6+FftZa94+UULjujPT37ik/aYxz/W7vnaXXbdk65fo4uloMhiZU3NOCblYqdH+NaSlCcx5dXOPE6z2wNSHKT8yiWL9ZeSslbhxpdSfFUiOyXt6eyBJBR7gthzciVSjVY1if1dNvtxHO9KIKLYoDhQ/hbkIiX93132VhUc2UA5paYc1TS7LEHpV+ACxe+hFkDicFi+BsRaNq86h4Aukk3wFeVUck5k1Idyq/PG4WYnIo9mPaO4GCmqkn+zUbD6zHUiBRm2tBjuuoEjlDgWED3WPGkHarttf3OPzabEVwdxgpTxAQEnyBtqS31YtToqijilHtuszp+VnPbmC1ZcmLOSmPKW2ew6TjqPfrqFqTUmQiUYhTSRldQAmq19fVdZAKG8WLY5WX4BPXtHdtkVew44WceEXGbHF2c81mhFtgAPnQfV9pLGuFNtK84EKwYue7gCL2idpABQL5/pSvxmLjmVx/WypMB/XPmauI/VAgtQTYAsU5C9UdauTpCALLoBAp9E0FgXdtL7BZxUeSYwiD/q1Q4sg4BlHyOS3Y4l9bPHQtIJvSq3Y5WJC4olcHFIIAZIF0c/xq1YQwKn7zpur3j5m9c44uLY9dIXv8T+474vrw2QUGK0OKcr1Qm5hQBmNqzlReUllSilPMSeVztNXBdWpEBNgjkLVQKLRu7gv0dP2vbvKGHQH2tefVN5o/QQH4SSCVjaSAromBdFpR6w0nUDaGF+lDMgK0oVinfNMgfuU8E6WlhxKJlZeEASVqVGk/7pTCjBgh2ics/u+ZZVTjxZ1pmilOe8VScFjqevVaD2KdG/PyjlNifihstF//0NB629QCqz+7PNOdF4l2yXmOb2NfbacEpxDfoTXYE8v5Lu8EnJG03EIZUUg3RSQOsaKZi7m9M2ZwomV0aBpIN3Rg2y66Zkb7TM7Tje69FqMGAGiwqKryoY1HENYYRtCevhY0L6cl2ukxVRbrP/0J69tn94TMQdVXtofqJFM881o66SxQWXTMaHr7MmtzqsR2kBk1ROY0Njhf0VjaFFxVjWFYu4Sm5hPcNK9PFJG0Mg6DFA6jt6JSGlnzawP3Txy2QEkmRFWwWUupTTzTLW5bDzexPydOsrPdT7HpFS3wGS6JNQlmezYYzNoUMi/KFW6p84xRKIJbA9EogB0vbIMc7lPJZAoajlLvOymFzkCZeb/pIeorhbia3MXRVZW8nVsv7OXnWULFKZ4XtFRnGNKMX3KitZjgBNcu0i3/rCQUuLVCM18KCe4K0pbawd25xg+Wpq5tuD3Teat3QeZuQH5N62UF/csKKBi5Erz2soTlQJZTKnGIa85AKwIoiez0D+HYrXmkCNYwFJD1lGiwdXTv+QfqtfsQ5KtvXSYb0u89+pwR9I9g8ty15HdqZQucaxbmJp2qYaM5YRrXdd+aEYo+BS4mYS5wGxTi4V7ZFyPDqsDeOSQFPgvLYkUKuFaPeKHGIoMWgzjTkbX5rw7ZspazvOcSAAMYP+6FOUTpRQBwLrCIFj8rL+FeSKBXMha6dh4UFRduY85cu96Mio6M+HBu3UwoxNynLkfaf3sB+wDOHOVVkSu52AUV0Wp6Sso5m8FmmVAk5nEGuEEs4YCs/bUvsZPqq/hjKj2bNKy31QPmVePdoQAii+ExMFuUjCF7ndUskXzMmztXldIQWJRP3QuiKQlctNrWDM4F7H9eLy0rZ1hsyW2w5ILU+WNEY1tkZ1ZwHExymWQCyBLUsgBkhbFmGcQSyBC1ACsu4sLWnhWLlkYekJFbTNtUQxCOk5y43dao35yyw5dK+IAg5onadHStNSOQ355ItZLSHAhJVDupWsG/dJc9giMOuoLMrivFyNhkR8sJmEkgMdfEaWm0XRcZdruJSpsmskFCJYvbKyCjGrz+9+EsdhTUqqrIALiy3BuShWLBgKM9a6SbTIbhGkD9uxRcpHVigvQ65yWfVHIi2GRFmt1kuhoq1IFymCsnS081zvzLX3N6XUz6r/y41FO1rYJeV+nzVESFGVax/AtKFxUhbT4ohoxoebRTvWOGnzzdJZVy47a+0WEin+9AHjAfARfud3qAh3nhf+5lgHU2ITS3GN0af6d1Aj8Q+IPfHw8G5nUTw+P+VMlBwQyp18+E5sEeOwXBU5g8ZhKgM4ErlIS/lFGW7g8khX669b4jpjHJB6HeM7w7dWNquODbLwtrfBkLYFoHnZ6kdbV50b5r1Dn8iftF4/bbo6yh5WVJaQCMaD+plWq19SAip41QUEDa16bLqg/k+kHuWZRbfsZYq6D+UFkILi+88kPjKWQCyBVRKIAdIqkcQbLjUJfOQjH7H5+fl2s5/85CfbNddc0/7Nlz//8z+35z//+Xbw4EHfDrX4v//7v9utt95qz3nOc+yRjxQYiKTJyUn76Ec/aq9//et96+23325f/apiQDrSK17xCvvUpz5lp0+fXrHn8OHD9qxnPWvFts46rNi5mR8iVRB9gXQosagRO7SFhB7NekuZ0TukiCetIotRkHhSJ7WQ6bW+KC7bEqmS3NHmLVnAqrG+0h7k08+74jvEDIbCXRBltiun/ZwWPYZ2COgMZYqKKQpo3lcsEhw9Vt9RCAE6WZW52dRZTxQeFOqU8mxCaLBe6gpimN8WeMtPak2kH/QFjqLFbKeii97tACmRswkp/GMDIphYmLRyZq+lqbuU/cnMlIPCkuKehrQo7e7GiLv7Ret0tr+jXPtCqC0lO1S2KTdQhmnJ2om+BFQB1gEQfFdH+FjEsjkkSu6MFgcGHE2WZ4PtHBBJjCfWXpqvlaxcKVtS4AhgFIIjDvUx06EEO2DRuT4mdTy08uRVkVsfgHutPl0eg8FRZI3FS6evKLddTbZjyWolXMqCNbICt9Fw+05/OkBVvQP3wKDfonUAyDjhRHTjJr4jHx8fxAnyXWN4Oa0l6eWjtutb4GI34hNPyUwMjrZLrnE+sQQ2/1SPZRdL4CKQQE2zs6985SvtJ3/yJ9utufLKK1cApL/927+1N77xjQ5wQoDE7wceeMCe9KQn2Y/8yI/YP/zDPxjAijQ9PW0vetGLfCY5BEgPPvigffrTn/b9vN111112zz332Mtf/nL75je/aXfffXd73yc/+UkHY1GA1K0O7RNWfWGtn0B5cQVt1f7oBhQ43KekOMhqsNUEc9qSrFKmmJhw9hp1bvm71HZY1eYPtdax2mqJwfn1as0++xf/aidvPWa3f+1Wu+b6a1UmimdUcdlgWTqVswNFea18pBChmG61PKoXKcbLZkNLYY/WHkUvrViU65/7OLvhaZe3dqEcqc06HvKGtMgx0iMCrFpfC/5opHGuEipjRWNsXEPskNW0ztKUiCEOWCmxYCNyvQuZ85oaixVZFgtJRZOJZhzGv51KDkxl+WmKnIA+9/4ECEjWoVvbirpoHxa2ZXCh3/rDZbKiuCIETteRFy5y9Gc5W7PjjUm3QrCP4zsTZCOshYWViL3h2ArGV3A0ZUbPpX6DspwOan2evNZPA4QBWmBmHF+csulKsPZWZ1nkScyM5636oGxXdU+sVETOrn3Zwtpuu9QhK2a7gWzBL/F54qEEGaJ16yzzbP6mr0Ir4Ap6c9oiixwgsg+77IareK7a266o2sdIjFMsgVgC2yeBGCBtnyzjnC5ACWDZwVr0gQ98oGvtATZQg192meI5WgmrEVYfABIP5Ouuu85+67d+y/7pn/7Jwc6P/diP2SMe8QirVpcD7J/97GcbL1K5XLbHPOYxbpUibujtb397K2ezr3zlK26Zeuc739ne1q0O7Z0dX4hdGJGSlJGPfFOz1zPVBZ8V7zhsxc9A2dImrDnEsGw1oTQ2RevWM2lx39JBxbhI+fJ1eVxTVPko+AGw63lqlx01KZ+//dxfsh9++g/bx/76H1zue/cqFuoiToy7U6dO2eve8Dr7zj//sr3orV9UAL/WKhoQKCqcUMzRSYGkWcX35GzE9lpZsSzzImBAeV+tku+EoAQSRDxxRu5zJjKIESnRk7JsJDKylqhCDoacMEREBgJIS7I2FUXqQAzOTiqfAA3qFM4VOHCICIxrhZgT1r0B+Lh1sUMvDbZz7QfgicVdq2W1Q0rsbHq+TcMfyTboAOUTWrAcoEW6xdn09Jv6sdYOQAaSD3Ri8h3Lj9iYXBeJCWIfDHT8EePFJEmgPkcqqq85xTiNpIfc0sTxWPJwD2ONrqYmHNLFfHfrUate5JnX/asoV0nqVZc1RZu8TtCgQwfu8ou0Yytfqf0qmXXJMFxgFrITEuxuWJSDeK2tTwJ1KfKcbuJeMPPQpFwx6zZ8mchPxHAYY6Vz2iVx4ReJBGKAdJF0ZNyMzUkA680VV1xh733ve93y87rXvc727w/cw1BSXvva19of/MEf2M/8zM+0C7jtttvcWsSDifSUpzzFfvEXf9G/cw5A6fjx4/Y7v/M7vq3z7Vd+5Vfsh37oh+wFL3jBil2VSsVe85rX2J/92Z/Z7t272/l1q8OKEyM/8oqhYSFUV+TkKuaKi+ZM11MyOX7bnqqa+W/WC8pP6kwb8LQ0p5bS0qxKRV44Iveh+RYDm5QsLf6bzJ3RORu7LX36zz9uT3nyU+zj//LxiCQu/q9jY2P2pS98yQ4fOWx3fPvn7Qkveoz8A0vqSYi15c6VGLZDqb2i6A6sACjK481JgZQpHx87KSF6X8TvNpEcEiX1Gdudqdp9IoJIZgYFlURdrUVvTfFSIQAB6Be1+vHkptdf2nzr/FrpwOnUC2U/K+sMFOz64XEoXO/dkjMhaqwDFGpl6NabArBpZ31ra/ntSw63PIEaAZRu+YWWEMonholrnLW3FrQgaUWAZjQ3rEkRuViJihtWO+5LDU10zDUWbKYidkmROUQT7Stq7a3RzLAltR5TbVH7W8iDeDri8ESf0XZTU9O7JoBHxt34sD4HB1F/2sxnAuQrOW4FJDlgVbtVlGSkka12r5tabaGdxHEVZd2CwCVgqGSCoHXAuhldGAcg69ywCHd0fbfXqLowqh7XMpbAeS2BjWki53VT4spdUhJosXVttc3f+ta37M4773SwMjU15ZafL37xi/bwhz/cfv/3f98e9ahH2S233LKiGCxHIYBhB4oqMUQ8qLAMkQBI/O5MlPGe97zHvvvd73busr/5m7+x4eFhe+5zn9ve16sO7QO6fAmVFRaPhFGpb4WAQP+tJlf6RP8rYAR5QEKB9wlZiZIiCYACvC5QtNRUzJPIGhaP/4irKksAIsUtJXOTltv/NUsP3ivZoaH2p8gc/84D9q//8Imt1vyCPf8jf/8Re/P/83+avfR6yU0uU6J92Kt1hvYlxmxOrnZnEtPSU6VcNws2XB2y6aUZq22HpXCjEpOVQUvZ2in17ZG8FsedO2NLuTGriPGwqLW0sHZRx3wjF7DZCR71NwI2WpGNH4+7WkETD1giAEew02GRWCsBirBuMrOvU3w44wq6BEMeyj6gQsAIVzoOyAhAwVRHAlQAdBxc6FJIE1cnYJZPaWFapKL6DOYGbFdy2IqKl5MvoltOs2LIIw5lpjxnEyVZgvTXef0DjvYN7BbbXt4qcr/EaoXVicS9w62MaZUPg93qW5gfx3bqlFafholzo7E45IncViYy7K9XYQMcUB1x9VuUy+FiU8sTbCBBk4+MWKDZyS66yGID2Z23hyLzwu7ApZmxFadYArEEtkcCMUDaHjnGueyoBOSWUzqqGJYHIhaKzVUAKw/ucYUCFg+zRa1s//73v99e9apX2V/91V/ZF77whVUZ4xYXdZ/j++DgYKDMrDp65YYPfvCDHrN01VVXrdyhX5AwvOlNb2pv/853vtOzDu2Dun4J2LdgYkNJ2coMbtfs19oo3SeRmrf84f+lL2JBy+ilBUtRBxOs/aNFSyvjT3RmO7IJoiyknImNrVkdFWh6uuV27XHqahaZJV6pt5YWVKSuNWJ27doV/LgE32l7tSSXLulGebmmHUrus4G0rC/paSvLbQ2jnSKWXDIosZtL4Xn9Kbfdy1AckgDQ6cqYXVmsy4VuTsx2AsYo/1q4eHctZbONWXtw6aTWTRK47lOR7l7WNm1Vc7OK5ylKUcdaQpWqcg2EYrvbBEi7VB0HMCL2KCGgAdhoyI2tLmtSKEmOdWmCnlrWppQAUkIMdlhnsJ7AZgfdd151wM0Ot9myAA3WwILqVJQFLiVLzaIW4cW1DLY7rne3JOu8xQYTEysTgCOkwmddpUyhofFT8XvFbG3B5uvzllB8W7f7Rthm9vmiqQJA1JM/fZMrp5j3xExI4liU94TAFtf+kqyETJhwL2i13I/r9ha0DTBqNreo1blkLQstad2O77YNaxPnueVIpZ4X4ylaUQ0E3AC3Wi+A9OyJablVNmxg34jGwDJojRYXf48lEEtgYxKIAdLG5BUffR5IgFnyysknWeHySU1jzukps/kHwre//W2DMS4ESMQjffnLX3YGujvuuMP27NnjLS6VSvb0pz/dY5U4nhikMGEtuvLKK8Ofa34S6/Tf//t/X3XM97//fWfEe8lLXtLeBwterzpESSXaJ+gLrj0LsF8R5E28CcrXTicBokR+PCiVeCS9UNF9AdTRuywhBjvW7WmWBWraVitpC2jyAkSViUdbTZamtCxKuOpl939VrHfq6x79jBIWKm473dTzoTyf/Ve/D2lh1yOJ/dZML9lEakqYM6FFX0csJ4sMZAI1LTo7KetRoy3zfmuPJqdrDPIN1HuPG+v33PA4nSdVsCYQfHL2qDUHv2xjAg2n63NWTBXtVOKMTcrlbrYp5bz1F555Tj8ZkpJtHUuPCCOIOcIy25B1CLDpNOhdLrGmlNW61i8CHKQzIkwQ8GGMNqEQFz4A7AQgSCdLwfW8dK2i7GL5yAkQsdYOzHBcw35diwChLPIH+jsrNzhAcFqwZHGxpLIUM5RZfpxj6SpoTa8yCw2r3DBRhyAWB6oCARbq3trN+l9z1TlbkoKdEdDqTH6d6VorpgZsRGtWDS4NWrFaEBOh4o8EehZF4V5Tu4l1oz0kn6DR/mRK8tK6Wo35fZYonBZQwhrEMR3C00/WIgOQUk/A0SJMfpLLRhNlV9R+l21nORvNbJuPDxgC1diO5m+qGOXhMWfEkdHX5Nnq003lF58USyCWgEtg43edWHCxBM4DCTQqQ1pb5zo94JmN3Hz6+Mc/bm9729s8A6i+//Iv/9Je/OIX2zve8Q4DFLGNF6QLn/nMZ5ztDna5r33tawbBA3Tf73vf+1a4xfWqDZYmXOtCtrvocf/5n/9pN99884oFbdeqQ/Tc6PdyreKxCX356kdP3O7vrlBze1mtAaQGjln+0KfkSveQHuQoYtFjAqWpsbjXqlOPMD6XpODHT/y1OygtAoTLUoesmq7ZVGpaFpmc7VKcV00uXSfrp+zu+n12V+M+j0Fy1661s1u1d0nxQPW5q6TxCiQBZDeVZNkUffdE9TI7U03bbrldnqrcYbfV77X76w8JHGnx4hVjYVOFbPtJuKnOVRZsWm5rJa2zVZVMa6xPJMulg9NIiSjjKL9VWY5AQoAjgEtaxAoZWWtyhbwNDA24xXlgYMBwifM1jnRcQfFFQ/lBG9WLuBlougFH5IlLn4MjJj30h/UG9jlc+GpinOM4mCtxacOiQywR8TdYi0KwQjU5F5czJ1RQNwL02NYUMUU1p/ilQeooQK082smPk9VK4A5gJ7hneY0vXCGzcpetiZxhXpanmixr7hYYPRWF3V+qX07gS0sL1KavVdzhYOuyXx5L1KPYAkcA0emFWQdHXm+QXPQ20a7c+l/I93xKbZdGb9LW68Z4GzoyaiNHd1sqq/vpskjPp2bHdYklcMFJYHnK6YKrelzhS1oCeq5U5a6VGvm+LBLTeiisnvHsRz5vectb7A1veIPdeOONduLECfvxH/9x+9Ef/dE1Tx0dHbXf/d3fdaIFCB2wOr373e9e8xx2QuWNRSoavxSehKWIeKetpiDmoCMXQGTLirPy6ckTGuYp9kur4bUjSTPKuWnLH/x3q03eZJXJR6pUFIXwya6ZeZRwV8Sl4NXk/hh4QG66dp3rUpHRN77xDbfahZkeOnTInvnMZ/pPqNr//u//3hXgF77whW1LIjsBxlCxX3vttU7HHp4/MTFhH/vYx/ycn/iJnzDGSZjoe8D4E57wBB834XZm9AHexMEx9vbt2xfusn7W5woPBiDNZGZMarTsAllLNdJ2vHnKCRlQEHGB2lySei23qebCYSfVSA99X920GaXO1XC5xZ4Qa92sTdXScrPL2NjCnB0zKXbnmRLbTVasn9NwcATpgYBCLnB7C4+lLyEocKuJFPqkABFub7iGYT112my5vRFLxFpdAFUmNHCXI96GPuQYrgOuBN75gzK8LDIGtwi35ITbGKBtUBcGAGxRbm3l2owsSiXPG/KGGa2z5HXpkC35OCmE8qZ+6UJKEz26B5QU3aS+xVLEKVHrM6BrSW6wbK+IwKGi8pL1pC0mSqoXdZUFKbloU80Zt3YhE8BS6BZHmSm5U2YHH7SalgCo67rP7LpN9+4pDnVANihQiCshi7DOyypWE5Bj1LA4LcCMvws6SU7tsbGNDH/IpjIrV0qNz/QgzIMXuJwu6E6OK38xSSAGSBdTb15KbeFho1nI6vgTLHfwM4HbzyYU/JGREfu7v/s7W1hY8Ad66GrXKUqY66Lp1a9+tb3sZS/z86KKcHjM8573POMVTSwmCwjrln71V3+12+YV2zrrsGJntx9uXdO6LnNHHUzi4rJCx5BCl8wqdiF/UouJPiR3oAXJkZlvPWBdlmfxQUv+ikfI7Pma3CTnrXrm8bIU6XYUsQguwYIlZd+aA9ruWli3Vq67rdu6VJwElTrA6ciRI57HDTfc4ABpZmbGHv/4xztxB+OB7VC7A2wBOT/90z/tr5/7uZ8zCD1+8zd/0zgH8AO4hpb9D//wD33drLwsBBBtfOhDHzLGDMeieP7jP/6jl4lLJVZIrIqPe9zjHJRRdj/rc3kGrTcUadkFLCMGwdySAvmJS1kqC3hsbuIgyFYy14BZkltcdfphCv4v6efaxATROnX7DmFHfWDOTtmiPUx57xGl9wM6cCu17FbO2doGk5pELUY6WYb0CkEEii8z+YAktsEmhjUH5ZVrDusOhAN5ET34Br1jSYAQISd3OaxFTG7gShfmSRug8l6sByCqDRCUH+5nZ0oTNidii5TKw5WuKRY7BZ3pfEoILEftc8hMCaDGH4CFT8oKYoSC4+sCeIA0XALbifw4joYoyWYlgFQTNTuum0GeuNVNNqatGlnY2M+hMq1EW3EZzOz6vtVPDwlw71c5shomBbZ0nLvUqb0Liqci1oryHGRJdlGZhPlt6NO7baVse56/kWN7ZtKxQ3mSvB269YWyDLZu7Z08S2fEBiqL5vAVWhw4pvnemkDjs2MJtCQQA6R4KFyQEkhkRAlcG7Ka4hlgPMsd+Fyg4HexJN3xpe/aXTfdtWY7i8Ximvu77czILaYbOOp27E5t81lsKSKoO1bdZTXF81RnrnUrgGt20Yrw0NbDVSs5SeMryaozJbA0rvVPjmsdnXFXXDQnLmVFufmxwclYI0KFhfJCly1UIWaaSdAQS13zFN3e2rS8R4AoM3abXEMWrHzqCZqhH20ZjuqWKmhGXGv6JAXgNmvdgsa927pUVAAGQyw+MBZGE5Tvz3jGM9xKyHZizohVu+WWW+ytb32r/fVf/7VTu0OocfToUQMoYUF8/vOf37YkApQA3iwE/Ed/9Ef2iU98wst585vf7GtqEXPG2PmXf/kXw/KUy+V8dhmKdwDSeutzRevLd/phf22fgyTiXKaX5nymv/O4jf4msL4h17pGeY/GxvcoaaNZrDpearJNSbluNObselkvjpWO2Zn8ZVosdmvga1VB27wBZR33s6UcZAMBYHC4IeYwwI6QvPqhpdTLaqSL0AEStPtQZ0NdHijGAVMc8TEAg4y2cxXhVsZ1RvwR1xeAoSRwVMO1jcw6k45dkBWJCyYld7pw/Z/wsG7nYKUa1ZpJw7lBXcVB7BMWIxbHbShmiutWZh+/jnHRa6hPgvLDXL2VwmEV2a5EXCFAXmqW1J/Tfa1ZBUgCKCb2yj25nBdgIxZKYFFtXdSrDdrUflJogfIffbxxPqmz7VwfvNTk9r2rMzvk4G6EKptytzW1ui+8b25n3tR76MCI7h8aB7GL3XaKNs7rEpdADJAu8QFwITafuKPCkY9b9fRTrTZ/WLERR+UWIr/4A59vudutHNZXP+a6FQu9Xoht7qfOC3JL2TM8ZkeGDtr81G6bOvkoxQiMWb7YgipSpHBdW5KrS5BQCOQaI4rgvHz/UzYkN5vLJdMbpFwrWF5gaXD4pO3dM2PFgmYmJXfodqcWpz0WAwVrUIvSomyhlpQVn0GcBhTfQ9kR7ZMyKcWgpMVqZypB8H3XdqC3FO+13KF5q515nGbfBdYG7xdQO6UdslqgHLpFq+vZa25EKeq2LhVxZZBr3HXXXfYBEWfgEgcwIf3Hf/yHu11++MMfdlbD1772tQ5gsPTcc8899qQnPcmPA+BcffXVDmaw7r30pS/17byxNtbXv/51Z0O89957fSac7ViaoHqnXtDD43IJ4AKQ4bYXuneutT4X+XSmqmb076re4+vfoNQGamLnURv5TQ6yPpYVC6aYkQSWI/ULbINbyRw9sSkrwvjSgH29XLKnDWXtWfVp+1T5wgBJKLiAIxJWI1jpamKrw/0uIQCVEfsbyjVgCga6AS2iOiSq6aIIF+rq81m5jwWgQ/Y+WWtwreNY8mKtHj4z+o3sS4o7gjEPWu9Q8feCeVM3+HpDxBCpnKBG7b1dvwAaRvJDtievBWUdlAWgwcGR6uLoTBlxHBYvFpLFIgTxgpffKoT9WkDALUniwAMxBae2QI0XDhhR4jyOJyE7ZwMUYKw25oUES5aoF3VpK4YKy3XrWOZYVAM/p3Vq8H2dd9oEk56mdMjK5RzKjbIBYUnufco6rJNnqWO5tklcl84kGGlLtA1+0A69UZeou2MvcOV1Zty1ZL5D1TtnxYQjiwqs6MdzVqO44ItVAis1yYu1lXG7LjoJJPNaM0dU0slTT3T3sfrCZVY5/myto/NFxTk8qAfL8tA+cvNV9t/e+Eafzb/oBBFp0Mc+9o/2v//8W+z6zBOsueeATeaTtn9k1hZK8+5Kl0iIXU6K7lKjqNlizeJKEykUdtnsYsqGC1orpDwp5SBrk6Vh++ytWmS0OGpPueJ6y8sNb2bqhMDOrA3t0+x5LmXfPnGrndY6K0/cd6MVFKxdQ/nIJewr498RiKrYE3c/1TKKUVgS5XdjtGZfOv1VMWRJIVpFyhA2QC5JYrdKHfmknnrMxusxCCjqYhEMz+CzNDNv5fne66P0WpcKCnVIM7Ai4WIHrftP/dRP+YK/Dz30kL3rXe8yXCJRPn7pl37J45VwwxwaGmqDHcqHYvvkyZN2//33r4gtYzt5k1CASSi/WJ1gICR+iYR1iRgnLJjEsr1R45S01vpcfsCqN8WzCNY6q9qqfZvb0CRWZPoRYsgSW1rxIcsM362MUE/6Ucd7l8nZ5WTevtXcazY7bk8b2WXPXJixT5RP2HT+kCxJgbLaO4fzY4+DJbnQLQmkaPbAF4LNaAkAvmN9GdR6Q7s0ebArV3BXuofmp2xicVaVl8VG52CtAFw1RI6A9QcFntigsixJWAMgU2BhWJRAYpVwt8PiRLkeRySlHqa8rK5zylwvoegzBgEQkDiElqPQNZDzXeEEQ2g/Fi+sU0ld74C0BuQOqiMED7ms3AJx5awAZQQIVafoyKD+2KeiLH9QdwMIcSN0Zksma6rDWhtN1sOR7+kepVjSVnLXxNZ3rkFSL4AQ7DTbOzBmg+lBlw0gdVH3m+nqvO5HxEkFedB+gJSa44m8w4Vt2RBa4ZAD1y3tRrYQdYT1CM48i++qalie10H36bXaTlun7jsjF8uGDV82JjIMtS9o7spKapuDRLVrrfxWnnT+/cpiLWX86o/28OwhrX8FnH9tiWt0fktgWYs8v+sZ1y6WwEoJSHFOpEqWPfg5zWwvWHXiJq0Iv8eaD95iWVmS0sP3SiMNhveNz36sff4Dn7JXvuqV9hfv/wtjHaOLKc3NzdmVV11lT3vWM+1rn/2mfePL37aXvf7/1sM+Y//55X+xv/3LD4q2V+uaSAmD+aqOO5AUheHRXfaG/+NtdvSqR9r377zHPvDn77THPfVp9pinvsH2jZTtyddn7OSxb9mH/+r99uAP7ucU23tojz3vx59nj33q4+yuqXusXm3a33zwb+3k8VP2+re+TjEWrFqvOJPGpH34f37UFmZK9vL/9tb/n733AIzzqtKGz4w0fUa9WcVVbnK3Y8d2nGITp0JCCYFACkvYhCXA8mcJCcsusP/ywbJZysfPLpAsJQSyoaRASCNLYlKcOO69y7Ysq5fRjKaPpP95zqtXGsmSLNuyY8dzbUkzb7ntve+957nnnOdId9sC6bIekkxnK6QQxElR8GMAh75noVoirOInoS3a8Ic3JREFlfFJJvr8tLS0aGBe3jpv3jz1Ebr//vtViKQ26b/+6780V2qQGBOLwIa+QamJIIvBfWkix89mMo+b3xlfi+Z2TI888oj+pZaIedOcbtKkScqcSKIGmuMNF5+Lx4dLKtwOd/KkjvMZQACBiWZXpBiCa0Ds+VsBjDswbiB8jUGiMJOA/8zW7iKxdtTJiuwsuawnLH+Jt0nIDg3HOW5uxy6gkJmpRA2GBohkCUomAIGaZmQFzizJgfYoCjO5I/4mCOvwtyG4ATiioM4UBwEDCRcoz5KqmfdT6COjXbbDB6CVIWHQXCeppaJmBN+ZqLFSYEOgBQ1PJoLMnkhCpIDPuEisD2M7aRokVdJEVutIUzukfEc2SCVofkwzW4A2gFclXICAaukC8113DKCJpoW4hD+9SU319KBxgII+TQk5RukzRVdDBjW1uI+BNT4L/khlmJ8QVFrpv/srxbZp+3T+wnEOTWrC8c9MLMYDWnOEGsag6gFjIDVJiB8FU0IGw60LNiiJBdvGurPvzU2LVHBkPjt9rgAdXrtHCS/CiCdHMEuB/GwkHRsoimCNdeHPSInPxe6xw0wS/cLhMUQ1TfPBlG4bKctz9hyfITceDHNVTEdoewzgNYYxzXWN/1LHxjnbkHTFzoseSAOk8+IxpSs5ZA+oIN0ltsINWBjgONy8CIuER2L1l2KrDPbxubshSBgL/l0//wd57sHfy4TKiQoSisYVD5nlWBzkgk3NBgUmhwfBDjVxcedChx9IB/zESPTxKHaGIfw4ANpookPnZFIz08zDCYIAmuNwHzMWMRZpCuJYMVU4SsDcjeQBhWA+u2T1h+QL939dHv7uP8N/yHitrfA3mFE1Qz7+iVvUj2Dzus2yc/teufr6lVI2sULjrOSVWaXDcgCgJijtLX6JhCGkQEgryQUzFgTXX/z4e6h2htx65+fQxxZZu+YF+en//bnY4X9VtWyOBP1B6Qx2it8fUHM97k/Tz6AHJl+hjqD40Q+xuFMCDQuwCz4bWqJGaCJqQApRjSCyMLOxQltALZH2jdFTJ/N711+3nszlfdeSSKG5uVmp1XmQpnL8HovF1ByThAlmIsMhadg/97nPKfU7NUmmzxpJNyZORV76nwAAQABJREFUnKh+SqkEHOZx5hEIBNQ/iVoj+hiZu9SvvfaaXH/99TJ9+nQt6u///u81Lwpjw8XnMut0Zv9yjGLcwf/LVfoXjEmYV7rrxgwcmXXnOxC32qFJKhKbv14uzoapZmervAwhN2LLhfbBENLN68/FvxRe6feRCaY/M3ltbilx50gWWNmCsbAc6WgCo5xBApNhMrJhvFOwNYVfDSoLcz0m+pBRyAMOAPjAexgGtTjmCYIxjfeL4zSNJUCi9sAEZryXsjH7dajEsqiFikLg90DI5GaJwa5nbFTwvTeFa2qJCAgIMBzYsacQSlBBhkQmxoJqjbdLO8wj4z2INcS2pBSqpmEp31mW6Z/ItjGvZLzL0D5BeyQd8ANMZGEqgLkd5pDUVrBv+M6QRY8Ah/NhamEUlrNsPp1Ptd/YTm5kYPh04x6zXPYV71OAipOsI+ttJhOQ8HsXjvMc20mNOMs9awl11DlCq5vaq0PXgO3wFKLvcCmBs/kMU682x5n2xYmzTL31nPnM8eiwgaFTUWDvWMezdsHqwQkTVs6bUTyvGNZFrpvplO6B0+2B/ln9dHNK35/ugXekB7gkChz9t4BlKySxxqXYcfRIvHE5pAssmvkbsSj2iM1plxv+CUABcUOCLR19O4hjU+WBYknToXp59N4fy+wrF8qqe27sL4Lbply9AAhobjInd5q8+rs1snPnLvns/Z+RkooyiUWj8uhPHpXD+w7LZ79yjzRb/ZLT7ZNnf/knaYMz/z1f/gz8deAvFPPIE48+Jr6cAvnqtx6SHvdU5NsEgQnCBwUfCBmN4QYpHp+UqRVVkp3hk4C/Uw7sr5aFyy+S8nmTpBnmTfWxVuzeJtA/3L3GffRFQI/SQKap8Zg0NjXLh2/5hKy+9noIal1SMbFMfvnjH0pjXYNclLlYYqD2JWAjtSx9LvLteeKC7wKDXdLsJgPHnb5mKRi/S+oaxklXuAQ/FSDUmA8gVw/TrSOS4TvaS7DBJzn61ZvPsXbHYSkqLurv41F+Imi5+uqrlXqdGiACF/r/kHWO/kjUGN1xxx3qm0C6bzLQUWjhNf/5n/8pX/rSl1TTw2OTJk1SMznmwXsJoEjRTeY6JrIdLlq0SL73ve8NqB3zIiEE68I60FeKzIfMk2x5pP5mXC4zPtcDDzww4P4z+QVPFKDdInZ3BwTFbvjDAJRDEBvrxKcdtcIfScYBSTbI4iywmwVb5aUkTLEyyO0+9mWOfRvQCvynAMcArcUARzkAIC3wx6vxN4NIAb5beBe0LWgOwQEFVtUA9QriPMZ4SAwwm4jSxBBBV+0wtQMzXTIW1/szLQBIuJ/+MozBxDzsbrxr0B7xedFviIkaqKESd9uJgVRYxmfWmaCoJwP1hg9ika0ApBBhCaC+BGmaD69Doe3RDgieIGYA+OMGTztMBYNo35Bjgm3iWEnZ9CCIIUhiYo70y8LAUvpygvEM3yFoK0uxX4JNE/q69SbOKwQqNO+zIlAxtU6srynw62VoB1kDbdSioUz1J1KcgPaCYIZ05FofXoc+4vxIE7bUxPmK/cHE58hVpQftjABocdPqbCbW8WQSn2FnEyjdoYF0F3jQFyNoefnMzYaeTCHnwLWsN8eQvkop9eHzYuK86cVzJFV8RxSm3WcT1KbUJ/3x3dMDaYD07nmWF3hLIKBn78UsCZ+UhstBeZot0RbE2oCvjaP4TdVUUIiwAyjll8P3YaySbtthVxXmIbplCfBzbHeN5l46vVxyS/OHLInR4scVlEpObg6EckSO9/jE4/VIc2OjBNo7ZcbsmTJh2mSJBQ9JcWYBgFCWajdKAaJsWRAeIwmQL2DnFP4bDtC6Rmyw37dCmAUY7IbJTob9qLS7tsqBo20QahyyKB8xlrDjTHknDkFnf3O1bK3bJTYEsJycNUGQi9azGyYzNkczFhsHCARK4VeTK399+QUpQLynqtlLoF2ZKQ986wHsRMekPdQCV20uuCwTTuaRmFQWlCPoZLcK9XE6PkPIsNoCYsmpxi7fZhReoKxoCRBrJAKTJRmYJJa2gNh8B8VesAltwM7vcSZ2xgLYJ8H09uiuNYb2SHfWh+zl4Q9WVVXJvffeq/Ta3G2mbxFZ55ho9rZu3TrV7FDYWrVqlZI28BypwQlsHn74YV2Qf/7zn2sQUAYXJiPetGnTYM5ok8985jNK202iBjLV8Sc1VhavZT6f/vSn5dprr4X/V1S1UKQBZzqV+Fx64xj9skHIoBCru/XofhvM4Ug3HcXuLEXIsUwUB6MWl+xFPKQp4Xr47ORARo5LPANC9BiXNZb1Hiovxu4JwPeFBAtNwXbtMwaJpUxqajJ4HwV8pdJGV0IXpGOJAIlMckkN/gp/H4AgvrCU8ygEq2YJ93XxvcJ9nMsYfJaZ0xSPpkf0EQqBLCUVJPGdp9+GEqrYfQrijE0UA2hQIHeAmc8Fv7BsC8zS4CvVzHcbeeHNhmYGAAOVaIHPYU93m9aXefbiieO6gedUM8MPWjtDW25eSIHWASCZ5ckSfyIgHfGgJAGKGG5AfUepUVZ2O4jEKJvxpujn1Z3BDSb0F7Qk7D8TJLGtTaFW9S0is14PTM34jwI1E03uoNDGA+gFVjjMZ0LQRK2D5oNBSN8k9pMdGzyMU0WWQWrcMGv25aUZnmO/WP8k1gNlIeyGOSSbbXT9gJryOZt9NuDEefKFz5S+eDQPNcH28VU3NIbaziH64Pjr00fSPTB8D6QB0vB9kz5znvUAmewy4EzuhFlQHCCpK5ovifaZaEWGOIoAkkzflzFrF6ZsaKliDZeCPS8o9pxd8NNolZajoKVGyoW/Dm3c+1KvRMHJm4uzyg8ANO2t7fLtr/4HFi8EYYzHJBfsaNfdfB38dRD2sS0sYNKFqYiIv80vz/7mWZjeOeXokVrZvnkH/I5WSMGEhOwLvCm+HgQmBSAh7XmPBRTC2GlV0xaIuaawYNSFUJHaHYq//YIGz1msDDZ4VDqcdTIld4Xc+snPyuOPPiQ/fPBfpASBVBcuuURWXnOtuHKLZBvqMDUfFUPFG2rr5V//AcJ9bxt11xfCR+WMKcwVC7axq2l1toC2uwnmj9skGS7D85mLv0XwIZsDExsf/Mf4nLCLTJCEttDJuxukEszCwuNMvXntfMUgQVD/C+PMsL+HiktFjQx9jhgLKTV4LwHOT3/6U9UEsR1er7cvXwIgMt/RHK+wsB9oU+AiGx1Z6txut4Ik3kRTPRUW+3IY+IFmdfyhHxlBmplGG5/LvH6s/lII4aig5o//+J19z/g1PmgPKJyE4jD3BBAYq0Q5BiNWXDCPsWf2SBOc6hNWjGWWfR4l9heJFZpCABL4x+8cS6lJ+1MP8CwSfikIxevBvxxHdoAemt0m4VtHUzo8DIApnAUIMgRcvLtgLWMcJmZgQwwlD3yWKNSbwEd9a3CW4Itxloo9eZLnACECxnOMJBC94IXl03SW8xGBBwGDA/HScjOyJQ6QQlMlXqtABSbDShTRxaeFf2YebEdKojka5zL+Yn2tvdojo+68kLDLmBdpGhfuAqDjPAmQZIFptHaK0Tu8GAAJVPM6jxrjQbVBxnSi5/mL/V4XaJQiR754AKzJvkcNkNNiBODNQB+yL1ITQSdpz02fJhJreDJheoh5kSaGUczF2paUuqTen/rZmM/ZT0abU8+d6c/cnMoqz9VnolUd6rXhOEO7RtGUM13dU86fbww3IKLw2yMb4uDE8xwHnbpBMPBZD742/T3dA6PpgTRAGk0vpa85f3oAwjP9XJzlf5YEzOzigQkQwqdB1ob1/Lg1WCC4lcjVeywS84FZTNwn3Z0VkuyYApOxBmmtNoKAFozPh4BAnxysWPpjlEmxMwGhoRuTOYUPL8yrPvqJm6SgpBh+QG3y4jMvylOPPiV/d/+nZVxWsWTGIWTAtCQUCsu6tethJgjtTVtQVl1/hXz4kzdLdfCoNEfapMSZqq06nTbCLM6NIKPeVlm89FKZWDlXdmx5Qzatf13+9/ln8HmLfOqer8gU33zp9LeibZmSnZst19ywWrJ82WgqTLKgEXn9lTdUszSgp1U7hIUaGrcM7xHpBoNVV7gQQgocvqFN6gJjmqPkDZiJdCqA6uIxEAUQLGW4G6Al3Ie/dfCPisrhzQekZGqZ1Ow/onTcpxKTikJbKjhKravpZ5R6zPycCo7MY/xLYHMqKRUcpd4/Uh3M69gGCrBjlXRUY3xS4OgX6JE7TjBGj80BCmoIKfTNGCsQw5KcEGCdMLcLgHY+meHEmzWUpDd0K1lP1vedTmYd9G9vdcy68TnR75A+PWxZDH1IgoPBtbZAmCeoyVSNEs5nAhCZ4Ag3UqOizxz5UeilFpimbjH4AjmhmfF0uzCvwDcTwMKOuE00U6PZUSbMk2z4TFecKLRQcYAwaqV4L/NjRQxBH2EUoDF0AxBnAnwZdWSL8I9lAqzxOoKpIUESztngK2m1GWOSgIMbNTHMd5nsA/wj8CD4ssN/hNp00pljpgRYoyb++GQGriWIUx8i/E3ViKgGG+QwTV2tUgTFYwdMAiPQhhc487TPCX7i0Agdl7TZGH3oV45txqwik2A4EVITLfPZmfexvfzHzmKX8SPboqZ/OMfne7YTn0kiYviBZTgxNoabCljf8zxxDJJkhO8Qx2bq/EMNdxg0+kkC9PO8nenqnxs9cPbf5nOj3elavJt7ACDJYusQ27hXoIhYKgk4ABMoWT2V0FzswOI+RsOe6yRWSGsmo9hDWAAISwTHS8thg3Y613uDZDKQIwQXCgM9MAXRO3Cfxc1dVhU5YN5ik2mzp0vOeCzmycnwNWqT5558Xo4eOip5MwAegOmgaIIGp1i+8LUvqHDy0HcekqOHj0oImgfu6nJRH6tEYaIyZ6L4a+tkz9GNMmvuSllx+fWyZPlq2fDmy/KLh74PoPZnueljfwdyBhJLCECeV5ZduUos2RC8IOx4kk7Zu3MvNCqkNR4qYRXHc+jpoi8Cd8bZSJgPQZsUqb0Kwg/aFIMWgaozgCP8UrPJrlApYmC9JLtfe0YFpaor5kkBNDnV1dUybhz8WC7AtG/fPnHn92u5TrcLuAuujtC9AuDg/KgR8DBuFp5XkBTKg8YeNSEqcA++cYTvjF7jseC9weMOYjz3UAjHO8Ndf74lqmUZRuqhwErNCU/3aUZGKOtsnkIXiR1EFA44kVOgo7kaTbbC1MKNIMhREKfGqM+fROca1Bz5maZ6bDf7PowdcwIWxi1ywHeL0j61qqQcV60BbuOmBbUiGvcMPk1kVaSWKhMaLoIoG+rHvGOoF9nA6AvlgobKgbrzeXuhWenEM++g3xHeRx7LxDhRkISy+4CS1huACOCOz411JGgggI8zb3SIB+dovocjoAq3I2aaVzrh9zSaOayvPSgzNfE4metiMP2t62zQccA5tynSIjnuLO0HC+YSw1wu9U7jswvO/2QNdMK0mBqtzEQm6mpQe5vji++EEwCKJnhsE8eaP+SHH1Wsr/18DmacrONLOTNH+L52NsIHCSaZWRPyoaHH+jawe85Mwe9QrhxznQBCPhs3Dvgc+B1BDgCQmDgPpFO6B8aiB8ZIUhyLqqTzSPfAGPYANBUWmNTZERdJGe7aZkGTNF0y4esCXlkUNAbTKLKwZAagrXoBsTzKpCswBbbgxdLWcEC8OeOgAZkl0YwjKvR3JaBZAIDiugWxQhyIT2Qtq9NaYJ0FAIKJkcUpHbD/r6upxYJuEQcEF0IDw5qEu8WgD3a7xEtK5Csvk189/Gt5669vyWU3rIKQ1HmccNgNSt4u7PJ3Q3jEfu/xrj0jdTcK3rVtlzz+s8fl9rvD8p5rPyoZXXbJySlR4SgO8xPuRJOVi6sx45qEA3apDgEUJdtkSdZctHekAtBm+BvZ8jbqRYlguebDDumBqZ1q3YgKrQaoNFZ8gKSkC8+xSnatMXx1CJCKJo2TFStWKM32YJOmkWtw/p8lVfltd9wuN37tY2PSGAOyU8tAgDK8lEXBn0xohe58CP+I1YOxSTBD4aUNQmNbtB314dg4caLuh9oiH8ZrAiZR8KRTk74Cd7bkuRGnC0J5S7hNheqhcit2F8jUvIkalLUmWCeH/EchLDHm11BXn71jFKxVqIYPoBNCNRPNueLweYtB24HTJ06DrtHng76mySO1Mgn0GQENBfNOgFUHQE0+/BXdIBtJADzFcQ4PEgIkQruiH1k2wQ8BhcMNYAQ/piLED6rMnqAao+bOFmmCGWwU9ctF/5d4C9W0MgiNih/Bno+FGmR7yx4JRjoNvymAOIJaalHMxDrSJJCAzQ4gwXAD5qOgDwlNARm7huPLDY0hYyM5ANRIoGMCYjOvof6y7uxb/Y/+ZHn8Ty0b60K/QRrxcURSKxUEvTo1Q/xhv6eazXHcKkU4TLZolsdxw3vdAEwEtXGYI3Iaoh8Ty+GY9yDWEjJRAg2bKxNkOE163Ujvy1DtGKtjfPaeQh/GAP090QeDxsxYlXOu5MPNFwZV9ncHAezt+rwJ/s0xdq7UM12P878H0gDp/H+G6RYM1wMQ2imE2wvXqRlconOCJIMwg8vZgUVkjIY+V0/EYyJBRGbWQenpcIPeukEqZiyFkBBB2QAA0I50x/LAFgcWNzA1dUXgu5KAIzp2Hkl20NzYIt//5g+VOrszDEGkuVWWv+dSMMaVy8FwreT1ZCn1dxxCThxO8k1gnpu/dJ68tuYNeeHpl2TukvlSmQdCBz92aHFND5BLF8BMrBWas5Y8BHqE2OEhcxMYsrB7zF3nAYsJmkChgeeSEJ5oUuNPBuTiS5fI1i3b5df//WtZ9/rbEGI8cuRwtXh8Hrl4+WXSGoiBxhsgDItVnPcm7BJomivWvPVoM/JDXZRud7gFG31ndcMc0vkXscJXLNE+D88JzGXsU9ZwyPsQF6a5RA68tVcJMEoqy4Q/7/nkdbLw4kVy5+2f1OCt75SwMtxQHOvjZLhze9zyta9+TW75xidl2rKqExahQiX6lc/e1PAM1U/UDpCB8ESJWqSq7ErpqPdLQ32jajxKxhXIzLIpiJFVLXvbqo1n2JsVd9yp5+FjNQKLElgboqwFwqlHIMSLTxDWWAkFZmdPlYwQQABAGK8/Bh8THRbIQLPEL9Y1z5kj/upWkCLExDspRxkiI6CyZkFsremXo+3hsVG07URtH/X53rL0/YIQl4AArj5AJB0gqGAbhrWJGlgKWSJpjkaAQe0dTYm6sJPOzQ8K+vSnsYB5kDHPCMwiNOGDZlvNz2DySid+LY8AA0Gd/T2d4sE8UeicIMWufDBPwvcIfkrT8icPKJjPiCEDfGDCnOytkHJHkaxv2Co1wWN4XmCXA5AwNTt9N2LuVdIDCLBMHHs05eMPCSwIpNlsAqJumCGjCL3GGJ19uRz3gddxfmB7h0omSCJo6IrAp4+bLc42jYNEzY8Cf5grM9GfjoF4bWgbU6omlFdwzLlg6siaUfPERG19DKZ7VvphoR6MA8XnmPoe8fPZHGMsz4Y4SBdS4tPnfBLFWOKYGXo0XEg9km7rmeiBMZISz0TV0nmme2AseoASSBKaip3Q8pRDCJ8xtlokrSLKUOIAmFw079EjhZUghih5zVj0Ub4VflFW0FrburcpsYOjZxyY5ibJvEUL4ZQNUID1lyY1DmeuTKqcInMunii10SY5FqyXsvwiWYLArMFAJ8xhnFIdOCSTPKVy820fkk1vbJZQW0hKy0olkAgCWK0ANqEpCIRKAJ0MdzvIHuJw6gYLXdU0pfEuKCqQlu5ewgPUlrJGfkGBXPXe1WDOm6g7kQfaj4inwCWfu+8z8jbA0e6tu1U4uOKqq+GXtFKy8itl3d6oTCmyydJLlknH7CqxOzwSCSC4JYQfe3FULl6xUG3C7U7sagapCTKEDO0g81cvoQRp2kmwwedDU8Uhr+29Z/+bfwYQjMuslQvMXGTl3ddJ7c7D8sKmv0Iwop/ZwMQFlMxsFkhldORNZfkaeOX58e3ItoMyacl0uefRB2TcNGrfhk4UTE3xgWZBZOmywWyKJAzhZATUzf19xWsprGsgz1GIHFbkR+KQR3/yS2lqapJxpaXS0NAg8y+aL++74/2qOchzwmwJu/MRCDI1iKsVhpajMneS+FxeAPaEtIcRewumMeVOt0ywzMQYypIJrjaphRagvaVd3nz2dZmzAmyUZWAywz+afI3PLpXS7HGqnaAfFFojGw+tl9a6Frmk4lJZUDILeUY0wCrpm3NcWegcC7RQrXKovRaxiTrPigDLfueuPgFBCMIcTchU1CZVNQR4CvnDCfocp/Sz4B00WWWixsjUHLEvjLfJ+E3B34V5hFqSMILBUqObBJsbpPjeVwllQaDHloyE8TsKcyw7tCLjfQVSgD7PwIYGzfAUQeE3NVNhsPGRZQ6cbpKV4UWsJ4ACtGESQJKr1CWv170tB+H/OBTeJGgI4X6202WHJhztpykUh5WaBIOSGnx7AEd4pkk7NFb9vkcmoE0FHWwsASJBDn1QCGZMcgX2DRPBMiEXQVEcMfGS2JByFIDIxd2C4+hHaI9M4MLYOQSbxwE7ZtSbzD7m+8BxB+87BUb6XFHvtpihKeXGk5kUHI3i3TGvH4u/jO/krwG7IJ6prwxBlh3nthbJHLnsx9NNY5HH6dYhff+7twfSAOnd+2zTLTN7AAs7g15memugQZqEn8nwRdqJxXvsh39rDRdjAA74E1ldTSqgUFjRRF8bLNT0j0pag3IUGpbpy2fK9Eu4+09BBwsbfHJiAC/b2/fK4UCdCqxNiTZZcNViXIFFGQJlPeLFdELImz+9Sq6fWa5mMzua9ip977L3LtcdzabQPkmijU6aiGA3ualnvFTOmyjlCyZCcIxIfUsj6gIjFMgTrTCHKissltW3X6NapsMdRyFEhmR94w6ZljtRFl25WBavXqZ1pCaspTFP1mwNSWvIJkU5Tpk8+4MQrqwSRDylOII/RiITZP9hkekXVWpd6lrrEYMJTHQI5qt06CqMGT4jyBSJ/YOdfmezOMY1G10xwtp5YNtjeteslfP0r/mrfBbah5/h0tne2R2uHmfyeKrwwS4kKOQPTZ0oYPKZ63OHwEpneQrMqYnnlBAAf828Us8P/kxBlf5nK1ZfKu+57kp5A8QcTz/2hNwYep/My5sqG9ZtlF1bd8lUgPNlyxfreDiwr1rWrv0rCD18snL1SskDwceOrZvlpbpjEJnr8T4sQNyuJrBQQoiGRtPYoQdFP9oxI3+KFIKtcccr2+VYzTGZM3eOLFiM6wHE/KC6d8NXJnQkIHEEPJ43d7a0InbYqy+9Bk1KN+J/LZTZBdNkZ8s+xPoxQBLzj3ZGDMrtwY0bo+9mPxIsUJvDRMFcA5eaZRDL4B+6Hf9J241nBpIDgkj6VnDsduH9sdgMnx5qURIAkaT05jkbQKgFgjpgIfwC/fAlAtU/AJUn0wOxPgPa3LiELVEE5kX8JAS25TPOBjCq8Jbgbx4KNRjxWB3Wg3GC6MND3yMHzB6t8N8x28E20O8mAc2PFdoqgrmhEqpl1A8n7SCSGJhQBi4IRIKSEYfGkva6vYl+PiyLbGV89uwPzo5uAMBid6GaWrbHOtT0kuOP/wh82N4k6tYDtkuL3Y+NJ5gxew/jXL9JNfuKidsG2tn6behfZAfkZgL9kqhN6sIYMp9R6yBwpM8Tz5Qmfqzv6SX2Betp1PVEebFNhs8XyjZvPdFNZ/k8W8JeIZDXvkJHMQyEPruzXJd0cekeGG0PDJ61Rntf+rp0D5xXPWCBL4std7ckO8f3apGqMVvTD+B0F7OB3dBaCwEfKb+8CIILAAgWeIN+1+DkYtBBmrBx7dvdWi372g7r9XTY5g4/11iaoaiWgwsfVrwtTbtkW69mihe74fPBXdj1DVsA8oCpkBkFFshMIoovjN1q7tpmYIEnVfaRQL0c6ajX+rBOTDSBYWqNdMiao+tQFr+zbARuxLkEhLPtzXshUB6AwEZBCO2BE3iw9iKJIoYRxZa39qBQCCDqiqS5GfXftF9k80EshhDOrDIeC3cp/LUg6NnaxYnnYM86grogB9TR3NUd4CTFtgyRKNDufX2nePN8Uj574hBXDH+or5zhLxnhDNuJ02M8XkYo8JRO8bnRZIgCKYVsCnZ8CkymgMu/KqxQKE3iE56BmXiO44/BOEeT2KcUvqsRgDj7zQ0AOttVm5kN/5U3/rJWXnz2eamaN1v++uIrEm8Py8xZM+X3v/yNTJ05Deaah+XRH/9SPnH77fIU6OtbG+vkAx+9Ae8Ayu7tZ0PDYoC1XBdi9MRt8r/PvSQtzS1gTsyRF555DmQeSWhOwPqGl2fT2xtkD3znLl26QpqPNctTTz4NgEGTrm6p/02tXHHjlVKcXyjN8N16/j+ekMZ9x6QWZCiTpk0ZTXNP45rB/Zk67xx/Ts+mXGK+J6nCN5/V4OPGMVZzYJ4ERKSSL587Sa6770Ni94IaHCaz2WC+dABEUaOahKaK1/GH2hX+ENTRrDcJjZKZSBwR6olIZ3ek/901Tw7xl5rKeBdiPPXOO+YlbB5rSXM7DkgDZECLDoDEOYqaM2OmMl49OwCLFXOUE2N7nK0Y5oDZYDwM6HxK7VeIDGbQiHLM2PK36Bg3ykrpyN7C6VtEHyMbTK3NeYF9yRplYB4m0HYoMDKAYRKEFspUh0m2A2W2RdqNeRJ9xfuH0wT2Fjf6P5zEE+h3bDhZMkHwAxBqtH74LPiMfCVgD0UzqeEb9OiHv/EsnaFGUP3MMDdR68w1jZVMZBLgA7RjLTvnKn2W+iZdzLndA2mAdG4/n3TtxqoHsHpkQItkgxYpDg1SsgOEDXnbsPZgQcJiNFap9agBkPIqCtRpfDp2vEuzCrCwG9S+YTgMH2yrkZrAMS2SZjc0A5oOTc2EnDIVDii+xmFycrj9mFTD4ZwmHNw9nV9YJfneXMT2sIkfkexrw40QJIxFnVuXRa4cycGuMOOXkKXqYOAw2meVmblTxO1wKVMUQVIojkC0BZVGsETc39rZJjta90KQhCkiFrBZ8EEozynVdZkOz4f9x+Cg7cfu+3Q4gTvEMh4mHc2MOYFYFCg+BJO2HYcRnwLKiMIsi0yrgJAO4ZwO4Qfqu6TZT7ENrFddXplSnC0VRaXiK6iTYJIO3/tRr1CfkHKi51C9Ya/u+C/5IEwJIZic+YQGQuPFMdKT8KJMCCzDUBGf+boMXQJ7l/o4UiZ7NbgrxWgDVPAOnk9NFATpB0OH+VRwxHsomKpdP/rWrf4XqXcO/Ky9z+ffGZaDr66TmoNHpLmpWS65dDmeUVQ2vLFexk+eKAsuXqCO1Fs2b5PLr1wpH7ntFmlrb0Xg47jU7T8q0UhUSkoK5f3XLZMrrlou649slo5ulI+gpX0JdSZwJ3HJ5VddAS1mizQ2Nkr90Trxt/slC8QE2zZs1ThiV914tVx67RXy/FPPSxPiVa2A2SnfoY2oz9GDNSAGyJZvrL5P7v2He+Xbf/q2vgd95byLP3BOuBuBif915Rfln9Z8RwIQwAMATcGeoL7rBEYEKUwGWGBsaTLf9ZuQ8XwXQUIS98FcUsfPid5DjBE60Zv5UgPF/M0yjBPGOOWYI8jXrRWWBVM8NaVDGR3RTmjJEVQb4IUbTU5c67JxI6oHWnUQJWjcImrYqCkdOXHepGDO+Y5J66PzH94hBNPlu8T3hsfZfg0+i3YHENS2GeCI5A8aABjdZbxrmot+1gxP41cP/MJ6EO5AMghA+/t+uCwJzkItMJlGPR15ngHauOHuOVvH2X92aBnd0HAasMh4ziyfm27ZMN2kv2AoBrPQQfPU2apjupx0DwzXA2mANFzPpI+/+3oA5iWZubskgZhF0abFYo8VYKdxE8wx2jBrj82rYAKkCZMnyLJS+E5EM+X1P70uR/YeUaf6eUvnykLsqHsBeKiZsWMXk8Cn1F4km9Zy93s/Ar73yNxFC2TxsoUyKWe8HGg/DD+BXCmSHHn5qVekDHTWc5ctkDpQ2JKpjjoCChV5jhw5tAPO8bv2yaprV0qpt1iDerrjdnnpD3+WcRVlMn3xDGkOwWm5vlPWQajNycmW5Vcul3ZfUA6inDzs/Fd6J8imNRvlWF29zJgzXabMHo8gjE7JBNBZs+Zl9f/phnmiHQJKWcVEaAWWSq4nV97YHZeJRRbJ7jkob736ksxftFKqKqpkTTucmiGxeNw9Mmc8ANf+t2TrG3vlkiuXypS88bK5fhfg04lEGmM47nxlq36oWjn/rIzPni7ElAEzIck9eqA9cxStx84uBcOxA9Wn2xAKaBRc6VBO0VIFuyGEDQorZOoiMCJA4n2DE49xpz8C2lyepcA6EF7138FyCDyyYCK3YvVlctUNV8nOLTvkyV89IVu3bZUgKN6P1teqLxGDn9IU7ljNUfndI49LfnGR0lBnQhBVARP1j8I3rKd9F4IGvy2xLPqXGfUjeyPHGlzu4WfRJeteeUsO7N4npRPK9F4GAU3C/4KAiWZnJDMhGUIkGpa62mPyyguvwLcPZASFRVI6vkz++wcPyWc//zn5zn98p78xF8Anl8slv3zkEWlsapS1v/4LTGrfK62Y+4os8FsBOHLifCoLZB84wLgxE7UVeFRgvZuovkB7MWcEwaBpxQYUBXX+GykRHJEMhrTfplkdYxyp1gebKhSamRykRMeGTwggjGORY5Ia7eZIKwgJoIXAv3gE/mdOh/ovdcZAP456nqh8s27EdMyTZoR8Z6hld2Z4xA5zQmAfgECYD2Jcsb7dvSCtI9kprTGsFQBK2l8Yk4ydxFJBoq4mY9Tsn15iX6NcbMZYna3IeaAJ7FB5c6Mojg2JLvqVZcGfFQyCw760Q2VwBo+xbgShfC6DARBbyuOq4eaw6R9mZ7BG6azTPTD6HhgbqXD05aWvTPfAmPQAFzfumhvCoCFKnZANCkJthgvBRn210CBNgsnPVFBxF4ujcLNkZO1FvTBDn6bgSxM7b36WXDR+PgLVxuQH3/v/pO7oMeykj5cwAr2++r+vyTUfukqu/8j71A/Cg2CMBQA+D3//Iey4b5IJUyZgIzApr778hiy7fJn87WfvhHZpsjo8+9sC8qcnnpOFC+bK3OX9AiQ7lCZ5MQi+O7bslGexcz5/CfxzSgxh2e/vkD/9/jm56JLFMvPiKrX7rtt3WJ567A/YefdJcUWpVMwaByf6Y9BC5YOmvE0ef+S30t7aAfOlhJTPmaD9XN/QKH/63Z/AOudUvxGa3jTDkX7ajCr51N99WeZNKlbfhxrEZ3rqt7+THAhRExbM6l33LFKYjeUeDHy/f/yXUn2gGpTlWbL42otkT+aBYQX21MFCgW3Pq9vE6XXJpIVTU0+dgc8YWd0OSfpngA1wESRzLPTQPtJ/7HTHyFhW1hAysBtLgRLC5WAhJLUsamAYP4R+GycSJPW9ShGMzXyM++hwT2d7sM71ahhonhWB309He0CioZi4HE6pwJifluuWj3/qVvFjLEVbO2Xvtt1ihQ/MJz73N7L5rU3y2tFXtc4060sgTzs2MSZ4fFIDDUWPFOvuvcNiB7PaNHEheGz9gVrxN7bK0pXLZA7eg6cfe6q3PSJXXL0K/lAe2Q/wtP3NLVJaUCIzZ8+U1TdeI1OmTlLtVg9cbfZt2i0Pv/Qjs0kX3N9/++a35M577wJxRlgOd9ZKka9QxjkKoa0Y2BXq30OTrZTEcUEwUeYulnLvOFlY2CLbWvfIHjAWBgBSMCmPOLYI5Ak4OMc53IgnBHpvgiPO3QT4DGbLxPmd8aOy4SNFsogmEGyQojsKLVGTpVVKPEWqRYpHY9IF82m+B0zMa8iECzh/oHKqeeZntpfiuR1BcR2Ix0RzYB7R6/QTrA4A3pg64PPkj3coqYSa1OFmMyYSQVaUQXdR57FI3V02zLuFyvBJLdKJEkFcVlmO9oG23+yME914Fs7zuVKjp+NmiPLUCgDjSSeUYR7dELelD6V74Kz0QBognZVuThcy1j0wMbtM2hEtnTt4XodXAy+2RNr6Frdhy4MAZsvZBY1AOS7Bzl8cKv5jK8QOhjvG5LE6WpGHsVAOm8cwJxLRuASbO6Ry4XTJtfrksacek1aYHP0/X/28zF4wWzrBQvfbX/xOnvv98zIVmpkZM6ZQEpC1f14rm9ZtlVv+5iPy4Y98CIJLHL4VL8hj2GmvmFAu77/lRjnWEcMeJfyoEPyRMTn6k2EWFUFwQzq80hGf1+jC03sRhVoKIjbEyFDxAwsoGfO4q5+A/8aWtzbKh+d9BEJHgRTDYXvzzs0QaP3iAmMer9PUK1g4cezK698jH/j4B2DGF5VXX3hZfvfLp2TLtrUyac5NMJsyYqzYENvE3CHm/QzPUZorUluzXxqhmcovyJfN6zfLxZddA8frIhBS1MA2feTpqGZbtXS2BWX+dUv6BBfuaDOpQM/PqCe1afx7egm9Zo0pfXs3WPWS/ulicbRrTK1+3MCyT7ug06smWs72UhNpbhgMlyGd6XnNaMQ4jhnD3IrtQ++i0TRJ4hgjGCM44nkKkF0QDp/+9VPy2p9fVdPO5ZddIksB7p1ZbvnZQz+TzW9uFK8vS669+iqZNnOG/PHZZ+WBu+9Dva1SkFcE4TIuvqwc9LcT4KpJCuD/VB73S9Jhl4a6Rnn0P38B4JMl+fl5svKKlVJeVqblPfubZxRATagYj/ENGmpcc/HlF8MMzwkN1jZZuWqVlNWOk59850c4nyGVU6fKpddfpu8GtSkXavJ4PBrDx+V1S6slIOs7t8t8V5VMd05WkM1+ITiiaRn/piaOA8MUD3MJwMg4b5EUewqlBOQJf61Zp6x3+v6l3mR+BqigaRzfGpIKcE4y5wgK0uqb0ovSCDbCXWEFTtTQmKCFrxtNclsz2lVj3hUGaMLcd6IgsybYYz4cK5wfqW20gAjDZXXBitYowwpnygz4OLFtCUToJktiECbJJMUhaDM2CKikIcNgt8ZYioFMgvkaIOB05wO8d6qhRicBKBnzywnmGRTZTcZC1MeCAMHnSmJ/8B3nvJ7aK3y2nIt4jNqlSA/M61IvOFcakK7HBd8D587bdME/inQHjLYHuEjN8sCHpgALGf51tgbFW5wl6xq3SF0IdNo6+Q4z40JDpIx2Pvj2BCZh/TFsvGP+ShA4FIsdtLCZOaDqhh+PQd092lqB7ADaI6bSiWUSRJ327tgns+bPkqlzp8tb9djR9oAp7r1XKejIAAjLhq17Z0dItm7YLuPKSmQpTM52Bw5isbXIpSsvkTcQ52gz/CqugU8Fbe8Dgh3a41KPUhonsZifWFhHz0EA6KFPDRJt6MunlMueHXvRhwGZWzxDujqTsvlt1HX8OPiGgFRBxRm9XH/pogazFi9iIVE4zsrJVUHZZkeQSh+Y8SJY1FNXO6zbvCfPZ5Gi7Lg88cybkpOXD2rwS2XNX/4stXDULx8/Bz5ZjSiJZl/GDnJ/if2fdpnmdZcPZK+jcKK03SwLZSfh/Ettyukn9BeEFXveVsl0+JE5hLtefyQjb7SMbbWiP1PbfPoFjzoHvgvKeHYC7REzpEhC4ZZanxMlyqm9cLrvUjYxFCUQh4khnhbfPVehW+78wt8q+OeD9mX5oKG1y5a23ZI9rUC+8s1/AiBuFB80lTlFuQgQmpAH/s+XoZ1sh2leLiikvZIPGu7iinLE5WmWncGNMq07LuUQrFqzbPKZ++6RcAR00RRssRlSWlwMCvy5Mg8U8izP6XZLtturADEAHxUyxC9fvUJABSlZ3ix5/5QPyUUrL9Y4XbnFedKEIMYaSBT5XahJwQKEVDrOu/ATA8FLY7hZJvhKlc6a/TNUH1HLx3FBYEyNIa/hZ47BXGuWFNhzFSCl9msqaMCtarJmc0Db6TDmbvO8CTD4VzU0yJPEGjE48XeBtKN3H8TIGhn5QSzDzTEPfO66AjCvg+klFUCpG0Op9SAQ07mMr2pvGRTUaYrJMWkFQLLANI3mmlHENvKHA9C2hmBCyqCzxiTGdpqpCxr7IJ0ukcw2pJ43rzvpv3jJrI4OsWcfwASN/GnRcAI/JD6DjvpWjXOVBfbUTCfmvnNgeLM/OC+TpIPEQgRFEbAuhgE6CUBJgkGK/zCOpVO6B87FHhgLKeJcbFe6Tu/iHuAC/93/8335l29/Tfbt3is//s5P5Ovf+ZoKxWRiYwBL7H3q7l//ktbfIcpol0NGuwpjAcJqYgEg6oZjbLRhuWQioKwDwWUtiChvmFMNlUt/fuantl6AVIYAr+1wHI8BYBSNK5JO7IQegxNxJxaChaWz5cN/9xElMGjqbBUoKSAstkkxfDIy3TbZegxaLCwsS3Lnq5alBgxbnR1BceRyx3vgqgeogwUI5AgQcGjGMHwy7uuBENAVd0tmrAyMTM0aUHLuonny5v++ASrmvXIl/Ja27QZ98qFauezqy2TdX9dDohlYJoUWmkYF2jukszMEcLVH5i6GX9Xy+VLftQM+XRCe6kmr259o9lEM7VHQ3yB7dm2VOQuXyOLlq+X1V1+RLevXyg2TPi1ZsSUScb+tOCPVKbw/F5Fdf90qFK4ql87sO8y8+U93oiH8UOhRYatXCOq78JQ/IHeQMmQgELCOBdAd63MAHXsC5ndkRcyEMGPPAW28En6MbqyccnVSbqRgxrg4jA1DsKKCXMr51I/sI8Y+4vM7Uert0V5zJeP5U/B0gBwkYUMcGgg4PBpMhGRj8w7xQYNrQeBRpmS4Tjrbg8ooRgE8350rrnynNHTDROkwYpHBZ67Qmye2bLscg5Yo2pkt3e0TxFlwQKKZTWKF4DvOlpBcBPB8u+ktOK5NQN694xf572s6osKVEyZ8TNSAdkW4I40Nd8wLFMDIdOaCU3g8CMEX7aYQneGwykF/nbQj/5H6iXnu379fnn/+eVmyZIksXbqUhwaktrY2eeyxx+Szn/2sHn/uuec0DlTqRWXQcq1evbrvEO956qmn5M477+w79uSTT+Id6o9Htnz5cilFLKnf/va3fdeYHy655BKZCg3Ypk2bZMcOBLruTbz+yiuvNL/q3zfeeEOiCAz7nve8Z8DxwV/C8O2hVtCDvqb5YgaCn8YBTnWzAReb/cTxwHeK2h9qoTMAWMIwp+zC3MBNFm5I+TLckm/PkZoQgsfiHeR8RDY43AVtIzabkPhuZkJrrTnjXpZjpb8Mnh3PdaEMM9wptTMuoN3x3jKpjTXg20BQz7rR7K4U/khupxex10LIz4iPNJwGy05zPmRD/ztqQFEqSCAcoD6Hvx00STS/DEADTlNBapdMcgi2f3AyyHGMo0OdH3z9yXznBpkVpuDcgmAdtYNGyIDPxgVyBgJY7c+BU/YId575U+wnsguSNZBatxi0xXx2UE7iGYSH6Nnj66TNQT5MBIMYjBgvxujkez/W/X98DdJHLtQeSAOkC/XJn8ft5oKwCQQDtbW1sm39NqmYVCHuXCwQnV1KMkChkUEJEwAPQwrbWIAyGLTVe0gSYLNTbRGFW/4gETh1RUB/q9qk3TiOeBwQjDkRD2vjjvtaagwNUgkAEsvnFJ4BgYAghoJCRzQge9sPYrcbNLbctYQWqSiWrSZKDgeCKaKMeLAQG6EuSWZB6ONaAIE2DhOODNjI9y8ExoJNTQADb9IGnrFOjku97ekGKxKXkSToY7vChajbUaw0QGZIeUV5MnnmJNkIM6ilKy6XHesPihumUZPgC/Xqi6/xtr7Ej4CSyhp2BIxlXTAP5BJOp+sI/KvcPqd0YrfQYh+o6bJnwpskB4Lnlq0SCnUi0OylCCpaKJXTZ8j2zevlPdd+WPKtVbIfPioMGKtbwX2lGh/q98HZv65Vqq6YB8dsU4wadBEqQ6Aw9gktN1bp/qwhVGX4DoPZDkEpWxZgB9snjvzN2PXFbuhp+rH1FzLyJ44HG0zr7NAKGeLC0NeTAjmCnXKOI/qqjSaRHpwmT8YbgSbhnYtBS8kddSaWTaGW8bI6YH6UmvgMCKgY0POovx6n+G7xP4+LHG6r6zsmSa90W8FiGK3FeIfQGrbI47sT4kbQ4+YiAP8ppKk3a2EMR20rD3FAGr/4of8TCmmL+vW7Xsvqafmswcjj47vf/a786le/kttBPf7Nb35T2/GHP/xB8zd/3X333bJhw4Y+gLR582YFVeb5F198Ud773vf2ASTGJbrpppvwfnf3AaQEGB5vvfVWufnmm83bZNKkSVKAgM1r1qzpOxaLxeTxxx8X5kmA9G//9m9CsFVeXq7XzJkzZwBAIlHFBz7wAfnEJz5xQoDEviGVNp9tMgGJFbI4yQnMpGZv6C9qDlmPHoDbTAXZcWH9+f4TCHVldMmB4BHZ23ZQwtAw2t0g9sA9LoBpajc5TghIWFacczJ8kNgXLJfscErSgGfGccr5hY+1CxqhKfbxsrBglkzoqZBXat+U+pAxvxqmeLgGc2MziGpKoJnP6vEi9hVowZGvYopB0yFNuYq9hUpdHugMSIu/VU3zemyYX60gjYA2nDM851TWl/U3amL2xtn9a4z4E29msFY0M3bkGCajpsnx2a3tyKWxHxNARATKZp/yGZ8o6buLi2gN4ASA90IL5YLPLjJRc8cujCk/wGxaA3WinkyfP9UeSAOkU+259H3vXA9gMZ0GH55X4fNwtPqwXP2+a3Q3mzbjhlAHwR0giZqkQNdA4a2/0qBELXkT5gwBaAKqVLNCzZIhzAHcgMI62rhMbKEKsRWAuczRgIWdMzMmbNiwD5VMDVJxRREY27xqyx4Ogpo2A+xQ2Gkd7y2VqqxKxHtphU8FqGR9Dgm1g67W5ZV2f0h6QmXiCoAtDQu0s7hNogAedo9DulBcSxSR0rHAqFAB4JOA1qgdx6JwXNYghgBJTKYsSYKBltop0hGAGZwHvllcmhAoMsNbi8X/WO+1WIbhGT930Vz5zS9+L1vXb5fdO7fLnHmLYCqVj/YOFKa5aGfARO/yqy+Xm267SVnCdm3YKf/14I/llWdflus+cSMYxBDbwljd+4SdkhyrZNkjsmnDWzgfl7fWviTbtq6VQEebNDc3Qgu4EcFmr5MdNXMhJEdg4rgX7RjIa7drzVatMwHSO58oPYEkBAxg9pLXxdpRKbGWRQBLLnEUv6VmebqKn8GKUnigtpSsXyNpj6hVoYkLfSlM4WQ01dKdWtzB8UStD3eBTU2Aeb/mh64Y+KTMs4aASa3V4ETzGn3P8NtiC2MT4RA+QUBFrJyetgyZVHy5zJwxQ55780UQPyBeDd4BjvsB6fhsB5xWJGYeOdG1vddxM+UHP/iBvPDCC/APnKEAqKKiQg4cOCCVlZV61S9+8QupqyPA609f+cpX+r6sW7dOXn75ZQUyPEjwdMMNN8jMmTN17JsX7tq1S/NkfoNT6rH7779fPv7xj8tVV12ll23ZskX++Mc/av0G38fvd955pwKpoc4ddwxdSrKETAB6bipR40M2OgqgBEccNzS9i+Kdzcv0SQHmLBvmvmgU2naCKYCJBoCW7R37ZBfAUSiCOYygCb4zxjPmfASwAQGez5vivunXZD5P/iWo4XgjMOGAYxUKnblSBv8mxreqhBaRMZn2dxySowiezSCxIWi/umHaSv+1ljCY+DyYr/BOtodALIN6UYuUam6XB0Y8L+I+sRwfSEBoIhjuhB8R6pt0ghAC7xEbTsBnmGiPDpwc16encgDdo2BAux6/TjKxTYFjoB4HyPWOy8b7BHQ46HU5ySzH/HKjVaNvG8cFwXUR/GL57BnoWt9ptqs3G/WpxLiNwAzTBFNjXvF0hhd0D3BWSKd0D5xXPcAF4eOfvE3+89s/kKKSIpm1ANqHAAR/TKrmosgJk1SxLpiPhCHcHS8cYpaFFsBW8LZkZh1Qc6lExzQ1szNiT2AmJhCBNikZhTYpb7tk5O7AYo6FGTuXpnNxaseZFN/Z5fkIYpkluaA/PnzwMAQ/i6wYf7E4e1xKrf0///243HrnZxAf5hqYfHTKhImTZcvG9dJcVyOXzJqtu5gt9U2I2VILIFgpniyvNIHEwBHDbi7KhuwiHpdb5pXMUKGD5gYRmNTYsFjQGb0HAkIM9vMzJvoQ54SL5360KwHQg91cRpXv1XBwrSG4ml41TZnpnnzsEQT97JFFFy9Gf3Gn/fgFjUfYl0n4C0EfIXn5iMsE7VcwAOEI9ehL7N4MaAAAqIpzLYhbc0gOHdgHqvMsUJnvNYQhXMz4UFs3vi3zLrpKxmW7pK5xseTYYYbhrkY/sCRDG7HzlS3a59NXzO4r4p39YPYNhLGsg+IAII02LxRra1TsxW+etaodP677iyY46oSGkTv3I13Xf4chqFFA5G46W8j3KArNE02O9EDqxaf4mWNOgyKjHObPcUOB1oFNhDC0SJFAu4T8TdDidkBz6sEVjlMs6eRuo39WdXW1YcaDWzs6OmAq2943rg8dOiTf//735cc//rHccsstx2VOLcsdd9whDz30EAgl8vU82/bMM88oqHrwwQf77iFwmjBhgvzoRz8Sapg++clPwsy2uO88P7z11luqPdoGwgkmmuMRnO3du1cIoj70oQ/J4sWL9Rx/Ma/x48fLRRddBBM4+omNkPCqEkgQvMR64rIbmm2GHqjwlGkg1IP+Gmh0D0lDZzPARJdMLiyXhZYZUpSEhjtpU/+j6o6jsrl1l7QlO2BqB00mtOVx+OWQcp3zYxiCK+cmloOHaGgvFQOlzBOsYu9XmubRlM6CzZEJuWWSZ8tREz72YRlCFvAnVkiflbAcRQy4bfBzq0FcN2oxqZXPd+WhrG4JRAdqsFlEAEQLDIxLTXsIpqGwFxVrAiAKedNs11w3MDR14wFeWDq3mm858zjZ1KfNQSZm/gPyQLsJCrmeMClj3qkWyDLG6gUdUMmz/4VzAoHqOJB/+Jwg98cz0iGCv5p6/2DwAtga7J2GyeTZr2u6xHd3D6QB0rv7+b4rW8dFbPa8KggyGTJ9zgxxeJ3SBqfv4xYhXMc4LhQQdZE+rjdwASOp2/3Y+X8TviT7JNk6TxLBiZh7IZSRqIGO+V3UJi2RzDACueZvlB7nMRWaLAAk/QkBV2ubxJMHUw/4UFjhT3TZqlXy2M8fld89/HtZumwV/BQOg4L7WSksKpap00FvfbQb/hsuufSKa2UzANKjP/uB3PDBD0HA6JTnn/mjOhCvumYlfJhC6jDsRODMbuxy1x5rkLWvQPuFxZ7LotvtlJkggqBJ4fRZ08X6hxfk97/8jdx4c1BNZ1587i8AVSC2WDJLzRFo/sdFh3mh0yS3MF9mzZ0hLzz9kixcOh8mdyVycE81+gwrkbko9TaUwtKR6hrZgDhJMQT3W/fGeglCcJsyfQqrov3C9UuBHAJRZmcH8Ays8srza9Xv6u+/8I8yffZS3e2MQbB5/JH/K9u3bJK2pkMyoahSalvc0lm3QlxFbrFl7VHBvKW2VZqq66Xy4hni8sHE4pxKEEswTqy+asS8KoCpXTaELsRGgdmOboW/Q3WloBiCBoBj/2QTiS7IPsX3iSZHalaHZzsWiTTObvgE0cE+NdEaNA5NVaLAKlvq98uxtVtlxXSnVLszpBbmU/3Gfql3jf1nbr4wUatxzz33qAkcTduo+SD4+eEPfyhZYMsbKv3mN7/Rc9dcc03f6YULQSaBRGCTuoFATdCePXvkxhtvVBBGDdPatWsHaIa+8Y1vqBYrOztb8yBQogaW99LE7rbbblNTugceeEDzIjCj/9G///u/6/Uj/sLzNH112NZjwQZphk+Px+7WwJ0MINsF/y5MsuIDEYbbZZOGSLNUt9djjNN/JCYtiXbxJwMKKLkx04XNFbZRmerwlxpH47upRTLmh9R6DQi2CoGXc0cSWqHDbUeluMCgHuc47Os7XOCGv5MPWoUydwGCW0ODFGpXZjsGyS7w5CkQI1RNKGwAAEAASURBVCV4aqKWoR1ml/SLS8K8mfOhw2PXdzTVbJpbA+bYpwCuk1pqRqP8THDEMcN6M3+C7771CW3gcfO8maWpSeu7zjxxgr+8z1cKG2YkBWXsxPM0sercoCmCOaTXgc0R9BNTKvjrhUsYK/BZAzCm+WQaIGk3pX+NcQ+kAdIYd2g6uzPfA5wsXR7Ewpk2WS6+ZKmaWEQRjZsT6+BEy3JGXCcjUeokO+A6aFQ4D1sdMJkqfUUyoDVKtM+VZGgcVhyAENrlwzE52QnfokiB2PN3SEbOdhyLajYW3B+PZEigqUMqqmZL6+GlsidYJisunyCIVSl/fu4pMNK9ikUyUyZVTpebP3YPtC9FAEgRyc8NyYqqcrnr7++Sxx99TP7ruw9qO4rHFcsnP/8JmVA1UdbVb8YigIUAdvJs96EDh+VHD/7EaALqzYCZ93/jPumwBmXSzMnyN3fdJk8+/rR89xs/VJPD/OJ8ufWuj8uUGdNkY9M2KcBOayaowL1eODdDsLFDaFi4YpFs27wDZAsLQO8N80AIRh7QANuhHWKifJwB8xqX2yU7Nm6XbW9vxYJvlZz8HHn/x94vy1Ytk/3tNdBiwVwHu8m81wZTj4L8oDR2QuA5tE+mQwgsn1glb+6MS72/WxZNdsiCRRfLzp0bZd/ejbJo+VQIz/B3AJFEqH6pOJMw6cndKrvX/EXrMOPSOYbAQYR8jiVS89pA1BBvXoqfi8ReuB4gCeCE9kJnOVFICuN9oEP0qSQaQ9F53wbfEt3hVkHxVHIaeA/fP46NweCIV7GbGP4zOzdH7MvAVpdskrl2ON7HLdIM4B/HuDpbPRmJRORjH/uYVv4RBFZl+ta3viUkUVixYoXQPG6o9PDDDyuoGurc4GPUJjFPk26cZf70pz8VU8tE/0r6Ipnl836W39LS0gfQ5s2bp75S9957rwKln/zkJ9gsOYkNBHSoUnajb+l7xA0WaloInJwuAAn8ZUDXQrANZmEnPxBj0FYEI0WQ6AzMH+VZ5ZKHY/5YwDDjRMy0HgjrNhBoKIsk3lOCJeZHM01DDWD0BIEotUypYID7MbzGbgezHt6dJH44hg3abWNu5xgKYcOIJsegkwBQ8uq8FwFBQwRjPteZLdkgbWgNd2iZqXM+6+ntccOfBcAIiRtsxyfoKyF0c2OB2q9TSangiPfrd2xKsa/VvwkNNQX/1PypSWJ9yTR6MokALOYH1TnMBR1ZA8MrnEw+58K1bHmhO18IdtkXBEGkV08C8JLEQ8NYgCxG13pcrJufCqxN77VzoRXpOrxbeiANkN4tT/ICagd33h786oOYPkWq5s1UU4vhmk/BiwJZBELAUAuesQT2Tq69pmcZCAia4T4GQgMCJZi8hUqxymGBhhDBmDjRpovAdFcmmXm7pAdxlLqjRVK/v0GrkJ23AItVpewPwcfJkkDMoFtlxarrpbWlDsJQluTllcGxOC5rD+2CKVaNhF1NsjngkvkLq+Rf5n9NmhqadUEtGlco8YwkwNFWOCe3wLykRIrLi+T+f72vT/PDAtkHGqsIG/K7oYWpsdXJ4lWLAXQWGnlh8cgvKQBDk0W2NO2Qus4myXVkI5DsfACmySBk8ECYaJNpVVPln//9nxCE1SHNoVYpnzoeFM1fEhuCwnZAsKCZ1ZzpuObbXzF2KVEwhRxvjhcSjQUO2ofUSZtBbWfPR1u+88/igs+CH4KKB8FC77zni9jt88L8xSU1LSCXiIkca++RxQuWy1dnzIQQ5VThy3geMDsBMI00zpFkxAf2un/Tvp152VzVBOquM4+cmvyieY3tLz4FCDdgPbSB7S7WchHqht3Nog1nBSSxdLMrKHiROpdMc6eSKJRw35w789S60pdvqPfmZPOmoKPEDxS6cbNZ39R8KCzbAZKsGCedEKhr4wEpx8VNYBprx7Eg/iWo1T2DKRAIKMECtUbUyFCoZSKz3MGDB1WDxB17ssRxg4HmcRyP9FMiu9xHPvKRUdVu69atQqY7EyDRx4kmdWZ69NFH5YMf/GCfqR6PEzQ1NzfLggUL9LIpU6bod2qWmN+qVav0OLVMTDU1NWqip19G+KUaDjxnvs98BvzhZo44LTC7c0uhJ1u1QU3Q1FihcXeBhdAFczw+SB9CFXjsHvU/aoK/UqclLE4AHDsIGkgKosZjuI59pFoTaKAHJAwE9ifrQH8l+lT2QMPDWEdtMD8uc5ZqvXiPalwwclpj7WBxJ2kEtE0A8jxO4BGBxjSr2wsA5MLGELTngwaZvhvQJNF8i5pM3s/xrgOyt1K8hecIkkgUQbO/HpBKqEk1L0XfDE5qIpdybrBmiPewb1m+KfTzGL+bqa8eyEevG6Ic89rBf5lXpA2bCfBBssFy4Vxjshtc35G+E/i4oB3kWIhBVRnHWCADHp8vZw0L/IDV9xIbhtz4bA63YK46Of/KkcpPn0v3QGoPpAFSam+kP58XPcAFgQLMqutXSQuoglvCfmNHaZjak7iBzux06OW95mLEyZhCG/9yEu5bsFRrhN1V72HJ8NQiXtIUBUpdkUKUwFUVC2e4BD/jVNBjfm21BolAXvFkLPbY8YYcsOmgTQ7Ug0YXwVetdBCONWHL6zUIETXSlQc7eQTE7AJzXS2Esma0odgNwQM7wAR1R1obpRWBb2nHz/o1ASS90b1ZTUSgFBuQ6BgdaowohXETFpKWcDt24fLEAxII8gYdbW+Wlgj8OhCRnn2xr/2wtEHIoP9Plz8pbfD1yIKQ4wBLUBLgrS0SkBxnFoAlAqQC6JF9L4Yd1XAypI6zZvlcs5ItCQ2WGETeFB2q/UelIxHQRSzRntAdaW8mbP9jFeJvXCQBMA1GohCW0YZDwJQdnQwWWaJCUhgmPSrbUdjQfrZIe41TandWS8Xs6ZI9zqfma3GQV2DFNNiydNt5QHe8Q18wCjAurJ5jYumYLPEOg4rcVrRex8tYV4pjjkIDgSvHsA3PMoldagIjssedTuJzZDLiJQ0SaI1Tp/SbGkebAiRjZ3i4TKhxsAEQ+buyZDL82LIlBu0G/HPglO9HNDDDEGu4u0/vOH2LFi1aJN/73vcGZGT6AfEgNUjXX3+90CfJTBs3blTg4sSGwmgSacRpYvfrX/9afYv4l6ZyZmJ+g+m7Cd6uvvpqZcyjmR8B3Pve9z71OaIGykxf//rX1QdpVKZ2vTfpvIhxlJr4HHKgTaYg2tjZjs0NxKPCvwj8MEmdTud5J+aMDDJ8Ypg4AIqgBpQsbAQRpKu2BNMlNZJMLINAyfR9UnMwzAMKkHT2wPRIljsAJppM1QSPSWXORMxDhhab86C/KyA1nQ06F5HWmmZ8KF4DvdKMjuZzCYDrvrk8tUH4zDFNTRlGovof6UTUW7Z5KWGLE22hmR5p5NkOls36D06sO3/M8hx4/rwuieDJ5jH+1XtpjAC/Su2X3nmLx9X8DgCRieCNfrOG3x/WJPzT9WpwwSnfWb5XTexQT1gE4JbzNrFvNMYUwJFhJmm03+gd4zdZW7sQHDiAjbsgLEPSKd0DZ6oH0gDpTPVsOt8z1gPcbVz5sVUABJ1S3VyD5dcwTRi2QMyrHsRF2fr8Btn9l62y8ZW3ZTZi96QmYzEfaWWBUAftUQ8pswmgBq1CUeyuFhYWytFtT8pT+/63N2vkB8lB6YtpbgWWJSZjmu+9JOXP4NIHXzf4PG+NRaJSOLlEqq5ZIJWLZ+hCTsf8IFnx+uqoVAd6jnnEsfDXdbZgAaemxtjZN5iAjLpx0aZztlkeRANd4OuCTX3HzGobdSTIND4xjsoxBH1lvhSAaBJBBrQexMGJJz0gvJiF/jCEbjILN7SzTwyRlzJCbza92ffIvo1/1M9T531Mkv5pkghtke49EXHBd6u9KCC50wvxTMyamrV6J/6ivRgX3eFi+G7QdwJtYgDZXuHwTNWIu/QUJslCBo8HCGtjB2jGss4U8jjeaLrHUZZJbUXvP75LqU9Q4RNo7QPJfGgDjsBZPyZtiG/ktrgAleISsvSDgbGsI6m7GdOIPyRjMBNZ4whERkq7d++W2bNHTyDy+c9/Xj71qU/J3Llzpb6+XrVFqWUQhH3hC18YUGRVVZXQnI6mdqTZ9vl88rvf/W7ANWP1hXOADyCowJ0FFjv0fxg+SXh+fMs5V1B49WdgIwRHemLY6MGOEMkOfE637vxzV5/+IZkA7mQg4/OlJlrBCXdH8J+aFgIGJmphCMi4gcP5nOOZtN4haJJyHD4FG53JMGJZ1UhryK91sdkQl4vIjLkjG74H9dCQU+tDkGTMZsx9YKJ2lD5TGdTgwDJg4JxjXEtfJIKkJOo4tP8qbsX8xnpzrmMrfC4Ez8ZGXCQGUiBOZnj9TZDEoLqZ+Md1JnWwU7NkbjgRhLkBjrgxZQfBUCcCMrOfFWBpCQPb0fcNzSBrIKhO+g6drx84ExDE0sqQfWr+HtwegkLGFTT7d/D59Pd0D4xFD4DEhbNEOqV74PzpAS4yD+/6H2PhwOrGfydKb//hdfnpV36kdv3cxaR5y7shUZAhIxZjn9z2H5+W6ZeeWEjjQqyywZkU3jGr6M4ql201U8LSx5hBDZcC5JRj3RudIP/4t6+Xwztfkbsf3CnZhRXS3fCE3HHdXLDnFcsP/+cn4lxe0Jv/O/00ISzFcyXWeIl0wXctw3dUXMWvw/wwgI6AEDSKMXqqLaBQMZp34FTzH6v7uNCYb6ohDHP3nD5Jmepo3VcOBT74uWSH4rLMsU/C2JjYFi1GINkSiUBsbLMGoBmlAHxq6ad3fFc2rt0AlsncU8tgDO8KhUJqfmWa2o0may7ZjIVkMuWN5p7Ua6i5uvnOW+Tm792ph4caOzStzIX2yAMNUTviBrUj3kyqqEDBnqZcJNfgew4PSfGCWTMToMUPDTT9fK6oWAZWvBJolpzAABapheZnZ+s+2e8/rII/yUB4r84TaBMBD7UnBDAKJDBYrplwuczOn6agoRla9PWN2yQMggj6DxGEULPeTn8j1ZXjBtRHA7z2jbTUlhufqaXxZroUl1jgB8W2DnU53ytqzbihdFxCOTTvI0ji5pAPYR0YcDcAqvMQAJKa1KFzuHlj9pv2GfqN39lm1jUDQI1zOBM1cm74g/I7/xEodsLHi5YP+o73Xje4LjT/az/UApCalKwK+Jc6se+NvM9kYhvMeo9lOcy3yEsfpBywDQZVo2jOGWY57BvGPupEP5vPjf3DNNRYNu87lb/3LbpLmfJO5d70Ped/D6Q1SOf/M7wgW6BLyDALxuAO2btup/z2279SBiguwu+2RLpg7kKPGzdO7n3y65JXVjBiE1X4GPGKMTjJVY3yCgUEEFzoom8Lwi9nvXQdAxtf3IPzI6/i1Mod2f2qFFXMAdPeVOQD2mA4Zb/++hrJ8uVAYI5DgINwM3I2Y9CYE2WBNkKI7wL7YRdML632DgRu3A3pByZJSZexhsMfjSZiZ4K0YayFghO19lTPpwo6DFirEAdCZhwCaxa0FTbsmvcLOtB0whk7gNhIPkuHuCw+iUJ4cljge4Af+ii9G5LHg/fgJBPfpVMFR2ZR1FDkgdAgAA0NCRQGjyFq+0h00Jho7dOQmPfyL8EJ/2VAOM8GgYMd8yoBD4kSEtAAOAGecu0IdYD4Q5o33tGpMJejydympu3y2rEN0AAAHBKg9IIGQwvS/zJTc0OfycqcCapRqg7WSjXM7ugX5XN4NV87gJhqr83bMMhYnvGV4MXweUud8zjGSCaBRhhzh85DqaPTaKmpRepC/1Croe0wO4HlcP3Bfw80RzRDZDDUeC8xCrVjujFEpQ72gkxQZLaX9/IYE4kwCCgZWFfz1IMAntBOJWCqR+0Ty1FTvCHWPOZDJle26Wz4HymoRd240ch6jWVij7AfSRLkxfghSIpBM5haDJ8fwwQwSDbBK58LTejpm0TQSlNjViz1nrGsYzqvC6cH0gDpwnnWF2xL963bLd/9znd1h/Ld2gklJSXyxfu/KAc27DshQDrVPuCSwx1emsxwd5PWIjBA0ThTNL8xV0uayTCZiz0XVEOLhBzsIDIofFuidZdDoDKu47X0u4LEAGGM34ylbd+mZ1FGl0xfdgWC+r4B6vQGsUxul/2HAnBIbpWchSUqCFGY46JpLorUkJ3txNgt3UkwiMFkiGAp1jIfnbMEbYLPBc5l+g6Ls2ADnAyw65nS7rNdz3OlPFN84XPj+KDPRaYdlPv4ZzxL1BTjoQsDA3vq4sJfRCRSITyjC/oINSkyBMyTbdMhUNiTZOFCTXwv6btD354CsNV1RBF4FTvyva+QAha+ghS8eS3fJlOYZ58pOOoV1Am0GNCT94bh/0aAxM8EXRRUeR/7miaB3JziPDAvD0Fz8bzfatgKKnr4LiIv48cg0uHz55MlQKnpPCabGl3SHMVmCWLdUbukcYzAwOBz+yTb7pWQHYQMMRqYor74R+GaLHqcpwg+aBIYB9GC1h1ldRF4AJ5bUW8Lxl4PrhlKmGZ+yrgIQgpqK1JBFvOiFpSbPzSDiyBwbSIOMgHYDVvB3sn28HpeQ78sJqNVxmcgNxXymb8D/UIGR97DxDaQna0DJuQm4OKx4RK1WK4CkOX0aqyGu24sjqv/GIKLm20aizwH5kG/XGPzg+uIz5aFURCSSFd0QA8wsG+m1QNSD0a2gkcZwBJ7iGtBlJsueCYES2NBMDOwfulvF1IPpAHShfS0L9C2JiKJ44Iwvhu7oqK0QnZWV5+xphEceWEGwnU8z5kjJb5CCBkZavsfgeDCXdbWYKvUBOr7hQFcywXc1CLR/MXpqxFXyS4JtU7u3b2GoIHlzYf8JxRnysQy3ISAtn/95f9oWxZ9MEuyi/fC3ALkGBB0imeXIrYSmKpwjwNsRnYIelmg9qXpTH2wGX4IjX19kCpYmAIKj1EAo8iSet44wjMDj6bex2uGTFYExfUeQQytSRCS4DORgMCCWEgZMLHLdICcA75rNL9zFG4ESGzDQs6t5XQyngWETAiEFguC7EKopVBJTxQMLgg40BRYaIZGAdjYxTc86vj0Ti3NuXSBvPrqq6NmnDu1Us7du9atWyfZE/KkLtiIoMzZUgASGac1rHGC6L9jbi9QYGfwUr6/fcxseDWp8eE5bkQQiADiAkBQc0RqeGroEXdOhVQQuASCIIygyRluRGI+vG929lRpwLu6pwPx1lCmAgqAFQrg3CSxYJ7gMT8IYl6tW483EuVy4wMfCO46Q50w6rNJVyaISTD3mO+oCyZqbpr04Voe6wR5jMZjwv3KXgeNVRRgLQIwx+8Z0PywnJGSE/OLBYFlae5mbAT1Xo3bOH6p6Yl0gmYb+VrQX3a826TqJpMfSUlQgN5AwEShneObGic7NDBJtDkM8EUKa16lMw8+xJGXao5wTE3zUO/h6snzwYYOBWeeYgAKaO/OSMJz0WeAR6x1MZo1pkWx/UrCgHFALRHLYYBfdg7JZzjWWKzO3Djnhgkov5lzAYlgGPuQPyH44oYAXNMp3QOn2gNpgHSqPZe+7/zpAe5EY2F+tyfuxPcvFWegtehHJi5clVkTELy1ETGZDhmLE87lFOTKjHmV0oodadqIq+kMru8CtS8FH5pkuEHBO7dgupRM9kHz1Ajq8d3SAKrWbAhqS8tAnBGMyFsvv474UWHZ8sYbUjGxQu5YdQt2WR26O72//YiWR0fmaBR0vI4eqcgqFkdnhhw9elRmVU4FYx/MgtAXXCzNxZYLOxdfmmFwhWV91PwGiyyv0etxQoURXEthhtfwHi7SultMAUfvGyyAIEOQMlgc7WLPPgDzQfhieBrE6mzCbjJ8kMDEJgg2HPfPAkhaKrb8LdCG1WFdT4MkHVAcI3gGYZB5hCFIUwNA4O2EfwZ3jq3WCBgWI2BLwzucgRg7ajaFPqckfQppxZ2r5aMf/ajGNHq3+CKOthsIjj71t5+Su/77HyCg2ySYRNwjjHdueFDY9MeDEgVLHd4IZMnRj9/UdoBsge+EqVXiS0hzMR6jmR6nBi80LXx/SJZAM6mWQCuOORQ0kRKdIInMc/xHc0qvDRpXPFKWxTrYEGctG+ZznMX88OWhGSYrQLjMxHeXoIZ1ikNbc7i1RpKI1ZXhgCANDSM3X3rwrjKxjDAEavVnwmce7cY8FApTm0U2UxIicLPHuF5vGuYX8+J8YyVIgjaK7UtNnDvoS6TBsZEv+4WaMprMudFGrS+pywHWSFxBE0GaBZKhlD/sQ6OnWW8j6THOO8iHGYxYT5yn5oo03wSzWqCZUWpFh/hMEh2WTTIKtnPExHowc/w/k4kmmhwDRm+gRPSDFyDJYYUZo7IUkpiG9TXWO7PvzDqxHTzGALLs57QWyeyZ9N+T7YE0QDrZHktfn+6BC7AHuOAQHJgCUgKL8ZP/8wRiLbXIgovnY3FOqu/BrIw5srx8kQIKLmx+gKUmaJVKvUWw1XdLPmIwuZJO+dWvfy1VC2fJoqmV8nZtSEq82RKsa5Tvf+t7Mr5yvBw9ckxI57344sVSYi+Qn/7s53LTR2+SBcUzZV/bEWiT4DgNgamtLUtKIWft3rZT/viHP8k//sc/yrKyhYjC7kVdaboVk+bOVrBx5SrIopDFBZMmQBTSuA6TXesA4jhlITjh1PyJaCnMcmAqdASU5TTzmZxPHwjSaCflqP+Y0qRTKBqYcBeCxdoL39LDZOrrod0gQRBN6qBhsudtlWTmRIm3zhVbN8xqoHE6u5qkXgEIgqQpfGjdBjbkHfnG8cWxFWuHU7w/quIRRBvZ1eOHj1JIGroD0thdj2dul0gmuOxyALh9EFrx74SC3aAWlc0cLzd97XZZdtlypc3OyyZZw5mQ+tjPx+fbBZ8StpWEBsen3mc04MTgPE50zcDz/LburXVSWFIoTzz+e7n7v78oU+dMBSgFTTbAUAf8PAhQcmDO5MvyKo13W8RvsIThGagAiiqo9iClXtx0CmNOoCBKggLViECbQorrSCgqUV9U4/LkIB4ag73Sn4ZzAttOm1pS06sAq3GGLFLkzpHx3gKYlkUkHkzgfQKNOAAWwxHQ18mJTZJujN02xG1rDDdJDIFpCcgcMGkloFZtV6//Cf1Wogo+MDpQzxjCFyRwPR9Hpt0mdqdDuuATyLlAfZhS2jXUR44xasd8KK8TQJ4mgkycB9gegiKSIxB4KUACkONGkmrXoMVQ7QeuoyZdY/tAY2rEiTKEebNM80nrhgyuZX21/80LhvhLDZavLKf/zMDH33980CcbnglBqsGEeW749HF8sE9J9Y6u1HnAqDY0cgCp/OkRt65FSawBZCtUqnd97v0N5PNi/xNQG8yZ/efSn9I9MNoeSAOk0fZU+rp3bQ88+eSTGovEbCBpdBm4MTU9/PDDGkCSRAhMNH94+eWXNTgkY5PMmjWr73JS9L744osaq+m9731v33EKFDTt4fkbb7xRysvL+861trYK6YS5OMycOVNee+01jYvypS99SYNRMuhjUVGR0NdouMRgkTWBOhUwh7vmdI5z0TZMoKyyxp4je7fukdy8XGmub9QFq6EBLFWbtklbaxsADsAFzEzKx1dIQV6+sH1NCHKZgKBCgaIR92TlZsnMeVWSdPVI1ZK5kgviBpfDKV/+f78in7v9M1pVH4DTzx56RP701DOSiCbltr+9DcKYS6KRGLRHEMTgOtHaVITFdA/MVuxS4iqUltoWefz3v0K8pbBccfVKuWzZJbJ5+zZ57e010tLYosE55wHU7di8XUKBTrni2ivkqnmXSUtzi7z6xF+kev9hmbd4vlx51SqUE5WX//yK7N6yWyZWTpTl71mOAMGZYOPabwh6x3WoIeL0gIVtYOJx7Hb7YAIJ8JT0V0G6cktG1l4VFgdeOxbfeqWkXjCkAAR16gEwkySCGyPAsQUCotUFc0SYAr6jCV3DHfDIYbCf1fYAkJaiboZ2rUcmygFUDmK1GJxzPeJNWKXhSJOESsLinpytQvLJ1n/+dUuk8uIZUrO9WtpC0OaNZWLXG8NgyFzXPvGKNOw/Jtd94YPizAK6NxPuMwVuHqKwSGF7QMI11MgmoUFhyoTWhdoLXGxIkzhPTQoly27MN0nQb/N9ixVAiz7ZLl98+l+lfEKpCpqMIUOtCmMHNSfbJOqMS7aVcY9cUp49TuOmkSUuDAFf6wJwkJoohFKzwhAKFEZZaIx+SEGYtQE4hUDK7kQsNocdceYAgqg94rzZjc/t2Dg53HwU14OiHmZp2fAnygFRB1njOoNRABGvargyYSpF6zxuRzAeWyAZVBrtLoIqbTPzpDkWRrhuSEC7BM0TtZH0NUoi/xiiUjPYK/sp04mNCQADmsBRcHYgGLetB/4rIzwvs80qdENqZ3u5+ULBnKCxm+Eb0N8EaZo36kLND6/piHbqdbyX7yAFf5rqKUhExsOCH9Rn8Lm+ewZVlhq+WABaavR5JsgaTHNGs95D/eVc7oG5NJ8bwrEOdck7dkz9W9F3ht6vvxrsQzMR+NisbkG4YmygwJQTsfeodUtNHLNsJwYIOzOd0j1w0j0weBU/6QzSN6R74J3ugdSJk3UZvLCMVD86D996661y88039102adKkAQDpt7/9rdx1113y9ttvK1McL+T3I0eOyLJly2TlypXy9NNPa3wSBoC8++679ee+++6TtWvXyje/+U3Ne8WKFTJ58mRZuHChrF69Wr785S/L7bffLh0dHbJkyRKNtcIy3nzzTQ1UecMNN8j8+XD2H2U6mWtHmeWIl111yf/P3ncAtlVd7x8vybK8Z5xpZ++QRQIBEkLYexcom0KB0kLphDLa/ph/SumgUFpGWaVsSBkl7IQNCSEhZE8nHvG2ZUuyZf+/78hXfpYlWXYSyNBNZD29d+9995437vnuOee78yIej+YgZ4BJWXzv7ffKhCmTpLqyWu7+7d3y5itvSH5Bvtzxh9vllZdfldTMDBkwuL8qIVQ8eM05IGZm1kCZSodbHVxZMAg21DXIM489I8UjhgCAZcnD9z0sgwsGyJqvVssnH34qRx5/uCx66wNZ+O77csIZJ0GB8skLj70oRQWDZdHb78vaVetlyszJ8sUHn4kdDGrJWLj3/dfek8NOPFxWfLFM3njRJYedfaQk1UKxwL3Tu4EXdyaU18S0TZgdb5TWmomg5k2BZekr1NN1cI9GdpHyKBBqw4r0AEI+bwa0iAz0NQ3f6VDOMNsOwgtb1tffPThCJ6j4+epbJLsxRc4++3TpP3BQpK7psVUrv5HXv3hLtm93SQoWEFbXoh5Ldc2QmpMuY+dE/3x1Ld39F/vB2XwmAhsqaKFSJcAdAVLWgDwZc/AEBUVWYGTKKChBPEmw5QYCUysNrR+0mviVcf+5WQ8T9ymRBfK0uBHPghWYabHKSocFF5aYJg/cz7DP5Kc7G629dLlzwI0xz5Gt7mFZmAjxATyR1CA48T1LRZXAgH1vhFtcbR0IVPBsJqc4pLKtEiQLm2SoDBGfG8QQeF6Yr6x5u8YVbW2ugCUHAAvAiJTiLliM15eXSEp8suSn56OOZAU51HubsTBojacWrcCPTj05IGcyuKE16irW2g4LD0AdLVlc6BWnhCXLriQgfN/A6Ii8fksFQQ4tYMyjVyvMNevsO3Px3cM3EFR45A+AJGbquOSUaz0IKEyyjkmUgTXxntHrgLJ63UK0QePAAAQVMHe0n26pPDc/TZUNmPQAzfcQLLwdBc03350NbpcCiGBgYW3bd7FN+TS3Yq073Kd0gw6Wl2mTGfc9cMPl9QhOlLkNVj8vQDBjxzhuWJP1mlj3x7ZjEjASiAEkI4nY9x4nAb7gODjQPYRuGPSn5su+GfEv5uXZU6dozaG16JFHHgmZtaSkRG655RYZNKhTaVu+fLksWLBAARIH3JEjR8ptt90m8+fPl2uvvVb+/e9/y6xZs+TKK6+UoqIiIVDiQpJc8+QJuJYxTZ48WX72s58pQLr77rvVOnXqqafKn/70J7W2ZGdnd1soMmQD95Kdl19+uSobV1z7I1n7zSpxNbpkSNEQzCa75JC5h8j7CxfJ1JnTpBoLzjYg+DbXkaXB2GSQSoEFJMlGyxQWa8xMk3MuPEdWrVgl28pAFgGa8ZqqGkkGW9dBs2cBIB2NWAe7LP10iRx/+vGybvU6ee6RZ2XF8hWy9LNlMqB4gNaTBBecZXDbm3HADExAQrHDDPRRpx4naRlpgcUb+yZ6aEFoaLyjCsrlF9JaN1p8jUNgSVqH/V1n6PtWvymFuhiPkIDYHQcClZO34zmhggClDnEbcQlYgT4eSu9OPac5dy+/qdvgOqUjDi0vv7uFlApSMNjIzsRaKaCprvAixms3Smynxq6BzZAAxSjMponsS78RA/Rn6eotMmoWF05GXlo/kKzKoG4TD9Ai1KEUayacg25igYTDBugY6mUjL37bAQ6SYDlhFB4JDZobPNpGWjNM4nuMwf10QWUsUkIbFh7G5AFp1R343eJrNFkD33zHsg4SD7gBSOoawCYHK4YdwGZQZr4UpmXI1qYyWVa+DjGFeEYBYOimtqluq9T5GhREpSAvY3JoEdq4vVStVckZIGBJocscXPAScA4Ag0ZYlkggwfuX+xl31O4GCQoAYlwi7IsoTxmQKEJlCeDWhu1EEiWg7ypjyMI6LlA2BEdMLaiL40kC6opH/bjhdH/3Pzg/6vYvzEwoiGcZsuO4w7HIXG/eA1EnnorPQKiE/ayLAEnlDauguvuib1oGTeWxVJAz8H4hg163ulCH6be5L5iXraeVjcfY990pVbiqNWYrA894Ou6PRLhDBwM5tpnvfw/drdGH4MR+ESBlJeNeZn9xjQikGENGsESCDILM3a3vwf2I/f7uJBADSN+d7GNn7rME4sBaloOV0P2DEl/61pccf7vgPhJN4iKrXEfovvvuU1e2iy66KMB4x0HkwgsvVGvOVVddFaju66+/VmuRzkZiL8HQr371K3UfWbdunVqVmDkzM1OGDRumLnXM8+WXXwbqoPVJFSDsYX0MGn/88ccVQBEc7YuJcjj3gvNkLNzumEaMHyMP3vdPufjyS6AEYI0RuBW1IK6ARA9FyQOlanuVFBUOVGVmVRzWHcJ1r6+pl4fue0jy8vJk7Lgx8jVmzE2iotECBbGhHsxYb70rr744X9avXS+5ubny3+df1Oun9xKVI3wIuJ989DGdlX7vzXdUEVHlDEoZB1Zz/Uz9ffs2ikn3Ab5v9XUvxfvUmeGU/U6eKfsdNx3gCIocgdHuAI4szaVCQ5nS0rBx40ZZuWqVzJg5A26OTbJq9WqQcnglLc0po0aMgCIPBZnXaTdKeu/AdYu6piq06Av3WRN/Dxg9WHeVrytVVy++u6joU8cLKMMoy2Qll1EQg2upwEuPdv6h5cEkfRsCdLEKM2tu3lVUEOnCpA5MaAvlzTbRMkEF3w6XNhstMbAu+eB614wYpQZvI+J1oJgTOAQlBs17YaFivKAqpHabDAQ4GpCWA/e1BKkDMcGmhm1SAyt5G0AwE61GDqdD7Ml+Vkxar8rrKrUdg/v1h7WK7msAWgn+93s7QBKiTdgZlS3lm0SACGAQTwsaXOe8cO2jJYaxSnx22RdasZQ9E+CTbmd0B6Rs6P5HuTCmiSx8TKQJJ77hArR6mo7LRgsZXQMpMSbKzZmQonVXgFyGJBDsNxMxbterrbt7/MNrw3Z2S9hF8Mnqre8aw25n8vMYXQcDeZCfYMLcg8wXyaJpHTtNnd/9d7u6eJKJrhr3JCdD0m2IZcN1tEqZsajmHg/XZsaFJaEYAbom1Mdr1oZ3ONlXaUn1k5KEqyG2f1+VQPc33r4qiVi/9xgJcB4wrfor+NVPw8iBgRPJDFJ8fRqmpGhe/AQtXFmeMUE1NTUa/0O3uNGjRwstO+PHj5e5c+fqOcwfghvrQo0ENBUVFcI4obS0NJ1RNHmz4ObF2Bwmo6SQbe3mm2+Wv/zlL7qfyiDro5WJ7nn7ahoBxXfr5hLZBHmkIrB7xMgR4kawN6+pGy5BLRjIhpA9r7FS6gBy7rrlTjnmhGPkwEMOkiUffYF4p4HS0NAoWzdskYsuvUiVTRd+6xwpZgupoFVWVMpPL/mxXHfddQpqHQ744YdQ/Pa2a7Bt2zY55thjZPHLH8vF/7iaOuRul/i88jlet3at/PvJJySvoJ9U11TJ2DFjVfndXl4hi7/YAtepFpk4DoyH1Cl3w36owgurjyqsaGMwSMoemCs2hw1udiVovqUD2FSgA0WdCi4VfpY1gIh5zXaXi2epgjIx78IuecwP5CV40HcRFWn803pxHn97oWxj1j0RbphuWOIbPHAFBTyJB+NdqEQLEi8DY6EIvFNAqlDgzESsIolOvFLh8rvcsc52BNQnAhzZYM21w7LjgKJKum0XKMIzEYNUkJotLh/ilmDrYnyM9h3tJSMmCVKsVjS2P9HuX1cJHVIAQEuTtoMNNTIBaklBXTkp2VhU2oGgfrLJ4Z0A+TILrQpqRQHI8GF9H67FpTq4VgELE9oNRz2MKazUn5jfaXOCVCJXakHwwv6TC47rPrlB7qKWOVROuUabeN0NCNMyqNQAoQDwCarMgGKCn5qNlRrHlz4wG9Y1uD22gcET/5gMOAq+D4Oq2+1+mvaS4KIMCwZXJYAllO6QlpYSQHKRWIdSu3eXN68Bnwd/GWtJPgcJSlJhh3WqXince2H1s7Qhtrn3SiAGkPbea7vX9oyvvDlx2+TTuuVSmTke7iB+kMQOcybIrK4djQD+3//7f+oeR0WZqRlR/w8++KCce+658uSTT8oHH3zQrRqbzQZrRmdgK7dJY5uMGVHOflsTj6Wnpwd20UpC4oYbbrhBGGPEZLfbtT6CKTMoBArsQxs6W44xjpahQUMGS/nWMvnBjy6VlNQUGVw0WP7190fkpzf+TGpa66UQrHgnn36yPPHIE/LSc/NhMcqWCy+/SPIysmX/WTPld7+6WTJzsiUVLnFUNLJys6UlsV1uv+4W+eUvf6luk/uQaKV///7y5ZIvZeCggbL0f5/LfkdN3/26j2tPUNAEYowcuNqdecaZ8jrITqhcH3nEkfLJJx9LBlwoR40as/u1PahFfuW+u8LGbDzWb/gA2bJ8o3hBNkLA0CWhWADEdDmAH9DxVOGjmYP/8a3nguVKlUH8Vnc76HoEESEBlamT5yHqCCRYsqA08h/dzJpAh90E9sU4KKAKqAL5um5oL/HHhhgnWmTKXHUgZfBIbVNjR5wT3ZjAAgd3Oj+o8bO90RXahnXMhmYPkCy7U+phbUqAAuxMJA22v11UaXnuYKY59lmtbiorACRYktpgYbaCCbrC5TgyYH3IVLc0yg3OedpHtbCgbFsLXK3AbteOhWf5j65YRiniOdSVLo6KMxn4AMpYA8Aj89KikQ62TIVCyEt3r61YA66xxeV/j8OoFxIkoVO8RmyrAS/IGHQtALrQJ2MF0n6hHK9n4FpAROaa21JscEXEvUCxUWioT+WDzT09GRkqfTzcnbsk9JOsgITpBNXmPmEZWibpRke2PtzRes26lLX84PWMpZgEgiVg3gXB+2O/YxLYjSWAxeOwSOn+nm3yYUOS1KaNUpDEl6KuoI1ZQvNS7akTZH7jWigGIDEe6eOPP5YXXnhBLTp0v2Jqwro8s2fP1lgl5mcMkkmcnS8uLlbXPOZjrJHTicXtkEpLS6WoqEi3uQbJySefrJYjxhuZxPqYL5YoAYx4SFf84io5/ozjpRasVcvr18jF11yqjHNNcc2yqnK9bEoqkYNnz5DpB0wTF1izMvMyMfvcLJuxttJFV10kp597OtxwMNsI3woqNIlQsqrdtXLrr38rzz75jJ5jX/zzwN8fkNsevktkdwRI0FGoMHKioRwW2edeek6qyqtk4oSJSmSyGZbXNExEDADYq6zYvkdfvn4jB4JBb4OUrd0qgycMjdwXyEVdOmEBNQCA31TgTSKwofKsH1hNPG4yt4E1Ea5otKowvijcO1EVdZRJBTlCGog9fHA3q/RUSbWnTuKTuBhsp/ueOV+obyr9ZGirrgc1O9whGRfEFIdnzw4FPhHud4Z5jtTSdGcjiKGFqAmuVDa4zqYmcWHgztrZNgImLhbKtXr4j/1gHkCFQEa63HEdJbq5aYLMGJuamgS3LMjGKMC0GvCcdA305wMoAtMf45hssLwkQU5MzM98CTgRlwNIjAM1OFz0aJQhmGIy1jfNjXYy3iUNliUu/GrOpxmtf1C0i9sc2qtA1tpp5tf+oZ902WTiKU3f8E3gRiEQBBBEOfMQg4T9JKvQvFoowh/UxzZa76EIuXeLQ3r/GhkEtcgNSyStS3QRZc+aAdDV8gh3ysRWrL+HODo7WE75FJhEkOwGqPXTwVtMhCZD7Hufl0AMIO3zt8CeJwC+2JeDNnp8RqaM9m6ULxrTxedEcDfcMDgYclY07AAV1F2yztHFjuQJjY2N+s14olNOOUVuuummQG7SeD/yyCMyffp0jVUiAQMJHkjQcP/998tRRx2l7jHHH3+83HvvvUJ67tdff133FRcXC0EUj5ERb86cOYF6uUHQ9MADD0gKGNOiSX/729/k/PPPD4CwxYsXK924KUtrwbx58/RnbW2tPPfcczpjyfMYwMeDvaUjf/XVV9WV0JyH3wR3ZOQziTTmtIjNmDHD7FJ5hWtDIFPHBt3oGKOQfkCBvFf6KWhywc4E5WOdY7Mqeo21TRoTAQZh+e/aNyUXs8NxGBg9G91YOd3viuOAQuWAq48/5gizwx11czaRSgTbt68mWjN9oEvfHZMqbFBgRsLV8qKLLpBPP/5UrRlZ2Rmyas1qtbIOHTa0cwZ9d+xElG0qBEBiKl0dBUDCPcv3mrpg4WY21ge1FBEoAYAE3PGgNBMkkTrbA8XfBxfVFmwnkuIaEwaMoQtWiumaRrxAnbstsU2qWyp1MqEd9SSDdl8V0yj6Za6fja5vBCGIS6LbHcFLwFKCesy7uQ3KK2mwa9AzAqfCVAAQdU1EO2BJpOKvCV9pcSmwZjVr32ldItU2XauYdF0iBN4TMATUX2yQMMIDlz0CF2ufk6EsM26FFp8EgCp7BqAW6mRZVMG/2kaCEC5aTMW6naQV6o5HagN/u6x1shR3pyengaq8EQo6iFGYLdAg/MS1oqz5zUSZhARHerTrH763GA9lR18UqEFOpDLnOXi9GytAcw0AnZID6xuud09JXQz9ne0p6x5xnNeElqRELGXABYIJmCgc3hEEpA0+F9w53Wrh5LXmNSCDIYGy5a7ZI/oaa+S3J4HOKZhv75yxM8UksEMSgGOCrMk7QpbXeWUA/NanuJaAkKsByi9mO6Es+9fkiO4UP/7xj1XxmjhxohQXFyu7HIFMpETyhbvuuktmzpypMUuMPbrxxhu1yO23364ueoynufrqq+Xhhx/WGJd77rkHlMTblRKcAys/xmp1+umn6/pGtGb1lFg/wRktVSZx36OPPqrrMnFtJlMP6cMJ6BjbxDZOmDBBGfJYjsCQoI71kGWPMTkmkY78n//8J4Li3Qp+WDcTCS3efffdwIc05QR8Jn3++efqNvjFF1+YXTrzH64NgUyWDSp9w2aOlkpvrVQ11So44uGKpirZWlcOX/EGHdAoP84Sbmook411W6QU67VwpXqydFU310hJXZmUNmyXKix4yUUv+alHvIA16N1y2n1m0yjXu2OHVVFRLVXEhftyS9k2GTN2jORk50pJ6ValbS8uGtrRdP8zpEro7tiZHtpU2MFkxzikaJO6mkGpZswc408IQqjRt5HOGu5lpLWm4sdnIwluwA6siWODWxsJCshI5250S3MjKLBh3VEAQkW9Q8EmWKjEM7INC7BW47nj2kI8hyrxeK8SjBAs9Jhw/dQVDWDMkQYyAycY8aCws01MbDO39VrjN3fT0kPmOQbNM/EYrTRsowFKtDYZxjnGOeWmpKu1gEquG27Rbfg2wMMAGD9AspAodAATLlCbCvc4WqvYR7oF+mWLbYAh0z4SAHhQLyQNAAXjkQXcmHaavKY/9gS7svIZF0HtEP6wbaY8y/AaWkGjyRf8zbwEaJkAXtmOdCyADUY3tJnvORJZcPKI545H/JSP6z3REOIXdXBVnb9xzRVcd+7Z47coA09rC2LCsE4WgJDe2B29MteGDIc85sI44bcuwW2yR2Ht8aKJdWAHJBCzIO2A8GJFvysJtMvGxm3SiPijlOqPsbBkgfhqF8rnmXMVJAWz2pgBM1RrMzIy5JlnnlG3OA6SBrQE52XskDVx/aKzzjpLyxEwmUSL0iqwbxEMkUnNpDvvvFP4CZU4WJIa/Nhjjw11WPcxjoYL0nKgZQyUNZFogovMkljCmsjMd9hhhymY435aewie5s6d2yc68uuvvz5QPd0FCcYIzpgIAAkai4uLA3m4EakNXTJafozD2jRUmqwpWOHgMQ5udJ0zipHJT6ViRxLXZaKL5cUXXxyoJpKVjvcGFwam/GlNS0IsBhOvWbjFhK0LA9Pd0noPsWyoNnA/UygrHYlDXnrpJQXEXJtrVyXoVpp2TMIhWocKvZh19yJg35HilAH9CuVsTBwMHDAIcmyRQw85BO5PoGzukK0Hs+ceWAzFttNbEqJxO39X/jAshov7tHR1EEAiZoF1IKLihi5rfAnyajA+ngECIC7CTCWcFlhV/GG5SQBQkTY7FGmCDSjUtMxgmwvNqtsdyvK9Z0ccFPd5EWuTCEKGpHg7zgHggjbSAuOA7JthjfEBNPQqmRsGhXiluMhzEsBOsxcLyqI+tWTwCP5z4VpSWJNdjuf1u0B5QOvfqKykPsoF+9PhxpYKC1KDp0aq62rFg5i1eFiC0tKxuCzuDy+eO8ovMzkdi8+mq3VI24y2UD50W9N3PUgbaCUiaQMJFrjujg9WK0SuADfiWy1QWGgWDH4EHlwygNeG7yJa9GixoIVKI1woR+xrwtpHDYhBYtvZJ5PYbgIiJm7zE03iu43toGLfAisW5UOrRzNo1dkX7QcAYwaWJ2iE/MjQ19Okgb4veZ8RXEXZjmja+l3nYX+0T2EaEvGZClMmtnvflkBXLWTflkWs93uQBDiobWyolJe9Y2RFaZkMysiVgZWLpL65Husi+F2IOLvGwezNf7+ui7xG6h5jhsKBo3DlqKwFK7YmrxUcmX09fUdiU+OM3yWXXCJvvvmmzj6auugWSPc9gjK6Bn722WfmkLzzzjsKkJ599ll57LHHlLKc4IiKezg68gMPPDAsHbmp2ANGObr40S3QsPkVFRXJV1991W1h23BtMHWF+h510PhQu0Pu08E+5JG+7aRL4mmnnabystYQzkpHYETSDSoqJPegNdAkLiZ8xx13KNjhYsJkR2QyCwMTrNKSdwiUf1rrTArXBh4PZaXj2lkEZiQYIQGFWZjY1Lezvqnr0hWKbj5qpcV2pMmHaM+rcTNOBPfH1ciL81+S0m1bYTXKkUEDB6sCR4U9C+QbqU4seosZ/c0b18vbi96RTU2lYssBuYpFCY/2nN91PoKY3CH5Ur52W+dsPvrB57wNsTsB97JIDYWOTaWb7yEG6SvZAxR8Woncrma1Kmk9zIf7kwvF2rC+l90ByxIAEX8TSFFJJuCyw9qj9NuwOrF9dNWitSKZwBTXPAmECqynr9ecroCEBXRV49o1fmWWe/yJSv/WxjLZUAsmy3p8GktkCyjCaUn26No1/jifdATjcwKlAe8+D0guIDJ//+A9QDYzWlqGZg2Ey16e3x2to37eZ5QXgQVlTFDZSpIGVODEWjvsI93+CH7sAIjJWDA3Be66RDrqtgiwaUMcVSLWYGpodUkJ2raldpusr9uMNm+R9bWbZFtDubruKfDo7Jq2gLLjxwpKeH30E+EmpquwF/3X+C5XrTQ0udRaiIrgAol2os8+LBLrayZJRUdnI3ztbdajCF2NHYpJYIckELMg7ZD4YoW/KwnkpJCZCK4P6cnyRdUhUujaIvsjUD/OUy2rEvthhs2lbgn9sF7Shdf+oM+D+nfVv+Dz0mpEi1VwIighUx6tSAMHDlT2vQsuuEDB0tatW9VqxfgpKiN0iaMlhCQSfaEjN+f+z3/+o8x8dNEz6aSTTtLNYMASrg35+fmmaJdvKmp0zdkVyaqYhKqfLoRkFhwzZozK1JonnJWOrol0R6Slju6aXPC2HhTkdGkMt5iwWRiYVjcmunTSiknmxEhtCGelI138U089JdOmTZMrrrhC3TVp/SooKLB2YYe2qRRDvYPSaBOn3Q9KoGZith5WB3w4Ax+wBvT2TFDqEh2wuo1IkyUb18qXT6+Q4oxBsv+kybgW48AQmS71DfWydt16yGexrN6+Tnz9YTEYliVJoMsOvud6e/rvKn+/EQNl+8ZyqdoCa/OQzmvF/tAVlG5nwQp1yLYSAPGfDSAISjzLtkH5b6O1BLLVmBRMhfY4g468VvBDEJKMoHe613F/EsBSks9fvy5e23ONXZrL8xMcecGOZ12kNpAJ/WAef3wQ4qcADPiboNwPOOJAguAAIEiSUtC/1zbCrRrghiQUXAyW1mSuS0QLEtdKs4FYgbJUe1wHWFGgg/xtXgbouxFvVSdZjlTJd2RizPCzodENkOCR57TKg78ZB1bdVKOuu6Qe5z7+U4tRh/z42/+/46SBDnbdYNsIVtTVjgV6SFovz4Fy6maJdyXJBxIB+iq2VUp9I97rg7KU5hsN98ssqE4FYyiv7UPbYykmgZgEwksgBpDCyyZ2ZDeVAAeKWTmTMYjB1cztg3LB9VJqEZhZI0NTG2UwFgfd6G6XwRn9pL66Xk466gQ5fu6xcu73z5WxY8fupr3qW7No8amsrAxQiU+aNEno/kdLAgdfxv+Q1IGJi96SuvyMM87oEx25aeE//vEPjYMyvyN9h2sD47NCJQZN78qkilaYE1DxmD9/vlrkSP9uktVK9wiIOugSR7kSCNG9jq51JOrgmll///vftRj389pQwWUyiwlzm8e4MLBJPEbLEAFSuDYwb1GR30p37bXXmqJ67WlB5HVnIvAlUKZFcWcCJD5zNlgSCI5oB9CgccRmkDmM69lQcWyBYsqZfrMQZ6CRUW4QJGWP64eZ/RbZUl4raz9+RXLfWyRZIC9xuaqlJh4xaYMzJGVEvgKqOLo9UdnbQ1PhyAGybMEX6manAAn6KpVlfqjgWpXz3nRR3evgthso30cR0aJCayGvPetiHE5qUgo+TsTAwEWutVkBD9umynuPjYR1C8HzhsUNhToTtoProPWf11dl0mF9SQcdeAVoxEtqKvxWFMjKnmLvAJKwDgEcsv5mxFTBHqYeBKgEwtQT6Pn4TLpBX74dcY2pyU7Jc2Rr/wis4sF4SUtXQHadLdR9po16nPcfEail7eY4i7H9CpwsdVg3CVYivY+sebnNvARGPDeBHmmtGZfFy5tRkCW2TKd442FFgisgjwcnypLy4Tfr6c25g+uK/Y5JYF+QwK7VRvYFCcb6+K1LgC/5K8+6UgYWDZKRQ4fJ5Cn7yePPPC1Z6ZmyfVupnHPaEXLiaRfKQ08+Ku++8ZYkgYnpvB9cKCdgMdiLL7pI14SJljHu2+wc41J6m0pKSjTeafLkyVp02LBh+ptucIMGDVKrgqmTRBQkULjqqquUnKG3dOSsZ+3atcqYd+aZZ5pqI36Ha0O4Qglg2/qu0pQpU/TUBBxWxTuclY7WJrpmkvGQLnT/+te/FJzQGhRuMWHWu3Gjf2Fg00+uf0ULFVO4NvBYKCsdWQkJ1h566CFdZPi9996T1atX6znourezkg1WhBSbn9HMqm+rsgbFjYHsnMknWIKzDxThFsxdMGgcWmS0iRUjRoZkAGn9c2FJLJKm8hYZbF8oczLqZb0zW5YlZAKKYdhiPEi09Xbk07ZaFOVeFt/p2Q2TXRnikCYePrVr/Ralu+uB6H5Z79/oSnTP5YWrchJoQcFMAABAAElEQVQAbzJACGnG6ebliE+RjMQ0aceaYmRqawQ7WBNjx3AMt0E3kGOt1ViN2DbGQgUuIPAgQV0XwISCVOB1P+cYcLFJVlCHAPu6pgZYiRALhf3qCoiyPEZ3QMYFsX5ad1QGaBMBEUks6IvHSbWmtmYpbSxXEEGwR1DvbQZw4D0VD0CG/OHAAwFQZnKGUnnXuMEcBxkRwNENlO2xAiSyzqHK0NayDsEEn4ewhoQUtJ6FTB0yphugthtAkK7k7Qk4UTJKtLIFrKVrIlBT103kJSlFLMUkEJNAzxKIPSk9yyiWYzeTAAe+jWs2yDmXnS2nHHmyvDL/v5jpjJef/OZq+WjBxzL/tTflyKNPkleeny/nXXqhjJs4Tp56/Cm549475Y23F8hbn74nA/P6y6cffCLjp06QpkSvDvb9U/KkqqxKB7ys7CxZuXylZIAWuf8ALLK5eKlk5WQifqRepkydjGByryx8b6HUVtfIpGn7SV1NnQwbNUziUhPhflFDh5cepIYBrR0+716sX+ED05S9RsqrK3oo0/0wrRgkb1izZo1akRgXRJctriVDSwctRowXYtwRqbZpXaLSwTy9pSPn2QmwCMZYfzQpXBvClaVywusbrDiEys88dL9pox9/QNsKlXPH9oWz0jH2iGQKjE8iQOIiwYWFhbJlyxYl0gi1mDDbbBYGNq0KXkzY7I/2m+cnrfzvfvc7tZCS4n1nWY8oV7paJcG1LglKWSQ56zHoZgRLTgBdTmI3IbhcFdUwnWknYBGSWsCdKp6xg3wucE29NmmtK0a8R5P075cu2cn1sq4F+6lxQontSzKxHvpsdtch+1LlDpWhix1T6ZqtO1TPrirMeBxafOgWR7Y4XldlkqP48UkByUFacqqCklow4NV5GnEVodhDtqGUdNNOPuO0rnANH6Bdjfkxx8y3AUwEy0kAHz4AKh9ATy0Y+NQChfI2O46BUtwG0JMC1zslbOl4F3DNJLxGFLTQ1dDTBGsX7h1bsg9udTVoZZvk2XOUCY+3FPPy/mW7QuAL0yzNQ3CSaUtHDBSAGu7VeAKOEH1mPyknghNtS6AW/4ax8ljfdX5GPTxnKEO5h5MjARQ/bDPradhSp7TqzsI0jTOz1mkFR7qfXcR7KJZiEohJILIEYgApsnxiR3dHCeDlzjiVcRPGS5tTpB6sQSPh5pSTlyX9ivI1aNmBRf+OP/JAefnZ+fLVkqVy0KEHyaT9JknO2H7ixsDcLy5HfvHDn8kPfnqZlKbUghK6Qg4bNFNqSqrlv0/Ph46G1e6h7M4+9BA57PB5csH3zpPyskr59W2/luOOPl7mv/ii/O+1N9TNKguz+BmZGXL6eWdJ+rgc+bz0K2Ub6ll0BAKY2fPkgKJ1oLx8WydLXM9l/TnoMvjTn/5U3bmooNPFihYMJrrUkW1u1KhRCpDmzp2rRA88RqWaIInuclRGQtGRMx8TwRAJAJhIGU5XsmhTpDaEq8MOhYeUrT0N4VRmdC0UKMwtjIGhcgSlYmencFY6Q8TB2B8mBsuTxZBxRGQMDLWYMPPxmHVhYG4XFRXxUJ8SLUgLFy7U2DJatGgppCVxZyQqaJyhJnNWm4ACucerYs5KYNWTNRDaI0FXU7b46kbAHNAo8SlliKWpkXY+E+4C1FEmcV6HtCWBpY3WKCqdfUxUJtVygWapItzHenZWsbScdHFmp3VnsttZJ9gJ9ZBBrRXrKVHBB6SRRmlSkJSE+B4q5vwkg9AgF7GejJkirb4vDkQHsIJEVMLxcKslQzFEiAkRHCc9eQrcyJLh5ucBeCZJgYICPOcERYy5InhywrJp62B3AxTRXvvwjicwp9WkGeCoFTFZtCDV4D1G97osAJx0OxalxT8FGSjFkmS466ndLR68m7ztkgWWvDrIg+6lfCz4bZ4P/MS967dEecDYp3VjTLHWreemi54l2TERQUATzBVIeRKwds3N0wKg4V+CjVYnno/op7NCKzjiXtZjPd6ZM7YVk0BMAsESiAGkYInEfu8ZEsBIwQHQDcWNgyFdQBjvwkGEI4DH0yYTJ42VGYcfIUu+XCH33PJHueGOm8VZ6MSAiXU+GGCL8pjnlqKMgUIyh5zEDPnrvX+W4eOHyYlnnSJPP/wfZTyCn5DkFOTJ7KMPlRcef15mTJouuVm5bIDK6tzLzof1Jk3yCvNlXfOWXsgPgzN93qEQJtpqUS465Z6ucdZE9jrGHNGaYVjleJwK+4MPPqiKM2WVmpoaKNYXOnIWvvnmmwN1hNpgjI41RWqDNZ/Z5oBP33oqZryekRKVJeYz+oBV+TDldB/vlQ7VQhVkczDK73BWOlppaK3hOlFcm4rMgHSV4yK5tBKFWkyYpzQLA9O6xmv5/PPPy+OPPx5la7pn47pVZMubPXu2shzy3MXFxd0z9nEPZUe3Vq67wpgUI8vg6vyPA5RdHoDMuY5MJOsRn1Ms4wgEXgVylTzxVOyPiQmsfG+rg6JHaxK2411ia6dVEeo56myDktkXiKRt5u3Ee4ENxX9/Q/H9HaZCWJHWfvKNuGoaxJmVtmtaQrnx3dLxOGmMUy/PBLHjeWyXGk8trqtHch054oS7HZ8vfU5xDicY35qS3KDfBm02LU4gEeDxUM9l4PSol3dBqMQ1hTgB0gQrFi2Rpg8EZayb8W+pYJ8jWQ+rIEW3ud/oaucCUQ9WYoI1EvcSrjmIssUTB3DkyIAFKLMbSFb6bwKMcAnnaHWDYtvVpC3OcuZIkscOV1KswwQXt2ysrZQPi5oLLnubXBXab1KAs39kzuM9aOKpVCZBfSfYs6O/bpSn5YwufyZRQg4AQQ8ILkiIYpUZ5Z9SkCb2Focy4vkIaK3Ai9Xwg0qUprxPT5BpSew7JoF9RwIxgLTvXOu9qqccsOlSkYxBRQcTHQH8XaT+U9/QJH+59zGZc+hsSe/fHy5PUOygTGPUwgBDv20snAj2tw/e+wgz+oWSgNm3wonZABjZsmnDFnn/zfflo/c/lDlz56heUVDYT7537hniqmuQ+/92v/zoqiuVmjkZlLmcoVzy0edy1CnHSJut6+AVndA5/IksfvcjWb9+vbqwRVeuMxcHXCs46jwCxQVWhXDJWEHCHd9Z+yO1wZyDLilUfhjT0BM4MmX8kvP/MsqROWa+E+B+yXvi0xcXwdWmk07bHO/pO5KVjus8kfSCQJSWIMYCGfc2s5gwfw8fPlzXiuK5SAXOdasIUgkgyTxnrFA9tSXUcVoDf/KTn6ilj9bAJ554wh+7ESpzn/ZBCcbz1QLFjQpcyAQBUymlSxYtR3R9JKDqOUHVi/dKQsYqsWFmP64FDIY2l8QlNuKZdYmjrQLfNTh/MtyZ6IpHBZbaXt+TutpBgYyouPe9+l6VJFEDAdK2VSUyYuaYXpWNlJnPAj+0IOgLDCKjck4Q0NfEZ5PWCi7ITPev/PhcSY13BuSYFA9rDkFSx3FabwhkqJRbFfpozs+YtySAlXqPC5NdHo0L4qXnO4L1kWae4Ihun3ynMxnrMX+ScKEMcUZZAEKpmHAhhXitrw6umtlSAMY6HwB3B14MNEfl01FXYCfuNb472nEvA3+hLV6dWLODOARc5ZLqTRFnOyxYaO+UTEy0gRFvKxa53u6tV6u2MvARmbCJvG35CZF4L5JOnZZN/3XrmpETQTgLXALhls1FdCF/I1N9Z25vhIsdns8sLswLAgZ1XaVMOu4DAjSUiY+Ha3QEDBiiabFdMQnssxIIM9rts/KIdXwPkAAB0UVXXCTpWOS1FTNq4+BS5GnGoA0Xs/zCApl77GGSjsD331z7Q3npjfdly6Z1csXPfyyDRxTLysqVGHSbwXRnl2NPPk5qa+tk/eoNGLfiZOiIIvnhNZfJgw88LFvWbZRTzz9D8rG+Uk5utsw79nAocvFy5sVnyfsLFukg3YTZfwKnxR98JtNmTRdHjlNqKtYHBq7einL/Y2aFXVept3XtiflramBJQ0yBG9fUr/J09gLDvLrkEDhx0I82MS/jEahMfPnap1EVO+aYY4QfawpnpSPwIXU6mQSzs7P9ilxHwXCLCZNBigsDcz0kkoUQJAWnUG0weYKtdHPmzFHLFddPCrculynbl2/V7SBHAqSWNsQiKXNW12vAX17ImZTfQDm9fAYIkjySlPmN/7pDAWZsEubb/Qug4nxJCSniwL44TGwgc1+6oW0ySmWfKtgFhUwcUhnikHYIIOEC8BmhVZWaP7f5n4l9NuBoR/uv1htYRbiOUXnTdlg73JIBdzXGJ1G5J1kCQZEdawhBjVcLr78V0f/V2B20uR4uda0tcJXD/cC6te24GTvBEdSXjmOk/87AorAtya0A6j6UrVdLVgWY6lw45gapQxIAIum8bQByjYhlwsMaAIwK/nhfdbx4CFhaMZ54O9ZZUjCNY2xHYqqDtzjWHqKU+Q/sclhPqaWmTGrr4sUFa9cQsUtVUptgyViD3yIKIAnvBKUlxzn4jjMTRMZFjoW9cDN0YFFYWpC8NKd2JLZNFwmG5Yhui3HoJy3lrINrPfkoQ1qjUHeCzU8qof0xFcS+YxKISSCkBGIAKaRYYjt3ZwlwMDv6/GMxyDXLlsoyKRgGd7f4bFmJ9VHsKUky5OCR8s66Zrg8jJZfXknrSYKsb0uWNTUbpQHMWrXuGtlkL5NZZxyCwa0zccZzW3uNnHYVKZgxIw6FEGOMVLRXy4hDxsrXNWsxOx4n04+dIR+uXKwD0MSZk+Tsn5+PWVNYkSqWg4IWJA8caEMkKuuRBqb++w1Rl63eAIAQp9ljd11/w/UyZP8RRkfRfvD60IUmBYoBZ6jJnEV3m94qevVVdbJxyVoh+UZfE69dOCsd2eRCJYKfcKAlAwB/Z6Zw59lZ52jFDHQzZB+PGfkEPINUDDXhInF2mlbZ3l6XzrahLrib6vPY8VCydg/Ws9nW0ijDE1pkCKwfm7BAtCsR7lHd5v87awq7hQrjE/0EAabpYfN+SwcMk10pmOx6m/ie4MdYiaiq+wXor4nXgvesuo4BDOysxPcv/3HigTFHjS1NymxHBd/V2gRAA69JxAjx/UlLk7F2+KEEr2rkxD55yM4GJZ/XSWOVOooxhsYJVlJal1hfMtzwspMzYbmySTNcrWm1hG0HTHMpUu9ukDIsJt4AoAUcJQ7EHPHWakX9dMfDCfyAAnXzvmCfTFKAoZYaACGAfv5mTJQtBWQQuE9b3B0seSyAGEh3uxvWaQ+sQPGSjfGmP56R7dj/eWt9h+sfuwKginYHjwHc50A/+A1pwbHUfx1NvJVKG+emFUzbgJgvXzzycXBCYtvS+mVo30wMFevywYpGkEq3VLLzqeW0Bd82PrmdfdVKYn9iEohJoJsEYgCpm0hiO3Z3CXAA/XTrUrz88Q/bW+FKwUQlrRmDggukDS1NUKIQ5J1U+5YMhl/4Z1sbxVs0UzKynBiw2+XLsuX+gFVLZzl4sg7OUDKp0uff0gFFFREd5OJk5efL9EhLVpy8uW6RKgE8zoEpZNLK/bODHJvMIGm+WWbaiQfKxk/WyLEnHCu3/v5Wofsb+7c3J5I/cKbz5FNOls0lm+WaF262dBdkHABGKQhc5jWhJGyIgXHDjau3Uvn6rSUqy+qqakv9+96m3m9QmPqS+NxwJp7xfg64UtlgKWAMH25mVZL91qO+1ByhDK57uc8m26F15yWCeQxusa5eX32/croj7mURWrhDh3IHY00nWE1L1/QOIKkCj+fG+n4IVnrVKgJrAmmj6epF9ETAwsRywfn1QG/+dNxGfB7dxg0O5RMBEki5bYARAQ6V+RaAHrqKMfHdHe782ja0l5YoayI4ohtaexusSz6SRSQhngiLBYOgoRX1E1AoaEBZO44VpObBKpMs2zFpVe8B4xxcQEsbYenFukcJcLHT/LCwkOCFsU58t+idAtlozBC+OcGRiHa0wkWNzw6tv60uAA+cz6S2BFiJcG4yLDKmNDEJzwTAfD+cY1hLglTjGWkELTohGP8HJ14aXk8vYqQYF0u5UT46lqBJlBPPTbnw+UtOQv8gB1raeT15bVsxucfxiu51Nq5Lhj7x0eS6cjaAQfYHVap1KZzcg9sV+x2TwL4ugRhA2tfvgD24/2bgMF0ggw9jJJq8cZKUUg3K7Rr5yj1QPlpYJv2Lp0nJeyskae5ojVlSth9TsOObYxf3+4GQf6d/PPP/tYKf6pJKzZA9MDeQ33q8o8rOL1TBQY6+4axfByzs44BrTSf/7vvy2fOL5LyrLpLyDdskA9TiTCzrV3L8uXXtCwyYoRLzMlmVJ2s+7q/DQpxtmG1Ny83wryXSUaZrPv8vDtYs09zQLM31Lkl2JktKZifhg7VMb7a9cHPZuGq9DCweJKPnTZQzL7jMohRRCUiUtCTSidNa4e8rFZkUxB40tTSH7V+oNix7a7HuHjyySNdx6g0TX6j69tR9X8AdMBW02X1J/ruKrnQgRWlrFHubHYooXKpwfai47YoUj2elLiFNNrbWyv5wDxqMtaFLce29sCzxrtjTE13fCoYWIgZpi8aQkLY6mqTPON8pNNd0JAIiJnVR4zG8y+i6xbWp1C0SzzCtgKTLJqCgy6Rx5eqook9ffA+r5QMggSA0GeQNBC1OsF/S1S4pzqZghOtjeQGSaHFqhCXQWEB6c1IuUMtyNAClpfhZ6JpQJ14G6AuAAN5pjMNrB7BmuBUZ7uLac9BfLh7rkQZMniUAxBBYEDAxboeEEmTFG505TApTc6UWcU917Q1wJyXJCOQI65sjBTceAIevCTKDFabz1sNJANi4qC7Fz3hHP0U5iBnQzpFcMwmAcZmnGoRCACnIE5yYr6GtSYCP9D3Pd61eX5yP5+Fvff+xLXhPE5CqKyO2aQkjnKrbWq3udIXDB0iaEyQ3kIOLLoqQOe8L3lesJ5ZiEohJIHoJdNXOoi8XyxmTwG4pAQ4XOghh9g5DlTTWY+a5cJQce8Q8eerZCinY9JYU5CbJJ/FFGFaojJhBg8O82e65a1Ul2zVTzsC8njNbc2CAJJDSYGMzEOqZGUSLYxhMZ54xWz+mGK0nGVjxnbSxnLf0YUCvZyA0B9wQiTOtVIKgA/gH2hB5Ni1dJ//84T1gdWqRq564Xgry8+CuAiUgaAD3Kz+c1fRJXW2D3H3u76RkY4mc9P2zZdoJB4aoOfpdz9z4iAgA0jHXny6DJwztUpDySQE4Cr4q/M39VEbo6x+NgldfUSubvlwnA8cXydQTZsmECRM08NtmQ3/3obRo0SL57e9/K+fde+UO9VrvCdysdLdrEtC/Q0kPga936BzWwj64bm2F8lgT3yIFYCFLx7m3w5GqN8+rtb7dbZtudlu/2SwV67fJgDFDomoelV7a7whM+MzyeTETI6yA7xgS2CQnJsP6SksMVGxcpETaMQBYuK5Ro4IEvlF2MPH8AAZMvDeSAFB4zryULLVsuD1gDEV7kwHU+OymJjqlPt4hNSAzICtbG5Y6YLnuie/jzv3W9x3rdyTBLQ3/6BpNYEQXMibcLnDLBW6Bi1wL4m/IPCcegCfAhXbIZXtrhxUZbSIrow0gMiMpTcZmD5ch6QPUNZDxVRtqtkplE4AHZGysj+2oqnOY4B3IOKMmqW3HwtzxqZKN60BJtMCTgYDNBg1rLNy7a2AFXR9PJj5/G9nOromlaAXqPM74oVYw8JEggmstJdpRGbIpSAJ1OCVDyxP3peSk6vVOByEPr3E80KEXZXyQDRNlRznpfYJ+W+8VzRD7E5NATALdJBADSN1EEtuxJ0vAz6BFSmAMLBhs7DkpsmLpRql++CHQoG6VmVP6g4K5XRrLN8rS5JFQMeCzDr95O3zIm+Mw84YZcR8G3zYycVkGq2CZVG3uAEiDewBIGO845FkVSM4GEvTYoMBwZpfKDF1P6CLBmU3OdnIG0CRlQkIeHTrxh9TmzBNaqQC9N60scC1pgQzotx5qMBwyaZjMufAoeefB1+TFW5+Qc+64VLxJrXBng0sJ2mQazLZyIKZccxC/c+Vffia3n3WjzL/zaek/YpAMGDtYLWLh2mL6EPxNC9qqD76WVKwFM2h8cfBhtQT6yQC6HcIOxB5A8eMMuQvWBM4ARzr/8reXaCUT502RqSceIPXlNTJ20jg58/QzJTsjKyqQFaoVe8q+zz77DFY/hzz2yKNy1ZPXSX5xv53WdJU7b5CgxGevFFaRFe99JU21jVI4alBQjuh/Un1O9SGeJKFZ78XVvhRpSKD1QJ+I6CvahTkZCJ9X1E+G7DcMLla9G1atcUjRAiR2xQ2L7uqPV8i7D78u4+fsJ0nJnYCf14Usn3xGdEIGLyD+4/NM67O+Y8JMsOyImDiJY4P7F59dB55RPuc8HxV2toWJSr0q9wgMImOlB1YhtiuQ2uhXRiRAq2TnfoKgwlEDZcSMsZKcQuY4EEHArY3n4P1G188mUm43tQHwODVOyAdwplUAJ6hngFp4/O3g+TiZNCS9v8womCz9nfmEFtruovRBoOzOkafeel7efutteeIPD8spl5wBYoZOIEaw48UEE97WCnzeActcDtAZwRmaE2g5+7od1Oh1GGtIOIGO8dRdUxtciDGpR0ZHmLxwDFY59JeL3NKCFQ/QqWOIGUhYP8YKfbdjHwEjZc5E0Mxrzf4SCPNbgRerRSJI8lfm/239G4fGF00fIUOnjrTujm3HJLBPSqB3b/J9UkSxTu9JEuCgwoGDiYsMcq2M/FnjpWR5pkzLs8v/tpbJQfluOTQ7Q+K2L5Usu0NGpABQYEBxw42nFjOalR6fbGmHW499gLRittWqiBWW1svUJdvkgZUlkma3yaj6VtkSFGtPhQSF/AlN0dk7KAUc5EgHa8PMp53AiApMRzZbx+DGnxzguPaHC8QPPE7WIg5yVD7oouLW2UNTsqOCji/6/juxwj3jQ8gqxgHSOvNqzT3noqNAMbxSVry7VCmwp510oHjR/2S0zwElh2yBnR3hgNwuhcX95ZLbr5C//ugP8sQvHpCfPXkTZi+dOBdnTNFytJODc09p/eerxd3YLPsfMdU/yAcVoM9/E5QFLhJJeXZRoDQvwC8sXmxhA6wYVJ7CpWUL/O514w+bolkOvfQYKZs7SZZ/tU582/xAOlxZ05fu5w9XYtfs79BtOrUungZiNpKmoqTb+u2nY8Ym3IRapbS5RIaOHyW/fPVW4eKkuzrxPnnhxseksaROxo8bL01w/5k4YfiOnZYKIRRHymEo3cpMx3es1p1Wmory0jeWyiePvyun3nYByGLsUdfdb8QAzVsKJrtoU3N9k9xyxC/kzHO+J9NGT5Z54+cpI2K05ffEfM0g5Xl1wevy5QufyGV/uUZBgd71XDIL9wMZ9chax/dnVXyNJCH+x0EXUICW1kSuqQXgxRdGR+J9SlA0q99UKUjJQxX+m0rBBPI895/n5OLzzlN6fs9pp8lp804xRffKb7oGbt++Xe75659k04y1cugPuzJ57pWdjnUqJoEIEogBpAjCiR3awyQA7ckDMEGf7lQ7aIGh5FOjSst1Sf/90uTzdReJVMVJtfs1+d7wr+S4wSMUPFS5GqQEixtmwvUgH4pNMawv+4My9oPKjfJRwmBpZbwDBtORayrkqAVrtM4DsnMkHWsrnfzyCnln9lBZNt4/K8/F/tIAzDhbGlCqUZZgBQgDwAiOf2iXOUaFz586tzhQ0xWFibEdDq4aT20XiTEECkI6fuvOjj/M4wA4IrBhjAHrYXvopmEGf2t+BkGf/rvz5a/fv01e/eNzUjxluOQOLlCWOA/O6wQ9Ll1Qgi1QE+ZMkRN+dJq8/Ndn5ZGf/02ufeh6SUl2qFsJwZwyUHWAJWouoXTZFe9+qU0ZO2eStUmBbVq/vJj99QBQciaawDK4HbwQ9P23AwS44NLS/bhIbVm1bFm+QYZMGirp+f54Lp6kH3z1+dnbkrmv2K/Qkt/1PV5wz0vyzcJl0tSEuIp9LF166aXy+0OvlZveu7uLRSeSGMx9WBYlk10LYvceuezPcsstt8h1110Xqeq97tg1V18jo0aPkj+e/3v57ZN3aSwO3/FMcJbTSSQF0njpuNqb1Q03wQZvgA7LEbPSFY9WrQyw2k3Pm4h3fm63Z+Xtt98W0vRz8e0sLBnBdcb2lXTZZYgFBVhyZDu7uHrvK/2P9TMmASMBy3yK2RX7jklgz5QAZw4ZxKvMZx0Agz0h61GcY5M4+y2SRCjTG7wHyKtl8fIh3Oz+XVopj7mc8lz7EPlXS395tD5Dnqh2y9rKdXJgfqHM862WfPdmyW0qk8PfXktGV52E/OfBB8rdM6ar8j974QZJbsbq53BDS8V56aJGsEKLj37UX97mBzoALFYlNpykCSoIkrLAwOekOxn+cXAnCQWtRKESFxFk3IG1fmNNC5Wfg2DuoHw54Rdnwh3FK0/f8Ii6q/DcBGENCFZ2wQWGjE3BIOeYy06S/eZOlXVLVstTtz0KmfgXOuSijJnJ6ZJud2IhR2dIYENL0zdwvUrGeiLFEVw5eE5aptiOBsRcMajczO6yP+ynxh7gOxQ4Yp7lYK9jmjBvqn7v7X94n5h/30VfG6vqZdPna6WhoeG7OP13fs4HHnhA5sw7VDaAUj7aZAfpCcleytZu63J/hyu/Bm5106dO3+fAkZHHym9WgiwBC8FuLdU1fsx+vheTYC0C9lE5JsHCn5SMCR64jdkRb8jJI5JaMB6K5A2T88dJYVoB3l3d1aDHH39c/vOf/yg4MvXvK9/0bPjqq69k/aKV+0qXY/2MSSCkBLq/GUJmi+2MSWD3lgDdtj2wIjCWxwa3CiqJJhFYUJlOTFspyQMWiaPfu7IqM0veThgtm1OGS4stA+5uidKGAbTBni+bnaPkNSmSpeWbZXLuIDkvzS1n124HuGJN3RM9fgZuq1cl3X/e0PmQoXvhCHuY2+9e5s/E3wRfdgCm4ESAkASXM2u/mSccQEqFa2GmPQ1gJlUOPHG2TICr27aVW+TN++d3qboZbn51ACf+xVY7+8XzXXjb5VI4dIC8//RbsujZd1TGlDNfKrQ8OQHwMpLTsJBkqp9ZqqPmLcs2SGN1g4w+eLyFta7LaQM/2GfWSeBbB1YmEjMQFBFkNcEdsBaWv2a4HIZLyxZ8oddl3GGTw2WJ7d+JEqjYWCYDBw70M3ntxHr3pKqOnHekVG2u6FWTuWCsx+WWmm1VPZbbvrFcJowZ32O+vTUD3z0TJ02SdZvWiYsxR5jMYSLQIbsbrf38p/tgOUoBJX0amC/1TcK8ONTfWSCjMosRc+nQfMF/vvnmGxk9enTw7n3m97Bhw6QBkx068dTDuKVEOZ1Dwz4jo1hH934JxADS3n+N94ke0mXCC1pWrpNBFiUzQLLztDrQ7Y7Br4npqyTBuR2xLYkAB07JAVDIhhKfRiVeBwL4qsO9y2XLlrcSh8lr5RXytcsj5VgpPVIilYFSydLigvP1DgpFqrn7MdJf0zJlEscmBugyJqdLv/GLcumaYOmByx4ZpfxWLrJBJcv3fnOBZBZmy6LH35J1n62yFAEbEiw3dV6XrjFF5cKAMAb+X/6Xn4oDlqAn/+9hWb8U7ocdiWdlWygHuvk56XaImVsmxjwxjUVgebSJ5yTYI713DdY0qcEikE0AbkY5ClVP9dZKZQcrmjz8W4m9CdWGfW1fImi7MrM6XRn3tf6zv7RkWNfJiUYGVqKGnvLb4AackkKFf99OdAPe5iqXupYGfQ/w9WLTuET/u5HKvbLm4f1GQgVOnI3OGS7HFR0qRw+eLbmOHAgw+P3of7/RrW5fThzDeA/rWAY5alxtGIHo+ArX6hCiDFMitjsmgT1DAp1a1p7R3lgrYxIILQEMjln2DBmchoUXARaCE4dB7ncCCGXY0uF/noaZRa4PkoBB1CmD0wul0FmIQdTvosb1V1rjk2Vx8mh5NXGsPNNvNH6HflwSYFny5kBZhxLf1NKCdT6wTkuHO5gBE8HtCf2b61rQOgLmotAZdAzygfCBA75JplXdJvowyJGliS4TBjglYkZVwYrlDCyfk50t5956KbUDefa3j0pTnctUrzlpmWtUVzdYbKCYGMtUwZB+cvGdP1JmqvuvvkfqttcEynVukFAhCfL2x2bRvY6MW1NnT+u2DlRnmdBbfqBE4BcZsLL08o61j8aDvS6WYhLYnSVQOLKDqCHKOKTduS/fVtv4buObsNxVKVWgDG+ClbkR6xwxDhK79R3BdYL4jxbwyQXj5Oghs2Vi3hi8/9Mtb8DOFlPZ9+r7rfP92nl039xSF2sMLqHGVSORdlCq7y6JLSE4jsb6tbu0OdaO3VMC3TXJ3bOdsVbFJBBRAnwZgiQba2u4ug18PJaWhBlXWJAYJ+S3bRgLB4gNEsg4FS+ZDlAHAyCUuSqU/YtRPyBf5dtW2uHPTjKGeYhDojsfAYwOCdiIm5MlR+e2yoLG1bLBPhRuYHAJA1CyJWHl93iAMBIM8B8LdWmd1qD1MHDYjYUMm+BCxoE/AyQThhaXpQIJRchMRoDAOpmMvYqDuzURGKUhDoixOyzTAiWBoJD1B+dlTeOmT5DDLzlO3nhgPqi/n5Sz7/hBoDoep6LR3NoCdzd8AHjSQeLAuiYcsp+SNrz0l2fk/mv+JNc+/JuQVMcpYMerWFMitOzsd9g0SUtNRX+h1IAmd1ekZW8uUavVuEOjt1TtinZ0r5PXCRLljcTE60aLYNfL5z+2l/59//33QbdvlxkzZgR62NzcrHEf6enpcuSRR4oTa7qQ6OHpp58O5DEbs2bNkhEjRmCdnVZhQP3y5cu1zLhx40wWWbNmjbz22muy//77y8yZMwP7I5Uxmf72t7/J+eefH1UbTJmI33qtcc3DXGO62DGV9YLJLuL5cDCUjBlbsmDBApkEF7V58+Z1qeK9996TFStWyLHHHiuDBw8OHKuqqpKXX35Z3VpPPfVUyczstBBGqo8VfPDBB+J2u+Wwww7T+ljXK6+8EqibG2effbZOlNB1lm1mG0488UR11eySMfgHxJmIdytBUnVzjdSCSJvvRb6n+F6irEkhTs8AWsz7OXLVyq7V8PHreH/yN93EeH79YDIo2mS9T1imBe/9//3vf7J+/Xo5+uij9R41dYW6v80x9pnleE8fd9xxZnfE+5uMcy+88IJaEymvtLQ0LRfp/mZsIMvwGTvmmGMk2rXgKB8upkvZhmJFNetEBRr+HW5wXSvG7XLApQeFB+MVrY1hH77vsK2xU+/eEjCTz7t3K2Oti0kgSglg3AuZ4uF/YeiiO3UUuF1gLQ0Osnzx82WaDre7fFC+0v2M+6zpm9H58sIJY2XzwAypT7XJ1v7pMv9oWJiGAQQBiJyYmyWHta6VfE8pdF4vFtKEaxqsLnXuRnUNo+WlGQM242nITucBAQFJCLiooKu1GavL+13G1IoUBHZMO9gigp2uCXvZ3hBlKA9ab0iekIF4I669FCof62PeE644DYu2Fqsb3GcvfsDdXZKRr7bRIp+jLz1RJs+bLuu/XCNP3fKvLmX4I7XGJWM/WSfbH3lTj00GQGJIF2d7g+XcrXAfdlRt2a7r8BRPGSGp2X7FoQ/V7JoiXPPE55A2T4a0NfcTX3MhLira2B6afGPXNOK7q/Xzzz+XE044Qb744otAI1auXKnKoVG4jzrqKF3M1+v1yrvvvhv4UIm88MILZcOGDVqWrHF33HGHso0deuih8uGHH+r+u+++W84880xVfG+99VZVuM3JwpUxx2+//Xa58sorAyx8PbXBlAv/jTu8FWv24HoLFgwNlTILssSRniKlO8mCFErGf/7zn+WSSy7B0gdJcv3118vvfve7QFMOOeQQYb9ramoUOH355Zd6rK6uTgHm0qVLFWwyHwEPU6T6eLy8vFxOPvlkVfz5m+mdd97R8xLUmg8VeqaDDjpI/vnPf2r9hx9+uDz66KO6P+IfvJC4uDYngwiUGACprrwdLyoCJlr0MxFnmm5LU1BEEOPx4B2MfvBD4MJ9nEijbFIcKVpfxPPiYPB9wvxz585VAMI62QeuQcYU7v7mMYJ43u+cDPj5z3/ehXwj3L26ceNGBbkEnASVs2fP1j6wvnBleC1Hjhwp69at0+dp4sSJ+nywTE+J7+gWAA2Oo1ZgyXKUPQl/dADpqaJdfJzAmPFmNox5XDqDLvccyWMpJoG+SCBmQeqL1GJl9goJcLUY/wu0EwwRY2TAkiSSL2VYTZ1AwDoglAzMFH6sqb09W5prt8pBdo9MzRso41qaZHntevnKlyY19hxQj9uxvlCLtYhua70YlDmWW0ELB2p+ghNf8z6sg8TZPGubmI+DV2OcW1n0gsua4aF7jcFnYLxQolx4++Vy+xk3dqH+Ds7J8/tBpP8Iz3nBrT+Usg3bZOGzb8vgccUy55Q5ktLgln7ry2X6WyvEB/e+ClBu2/F9dZlXPva4AfagmKgEgs+wY7+XvelXviccvhuy16k1AdcwjgqdV+IImKBASxvcIZNcWO+n+72yY9LYfUrfc889ctddd0lxcXGXRj3yyCNyzjnnKNjhASrWDz74oFxxxRXCYyb98pe/1HxHHHGEWo1oDdm0aZMqaVT+brvtNnnxxRdVeX/99dc10P5HP/qRDBo0SNauXasKcagy8+fP19l6Wq74LFpn1mkxCdcG067I33jyeK3bMQPfysVAAQjiaKXo+kQyDonrg3GNI4KlvqZQMmaf3nzzTSE7G+VEy91pWNvnxhtvlMWLF0tJSYlaPXhOXptrrrlGwQyBJi0arJPp+OOPl2eeeUa+//3vh61PM+LPxRdf3MWCwv1LlixRy9wNN9xgsuk3ga3L5ZInnnhCf0+ePFl+9rOfKdV2l4xhfpDGm59QyccJJQClFoBtNxcEB3gxIM/kp7WSHyr7PSUCulD3CYkdcnJy9L5lHbTw/Pvf/5bp06fr/RPu/r722ms1H62iBOZFRUUKlLZu3arWvuD7m/cqrXC//vWv5aqrrtLmDhkyRAiKaUUKd3+Tle/ggw+W3/72t1pm2rRp8tZbbymQ0x0h/rRiAWTepsZS19aK+zgoBY83QYe/1Z9kco2Hl4gZ8+gK3saZuMCeb7U5sZPt4RLo+W2wh3cw1vyYBMJJgO52SR0xR9Y8pIJ1wsUtHVYhrsHDdYXMC9eaz2wTy2yyDZJnWgvlubJy2dbskqm5/eX8XJsc61sj/Zs3ozyJsLv+0/JQXLqAI+wkAUMo9zqexwuLSygXB87wueGe1wBw1psAcVTZLRUOHiCn/vqcLtTfiS0AijrQ+LO3oR1exEJZB0eubn8FSRvSUuQ/IG0ouv4JOeGBd2T6myvUmywRg+ufZ06XD447WobUe2TKW9/ouk7dGmDZoUMbUWtHYnu7tLlDfp05/BmXvblYFaaxh04yRXefbyjHcfFuiUtqkDh7FSjoy/0fe20AHEWjqO2aDgVL0pxFr4T50edvKn+0Eu23335d6uBMO13hTKKrHBVOa/r444/lqaeeknvvvVd3f/3113LggQcGlFoqmLRKcTabLk6GhYwz57SM8DkLV4YVcuKBFhYCiURMFIRKwW0IlSfUvrgEAGF7BT6I0TPudkEZAwvG7qAVKZSM+ZzSTY7giECEQIkKMtOnn37aTfZ0+WKivKhUm0QZUxGPVB/z3nfffeqmRyuKNdEyRSsNgRmvJa1zTLyOxmrF3wQF1vci91lTl3eA9UCIbb7n19Rukg9LF0u9t1Hfwub54jkIhm02kNZ0gKM2AKpWTDiFS+HukzFjxig4Z7ktW7YoiDEyDnd/E2zRonPAAQfo6QjGySBH+Ue6VwmkCI7YflqgjHUoUhk+U2wH3VE/+eQToRWKYDhswiPP+q3v+LB5ozxAix77TBmGSjyf+bTCuyLiwBtUAcdAmhCt9waZDRNg9YqlmAT6IoEYQOqL1GJl9goJ+KDkN8O1jbDFmhjL5EIsE2OH0gGUuKCgA/Ez/hewNWfnNsOFfQlOWZU8Qp5r7SfPlFfJmoZaGZXVTw53uMXZUoXyPT9ujCdia7q2qOM8XMODsSpESmGSB9TX9XTVUytTZybWqqU6Bj26ExJoeXwt6rffmdNf/awTZsu0uVOU+rvm0r/LlQ98Ilfd95Ec999vdM0nDkXNcF3hIGZtzRAwmP31qEN11m7Bpi1arfV4bnKyjMrIEBJbDF9ZBjDX3d9f5YxCSmkOVqo0uAZmJmdIgTNXBqQPkP7p/SXfmYM1ojKxIHAaiDf8LhWDtzXI6c8vk8PuWiDlWFNmvzHFkpebF/G6Wfv97W1TIh2fdlzPwKezBbwPNI6ic9cu3eL1pCJEmuQUuGMaZTFwUrSxvQ2xer7uFPOBPFFsnHTSSZINQhAqQdZEi9G//vUvdTOi29Dzzz+vCpw1z//93/8JrUEZuH+YqERzxt4k1ltRUaF1m/bzOaAyecYZZ6g1I1IZKspnnXVW976bE+A7uA2WQ5E3uRZA4Enp2ndTsDAQh1RidvXpO5yMWVljY6PK4R//+If86le/0voZv/LGG2+o2yJjcB566CGVIy0tVKKtMia7G13nTApVH93JuB4ULYXBiSCIgIwggNYVAwyYz1wzgoubb745YOkIroO/Q0swVE7/fU23uxV16+Tjqi+l1d4maelpkupMlWS8j2h1SU7GvY20efNmuKj9UJYu/Sp0Zdjb031CS8348ePVIsV4LqZw9zf7yvObvjMvZVxWVhbx/mY+JsbJ0V2V9zivU6T7m7KeM2eOWg/pznj55ZfL8OHD/RVF+LuzABKfeVqgdKFefNOtsQ2TbMEXk8+srxXjAv4HvyciNBNPV5zGnAUztybC3S7w6EWqIHYsJoEgCYSeJgvKFPsZk8DeKAEq4gRIVMTJXud/i7bDZ90NynC6fvnf3Ynwa04lIQFmIkkzHf6l3QZSB5QB+9265KGyxdcoNZVrZHp+sYzZXiafSo4ejyxLwKiOmczu+fx0DGxXpEQGPYIkLlrLuCv65rd2MN/pDB5mSDmI+Jno4jTuilYrq9KRDgvPs/2Hy+zUVfLWtm3y+6n7qTyGbqqRM5/5Sh4/Z7JSKzCmiqx4PE9mea3Me+JDSXRkyAEnnyCFKaHXGDFtT0Sb0uPs0tDu9//374/TBWazAIiSMbBxfSoGWfvjx0xJfoNQA3/ZZlqz8r7eKJNfXKY7PGBUKgYBxK8KBsnohZtkwcGDQAkOi00EYMkad6dE4EhHSt5zJvB8V7aP1PhcL8aWmAADBxirIKtGXFsyKqpQKexWh7TUD5U4W50kpm6ERttduelrG+myRVcvKs6puHYMIKfybRJdwN5FLBJBlElUVI0Fgvu4zbLmOlPBJwEAkynXUxnNHOZPqDaEydqn3Z1U31v7VD6aQpTPNjzPJGRgPBEBQWFhoQISKs+U3XnnnadEDA6HQ4k0gmXMAH+TguujNeSCCy6Qv//97yGpyAmezDU699xz1fXRasGiBYQufXTBo+IfOXW8sfDVDqtcxxRQlyJ8d6dgKQc4r2qg/rJKLPOAfQf1nyaZKekd7/J2qa+tlDv/3x/kj/f8WV3wuJZXXxNj3wiIGOd1yimnqBtbuPubRCUECtZEeVPG0dyrjNO68847lRCCbqSRyvzmN78RTj7w+vPZoHyLiorUFdJ6/uBtTqS1Y4V0vhfCj03Bpbr/VqsRrpV5Pnm9FDTBqkRLD1/oPKbxTAhp4jGTt3ttofewrYz1dWKiB4WRCURLGE/5T2PUQheL7Y1JIKQEcFfGUkwCe6kEOH7yhYwvfrjNl24LrB5UOunqQuW6wVuvrhdNrViIFB+PWpVYwJ9YDV/mTliRGAAaztfd5Od3Aqa/WrEI4dL4wVLtqpb90hAkDCsSh4KekoIXVf2756SXG9vTUyJzHQkiarFmUG1zA/roAgmEC0DBT0HOgcTMtNEpIbjOCQtXSjbACd3hXjtyXuB0lGN6g0dGr9qu+9ywWLFukk7Menmx0I2OeQalOnVgChQMseFGnEVOZj8FqLwuVGbyUrJkQFo/pWG3gV0wkRYz1OgHdAR1nR+zj3r6hP9+op5LPHdxWqp8dcoJcvSA/lL0xVoZ1pikPvQhmtDrXZQTgTXbsSsSgaBJPA/v094qCaZ8b77jYCFScMSrh/92sH5xoV+/QkSpor+JDRJvq5GWyinirZgl7e7s3pwiYl66FtGqwTghss/l5uYqWDKFHnvsMVU2rdaMAQMGSGlpqcmiil9xcbH+rq+v1zgRWpWeffZZVfR5IFKZQEVhNkK1IUzWPu3OK+6nCyeXgulxZyeSErz00kuBahnUTxfERYsW6T7GehHcrFq1SkElFWemYHlR3jwWrj4yDpLQYe7cuQqESJDB+KXvfe97WoYuiibx3uL1YqwNE92+6JJHyxNdHSMl3pH+9wKsDQTxYR7HVjw/tFJwnTiuTwWHK7CMgpRBLecA1YiD/POf7pZhI0bLrbfdAauSU/7wx7tk6KhhkU4f8hitN6Z/BCo/+MEPZOHChcqMF+7+LigoUKsp3R5NMjIOlj2Bjbm/yQ5IwM7Ur18/jSfjBEKkMiRzYJtogWUZAlTGIEVKHPfi2jA+YNKJ1h/Gulrl7b8OkWrwH+P7klY8uq4mJnV+EjAho++YEBX19b1H5kJS/zDxLyeZrO9VPRD7E5NAFBLoHI2jyBzLEpPAniABqvt0/WrCoq36afFgUPQqm1GtpxHAoVHqPWCNqymQ5oYcECgkKb22CwsONrU0ojQ07hCJL1uSOmRwUdmwVp7OghxcGpLSZXGTD+5gqTJealThbcfMFuc7zZhuvk1JUpLyw/ImMQ/dX/jyjzZRueYCuaZ+Hexwbmu9HDisv1k38xduRmwMvjMw0PNjTdzfr7xBd1GJJ+23bK+U9JomS4utJbpvt6Edq0CgwOBfDpB06ypMLZQ8uNERFBmriXomdRQP9APuF8PeXiyH3P2MzL3tCdn/wVcl0e2PZQg+UxsG4P5ba8FMmIOBkv7oCXrtcPqIiXJhXrO4Lc/NAZt0wZlgw2KMGuPXIif/DChdNckk6AcboUvwGM9HeVrTtwWSeM9T8QmIBRu04JEmnm0j7I1D7FS8s0SSslaLz1UobY1DAEp7koG1N+G3//CHP8hPfvITdUuqra1V9yurBYGxRYxTsSbDEsZ4DcY13H///coGxjx0lZs6daoGzOuMdEfBSGWsdYfaDtWGUPn6uo/KIkHS9g1lfhejvlYUohwtFQzOZxwSEy01tOaQyYyMgHS14gw/8/3xj3+U008/XfMZ1zDSQ9Pti66PJMgIVx9JHGidoPWPn+uuu06uvvpqjTciaCDxAkk0mBiLtmzZMr1mVP5Z9sknnxRSifeU+HxyYWwEMWq7w+aHYu7BAuItWPybz9L43JEyb+CBWCA8S/79xOMyGnFDV1/zc7TZLb+5/heyZvVyOeHcE9XiFLbOMAcIGuneSFkxMcaK8uX9F+7+5jH228TVkViE+wiEIt2rBDskaWCivAl+p0yZErEMnye6UjLxeWHsEs8dNuEdwPefvgM7XgwES+omB7nSHZfgI5rEd6eClF5qnPF4J/Y28T6mG59JJBOiFSk47apJruDzxH7vuRJI3HObHmt5TAIhJIAXtwsKO+NjGGMUnPxgAK519QXiKZkJ1wxMjNvckojg6eQUlyRghjw5tRHUsR7MdlHpVtU4UA1/UYHnC7/rkUAWywbVznjZEJ8n2xurZAosGyXV66QxMVN8qKMtLlG8GOTpmKevc62ToxLcmwDqEuKSNA6KtdBa4obbXyvc4zrGKpzHv6VlA78sp49ikwvANmP9pRS4BXIIIXCLw7laoKxFSm47FGMGm0OAbEViix+Idbata2lrG70Ou6w6crqUjy/G7K4XC/xi4V641JGalW4QdliOMuDuRRk3wZrXAKseZ4AzE1MxyMZJ8b+eltQt5RJP/3Wk9G1VXU8W9KsdgyOB15icYbh2iQqUNzVskQpXlVKsWwSqJVMBCkZnFWtsU1VTrayu3YhW+SQbSlWGI02BEe8tgthyrJnV7AVotXTcD3KwvhbAVHHGIBmYBjCBQbuyuU5W1qwWD11qLPl5Uh6nJIMBkunKrhzM/SAMMWm47knasI6rBVnboKBkw2UyARamGk+9QNWUxIzlkpi2BlOzcDc1DdzB78suu0wtRAxq50QA6Y4Zx2ESQRAVbWvirDytDVzjiDPxVPJprSCJwKuvvqofw77GcgQHVAhDlbHWG247VBvC5e3L/qzqJpkBBs2XMAFw6B8WiH3qMFk0q0iaHTsHhJKWmyyAjO+h+xwZ47juDhOp08kcl5KSIiQbMPFJBEqG3IHkCrQ0GeKBSPWF6j+fZ5ahYk+KccbfkNabbbnpppuU9Y1U7SYxPojKf6jEurKTQY2OiRUXiWn8b65QWXWyjM/cOICjmQX7ySfvfii/+MUv5EtYughGLrv0YvntTddJXkF/qQA497hao1b8rSckAQYBIGN9WC/laFj5It3fpAvnfUkLKss9/PDDamkJd3/znIzFo5WN61nxeWF5Mg/yGoW7v5mf7eNEA0HcnDlz1PJk7UPwNkG7STxPu88/6UPQxDe+j54YuyhRFnZMLjV5u4/jkU7Je0PBWCBTaNdA5lMwhfce8/N38Hs5UEVsY5+UAHQh3B2xFJPAHiQBWhf+ueKpkC3mLHiNuyGiC1S7L0k8pYdLS8MgvBQ5s4gXo5oq+ILELHmCR5LsLklMbhBnRqk4MsoxcLWgThxHIrEB3cr46PjhQcimdOxkDp9M8myQI3OzxYeV3pt9cHMD0GEgqgczcm5fvHjjQQyBAQiRMgI4IE1t9KHGIohYnA9QCWppnLjakA8xOz7M2lHpx3KIAFlUqrnthzeM12FS1yyUiSq1Yc0IX3+xIXg5IQksT6CZHrvwGxm2aJ28s7VUTi4arMDE1MUXxqOHnSfVQ6sk3l6tGJIsxpc9+KnYQwxmzE9LztLTZ0tDv2zxgOUOJ9HqjGLjBweAk+jb4NR+kop4l7raGskekCerwECVa8+UjPZUaf/4Uxnw8iu4TF0HZvMSC+4xrXUf/PgUseX3l2w3SDRWrJQJMyZJSUuFlNSXS2VTFZgBeW39AIXxaAOcBVIUVygbvoZ73pSRstVXqUqWA3FoyAhZ020jDjFYWKCyqU5BkgJFXALa46g4JKEfQzMHy4C2PFm44H1c9zY56MSDZWXzJilrqAgawFUU3+kfXg4bwHoaFygOum/8s/UO8cJ6WQF50S1Vs3Q8D9aGb162Xra+slr++/x86+6ot8nGxfgLVVaiLMUYDrooUaGMNvWlTLR1U0F9Z+tHcuBZc6MtIpk1iJd6eql8sq1M/vb1SvnbrJkgJ7GLKyVJnjhrP/HaOucyP3r6XTkob6r86pd+koWoT9KRkTI2RBfWsox9oRJMwBKcWIbgiQp4cApXX3A+62/GwtD9sTfX2Vr+lDNOlcknHSBpo7KlHuvMcaHSSBZaKvSZ5XZ5+q7H5L1339OqaFFhnBCBON8b9U30IGgWF7wLrrj4h/LXP/5FLUDW80azTaWb96NZuNVaJtL9TVrwvLw8a3bdjnSv0krH60UwYU2RyhB00tUt1LU0dbD9oyeOkUseu7arJZ3vP3xCWbtN2Z31TfIdjBwgTPKvuxVNvXw7p+A9nQL2WU6mMZHVtRbu5pxcDJU4Vhr68jiMq7wnzbj0y+mX6nsxVLnYvr1fAp1v3b2/r7Ee7mUS4IuMcStc58AHFwpqbVTm6LblhRXJ/3rs3mlfc3/4VNvEnrlKfO48afM68ULkAAPVF4XI1uVpSsZMYq401wwWR2aJjB62SZKcbaC29mBGyytpSan6wq1y1+Lb4prU7XS0/yTIN4n9RSrWST4GakdimyTjOzkeCile5lnYpu1EV2/A+QkSwAeMpqAs+tWUkII2on++erhG+P50yAAAQABJREFUwOqBczS3wX0QboRuWJmaALBq4pzizRwtORmjVUHfVF+CdZygiGu/ujWq6w6gG1d9OhbbHC9JqTWSkFwiH41Olrv+/Iy8uno9AItTpuXlBsq8Pew0KZFDJb6kXmxZX0tC+nogBpe8ezDcQt5eK3d8uQwyaZMbJk+iRKW+MFsWfx+AFDTgwcko437Y4T/K67YZDHgP3veAXHfLjVII608yXLleeeYVmQSK2gEW9wlTn7nWBES0gClgws6NR86U/oPHqGvcho0b5L23F8nwCSMlNz1T8pNzAE7dUumukUYMoCm2ZFwbh2RjUcnqtdvl44WfyMjxo2Vq/3FQwhqkylOnykEu4qRssPpx9rQisRqWJLc4sODwgHTGUyXpPUIQnR2fJp+9/bl8/tGncvZl52KNIwBezE7vSOIA3hsa92jPRQslyT1oDXOA8thcF30mIMw2WC+5yDBdTJtAYuIXcPfaa0ur5ZUX/tv9QJR7QinuPRWlotcbcMT6+lKmp3aY41TUeZ16kw76aKMkAPQflJ+vHy2L+9zZ1CKTviqTz6YNDFS37tNVUuPb1meAFE7GdIELl8KVYf5Ix8LVZ40lC5cn0n7GgbZhMovveb5hEdofNntVyXZZcP98Wb5gseYhOcXvf/97GTt2rBIkMF6NLlmNrS7Z0LRVllZ8Iwvffl8Z4egi19vE6x8KHLGeSLIKBY5YJtK9SsKLUClSmVAAOLgOAi5lTMU8FK3lcExW4MAx1wAIjpUkd+HEoVqXwr0UgiuP4jfHcb5vXB6/27a+z6MoxwkuByZ62EYmvsfoeaFxU2HKq/UoiW7dGDcwadmKeyEB01/2tqYwJWK79xUJxADSvnKl97J+8qU2MrNIV0j3tnngurQRrhYunTWyAXh48U/RTnC/2/miR3zFwAVYh6YeK6ymS6s7X9pgTfI1F0hbC6wUtAPQfQwDLzwKJFuKZLi9n9RUrYH1plYyBbSsGKAzszNkrX2zrK6GcsP4ESjMTGYNI2OVYD2eRKd8ljgJlg+6yLWCAMwHQoMWSfDibABBdixgaG/3Ksudo71ZbO1NYkM7hwP0pKdPFzcWEM1J84pr65uSBKU+E8p8LgZiW7xdGfjiQUXuzhomi9d6pA4K++jiAriQlcOw4QcLHCjMoNHZLvYRJ4HFKDFzjbQ1DxZvbRH2DEKw9hsKjooHwgoybJzUwDJUmTpA3i8+QcrTi1AGJA/eNHGXz5SE+hGSlLtEVo4RceGN8ofH/6NECT8/eKZs2X+0bJgFV6moFEZAQsiwDmuV9B8EixZIMZZ8uliOOPYoqQJ98xeffS6HjxwmsgruXRjMghP3lA2HG11pmUhujjhPPEYyRhTL2m/WyrKly9hTgOd4sOSBrQ3/liz5Ukq3lcu4sWNk2ugZUgH64nWr18EdcqsCAM4sfr3ka2n9rEWGjxwho8eNlhaPVzau3yjfLP9GiQQmTJ8oBYMQx9bkkQ3frJdN6zdL0dAimYb4l5KtJbJ0yVKxY+Y9zZkm6SlpYm9IRkxXGkCtO+Kgzb6xvbxZrUZ+Wqh653DCSnpOvD/YX7ISUjlKgZtjAiyY8dhm3FUStmklcyU0geyjOTA7G1xzzqB82X/WjODd+9Tv2vpauOx2t7REEsKAbfV4D3TPQTr8wVtquwCk0QePl0FN3S0N3UvvvXtqqmvEhgkXcj3qqyCE7BqrG+Sdh16Tz55fpEQNpFG/4aYb5LyTz8EkCiz1zZ0KcBKUcWeSE5Yft2RnZMpBx8xWS+beK8H/z95XANZZ3e0/0Rt3d2lTSepu1IUWK7TokDFs6IoMmcDYxsc3tn2MDcZgxR2GtEBLW6rU3b3xNO658eT/POfmpjdt0tLB9t/anLRX3nve4+85P31+p+9ZcXEx9y2C5EhzybF1FGDpTjGBihGos7SG+8HJv5++9G/zK4WeipckpqWL7PZ90X6u6QwO9aT5urnDdpe03XU0V2/iGSugCWkSlU8N12ntzNzm/KXg07epEv4Mth5K4WOIxQXBrs4UXHZVexeN6r58To1AN4N0Tk3n+dMZSbJD3IKw4vMVGDpyMO3RfelbIlhgamO4+WkTFIGpDbaDuRkJexdBFCuRWYJrNf0pKuDke4QEvx+a623MUpO0TA2e3B4pDaSQriAvB089/hB69OpptFQKinrZVZdSs5Rs7ODl29JInxRmNyr5ZkqDi2uLUFJXiWiajAV4+Bl75yoycTlVxwlD6oko/yhuwC7UYjSipLaUhLsvYVo92H5pIRpxpDoPdZ4Ekth+GGtXr8UPH74Za1ri0NRYCW9ybgk+wQghYIQ7TcQ8WG4QTUR2bT1A/6s63NZ3Ejz8fVHkEogSRkO30Fbfh0yUEJ2K6HuTV82gpK18/Glep8OiuYnEsFcWnK0hLL8VS15/0AzRmJvexis9RjALyXLnRqKYVZHJKEBTLTVKJDKksWkmmpkznfZdfY5hOxmyeprpREwajtUPXsU8Z3fAKHc1TRAjfN0wfOwoanE2YPqsaYbxaKyrR9DkicD+g6Zt9peluXk4UlWNsZyLt0k4hScmYOv6zXj4skvhdDgXv//tHzGMayQ3+zgaWIaYnBVfr8TGNZsQnxSPd7fswKU0t8k7nofX57+BaTOnITYuFoVknnbxN09fb6yn38I9999j4sO8/sobRADrhYN7D+LAvv246aab8NXytQwwuhyp/VLx5aefoyinAIPp01FvrSPTTfPJUsbVSnJHoGcgfZu8OQfFKKVPEoev0+ROLagbJaE62BXbSklMjO0D389yXG03nv5V5ZvYYDRp8WOMGD+uWTt9IDJF2rZq+oOJSesqhSdHYtPajacEH+0q/7l2Xc7vH33yD0x55LKz6lozGXcT+KWTuxrcpFvW7NiepYRB9LWa+2s88YvHjZlaJ7ec05eEDJdfWAB/aqZLmytMX7U+jckzH6h6CivWvvM1vnlrGRpqGxDAfJNvuwhpUwahd1w/CsaoV6e5sj15cM+tpSHz8eoiWgZ4Gt/BkWNHYsKECaZMe77z6f3Rnz2KWPrAmcTHvX3vaRsELyJcuvGMraSGx86ofJ/jIzNlGqGbs7urco3/kCSY2g71bLjwHj5/TmRsTOIeWcu9rI77vWgAJcF961lyba1HckMuoulHGUatf4CnCwK437oQVKkF/qjjfVU0t+xO5/cIdDNI5/f8/1f2Xpt1rE+UIfbXrVyL+OQ4xPaLN47+NtjuWoNw5EJ1exNBALKrcpHLw88maTK7qUO/9d0GkuDkTmbJvdIwS24NAWiyRpPwp2mLSxThYBnvx9MLdz34a7gRLMDFuQFhgS04eOQgrctIxNZYcQEjzu8/vI/oUIcQEh6KoX0HGP+WZv6+b+te1umEPoP6IInxKlxaXIhWVYCc9HRCyiZicNIYVNLOPysnA9UVJYhOiIHFL9LEdhHCUmWZCAEyfZTmOzsFIyk0BeEEfzi495BxZE7tPxDeviH0X9pHLVcd3MhYedP0jk1EdGw40ukQvXF7OvyCAjGg9yC4VPhgfwZhW6vL6GtFvxN3Bu9kftCUbfNXf0RJ3kH0v+AGxKQMprVfIcvLJ2OZDRdPwntTKtdU1QMNpX2pfPIi8EEN/ZeyQaNEVB/INGObkhoLN5prNZPQb6HUTslG5LV9Nm9tRF8HYt+GQFhJJnAQYy+tWb4SWceysYsBJntRg+NDpKaKkUPhv3ErC1SJwN8PHcGX2TmYxPn+3ROPITI0gmNYhXSaB5bSj2nAwP64/+GHsGH9enzx8RdkdvOxc/MOjJs0Bj3pWL2cjM2GDRvRk8zvBVPGkxG6G3t37UNEdBR+ePvN7J8b3n7rbTJDB5CblYPBw4fg1rtuxd7de/HO/LcJlbwWB8i0zbl6DiZMmYj1/L7o08UYP2Ec4Y4noJzzOnT8UBwpzqTWiNpDtlpaGdnIm4OdfXBMMhHVf63lJjKb7YmdlQTUWUhSbWNm7heN0BWn1X7zt/8g5EOhP/rS58tQH7qV9TWy7YLIN4PeRXGu7m70RXvQBKNct25dh0CgXdxyzlwWRLlAD6b8aBbCk6POql8He4TQfJTPGDVGjqmZ83ogfCharL5w8SakOYUSIXHhmPvEjUghk/7Fws+RmprqeMs5+1kEsaDWBVDw+BtP00+UkCI1tv1EnZZP59bP1mH5379ETRl9c/y8MeO2WRg55wISvjS7pml0cW05NaBWg0Sp3Ufx7iRMW7DzK7y76RMjsBBYTL17M3qPSsNll8/G47/4pdEWn7MD29Yxq9VqTOVmXTQL5TWVuPeDn3XaZY2XEEGryUSc3ry809u/3UU+BvUyn2xjbDq7SZruZumLxCTxXxOFeLVELPSk/67MkBXP0Ep/Mu2VmmtZfUjzJa3joIajuCA4nCeqD02Gm1BBZmgHfbOKKWQtIWBRObxQ6+KPebyva8PTzlrVfe1cGoFuBulcms3zpS88E+O8qLGg9kPOpoIC9Wh0x8512zB82Aj0DPHH8jWrcWTPAaSk0nxqOH1hWnfhEOOrSBHiEeHTbjrQYchIfIgJEYmiYJhuRLRz8d8HN99UuJVwmyT/4ESJvpNTAzdbSiqrW/Dis/MZfC8PM6ZNxx76tTz/5+eRwBgayxYtxagxo3HV5XPw5HO/pTlHHU3GXPDNslV44je/MvExPnjnAyT0SMLSz7/Crbf/CDXV9XiSULzDRg3BrKsug4uvLbq7CGlHn4YgSvYjnILwxouvoLq8mvFGvLFy4Vf4JYMrWlx9SQQ0YuGmXfjg5fdw3z13obWgHn/+v9cRGBqMwtJyxCQdwUVzbkH6tiWI8ahAUYkVwWH0ofH2QklpKf702a/g5e2J++8kE+b3B3h60dyCPkYi552oafKkj5ST1w60UnvlikBYyCC1ulSSuGvCz3ZuNkN6aWI1RpSuRa0rTSV4H48p1PKgqlcZrTQ1o5Su0uKMGvcoWKlVcWo/CG3EfxXN7GIjohETHYvlS5bh2OEMzL12jnGm3Z2ahj2bt2GSF7VnZFxnjRyBb8orsHLTJuzfuw/BEwK5LujVxTLLKisQGhbCNnDeOH+unDcrtTpZmVmEIa7B1g3bIbSs/mSixAS4kTiSj40OVoPgRIaEbAHL42EsTZC1FgmxSUbC6EbzE18/XxQS/liSy4ioCGrvrOaaOwmyCmq1mmnWod9KiYZXQl8nk7jM3AWRy3XbmeOwmBDFaZEZEAedI6Yxo9STBIEf59dC6a0Yf0EXy/Zf49vCsTfAHzTd/C5JhIQIiBoSkVaLLQiwo4RYz4ZpjxrWRYpNS8D1f/wxbn3gDhzZfhBhUeHtOVV+h1tZoGS6ZAeZx4l9Yl80UWdKRNVr5f8Ga7XRzHoa4I8z3fSv+z1bppW9EzH7Z9dhyCWjzrqiDSPiEJdD891yImqSSdI4C4DlSFgqdgZeBEuT/GdOxHwacOEwMw+33H879m2kX15C9FnXedY3sFFqmbWce4FMrBjHTMmshK6Xw5mrUbkiYlmm9rp2gpafHVPGkXSMnj4Oz331d0TEU2hFAtrC2FyNDY3Y+/V2+hl9jrLcYsM4XXDjNFxww1QiktoAJ6Q5156QXp2NskNl8HHyhBuFQdKm94hKRE51ASIDw3DDuKsQExyNwooiPGt5Cc37a/DQow8h/Wg6AgIDTf9t/bW1Te22hw+Q4EOaD7PG2xpuf1bESChJkCHBh+ZX+43e1U098/ostE4l+336rHvkQ6N6zH26yKTPelJUmjP3h3ICxlgI6iNzQQkz7GXofnubbDXaxttWxokSD27fjz7D0tBjahouuGmaYSiUxzHpfu1Dddp/2OaOM+SY87t/Vp9Vn8531aN1YdaJQ9FikqRlN7GauIVUMuZfAzWCmm/F5tMYq/+GOeL4NbGshNqjGBlA7SP349U8w4/zLK13CSBQEn1kvVzNWGkm5cvatrodauz+eD6NQDeDdD7N9jnSV21+r7zwKu69726zeVZVNOHlZ18lE9KImZNn4bOFX2LRZ4swZtoEvPfae7ik9hJqmRJhLShiYNJgbKZfSPBIB4LCnBEnbfUkvszxow3WtYZ8U5MJzPen3/2cPhpOSKYvzLXXXAcfP3dcOOd6XDRjlglwOfuGuQim/8sGmlzt2bwLM6ZORX5OHi67YQ5S+vbE4T2HUUWNwtKFSzB6yliMn3QBFn70Ob5etgKjRo/EgGEDMO+Jh1BKQID9pUcId+1rDtCOU0dimczWiNEjEBQaiNLiUrz70rvIYz1uPAT279+PXezjlddchd5p/fH6m68TTrwJd91yGfYdLsZf57+OmdMHoE9cI6aOm42NW9bBs3QJxqT64Lr7PkEdzdD+9LPJuLZPAavluFCD0txMJsb4M4kw5XfzSzNZhzKa1NUzF0EL+H/bXmqbaOKQ1jcKzh5NCHZiYF2OrwmcSx8roQY6UcPlQk61lYdVPs0QtzYnock3nofcCeJePjqNNOkbPGow/vLMn9E3rS969+tLpKlyrF+7HvVknKLvfxALF3+GrSvW4dnn/4Sbb7gZD941D1+sWmSYI1c678fERWHzhs30LahGeVm5YY68GQyyZ0oPjLpgLCZMmkAmqpTawgZs3Uqmj3/2ZKSX/Co+RfbrHkQVCwkLRja1fs2UOpYWlqKKDt4TJo1HIeNAHSD6WHxcPJmvHB6vLQhgQEa925OIFJUvxq2apimdMUfKa1uJzMvxtjFGZMRoHhlg8TfmP/K/c2ynmtxISXgpAUNKrG1MmL3Sf+rdFky5krDe0nQpvKbGQLDlEd6hBkJfcy6GTH1xZKDs1fUakwr9PzlJOu/n4c0+alBbiVZYhqFNWQijdnY9mdxtbj14i0bgxDycXIa+t1ij8OWfX8UGouUNvXQ0Lnvs2s6y/ddca3R3wXtzByB1fwHissrRzGfoSFIQDtLU063qsFkLoNbZSHjaVsjAC4dD//9dSfO8d8UOvPfofIwkIuWMe2ebdWjMmV05o1wkWu+Gsef2aSfKz9Q+EcIeNG8K8Q3i2qL3KH1Gggnh7UVfQcNQMECptEfSAAk90t2TCGXUBnhxD8zbkIkP/vAmcvdnkcFyMmthMrVGvhSStSc9w2y77pHgIdt6HHX0NWplueTIEEdBjOLaSTjibeHaJGjNgJi+GNtjGKrjrLiw3yR8vH0Rcsrz+Rx64r5JtyK7LA8fbl2IwqpSY7lw86i5GBTfD39d+RqGxPXHuJSRFLLU4fkV8839e3NoacD6x/cegzc2foTC6lIUlh2nv2MFJqaNwWUDphv0tcX7VmHVgXUorypHQmgsrh97FWH2ffHa6vcxKW0ceoQlYiG1XZuObCOSqhVxwbG4dsRliA2Kwm8++yN6RfVAz4QeSCdIj/ZQARYoXpt8L7Vv6FkWEycGx8pxbnHYc9vH6zQfNKdi9nQGn+kZdSxG93XYsxx/7OSznn7FLhJQg3yKXThPTaxTGj8FJ3es265JEpKqmKh69s2sPrORSrBEMpfrUVAenrXFGO1JQRi/b6rzwDHPOHOPdlRjR0LmtTt1j4B9BLoZJPtIdL//14yADrvtm7ajsVaOl01479W34Rvgh1/86mlYac628MPP6Cg+A6m9hqP4eDnWLduJXj2HYzQ1DVFhEdjx6lE0lscw5hE3UmcCa5N5gLNi2djIfm2WRhUvrQbrMtQhN9uIyAjcdNeN1D65w8uD0KrUKohp8CEssfxJcgqP48v3FiAsJgIVJXTUphYhiLCtc394FZYsWIxlnyzGqEk26XI2TbUqaMawZ/MeHjZNDPI3iO+t8KS5W1lDJdblbiEEeCMCA+wHPY8Ybuo67CQllOXVbqLF5dNcLDhEGhK2mcRDAyGPt63djMTkJEQmRJhDMjOLQBKHs/D4M69SOt2CnolxjD3khvX5x/D+x++hqKIAwQkuWLn4MD5YfJBarRAETO6Pd8rMCWMOtnoySTqUSLJTCyQGyeaJYnyQhLrHVF/XiIPHShHXJx6b/EdQQss28TB1pkTci9qXOjJTzny1cFwtPK786QybHBiCQTWZ2FZJTZNvAkvXmLeYw7C8qYqMUSrCI8IxaOQw8mmMcUWzvSEjBuPlPxHh7pGHIQSq0OBQTJg6mX5GI8gMbcQ9P7oLMy6aSc2XJ4amDcPKZavxywcfp18XYy75BiA6Lpr+TSPxjw8+IuTvanhwPKdNn0ITSsLDUoumnrnRVMzbl8ypISyodaRGLSg0yDDar748H08++msbQTZiKDWUQ1k2fU/e+RDbt2xn85sw69KL4e/tR58yd95LZ2YzQlpOrahioOIyMjNnSiLYFJPJzhiJWNT9dnt6x/sVsNGDwApnS4g4lmH/rDKkl5I0VuWGeBGOmX9CiApkTCTFRZLpnyS3NTTFqybCn2JpnQ4pyl62CBgbKhY1kU0V6NuQTs2lH7ZW12G3exIHiItca+C0yQnHdq8yzFFQdAgu/MmZA4uetrj/kB/FFO3qF2n+25vk4lTGNbifQyJ3ca3Mf46AE0Grp1dMgubyn0laf/tX7jS3pk4eJBq0nRnSFzEwjdwDnMksWaiVFfT2t0lisJq5jwoyX9qVIEuQ0e5IY6s91IWMkLO0hdQWN/Kam0cL0vel463fzceONTS1Zeo7fgCm3HkxQhPCT+mfnhlH4lyIbPIZbSWaqJuFDIRBbbQR1wow7sEYbAWlhTiYfwQD4lKNQOzQ8YMYkjAQF/efYeK1vbP+IwxNGowL6eu54uA3eH3D+wj1DTb+pxsztiE1uhcOFR5DXnmBYfSOVxaapa21n16QQY27E26Z9AMcK8jEwu1LMaXnaBzmfrx013LMHDiFzFE8Xlv5LlbvXYNpfScgl8xUS30T0osycSQ/A7OHzkSYfyj+uvQVrD+6hQiaM3k22Pbh9jFnv6VFkX+VtE+aPzFIQt+0BRDn2aY51MtZJGmtzzY5jn9n9+p3tUNt1A5gIUCPUF7F/NiTrEUsNIeXls1KAVOjGDWd0Uo6pm0vhhHUJSf7veyeGK5mno2DWgsQ6x+NnZzfXM9eUt2xPv3anbpH4NQR6GaQTh2T7ivfwwgoEN16+nycnBQIUBCkJ6cPP/zQBCpUsMdvk8zGSal+De2ms7IykeY/2JhACYWroqwMe3ZsoL8IgRe4fw4cxICwLT5Y+MVncPcgge86EC7501gNNRouZJKIzOXsys+uRJIiaIOzB7/TebPFhU70bjYnYO2hMqkKiAjBoaqjNPXiBlwvaRqL4W8iGNesWE1zogjc/cBdWPLlUmz7ZiuK6UxcTmZp3i8fxLGjGXj59y+gbw/6ISUnYMjkkZhIn5dySs69WjxwZN8hc3CJKdPmb04v+2Dwmhe9fEaE9zdEc2lGEXaQSXz8D08YHi4vI4f3NvHAt2DW5RchNikWr//5NfzyiV+gd1JPI/X7yaP3wKOuAjVEKGr1J4OXyr5kMs5TlDcKgiPw159+YGqb9MgPke6T7HBsdjxAJAvscKSybUqZ+45wnFsR3icOx2n2EuYVaqSyOrhqefBRVstczlCceQ1bLv2Mqsu3oj81LYOsWdhORV2TdwIPSZuUs4KMRGhgPJ74/W/hSQYlt6qY8SyqkDZ0MH7x9JMoLi5BbGIsQRcaCavrhxffnI95d9yN1QRg6JPWB9fcdA2ZHG88+quHcexQBkIjQ8iAesDL3xtjJo1Fr769DYMZFROJqKgoVFVXoTd9xARGIB+w63i/TwBRDdm/S6++1DDF7tQi3fvIPGQezTIohuFkQnNq85E6JBVxbMvxnOOIiIlGEOM9VdbVYNSEUWRmBbRAe3oOWh0ZCWl6JBHvOIgcEIckJ+gwrxBKyWnGpAOebdD/rpIIC0lKjaTVrB2RGd8u2YkTx9yaLTlJl5HxF1EV6B1giGEbsclZpHTXoj9qlfxoainQCeU9XZ9UD9k79p2SXDLKyY256Emwk8O0/d/WGsKnUWFqz0x81VbW4OPfvG4Y1Dm/usGgbTm2/Vz6LDNCJ2pSKWVgt7qe/9P1Wc+k0fTxXUU4kxHT/H7bZNYdszcz1MCBb/YY7UzCgGQzm6actt+aScC30A9I2mRpP00yVdrqFeXbVb16HvRsaA17kACmvqNNAGVrp/G9475QXFiE+b9+AWsWrDDFyyTsmoduhE+PIFTVVtv8UVQPnwd7/cZUS88P+9/aBhUoDbwzBSMWMkdmLfOzGJSnPnsWPl7e1KLXISWiB6anTuKKbUSoXzBm9puMQbGp+IjaJE9qkqb1vgAp4Uk0Qw4lk7IVGcVZGEOt05sbPkRJVRl2ZOxGn6gUhBJMR8OhUdfOaaF57fheo6kNSjDPz7I9awiM04QdWXvRK7IHkiMSjXDl9snXk9hnsFSajGk8GvhE9o3og2tHX479eYcN81VLBqiMjGVdLZHauA+yGtbQMYk5tgUY5y9mKmyMsjRKp2TueOv39k3z0dX+pevuHH9f+vbKhF1hO2QOeXLbbPsHmSeORSvBNIjGQT8lMv72tcbWCnBDYQpEB9gFNhLKNFH4GNuQg+GE0S+qLMJhj0SOp8hfHuTdqXsEuhiBbgapi4HpvvzdRmAno5Q/9dRTpzi3Ksr4yQzSwoULTYR1Be37tgySIdS42XvRXOqBn/8KG75Zjtfm/wkPzfsJklLikTpgHC5hMMG87BIejNwK6bNUFXYdUerq4RUeyWsixLjRMiApA/TwENSx4mB2J1MwNyssgTvhFEyfI6r4PWgG1Ey79+PVDBxKZiTBPRoWMiTGvpm/96LT9KfvfoI//uYPZNqyEBESyb66Y9vGHdi9bTe8fbwQTeI5JikG4y+chHdff4fQ0EcJH16C6VNnUOrKA9viYQgPUjRsnk2qJmZQ4ACv/eU1YwoSEhiEiRMnIZz9eJ4MlwuJigIGdJXw3cPTQojsaEy/bCYyDqZjwScLMO3C6Vi7lmZoTz1HjYaFTIMPZt9Mfx4/TwT3DmPPnbDmzWUoOnYcg2aNQBIBLzgwZ70AcvZlmHti+8ajgoxYE81ZDJHPQ8su6FMGjTSbSsbUE1lkbFsrtmEAg3wOq06nqVo6x7oNNINDgFIPhJNZaKwgVHpjFQPa8rAv8UASTXBSIpxRX7mPbaWp35FWRFI6/usnZ+HKA/vxyl/nI5FoX4OnMZgkzdPC+kehiRLuspZq5BEEQ7MfEOiLcPobWKlZ2llyABbWK0Ism9JFBXr14NwW0vxOpKkYlkLarNfRjNOPTEtoWgR9i5pxiPDyVpq6yBQt0McfYWn0qaLpSn7RQSMV12FeRZ+mqiortUyMoUVn4HrZxp9MxbAOJREB0tooHpPMfQwjpXHoIqkYeXlZSRCUEzGxuZk+dM0yTWIPCSRi04p2cTMvi46UVlJMqQgKO1GhO7QupCUSQyfAEz+Oo8aHFZqktuqfGChpuirpN+Z4vy3XiVcbcSyQiQZEN+cizb0ZBYxHtqHJB9UuIo7OzByptAW/ex+VheWY8MPpiOuXdKKCc/WTbIfMguli0Zyh34Yw5Txp/A2TIKd2WeuZMs90M4UZ0j6RCD20YR/BaOrMHqF1YL9fZUqrYKT5bKIUGTKzkzZGD4/qlybInr+rGkVEa/3k1BQy9lkYfLQmuMAkSxBIzQfPvYWl7y3iHtyEWO7x1z14M4ZRyKRyK6yVqCdaWT2fA5Uj4l/X7WvUmP2x21qvYhBd+TyLP7A9bxTIsI547gWXDJmBPqE9EOQdhKiACMPM7Msnaib7qOdWxHslGRKhkEoLpaCrLQyBIL+cytoajEwaCi8GW96Ws4caJPpNDrvICBdsgCz2ntNcl+EZ1Bb5USlJg1bPfcODjJcCMhfxjInzi0aoN02oq6hZ4/NsoQblWGEWXvnmHfgQtTU5LJ57vs0/x/jpyJSMfT4lsR6NhZ3J1Oar798paSyZ2pkT1aHNpKvUlr+zn93ZL1/GkXPn7Y0cX2eOhawqFGLg5GTazfyeRCG0OGvfUFxCebgCPrQAUHBZzbzWgU4wrb2mxhZqq0sxwUtG4I3Yzv2x1jOYGjnrycV3f+8egQ4j0M0gdRiO7i/f1wgcJiCC0JWef/750xaZk5ODl1566RSm6bQ3cSP2oIlbAwnAYPqEBIW74YY7f4A//Pr32LZrO35086343TPPYN+e9YT4rMElcy+m4y39N/wsJJLDSUCKENOObd/Q9bnjDt5Ke//WBn/UFo5BtVcRehF04PZ5t9Iwmvdw05VEz9nNCXNuuJxaBj9kVGRj8IQhiIqJQkF+AS67bi7jK7lTYxGJe+b9Fju2bzFMWd8hKagmyEPq6DTcG/0THD1wFOMmj0Wf3qn0k6nCxaEXm83dNI1NEoGaNjgNdz18jzEx0bh40AY/OCoE8x75CTZv3UoQgiCa+fkiKjQKYXGRKKuh5osmHDfe80OUFpQR5jYQD/3qEWzbstUwdH0G9SWqX54JwqduVxaXY/nLX8JCU7Dpd58dPLHaY0+5ezPNx2gySDrIaghYkFedjzD6rfiSgD41SZLpiWwySS7lOzDA4opw8qsd5oLxoNBM1RJTJMfbnKKMEyXpoZKveeULf3IibHugXyt+//TFuPlHr+Op+5/E//7jWUQlkSHW9CqP8pMyaiT878Ete1BTQpCLMJrd9Y4hp8BWU7uhTIawInS68osIqGRfbJ8ZpFfwr6Z6G5khwsAq5oeO3qZ45tQ9gls/XlVI87NaXrH9ad2YgkzOU1+US4SmlfXVkvFyJ+Ole0x7HLKbfCQLrLVOKKn0QGWVDyHM44l0yyCJFpp3+qaTCGY7z5A0Lk1kTNzZB1v8Lj4bbf0XUak/OXznk2i1EuI70CPAIEQ6EkMiNBUwUv5FtXq2NFCdJE2BdINhTUXo71xFx2g/+h3VodAjyAB8iIhUkrkoh6/TtPOrzdi9dCuiesdi4i0zO81zzl00DJIGRP+7GNyuOs1bRBiL6TbMbVf5znSd07pn2XaTK3XSwA65Va5MUuVjowfNmN2aPdaWzfiA2JvN9ujZ0LrqKskMrYC+IhU0NXauc8Gqd77CF698jNqaWu71IbjynuswfvYUI5iS5kVEsCcd7IMYA6eYoAsmSLj2adMcjRmTHjsx97pM7adjkkBG61nah0SatvWJTqGAghoMqXw55s317FMDHfytFMRQS5YYFIuv961BdkkuIvzCcaQsndpittWdpDnr7R3VC59s/5I+VSFICI4zTBYrIJNjijOzWN1sNb40Nihr7oP8Mdw3FAfyD9PnZiTigiKx5uAmNtcZAyJ7U1bmYrTx2zP3cE/wxE1jL0e4fyQyyISJIXChU420Ym0soWP3bGZqrFvCFo2tOAeNvxkHXnd8ljvceJov8jVrkflE2/CyOFPPt11jmjO78Mdb8ZTYtnoKTjREJrWZAdq/2t/VVicySAbQQz5K7E8dz2oFXPck0ytTQvlVCeCkmQyzW0st4ltLMNCtDnG0RthWWoRCn34UVtFEWGYg3al7BE4zAt0M0mkGp/unf34ExCD16kUb39MkoXspovmNN96IV1999Vtv1HKovefn9xjTmh/c8QOiqfHAo3/KvF/8hBIiJ0TS6fZn//sz5BDaOjgkFD4RvtictxhuUZTOl6XRFCGwrVUi0CnBa9+Vedl81jVunjwgWxqCcDQ9gnDWdMaNsCKn+IAh/HVw7aDWQY7F2QQaUAyNADcfRMYkIjKsP0qKg6h9cMXBdc0k2n0Q0ZOmGlTxHMymHXllFoIiDyIuzA0JEwmXTXO0FXlrefB5wOLjjiKawBn4VG72mYQob/al3X1Pb5ol0dyKSWfSxpIdtNMmCMGYeMZfakQ5ifCKxqPm90a3ZuzJOUKJvy88QtyxNGst/VNcETUqwRDfe6sPI7uywBwkOnAW/ekTE+h01gNz4BPUznKYss7mJWdfpmGyQuLDzG06hOUwW1BTRKKavlP0kTmZ0FdGZ9r85/gPo08WD/tWm0T1bOq15/UgU5HibsUVA2KQ+eBY/PypFXjujkfx8StXw8vTcatzRkGRG6pKEzF+yGRs27eTsOaljJ8UbsZH5RkCrm1ddPysHx0XjK12ESmO1w1oAiGFFc9KkuazTYLZzijPM/4+gV7+FPiT+FG1fBFTU0tmpZy+P5VWEhZVhLyvlSawBc4BdAb3YKBcmWQZAq/rmjUXrpRAB1EbF+UbQeJCeVU+mTtKYPMZaLiMdWjFifAIpW9IAu33hZ5XQAk349Mbgqu6jsFjm2ro70CMQlPGqQSw1qza59tUjYEuRdRk+mNNZTUyaOoSRMImnuX6cL2SbCLjXsv1mUvNFQM5m2Qrr4LM/sLffWCCsMq0TpqAk5P6ZOaLP9jXmv27Pa/t+slX7b/+p77bKdGzbJ+WJf/0rz2xKLum74w+SbxPGmxpNw6t3Wv2h5i0BDO2jiNotOhkkOzaJGYwSQSzGKJ2YppTJp+jDu1pb9iJD3UEOFjz6TKsnL8YCvgqlMKZd12OydfOQBgZCTHvpswTt1Cz64NmzyaieJYZyG/ju8Sz4mSGyOEWw3R48PmU75MEEe4ENXDhGtQ/SpmMyZ7AWrSuW/lSz7U5OLofEkPi8cqG97AmYyN25xxAHIVTCRGxKKgr4nu0YZgm0YxOgCQi/MWYNPO5qudzLfQ3o03mni1fID0XCmw+jsGqd+TuxQebPkUAn/k9mftx5ahL29A0bcZgPcLjsOrgWry0+j3Kc5yw+ehOTEwdJ+6HGQzn49g922fNPefDaA+poVHSM6A5U5L279vMicnc9iINnZ4/rSPtFwaoQwxoF8msg7a6lcUwOmy/YZLEOXKL7CgUaWt0e3m276qLHeG+RaQ+MseKIejLMRZzxEk0VgtVvObOM2dg/TH0pvl2FE0gZbp7uCwbByx9KOjhHsN5OFuAivamdH84b0bg7E/u82Zoujv6XUZADJLMzx555BHGBTqAPn36mPgV0dHR7cW+/vrr8PLywhVXXGEYpPYfTvrw8MMPY/NmG3y0foqJicGkn83GMfp7SFrZUFnHDY+xLSjd1kGw/sAuE+TSM86CHEqrC7MP0jGeDue0anCJ+AauzZR2UmooRktHk4gymU4o6TDe8vEawsbuxPFjuRg0nv5Ljb5U+csmmgSoKzUJrpLM2/Kbm/RCCV8r4y+0NGmj1mNl29CdnHloydSJ3/W78hlzD5pMmHIk5TcSVRXimHS/0kn12C62v9p+ZV5zgtsOPFNnew59IClDyWbCmBSkTaW2hhI4u9Nu+vYj2LVkCxm4aIy44oIOd53NF2sFgQfySpA0NKUDQWInzszB1lWBPPRayMCVBfQ2be0q2+mvcwxIiNRX7sRA+rb8ZO4g+h0V45WPduNJMkpvPT27/fYmjlWViDYSLatWLcfyVSux8NMvcPmtV5nDvj3jP/lBxIdMPMQwfJekudUqMMQICRIRFcZUh2tVTIps622rxJ5TtTl+1neHJEm/jwW9xhL4QnF6mFVan0RvongVt2L/nv2sg6YrNNNMSIlHdFg/7C09iCIyeiE0SYl1j8DRzYcQQI2lO5n7TDJwaqEYdMGoK/aIiFE3OlerrfKJk/ZJzKMr6yG0CBLIVkWT+NtbU4PDFjJHDI7cL6An6otrGeRYz7gTUvr1wuC4NOyiAKKEdQscQmP6jyffRF11LS56cC6ik+PMuIjwlP8fqzPPs3C6lKSFs42XJMpG3m2IVI2lq7QpfBehqjVwXiXOucbDEMsiNpkcHeH13TyrHM92BoifM7YeNmM/7PKxZv8SUa251ng6JhHCEghoXhSfRmXZ49Qon9n7HG/o5LOQ8pY8vwAl2YUmHMPwOeMw5tpJxvfJSjAdCR+0Jk5J7E6Au59ZcxIeKC6S9j2tg66S1kkFY98MTkhDT/oTBXn5sU88KNgHtV0mdMG+gbhyBJFQw6MJxlOJytZqXDn2EuzM2IujNHmb1n8ShiUNgLXFSqECGaTAWPx0xp0ICwjDrvJD8LP6oH8SQ0XwGZDZ7syBUxHqH0wNcQN8Wd/FBFzw8fZlcGY/3Dblemw4vBNlVSW4edJ1SCPYg3ifCwdNRhBNeEN8EvGj8VfTv2kvQonIOpZoeX5eDDBOhmFKvwtoSRBI9E/pYMXhnUhmHtrmW1cNMAbnUHvA6cbnRAmdfNIz14kZXCc5zXo7+bpZP1xDtQTrcW6l9sewqPZc9r3NtqNRJ2QzR2Sdbk48R8lUSfvmQ82RQBskbK3j/l9DrVELhTeXuOUSpTWZsZBasItAPhksv8xjIOhhjFpaH2g/6U7dI3CmEehklznTLd2/d4/A6UdAAA35jA0TERGBa665BmPHjsVHH32Eu+66C2+99Rbj9vhgz549+PTTT/HKK6+ccYNupIO7nGbtqZ5IZlnlOfxq2+R0kOtPsKdKOg5LhBLWtgfaCUz7dxc3SrKpfbHQjKKZTItMjBp5WJRQc/P0hY/ix3fdicdffxQFBQVITk42Zf43v+ggKmV8o8effAJvf7oRN/3tXtMdERAL6c+hdNGDV7ZLFM2Fs3zJsZvXEcHOMYkJDbQwVhJNxc50KDl/DyYPpX4DsKqGJlvN1bjo4Rux5sCf8dHS/QjpPxSXXz/L1jQSTBWhzXj3Ly/hyO5DePLJX8ObNv2zp5xgohz7cK581jpIz0jHU/f8D2Y/8QMkDUsxz54ize9aswVrGKNrzOQLUFRYiK8WLsKlV87GNH7Pq8ynyZEXPBlrLIOEiTs1AHEhiRRI+BNWQYIBoIKIg7nVx+lzFoZQxrUSfVbHaPXZlXlkxl2MhsiNfgMhBERxacyEd91RRFJzFeJNk9RDeXjvlfcQTWARD4I2bHppIyZfNAmDxw0xflU+Ll5476W3cGzLIaSNGYCb77gF4QSwEJMvuHH5PrmSKfOj74e0AHreRRM3k5GkWIJNaTWaPMXWEmHt7+ZHApH7BbVe6eXZKLSWnnFtnitrQP0wDBDftWeKeWmR4IdrwyTumfI5EuMglE47A7Rnuc28Lq0NvU6w9038E7KYzHn11574UXPOqbAllalZ4HzYy2vPqw/8XQxV5vajZIw+g/YSMVqDLxoJQXZ701fQaLra6mlyYduE00xBh00DoSJYCJM0+yE02ZQAoYaaTfXF3NsFkyQ/qWNlmVyfsQj2DkZmbR78idIYzDWse6XJ8qL53uTEMUivysHK3A0Qk9Y3pAcGJPbDoB4DeXbUm3AM4a7BNPXygTd9FHsGJhoG/1AuTeIo/In2iWTfnXCw/Bj8/H1QRoCavDKih9LHKDYyBpU0Iz5MdDohVo7tQyEW16nQLjce304mwBeRZM4KGspwOC8TEf5hmDl8mtHemNhn7OuR2mxaJURQG9SCrIrjXO8O5mMaX2l62sZI4yQ/rgYiDsosz42+r2J0pFGxjaJyfL/pZA2SY+l6Pqup0TGriPuGG9eiXbiha9LCC8BD/Jxm2sW1niAZHvQD8zCgHoL9ljl3vTRohEef4JyF3gTY2EdY9l1uSbB6JXP10QyajLAg5M2Cc2xA9+fuEehiBLoZpC4GpvvyPz8CYoCEShcUREkzYY6V+vbta0zpvv76a0xlbCCZ1t13330IJQz2mdIf//jHDll0eD+1+QVzGPLFJG3sLtKiOKaTvuonk4/SQUnOJVDTgW3hf0aKwGu/eh8PPfQQfve73zmWcs58XjVhJQIDA7Hpo28wYu44bPxwFQoJzDBw5nAkDPxujKDM65RiUuPbx0vEaKhXsIGGthNl7T/+Cz80+yQwqrqNOnvgxafx00vuwEvPvo3IYQPRd3h/s2Q+e/t9bF69iX5fNv+mm2+++V/Yov+soufOmYvExETc9vcH0HtIHz4URJEi3PFAwqdff+cNJk7X118ux8bl65CW0gcrFi0ncUt4+OQe8CXQiCcZkeMHc7B+8wbUVtXSN6Qek2dOwsReo8iAZWLRPxYSfr0GA4cOwJgLRqGm0orVi1bj0EH6Jfbtgdnj+yAkoB4xNC1tabBg69ot6Jmaglvo46f5EPpjTnoOmbMQ5O3Oxnsfv4nXXpwPH8Kuv/z3l+gHQsTIr1YiP/s40Qp7Y+z4cahnIObNhLfPzsjG0EGDERsfhxXLlxuhR0BwgNFg9x88AJls35LlX9JfrBZDGZC5Z99Eo3yVyeA/LUn/z5re07eGe6IJgMy9z2jW2rRJYmDEJLVrGvQ7TZGkgRGjsH/1LnjT/DZxcE9D6DcRHrmJqHbNBChws1Aj12Y2pzG0/29vCOsU49qm3DObsIh1Eb+qL+9QNpb99XMcXr/P3NJrbBqm33Upwug7aJL2cbZHSXu2laZpfi7SmrgSNIWmUhT0GE1GGxMkpkeaKmcxUUynm1f9Ji2lzPLaqmCMsjqMjR4KD1oNSIgkE7nDxenYWLobFcTgVFyeHUUHyAQeYlywEPpNhiIhLMagOao+OxOo/jVR26VgtFmMm6S+6rdGCiR0VIm5PF5diPiAaDJUCegb1BNF9WVYn7edBL+j/2C+aZueQWk+M8iodUgsq6GKMY/om+RODXED22vTLmvgNHTsmTrX1kH1qYnPnhjWRs6xO/88CattbWBsKEk7vuek+s264ruZ87Z3x2rsvyuvfMiM1lEZ2AWjDdYHJqHbeTMUhhfBj1SW1rCJySYhKkMFjHXKxvDIWGSW5WKnJQ11br6cQzJQxrSxzXy7bRxOty5MZd0v5/0IdDNI5/0S+P4HQBuPtEeOKSkpyTBDx48fx4IFCwjRXIylS5ea/8onwuj999/HkSNHjKbJ8d7OPitopYLGNdTQrKqcaHO+RBXyJTPWtvl1do+uaZttol9MPTdhD8Ktms2b1yoIVNBUVX/OMkfqu9K2bdsw5eJp6DtpAL5uA2aY8R2AGWylAu0MEgEalGRWJd8WxczRYf1vTZRGG0Q0TnZoZBDmPfsofn3TY/i/u3+DZxY8T0dvBvL9fDWOHj36b23Wf0plCQkJ+Mvzf8GHqxbYGCQ2jBaHJoZWHU2Kqsrp20RoegGh5GXnYcnni3DJnEuNCdCSr5Zg0LBBqCW8/spFK3Hx3EuQmZ6FxR9/ichbb8YiBj1u4nz36d8ba5d8A7d6anmIMrWdYCJjJoxj3K8d+LC0ADdeOxYBpcdQ0tiK8soqDBoxkMCJJCD5N3LcKHhN9ISV7Vi2aAm+/HShkXjPIBpjVUEVNm7ciFKiC/ZMS8HWbduNu2BsbCw2rFpv9hhfMlKL2eacwjz07Z+KDas3orG6EQE0UVrK9rt7WRBEYI41y1djlNNohKYEo5gBdkWInTeJz4bdb0h7pm0fPEHIOo7D0c0HUUdGeDjN6+yaJleBMlDDJIj9egKeGOKfPi1CU3OXRoLMiZ57XVcSMWtPqkvMV9nxUqyY/yV2LSaADfPF0rdJIDEJRJ/skNq2DxHDjSTsywRnzXUTTA1mSx2Nr8jACX6fHIvxhSsVgibNr8QvfRsiWHkc27e7ZD88GPctwiWE66IEuYxhlGPNR6OFZoXso0xKZXWQTK1TEgNclxIV85uj69UreLl4Iyk4EVGBEUjwiqaWNBzlDFLtrHGgVkz3M5vRumksVW+EbziyuVYLGDNpSPJAA+1f0yQG6USrlJNqpQ7DYv+iMqvKaGFBv1k3DxuAgamkLYPRsjmUJsGVi4fK0sASdpzMhgSGddSMUYnUIWle7AyKfe7tGdQ6obsqyZeqq+RNMzjWqG5zL6g35sfyxzI8s9E0nuin5kLMruDY1W4xStoT5McmKwTFqlO8N/VPjGoQ10CgRyOyivLg1JCPQdGMQcj53+qWwHAePqauGlqWqCytTTGCApHX4pCfZaNBFD2xNrvqQ/f183MEuhmk83Pe/6W9zsjIwOOPP47f/OY3EOGiJMaoqKgI8kGKj4/HDTfc0KENW7ZsMbFoEhISOlzv6osf4Txr6upRtv04zR1SGGMoHU2p3DyDvY202ybFk4Ty1I2bgjOq7BuM6YP9ALVS4h0eHt5VdefM9cjISAZzbMDi5z4xkL0z510Bn2C/79y/XGqQBPDgH07zKiYdrJJkKijhiePvdNUIYUk0TudEwOnutP9mjjnzwsO1mdLbJn6hD1j/MQNx7QM/xFvPzMcf7vkNfvX2MwwgXHgKE28v53x4T0tNw9uLbeaVegbq6A+xceU6AldUEBmvDt4Msnv1D642KOGpA9Nw+XVXoJRAFvTaMeZpCsI7ZNRQzJg9E9vWb8WaxauRcSydkPUVuOHuGxksmcF9Bw1CWU4JPvtsATypVZb5kydjzBzOyKME2xkBNO0qb6k3GgkRbZUVlVjw/gIcI7Jj/35pJgDv8qUrGFsqj9qoQYiIi8HK5SupGXDB2GnjyVQNEn2HssIyarZ8yJT1xaiRo41PQnUdCfpxIzCBcPquJOSbqwmOciQd+Yyjk9w72TB/1horjucVIKmHvyH8jdO/WT/nwwpw6CP7rGdUGgVDDFO9ISZGY6u05+tt5j11Ese7PVEbQOLY3dOdZloETybT0mA0IwwCzdAL3tQyysSxiaAr8vWSn5g91Uqj+PoSrP9gFWPXNSEkPhyTb5+FPuP624hj1t3ZniEC3ZhVct/PozlnuXsZzXf9aNLmzRhIldTtUJup9STGQzSwvQP2ir/tO81I12VvRRMDkUub0UwTNk8S5haa2tnLFNHuQWI7n2Zyf/nyZfh5+tA/KIjap1pjFnrDyCsxs+9EDAruY5i0BrZLfj/lDWylhRowAkrIJ0nw4NG+YTiSeRh7s+mrG9uH5n1EXCXstWZBcd/kX3u6fVR7rVeID7xkxsw54Sx26LlhbE5Z1zZfPQ2J5k/90ZlJnQzv59y3JXM+8quejRaZNsp/z9TBOhXMtY1ZqaT2yREVTiW4sryeZBbjySjKpE+pxZW+jkVHaHqbbzR/BtGQ5dnmTG23LTvDKEmjyXnUGe7GevwIgS5fRjFHWlOxPlEIR5AR7AiJtLJ6D/w9QrCjqgGVfJfZXR1N6jQ+Cgbemxq6KM8QA/st5r6e/sd7iw6hsJahQNp6rWGyz7HuszGRfOtO5+UIdDNI5+W0/2s7LSbHgwE5X3zxRTz44IPGf+iFF14w5l2TJ082wAz9+/fv0IgPPvgA48aNw/Tp0ztc7+qLDgKeHIixhGHu7NlYvGQxNhbthR8JdCHZWYhGJKlWtaRHJzFJ2gAV08LKA0uHijZjmS/YNsSuajw3rkuSJmjcnYs3G0f9kXPHf+eOSRJcU1aN3uP6tZclE5JK2tD7kJH1JxFz8hzYM2ou5HRdQj8QHX6hXkHMq4PpWyZKFnWANrFf7Bal2e6oq+ThWBUAq5Xob955CIk5hotuvxSHdx7AxiVr8dpTL8HX/7szhd+yhf+R2cxabxtmfXanT17a4P64+mYyRZTEBwQFkij0wN7Ne8x81JLQKGuoML4MhoQRES0CmPb/xhme8yBTJ8Uw0Z9iuQiC35kQyTXV1VRPOSOP5m/+/oEYPmwA63BFIInDUrpNe5D4LCsrM1D1k2dMRAyZpcP7DmAzy9q7Y5eZq6mzZqBXSgr9JuqRm3/cEHMNrNtZfjJE02oRd81/lE9TMkzpOwkrwTc30fRGAhGRffW8t95ai8K8fDQEBKJXam/07tML9VpvZ7Pm/iNn9Ls3Svug2Qs1kEx6NgXGsH/VbngxYLLM6zpLxleJc+BKmH7jZyRNB4vgMuIbSQwR1BzfOmsdmaKVZI6WGsAH3xB/TLp1JoZcPMoQyDKN0z7hLKqY93aWXC2M2UXCWXNZS6Jce4cnfckaBXrDCl1p0s1unJJsPeqc8To5s9kjuZZbXfhc0MrAiZoKxbPT2NiTNCeKlaaV5evlg8cu/AmGJw02jODLa97GkgMrMDCuL1LCkgneUI/M0myeNZ5IDog3a9eZz08DmQbFULO00GyMTJ4bzywv1pcYEIOy6goTW6yosQy7CvfxqHMwuVNnTjTFjLmbBxkHnmfG1+uktWza7ZDf3gf7e6B2iaYAAEAASURBVL2eYe6fAirS38lJjF2TCzdX8bgOFGOT5orPcD03XmmGNP7t5oVsQ0pIMuLdw7Ho3S9wkM9zCzXEI8aPwMipY4z1hlAqbYAuXBvcL8Rwarwb6XNUSUbSQibRlXOt2EY+9DkSal0BTSHly+VBPy8fT6LTrtyGjEPpGD9nEnoz3IYbgWRc/LgWGV+tnoylnnshdfYP7QPvWgv+8d7HyDx8zJjqTb9sBoPI9zG+YsqneHAK6l1GeHlZmPgTHc9xzk8el+7v5/4IOCz3c7+z3T38943AvHnz6Pz+JGaTeVGSid1f/vIXwxx9L63gPu5GSOys2gy89fYrBG2gRmBUDIOCSoNk2+SFVtVAoru2zQH0xOavo5+27DT9kXOwgv6dT6nBakNXm3n/FabbRmrMEflnD4PcfRmmHEf/I421nH5LeKDJFEKHn87eE3PAM56TUMs5kASvmsxUgJz7zcycekibChxenGmC0UAipsxag+oaCwmuMNrhR5CAptkNA/9qfi3udfB3IgRsvQ/rrcH9v3oU8w7dgUVvfIbIaKK4daf2EdBc+JLA8Inyw/7SI4ztkosAMplaG22Pk/HrMIzVSYSU5lTmK4GhwUTA88CBnfvRp7UPFq34HGFB4ehHbZAk53NuuhLlRZWMQUU/DrcmrosmhFka6AfUB6uXLcPY4ECkLluDgdU1fGabMORnT5h5fPS3P8OEGZPRbKVvRW0zCvMLGQQ5A0HMn3kkA6F+IQzC7I3mfGkhW8x1fkIGtcrRcVHIOpqFEDJmcSnJiI6NQuqw/kiltimf5XjQNLfWqdr001TWPiLn4QeuARG4LYKI5z/Nq8zraqldH3rZaJt5WCfDYn+m5VMjjUA9CVwRmMZuk4MqJmv75xtp0vsFqooqTCiAqT++GKOvnmgAAuxF6n5WadsC7Bc7eRdDJjM+BRhtJVFOZbEhtOXjpOfentQWaZyceQ4Yn1PuR4KFtvnn2HOd+i5thgdjwpkNSg1ioY7oe7pfDJIYHhd3AvCzDoVlkOmdnoPeYUlYn76J35uwdP9qvL3pE8jMq7yGAAJ9RuLGMVdj3aHNeGXtBwZd9cohFxuwBFcylmLql+1ZjfWHtmDO8IsI6OBva6DDuGi87dDc2rNlYleZW2YEX75RAURr5UAof1eJ92iczLPMdwE7NJGJs13t/CYxSRI62M8I5RVTJaZWWjOZOSqJSVLy4TncIyAO777wJnJzjvPZn8t9uQWvPPd3BAUGYPzECQyDUYQaMs1CogsKDkZBSQHNe6sRFEqQHUWNJaiLTBObGHuqinuCPxlqPzeG0yCgTksNYdPLOJ+8v54ATuEUyPZkDMGCCpoZsm1jIoJxoCIdB0qOINwnGGHuIfjT0/+HQMZDvO7OG5F57Bhee2E+Hn7ip5jYcxTKKstRVlyGoJBA1DjXMbxBOeJ8Y4zGzHSo++W8HIFuBum8nPZ/fad79+6Nd955x/gauVE67W/f6Luo+osvvujil64vy+48ZgIdW/MqEJoWTydiHyPlktRJ54M2fhFMOg1kzuBPh01pG4ReZY9gLhW8kRhysz9dku+OkPfsKSoqClOmTLF/Ne9r16412jJpyexp3759+Oqrr9CzZ09cdNFF9ssGlnT58uWmTGnNFFTXnsrLy7Fw4UIDk37xxRcb8w79JijTru6R+eInn3xiGNBLL70U8sPoKukwGzB9GJIYtNZ+4HWV11w3p2nXOewIdjHyP2JewfyKgBCSkpXOxtlVeXRgJowtEZ4Mo0TCRWOueDeF1mIjPeRRaOZGDOvpDmppphrrXVFdbUFxqS/NskjENxDeXfDqZp7pW+ZLWOqgPL6TALbQ8VhNp1TaiXzwQ3/8OR657j6jiei6R7ZfhPynMf3Rj37UnvV062Dv3r1mrrX2BUSida90unkrKSkxPnkaD8HdBwSwLw6pszaIOFq9ejW0tjTXgr23J8HrL1q0CMOHD8fIkSPtl7t+5+AowGdwSIgJrljFwMrZFfmcDScyHdT+kfGIJjOpOXGn9D4iJgq+JHDEgIRGhJhxFXMSERNhmI9xk8bj0w8+ISLeapquJWHE7BEoKy3Hm6++iScefIJBjYMxlVqi2ihPapeKaKLjjOGjR8OSk4leny5u9+OvpOanjP5Q8/qlomDLLjy/fS+GDKdJ36zpGDxmKL747AusXfkNknolYczEscZs1J++TSrAJ8gLw+nTtGThMszfsZeAEVUYNmIYevbrjVJrJb7+YpnxmerZJwWjp45Gk7st2GjXg/Tv+UVjLEJUWgCth86ShchjjTQxbOG4/SuS9gP9FxEus6rdS9rM6yYMNM+X7WHqvGbDKJmHjbQt26//B9bsxrIXP0dxZgH9klwx+pqJGH/TdGqkKJ3n3ympk0ud5TF+KhwDmXt1KId7ixgiCccMtDw1HPqspLUtpuCMVTCDypTmQRoNCxkxD54fMnuroCCnjtYHvQJ7YEjYABwrzDT9zCgjAp0vTf1o2vnhjoWE5GbwbmogirOLceXQWUiJTcG6w5uxYNtizEgrMuZobiz7rnG3YArBTRbvXWW04Mv2rcauzL2YPeRChAWHYm/JUQZfpkCLc2JPpr8cZ+3jYo7UJ2cyReQbOR7M1TYH9vzt77qH55+0PgJ7aCVTJ7M47b2dm+G139npOaF6pfnR/mYGlUtWgc31DArNr5IhM/Zs34db778NyX16GE3xzffeQvNLb1SX1eDZJ5/lPl6Dq66aQ0bQl8BOHxmIdmkBH3zwfpQUFuO1+W/A3dcDufRzHDh0MO7+8Y+xdd8OvP7ia4ZJLjlejN5pfWluF46la77BgkUraS7ciJ40o517/VxUeFfCl5qmzMNHUVJQghvvvolxBVsxLnm8CZDu4eSFbAr43njzTcPQCs329jtvwZBeA/DRBx+h73U92oGmToxG96fzZQS6GaTzZab/P/UzhITXvyLZzgA6bpJJCu9BQAhu1i6UOCVRauVv8TEHgYjtOmoZahpr6DxrgQ//lI43FmF74V5zCOq7CPlgRmFXPIWu0tNPP22gsu3EaL9+/TowSIIEl7bspptugp1BEqF6++23m/9Cx1u3bh2eeuopU8Vtt92GzMxMjBo1ChMnTjSQ56NJKAo4QLDot9xyC4MS1hukv127dhnn867ukc+X7r3nnnsgXy6h/smR3U6gn9wnNxK6M+dd3umhd3JeEQmCni2vr+DhJebl1GQHaEgb1J+Bc0MNMaGTupToUBU0o2ggQVHcVMLP5fCkuYSIbwFsKFaQpJA2swwb4hOn0ZEW6FgZKy8r8SXCWTLRq6gpbJWsUPmJYuVJfwSvMoSE0J7cqxCtbrU0nSJMr0zBmId0FDwYCyMwLhg3/fZOfPTbNzqWfdI3Malz5swxxI8jg9TVOhATfMcdd5j5mj9/Pl566SUzpyq2q3mrqKgwjIyY4JycHPzpT3/Cpk2bjHmq7uuqDVof0sgOHjzYMGKPPvqo8enTvAtGX/59WmcidD/77DMV1XnimIhAqqf5zODxQw2cbm5tvi0vB62ONvopSfGYnjATxXWlaPF2xqxrZtE8hswoifjwvjFE/yqhqWYEIpOjUUaMr4RhPfBA/58SHrkeXr4W5NYVwiXQGXc9djdBUBoNxH+zpRX7CrcjubbaaAAKW/ZgBn2gNEd24i6cZnfZV88hEIArygf2Re4l0+Hs6cK4ZoUISAnBLQ/ehkZqlLxYlqtTFdxI9FwWmUoGg5Jw1pkc7IVrZo9HMwNIfv31ZrjRV8bK/gyZNAxpI/rRB6qZYA1uyK2lA37pcfbGRuPZOv//65VMCf/sGhnHVvQ6VIRxazPgbaUGhON0JCkYyyckoV6mVd9n0hzwv8AQGmvrcfCb3fD080I8gRNkSqnf7ExUB8bkpDZk70nHV3/5DFm7jpn8EshMuYMakfAAo+FvJgqeNEE2ul+Vnl0yjJF5tsnwsBDtIfLn0R4ubZH2GF3TWKqd8jkVsIL9+5lqEwMRSF+gMBLXXtSAS4ggzZgvBT29/XsgjoGNFXsog2XXMK7O31a+RXhwm1CqT1Rv3DBqLhKCY2md4IVlB9fg5eVvIp/BuQUu0tSmxYqldjUuiIIJtYt768G8w1hORunGC65B39heZI7oH2MtMu23jzk7YLR06pMYFJlLuzC2nmeojeHU/tlZUl671kk8lAvHTGbJMpsTIMI/k8RsVbPvalN74meZ0qk+CSZUl7TKjZzvvPRD9EX0Rmx0DBoJrlRSVIzb778dowaPwAIKBGdcMQtxiXFknP6APTKt9eW5U1aCe++chwr6J779whuoLKvAx699gGFjh2MqwYbef/U9Clrk41yGd97/HDfdfiNCYyPwv794GoPJUAUnUpjDvlZQQ+TNdkirubfwMP2W6jD3xqtNSIKPP/2EPo0TkMZ95m+//xt2bNyOVoYufIehBW658qZuBql9cs+/D11ThOffWHT3+L9oBCw8nBSE0p3aCh1mglMVyk0EVenLFixDfm4hJWUMHEgznFGjR6JnSg/Mf/FVNNOufAKlmJ5lnpQIEsWOG3ozN80wOo/LybirtGPHDiPpl3agsyQiWloix/TAAw/g3XffxZgxYwwyX0JCgoERz83NNeh9YpAkuUuhb8X//M//GK3R888/jzvvvBO/+MUvTFGVlZUQwS3tk1D/OrtH2jcRyWKQlASCIUZJzFdnSSheguy1Ezg6fEX5yCTOMemqt7s3wrwJ186xKmAQREkI7fcpr6TEeQeyEBwbhoiwCGNLbwfGCPcJIfSsB83sSo0UVDbrlQzgaCdS2g99lqNrYsDE1EoCrPZ0lrx9SHj7VNOsggEdGVPHzbsIrj6ZhLfNQxSJFycvJwZy5KFtBPAik06URJKJdTSiz8R+8HrOu7PizbXt27fjkksuMdDQDSTcHVNX6+Cxxx7D3//+d8Mc33vvvfgxJZ2au6ysrC7nTQyN5vXZZ581VYhREjz+9ddfj67aICZbiI9vv/22uUdACPLzu+666/Dcc89h8eLF0Bq9++67DUCKUCF79Ojh2AWHzzYt36GydOTQ6V3PgvHfEd1EAIV8QhBX1lcaMxMhPmmZeFCKLuLHSVpA5hfErhv9iaQ1tOeRptD4iRB2t4KmdfIpCfIK4DoKhW+9NyrJKDXVusGHDGswCdesvB0YlENCkOU5JmmCucCA7EzsqdmHJmqimutKEOLUiDiLM6JItPpVMRYPCTwLY9g4t3iQ4abAwy0R2VmlWErQiQoSaT1IdF04KpWIZwewhYKMBsblUpyZ+up646NoYKHNM+BY+7/zMzvO+psbPW3PFgNR29h62zPQ62ARpn19mONoa5Pek9NLEVxqxdtXE/3PcJbfc3tZR9audJrXWTH4klGGmbGbUakmY3JF6sFxL9B1hQ1Y8tcFOLB6t76i56i+mHbnJYjoQUd9Ptsi6JsJD671ofKM/xLn0bYHmVu+/QuHRwIcD+77imlnAATMyGmgbMwm33iF7TWvaq1tTM9UiYZUsYOq6OdUy0DfvvR5iWTMrmT/RArgyAipCiYxCT40+bp30o8wPJHxi9gXnUPqTxUFAH9Y+qJheUf3HEpgiUJUVFfwLraCv8sUvJ4ai3qatxloa/alZ2RP7Mrai/4MXCuT48LqUrL1NnhqMXxuFBgobwsXQSvvNYltqS+mdoyMiSWEjBLb4JgMc0Tm1gii2C81XePWoDbw79uOico0Gii2Q0njYxgs+2CYqyyf+4PyiTsy5rmsp6aqGssXrcDa5WsxddoUzLzkQoRHhSG+RyLN4JsJwBKJrxevxIaV61F4vIhnMfvo3YqYxHijnfbwJrQ3gViKy0tQyf1vAP0lff29kdgzEflHcpCVkUXAlXx88tECMmSetCyoMkyVV5PWlmZfbaIQlevOiwAi7hScWKtqUO/sg169euMfH36CXZt2IPtYJvr0TMG+nfsQFR1l06y19av77fwbgW4G6fyb8//6HutwGRo5AGW06Q7w9DNIWwq0l12dBytNHBYwDsuocWSKevXEwb0H8dQvn8Lvf/8MrCSWrPRHCvEIxviYoTTN4lFFKaQLieqsyiwS3B0PFvtAVdPJPC8vDwcPHsRrr71mTKGGDRtm/xl//etfERcXh6FDhxIYwBasVmYH0gbZmRSZTiUnJxuzKGkLpPExZg0sRQzUI488YsoT0exoXiMCW2XLfKurexSAV0kHkwhkaSbEdHWVxFDKBILDaA5NOb3qjKs2wfYa2g9MMRQidqUN8veQHw8JIEo0pXWwH6pF6XR4J8yvzOtkZ+/l5sl8ysnEN90ns7oixplRQE/Nnf3etizmsDaEBSW1VURtcqck2JNOyy4kuk0hyqjE8jzos5KQnE7pYiUR0eiw613BQ48EUGsAvBro6ExYaQu1hVWtdSTyKTUmoS9SiZWyrzT9YHs8iYZ0uqRxlImj5vyZZ55pz9rVOhAjpPkRYyJgkrS0NPztb38z951u3vTb1Vdf3V6+1oEYWzFIXbVBa0BMmj2JYVZemRwdO3asfU1pDQj4QL+dKYlpLCeyoZKdiNIciaA1ZkkcQc2bUi0lr45J1wV40k5oMZvyqFaxp/qdQMyMBUM4Bq6PcJrCOHOe6rLrsDMzFzt2l6OwwQUTnL3h5Vhw22eV02qpx+CKdQiniZbiMEmDpebIyb2KDFYB217EOSjis0wdJU0r3anJSsVNg1PhRLOqCB8Gh3UqgVN5Onyac7Gu3As5rhGUxNN/pK2NnVT9b7rEkRNjVxWHxope/EwiOGgfQxZkcAAbzf50wdqMdubI3igXUp7+FXXoeaQYh1JC7Ze/l3e5IIWW1WLFip2mvH4MDmt/btufbT5zjs9xZWG58THa9vkGQ/hHcz+YfvelxoxXhZh1SHraBJClkErgGULTFLiANAwipqXh0J54itncaXplhClta1OLzqCisWXyNRKwiFatTbPEesjI15JwP5MPkq06rmuWoT2tlqiOw3ne9PLrYXxrTnmmWInF3cakae+WT4wL6yqtKqNvbC6uHH4ZxqUMx8I9S8zeaVgSNawtKRBqTbMVyWHxmDvyEny86XMs3vE1rhhxCeICIpDBYMvSfikZvyvTB5kw2s4vMUSNRNwTIqB7M5+ik7dNw6UwL/2DNI+29tvgtI15XFs7zvjG8ZXZJcVYZj91oiqz/bl3uFkmewruHhhKqwwK43KOZmPkpJG4++F7zVzoHrXBoEayzLKaCrz2t9cxfsoFGDOFMc0IwGFDM2UeMtEylde7gJQ8CNbgxn2gigwXe2BicXGjIjiDC0Iiw3Dh7BkIJMBMA8dC3w9aM+DCNgeHBlOwZGVMtjoMjE+BV6sFf/vjC7hs1iUMYv8ZhSjBuJRM21tvc0/gGgykALGWJr6nzLVDP7s/nvsj0M0gnftzfO71kJtqbYkVCRGx2LxuE44dOYrLrr+MCDc0reKfF+O3DBs7DEPHDMekqZPx2LzHsH7DOtosU/pd74QwlyAsXbKEgSU3gfQzplx4IeKjI80m3NlgycRNmgQRpjKxEwF7E03pxNQcOHDAmFPJ/8gxwGx2drbxA7IzQSpXQVrz8/ONFiiYTqn2pIC6hYVsOw8NHWD2exQXSnVLW/Dyyy/jdPeorBtvvNForH760592yGuvx/6us9mTEld74nCaA8+LUjU5G0syKOLHg7bgnmJ4DJHtRJhVLx7KATS3KmMeDhyT3bwuum+cAcMQgaA+2JNutZDxifKNgDs1ScVEq3NMctD1pC2+mDbVqeO3loSSiBgvQuHqsNIvaqDtYOX579qEyBj6mzC1tlITpA4wS5Nrs9ECNtOp18Igj9STUUrqQp8z/uzewGj3FpZF1CW3jlohU5DDi0zXlMQgOR6QXa0DaZu8CW18+eWXG3PJ119/3awTaYPEwHQ1bzKNdPxN68PO/HTVBrXLvj60xp544gn8+c9/1uX265oDMc1XXnnlKVpNk9HhxcwVx89xzuw/GwKY42re2y52lk9jf7o8+k2Eq9pF2S2SPelfVLkUXx1pxdTZdyEuKhx733gLofnZpO3MarQ3QQUjYlgQQRbo30En7yya9OQTNKCEyF+lzp6odgpAA53lm7lWW0Vck0lyImGcm7/boIDJD6WhoAautbkEjijBAD9fzHRrxKaaLBxwjWTsF5l8OtbZtphOtOBf9ImruYVImzWxaCzvjdbaQPi55iHesg/ezdkooeatlM8F1WHwqm0LcHlSS+TAHlFQCT8Sfan7C2FhAN2CMG+sGxWPolCbOfFJt5zxayI1U1O/PgIPPkPPrN1H81p3TAgNQw6lCwaoQES5Prc947VVguxeatDpmij1lyZZAAxpZKock/IbEAdtCGSG5AdjtLOcX7PfiNjWb/x+don38F8ttSoeZLyoyzRrrZlCHAlypMngsFAIY7MwkDDI8Znuqi61ScxREzUvVmos8ksKUeRRjBafZvrSEF2Nmhz1SZo0T+6b2qMayBRIQ6byW1uJ4ugdiJFJQ/Dq2vfw7pZPUFVTCSv9Lmnsxva4GqbKoEPW1rAZQmZzNwzYNaOvwAtL5tMXaTcG9xiIUgqNymoreB99jaiNtVBAoH1aYipOilHTeEfIv5bjSjRBjYdjMu3keDuOrbIY8UDbPDrm7+qz0Qq1lW0HrVDZhqnluz4rSbBSTT9fF8ZkmkEzuC8+WkgNUhX8aM2xd9ceTJ42lcyarT18XDljBMXgmZ2bkYNVX63A7q3bMWTAYARxbFUPe2SSLBP8+PympqXii/cXUgBELfGXS5ESn4TeDPgcRB+wnfRX7D2AyHRbdmDqJTPYyRaad1eiV+JQpA7uiw9eeRdTJ45CxpHDKM8rRALN/fy83Qj8Uom16/djw4btNHG/ACNnTsMHDCbenc7vEehmkM7v+f+v7L0IrfdeeQf3PXoflnCDTE5JpJlCi/ElktJBB5RslauImJWdlcP4S4V0II9BJglK2adXlJUb+GDFdsnNzMHbf38FDz3woM3GvpMRkdRegW39/GzQ0AMGDDB+Hvfffz9uIqMkbYGXV0f5t8ViMVI0x+JEEKgMdxJzjqZb+uxD8wH7AaN7VKb8XZYtW2YYq29zzxtvvGGYtAvJ8Cn+lHxiuk62w8xoV9oyCeZUpiSKOi64U19XwqbyIJeNvCSY1sZqMjCMc8IDWsSDSmgHaEiNN5oESUMVxFd6G3vSwa6+KWBgaS2ZIM6Pvos5knmMPSmfkspV9Pomwq268ZB0ZtBGNxK/rvIFICOlXJzutmS7p5ZgEMUkQGoqgxnfiRL1BjJXLTTDa/IiDK0FSTGZsAQU09+GLRMl8U+krtaBzOQEpqD5kj+ZpKeKNyUG5nTzpjVy8jqwr7EzNU/aJ9UrU0wxaPYkqee1115rvopRO12qJTRvcWUFgn24rm3L4XTZv/NvevbiaAIbxXVUXENTyaBeGDtyCCXfzSiaOR3rXn0b41qJLClGh4SfM6XGTsMDkJUQgCNNwai2hKLSrRUlbpTqy3Gd8+hMoklNZ2hJfm9fFCSKGxjMVtpQzTVfXYNRyrVQWJ6PkdQYT/D3REh1LrY2BaGcAhPz7JH4bG0mU0J0PScS1GebzKoy48iXtiWm+m3rmgRkW4GtrKelLpQaoz5U2wYh3DkbaaFLkRpK/ypfEoTse0MDCTsCmBTRf1JEpOjgkxMfBfTJKIJbNU3V2roel12B2Nzd+MdlqTgeaduvTr6vq+/h+VW4aNGBdm3VT/unMc6QOy796hDem9MfhfRz0fMvBqmJZnIbPlxl4hnJDE8x0Cb95HIMvohmvWyXDdGNwg0JPtoIZw2APsscs5XxcKTR0F6usbI/+121ravrItqlVRFUdTURMX24f8l8zAQi1T7TNupieKQpVXuk0bQn+15ga6J9huy/cl1RO+POMci05mJ/+RH0deqBYOcgwyApV8+wRPx81k8Q4hVCv0giqtH3TmXK/1NCk7sm/tCgpKVTCxTIQMUySQ31D0UAmaeo0CgTK66MvpqDE/tjcHx/A1vvRxOxH0//IQfFxoCZVvFF5Z5or9aJbXXzAwV/3Mk5Fs4cUw7yiQ7wk+arQzJrSbGFKCzieJzt2GsOxRTpv8ID2NolgAZyomyjmL8Gxr/aXXgAI6aMQgAFP1sojKzbfwSTyXhMnj6Rz7YTxk+fxLaRuXWqw8333IylBGkpJOjC7B/MpeldAiLDwzBm0mgj+FBctvEzJwquEFdcdzk++QfNOLcfxFgCtKTGhhMt0wf3PXwHPv1kGdZ+vQ4Dhw80ZuTV5TlEpKtCesVR/PiWK7BhBcGWNm+Dl78X5s27Ea5Brrji5qvw2YeLsPPQUUy54iJEhoTBl8HEH/ufx4yPc4ex6/5yXo1AN4N0Xk33udFZbcjfEMFq+uwLUU4UsHGTb0RBVb6RGOoAFNH5zvx3sWzhckr16jGZwSIHDR2M1ctXE+3HgpDgEIyfPIEBLjfTCbSC+emoTh+LrpJM4oQSJ38PJZnK6bs0Cjt37sSkSZPMdTuxK7M4aX1kbid/ER2USscZLDchIcE438ufyJ6kqUhMTLR/xW9/+1vjbL9q1SpjXqcfFGC3q3ukvZLfkbRbERERBlxg5cqVXTJIIhr8LQGU3FLiSQJFfzJVceXB50pABhEX1STMxCyJgVIeaxP9fsj88LjlfxEYOmWdjAZJpomRKbEsz4ZaJ60Tj0uTTb4GOoB1l0xo7HSel7uH8U/q6nBWG8WY1ZFRU3Qb1SVmzYtOzyK0be2wvcqcpqCqmDb/jIGUxwOVzJGtjTaiws2dpkredajxFfGilvxzqat1EBpqM3GSiaWSiCOZOMqP6HTzpt+0JuzJvj7s37t6FwCHAEGkORLynT3J1E9Mk3zhBBIhs7vTpULmX713D8b3SUUoiRi7VvB093yX34T+lVdXhDiaQLrR56+K/hXpB3fSt8AL6Uf3ITOcwV3HhMMzv5rEF+nsZG8UsV3prrGo9omjj1ELAskpuNdbjKmnpO9mYXXSKK0f0YrtGUg8NpOx3+8cR2j4Aoxyr8VAXx8EkzhdRz+TPLdwEnieaKlKIn3ZAle/w4ZR6qToTi9pWbnyeQpqLIFHCwOWwoP+DR7UYDKuC5Gymvl8tUpdTfu11np/uJVFI7YxB6mRS5ASaiV4Ccg0VmNtUSMqaBIUSUYwnlL1Pux/S1IDfvfpFkSScL6+R/KJ+kmPelTZGAz7RQ6bMXGbvOIo3rq2oxbHnqer9+FbcmyPdVuGm+m3aRIf2qs/3IWDPUOwZEIitn21FV//7QtUFBDCnyZUk2+bhTHXTmLQWApG+IzLJErJbq5pvji+cKzM/LhyferxZvld7QOOt5l8nH/deyKROaAJmYXattqaOlSTwdbeIn9K+16jvGIeaml+rf1I93M6yAxz56N5lnlOuPd1lsQMSGPUSM3QprLdKHWqxGjvodSD0s9Iiuj6FsT7xZi9jTorA7CieyQwM5peti0mIAplrf+PvTMBj+sq7/6rZbSMdlm2bMmL5C22YztOnJVsBhKSkAaaBpqwlK0sLctTWgq0tF8LpWUrFBoo5aEthC20QFlSEhISQnZInNVrvO+rdmk0Gmm0fP/fe+dKI3lGlh0HSDzH1syde88992z3nHf9v71i0KUFku/Qxo6tztwgKDra0yLku175501zxLyjR9rcx2hm7XS1o0yCF0GfyDQ5XENjEgSFbaP8wCxRfpcSBg5L0FA5WxDZslgc1/gMDePZADUETFbmth9zm7I5sAYMmf7Rzwi9MH2L6130QMEql/GA+T0gUAoEbYuXz7fXnvt659vIu6/3oBirYlv50lXyfTxie1oP2IKaeXb9e29SfSTbYp/RFOqR79eccxfYxvYtPr6LLznTtiT2+D7zspuudO3dgMa5Iam4aG2PWlneoL36j39fTJ/Q9fROb2zZonVCZtjS5lUfuN3q519ir7higZ139XKZYAsZT6Z9D+99RHDes+y6d17v85UYTPg2/+roBpnqqiOn2DXH9FXuxIuiB3IM0otiGE+/RlRJ1f69b3zPptfXW31jvT1y8EmXTuK3ArLdm972FjvnJWc5cU9ciB4IfG1gpcJ63rp1q33jq9+0t737rS7B3Lll96hkLlNPQngCxQ2EMhJ+iE8c6iGIkdiHCXMnmKLQ1I48gC5g8oZvEBtxc3OzI9JhAgVMM4Q0fitXXy1zAKVb5OOEaR1MD6Z3YQI2Ots9IeTztwRVSn1ALgOBLVtyKa6krJlQ+9j4CLRbIoKDY4ATemWiANIfhAWaITYQUlImNUe2H/CAsyDjsenGhxJWIg1BpyLbyyreFCtem5scqMXcdMjhH4lxoezzS6QNovzjJZ4ZJkxmepI9IkDlsItZi5hhNrQjvUfFwIn46Z8RSL8jPdrJYebE+EkbEI3qWwSxBPfavMPSTvw72zyo1xwE8h0NHmOE7xmmchdccIFDtWcbN5gc5hJMDoz0D3/4Q2eMJ6sZzDTzisDKa9asGZf1da97na1evdo+//nPjzs/2Y8uCRM6ZfYzQxHpT1ViXNwcZ0KB+C609XdaQqAfyxfOsj2xEfvsl/7dSkvKRDDF7aaXVVr/nALrmiXGXBRsQtPjQOEM643OEl8RzDmk6lERZdUy9RwcaXdNRdoUmfDE8T/zND+h0g4XNdg9gx3W1t1qZ1VE7RqZ3K3t3WObTH50Mt3zeXkcRjqcuczOEZVZqHm/bKTVLojK90H+KPh2xIcUQFl+fbFkxLplQqa3SGFxFZxabVvYsM4aykv9Hdkv6O5tfaV2NNJk3Yq/E5M2ZL0ENiXxmMzteuzxroP29afW2RWNDfYGMUjDoiLxQTrQELWGQ/FRE6SwtdRpmnyICoXUl5RvxtgbFObI/F3X1ntMWWFOGK++X2+1b//LN+1ZaeAhlC987WV26VuutArFlpE+QT4lmOcGLxhrDIX5mqFzbpY3oSbkoRwPNKz+pt8h+P28+sjLCCugb9YOzsFkhOsCYRxYd4q1npXJt7BH5mqY6XKOxDzE1yUYU95/cZUkTSfMt9CAAHhAIk9Yrp8IP9QUNEk8f4d8VTExXl612OaXNMqXU75z0XKLCkSA9d3rp2ejRWa9gGnZ0r5T+5M0KBLUEHC2LlqpgNhV8pFK+ppUUVZhcflMdslfzoolCFKdWvs7xCnoj3mo8qgXTcJ8bTR5vQIhSGkN5s/KFyH/aI6sB2jc+gXVhgZHRU8ppTO8+JIRjB3GEd/ChLTRCC7xFcK3LE+mfuzDR3rbrEWm1ZgiAl6BGaFrQzWOsKqs372a62sPr5OADj2wj5TKVlgOge7ALLV0t3n9MB/EFJsCClslwFBKqpz58W12fW2ZdfV024MyN+3uF7DG4S5HryufXmIrh3bZBdO13hxca3cPzbSewirdKd9ICTRIHQn5sabK8+erHcwr6rdm1nkBA+05cx+nWw/kGKTTbcRfBO1FY/Gmt7/Z/v5DH7WPf+7jcsTXhhSXVLpAKFCydEOCVSLJZqfQzPbItGFY6v6mika1XMufFr7OWLc24mFHuNuo+Cpdbe0uWczWNcuWLTPM6TCxYuMjxhD+JcdLmFxBzOI/xOb59a9/3U0zAGz47Gc/63FqIK5BGQuRzD72sY/Z7gm+Kfg8QXxnuwfEMmDBMf2DwOCZBOrNltjIfMPNupPCBGGy2C+tUZ8zSSHhgLaJvuP34a37fUMcDRCrjRaQhV5JPIknwb7LhuP3pjZhCIhSSQ/ZMIOtMFstM5+n7n2ybx9yhA0R09rcYiIseEZ+VNL72XdqExX1I8YIaX1pUZ7Nqar3OFgEHsR0a8oUwYQqTDYPAOrA5wfEQTRBX/va14yxJWUbt9e+9rWOjAiTDFEEemGohZrw6NGfzBO0l5jyhalEvnUPPvig3XHHHf4XziWu33bbbT4fwrwTv50I1Zg818RYQjQhVdahm2kiLQ4T4wOx2iln9MMjYpDKZthrL0/Yiubltr5FootF51nrtIgdFpHtVJvXCWLISe+wGJ8z1BnCdEBmdB3DIoRU7lQTLYXN74nU2COKndWqmE8Xlsncp7LEarsP2GNiFbsERW8FAE+MTlrdFVCdwTl9OgOlc3p2sebjCmuzc8tkWiSNxJPtrWLeReDJjKxMjHyjNEHNmu/5aJAg/KVB6xKQxTqhaO3Or7bOoiYbUmwYwZAJ4U0Mj9Yr2p0QIbf/UL99+8v3uqbm1e+/wZ6RRioh346tC+ts2eYWm3V4AsxyqiOobXSoy7pGakSEq/eD6qeuZv6KlRdbZSy7f973d+125uh6IYc1f/wNVjFbfpQqF6IYyQRrI0R6oZzoA62MCHqNJ+OD7wwaD59vaY/nN3mdMUoxSaCxDeodRpASMlnc4gQ4ZalvRsvRehCuI6Wae0kxEJiOMn1gykaSAdE+ZmZGhbkm8zAFm51ZPsP3BMIR9AlNjvqTGHme58cqjD2HP520FiGp3XX4fptXo1h4Cy8VvHe1m5XBQGFFgJCMb/qF57YIIh+TM4R39TKta5S2qFDnuyXMwieysXy6hFURS+j5Mc0LCPekBFI8nb7DXNHXbBo1MekU+11ReaA2CmocZPL60w/hPA7v5Rx97YzhMVfDXMd8j9VBz5PQCzCWXmnlfPxTVQsQTCUw0JgyLowTfzBHUa37PI3z5dqr0ah2S5DgfodqP3WnXGLmASJUqHEGzW6odMg6k0LT1DsUNCVYS6igZo/evHIXplRJpVcf32RtG4ZtfnSlTGwTVtO10S4/d6YdEqP2i0HMaSs0F2Ey0Z7BHQZp4hoSgERwLdWwVL7c1+nVAxKqpVaB06vduda+gHuAKfvEtqftox/+e/vkFz5j8WifbW9pt7a9C+3CBaUKAvkNW3PNRTZQM2jbuvb75nP2jGW2/hdPKnZFsb3yldfYzV/5kq1/aoOCWTZpCcyTNP4y+/THPi3kpl9m7Rmei69JumN91sxpFyBoQzOstNNOUKA5mBgcND3PxGOIkGz3gLJWKjMcJ04m3pj6zea9dOUy++QdXxzn/xNcFmEiIi2hZxBZPTkB0pvNYkCS8q5EgNT3q/+5z27/lx/Y9X/zBlstKODjJTZGzOOqRAy6JPB4N2S5zkaKOV9XIqbvQKocZNUViNDRTY3ts8CmRWsFMFHh0kqI6n4RHJ941Ydt3+59WZ4w+enJ5gG+amj+3LwmrZjJxg3EOUxyYJJ+UwkTzDd85N0W/YPldtnSJba4vkFjniadPoGKMK4i/x0dMCpCiB2FAJIgRkI0hol8hSLwz4jOsMsUvKR6ZIuYBb1T8vtZn6yz9sr5ItymVgeILvzOWuJtLsEOn3Ei32h+YOJmJgOTuwUag70yWXt0oNAOKZYa/k0REasRvQcFmm9FghePSgtUKmJXRnOCKZfDvhjxaknFp0srdlDagkfihba3UIyxiK+C4YQViZGnjKKE4umonOqiQy7QOVwgf5Rog1C5hMKp80jSkZY7YawOpN/Q0P7HO/7FDm87YK/56Jts1TXnj2tew8Fuu+HHG+BNxiV4t/zGqHXcUGfPyA9rW54QvCKVrumCUQqzTyT9Fm1rtavvlvlXmGFcqZg+DdlRIbQ1lJfZbVcush3zajwH48orB0gDJmsl0oLBTNAGH/9Uea5FUp/HO2JCr5NNYVqCyA7zenmpaw6GIGaCBLPFu0c56cwWTChCF8IIEJfHYbBVHiZ0gCbA9ESKFDNNZl+UVCJGqlxMK6bE00prHbo+qXWhW+tJt7TfAxoz6hOYr6UYI6+BPtQWYkQN6i8vUmD1lXV2aeN5Njc6U8GnNYZijLgPYj4i36Xdvfvt0aNPW0Ia7Vk10222AsgWSZveKROwHvVlqfajYrQq6hdmfoEGr1Caks6BLjdpJsZSr/LShQCdZEowez0HhFgpv7VoQ4UVFMlvVFoz+pMWMxZjDGKqBBWFNmocs6lLMArO8Og6z8OfiHvD87SLftQJD6w6OplSxaI59cC83td6ttoSFfJcuVBJ1URv52zB7C9Xf9EPmHAnVVZCde2S8OSA0GgRQjBmSZm+60D+annSqLUJabNbv3m1gvnAIxnDQlkm3FB00ObXzrURhQH41n2Dtubad1lMc3/dg9+wFStkuipAlo6COpWcuQ9T1T/m64Or35ky6T7mUu7EadADOQ3SaTDIL7Ymskne8dM7bflZK6y2vtb2HdkkM52kVcrJuaNvgb3yxrcKUnrYDnU95Yuylnxrky3yBa94CcYXtju+z256+012gzazIm1OSW0Ej979sEE0TpbYxE6UOaK8TMwR5yGIT4Q5Ot49AD0cL9EGNpj4oGIISWoHStxo0t7RJ9OLhDYpbW36G9uIgjxolsY2mP0bd/tpEOwmS2yMSE8xr2BTfC7MUfgc5gA1oT1jSccKmpieGO8WSQ/b+4S8x+avP91q+wXOcbJpsnmQLTDyZGNdVYXJx282wUTPKK+22fWNJ8wYpROw1JrxLJFWBDTC4LeIUBgl/YuLiaG/gwQRiJmdoOELWjVUSYvJD6m8dJqdOXzAnukttG75GuVNkVELiLu0+Rs+Zorf6SZ3d4cmd5Wl9ioRyJ3xXZKCAysfUduK5FGktvm7ou88mEB86wo1pyRQkDBha2+fPT5UbYcj09y3A0p6RM4g/fKZk15CfdwgBZHi5xQL5jwihC+9WyKLFVC3RwQ5RLzmpf75O6f+Yn7//Es/ceZo1SvPP4Y5Yta3zK21LStn2xnr9tvrfnG/EVz38xdfIDTHPNt4cZktkjDiyrpyO0vhEJ7pa7Xt+QK6KBTamd5Ffagdojb1rPAN2iYfozrF0znvyQPeg+H5sDuB358tf8pBvXO1vUnbKSLY/U0oS+V4TCNxV/5K0gatFYGmTcdqz90332Y7hBR2eO8ha168ICw27Vs3ZUxhTSZeD87zPPotWBN4cFBIME/Jk+rXVD4aHK5to+sH95BVyctRfYP7g3OjF8Ofo98j9u+6Ee0pWoewPBg4/GAqG4Rk97aX2qrVq9R3Nc4At8sMMG+4QMxzkaPk9StekqN1CmyiWPOtWPMKX8t8aUSKZRJeWzQijWxfEKxbtoFh3cMqeLVhGqDmVAfqHzKbzszo9OjcSrsJ3eyIGFp9aYZq/umYe0eTDkfj3ol749qQgnIXDgPcMza2o/l1EJEGyPsx1cfsIx7fTvWWl6udUVpvy8rFHOkXiamj+M9Wo5uqh4oFTNIvKHZ5c6FJ1juR79pIzTeFcUgI/htABxJ94Gu5kC37hET5RL980NoOKrj1oB2OFtgPfvp9AWYoxtSsiO3LX2TDWJeojbmU64ET6YEcg3QivZXL+zvRAyzU+3bts/e8/08UhLRDBD1O/IrVUyMt0kCrnEP7ZL6Aj4v8T8q1+ir/7p79dlDO2SQktdg4Y97gG4Ny9swasLoZdb4JhJucZ36RfQA0UFImZ3T9G5IkXGzLGCGgzQpiMCktEeTaxOTSvkFt6t0zFZz1gAM0IAme0TxrYtbR3xCxUZkslchchuPxRMdothM6UDVFUAjQVwQbsXD4PVnimfhNsan6P90wrb5uHIDGZPe/GK8BK7+kcYElBSTA+3EiCeKvCObax5OxkM+aGCT6NkwQraAZUrQzSVzQuUIx3+UDneIxFKSxsNF2ly2xouROW1ictMUDO0XIy0yqdLoIyOMTMxBpzljo+2TfWWoM4RTD5G5IQY07D9mqIsEJl8hHRERphwQGfRBmg9JY6TlgNyZEDPeJEe8TKSv9kJg9xUwpKLchgZOkyD7vBu8NMeTiEqQVAKYZs1PNQ2cA5X+hbwz5AnIv/AwI0WcfXG+P/uABwWZPt+s+eKOXF37Qz5gi4Yf35FUrbX9jld35ze/amZrTT62cZY+vapDfVsSe6Wmz5bEWO1NgFFfK7+VsmaPujR+yDtGe0uFYt2DSuxUok7oPq02kRy6aZ5uXTLc//N/1gvoOzGTD5/L9Pzt32c2bnrU1lVfYDD0H4hqNCWtyfkq74MAs4ZioE7h2z+eD4LE7tm+334ZAIL0Nv8njW2+91YM4f12ajFiR4Oe7W6xc6KClWnmHhHjH/C2ACXDY8CB+UIvi9YBwWSwtF2sump6oGM+e/FhGYQZllNdLQ8hcYjppyrkVgcYm/Z2c2G5/Z2COdD/MLOmY/JyWIofEtZDhZQ0YkfaXZ+m0/7G+k9I1PPwmEHO/1ulZpRW2KCpzQk0a6sq84PXI1/rhBoW63Y8Tmk9o4dCEqV7JhJgrMfVzqmcJsKJXZogxmfbFXdNFOVRjT9kZtkfHgDYUrDTrahHQi/b40po6zW2qR0VzKdcDJ9YDOQbpxPorl/t3oAcwGfjgxz+gIJG9tq1th1Y/mSVog8fEIjHSY0lJpssqMANDquhkitca6F8SC30idewn9FFcLYmdwByATCZI6Is1/eFNN9rSy1fKNAjo7IlACXIQFiNTJMl3Qr5H6Uk9qY1KzsQHF8t2vVdSu/XWtq/FmlYtCGzz0zOnHUflsB5NAT6wmZ2qBPpSkeofRJkfG+Ns5U/c+OsXNthVV19lDz34ULZbXtTnCUh81Rv/wG7v3mhLK0XoHicxdhBUmEiWCg2uSPNklCnRsGYaW67jdwCzPSSToQXJg7ayMGmzRbQUFlRaW7LAWsoaxEAprkxsvTXKQX1+Ypttl4ZmyE3PJidqQDmE0T8VCXO6Ic37jXnzbJu0q/mKAzScX2WDYsSH1eYRtXckRQCy3tBiPn3mqf0yKNNxlvnNafk05cnkzkXmwV1e7YnzkpNdRzvsx/90q2tk/vAf32rF8qdMT8BYw5z246ciSfuTVYFEP7lopt1//mwnPEWVWnukzh6yabZJTu5L89ttSWnEzqquE4GqJCm9+CQh5vXYTmmXtgwKGVD5EzL56qiN2h1XnWHX37bJH5v+dqFw2CiQhnU3f99m37vWrvmzP7B5K+fTHU5owzAx7j43AnrZ1t/zpMV2d1irTI1PtwTkPibRX/zIzXbjv7zD/aNAwCvDV09mf8SyKpQlAUwF5p4D0qDg41ks8zw6FS0JfQvDQ8BtzPvQhKfPG+5NKC4gABTsYwSOnWriXvftSd0QMC1M2NQ4MlezFOdMWMBXp+7O/oWmdUlUCJXyzaPurBeDYoKGZelBsGDW82ExUUMCFnETRTGNQJbTF7xlhUWYOkZsuvpgmjS1+6Rx7uwTGA9J9cOna1B5Q4K2XHGh6LeQ8Qsy5j5zPXBiPRDOpxO7K5c71wO/xR5gEX/06Dr5ysihVZtFkQiGQhE3w9ISEOvCF+A0xiis6rhNRbkmpr/78afs3975WXvvn73PrrriFe7PMzHPC/E3wWnxcQEt7aYPvMmuetu12qAr1APsfMFmmN6uqCThmMIlRNDBVJIv1lNjnQdWikmqspLGu23vhj1+S+Oyeem3jh7Tu0i5Q1Or0Qun6IBaQ6Rj2uJExAmWe+Nn/ti+cP3H7IN/9SF7x9ve7mONJPXFnCDUQNa66KKLvN0vv/YKxQXZryZrtJzoP7b1zhjpekTECciG/LlpDiSO3sPjJhHylSJe5siV+uJKMeT5lba9u8Pai2bZUNVS64JMlwZmR8kyMUkbbGGFIOJ7N9v2QgGO6J3Og0DMkmC8grE/9l3OcsukpzG5g7BPFspUNbUzUnJAH9JWWAqlKTQ7yBh+auUBNKQwZR6EeZ77yoXXx77x//jBR79pxBa6+s+ut8Ylc8cupo7QhvIXMqVtLQHKV0Wd/JkYR9WPsckTAUpAzvaiGfaw1dmT8W6r6umySsGQVxXIH0rv50z5A54lKPHlgmDf37vPNgwIBOJoiV17+y5nPemGsLksqdeuWmIfecvFQhC907Y8tMF9pM582Sp7xXtebdNmC+6eZ0vqT9whv1H37F+32/7qgx8+ph2ny4l3vOMd9k///ElrOdwiQl9x+JLSuJYVuYCK4WIOgwbXJ3+jEfkOYfbt2xdaHU1/xhmNTZB0w4TEmCdiAkuQD1xE74+WxaDvJ+Sbyk/KCs3yppI/Wx7axb5B2/ATmqWwEg1FikunC7TNfc7EDNHEgT75benc/mSXTAlB1iPmHUwUzJugzMVc+bzWw5jXBWog+0qe9aSmmJgrvTfp65GbDmarXO58rgem2AOpbWCKuXPZcj3wO9IDcQKVarFlwUVzlBSSFAwQ/0424VT7zi/+mT3604ftn/7tUw7dmqksiHI2rUCSl8qhx2rtHn26xxUS43a85OWIMEca/nwkzB42PbHBll24wt7+2ffZJa+8XAFaFZTWa6oKH5OCPi3SBsSGq63LYh111rZ/tTZvEcnTNlph2SEFiN3nd84+s+mYEjiBXwqO0yExnTHTczjJKDMOxZK+xmXrf6Ljjr/En377Q/bId+6zO/7oNcfa32eoG5s+/emzTD/8mVQkUzem3c+8QBCaJ1S942ZOuy/TIc9kzo/NtIDAIkZVv6TLlYLMLpdJI4RJtwgualsu+GMc0J99eqNd/PJL7bI/ebW94y/fZ7/Y/oTFeuWbV5O0Rtn475MtP+9SupN+oQgUAgPDGIEqRVOZs6U9fVbR3mtx+ezEaoI4XxnrK+JmxpAQ3iKC31WcobtaY7a/pFkABiUeg2hGVChrujEmAupZm2+l8fVCoFIsrtjTtqPiHDUz+xbF3ArMeiiBPjk1CdLsRBJ97QxJSijjxOwx1VGZBTBIk5d+/9fvst1PbbfFL1lmF7/uZZNWw+efcsRaA0l6RV2Vr4nuzK/HUSdQxURrekpEqi1eVGMHfQ5Ja671KSItfP3R/bZUENTNlTU2d6TQkrcqWKwmbNiE8HtI8+67r11pxdJE/dHn/sR2PrHV7rz5R7bx3qdt8/3r7ILXXm4vfdvVCsJZ5u8moAp0Zb5snED+PJ0TSJNJaYcKte70CYa6t1B+aHmKHSTz8IEC+cpIEIUpGnDihdLxdSomVpni0JXJd6a0sFTw83rXJBBknwjHPezPwMSuSl0tRkqBVE9w+obFnLJv9mVi4WFSCqJgkdaNJs27AvY5E5CH3pOkzFYHND8Gtb7gg7dbiIsd8rmCsWZ9U3gpzWXm8LB8ieQXK1NXwCsiskgYAkBI+dyUj/nlTBQ38D+YrenM0ilrWK6g064Hsu8+p11X5Br8QuqBUKIU1jlcGMPfJ/sdrSyzl77+Ff6XqQyiwFeLmOvXIh0bCCRYE/Nh/lIhaRkIQNkSyzixheJDQk0ScTuV+msvEJMS+NzkyWY9e5JJgoifUkngIW4lwxMTgZ+WbNkjYo7YeY6TfHPSxiPBpLUdPENS4TwFIXzCquv2yUcpaoc2pxikLBok4J4xgWPTfr4SdYxoPKbSd5nqEK0qtyve/XuZLh1zLmwHzA4bOJsy/VtdUukIecfcoBNs0gn5c/XJZAvSgF5PN/nMdM/xzlGPYplB4ddF2yEuejQPt7fstx898ajs84fsquWX2RtXX2VPH9oj4iTP/mD5Gnt4zzP29cd+KgIsYisam+3fH/uh/c9T99gMmbesrphuFxV321NdB2xzXo11FcplWlQ187dchA5ml153Va5AyFIX3fGMzdl62OPx5EsE3DK71h589TnWX5ZmCqZ+gh2sEvjB8sH9UhLNtKe7e+1IxSIrkJR4RO9Pj6YkCGRlckgn9ZXMtGelWVnZv9WahXrV1b3ZWitXOOHjGSZ8wCDDJP02k88L+AD1A4yJQ0FnrdDk792eZ3bYvf91h5VPq7Qb/u6PpvSe8qie1i5/Ysgg+fut/p9IJOKHgb+GJ75heAXasCu6yHYqTlx9e6ed19FuC+JjzFEqd/Cl6s8+0GU7BDFOmr96sf3pLR+yZ+5UfJkv32a/+u9f2lM//bWtEZNEjCS0JYGJk0hlabNO54T5XLGguGEeER71CsVxWLGPAqc1aUW0nhfK/Iz5RJ/1iXEitluMNSZaIWFHr1tHZHsZNPWUwsFhUnTyAABAAElEQVT97fU0Gh/ilBXLJ7En0eNrQLXaMEuIfYMDB5w5GtBeMhiXNlt70tOF/XZoWGikkso4iifTRK+0usj7aaBXjBS+WmobbzvmpsRYAqmQ+c3aT3+OSgFSTQ/W2t9+f/z2RiL35FPRA5NRWaei/FwZuR540fQAm5drELT6Erl9QE7d+OpMJNAj2hAmY45wvE0IAhkYZBxwJ96fqcM8powoTm2jYnNkXqMNF1OETAnmqEKwvnx7nbW1EDeG4ykl7bY41h+OtQplrFrMwLDiC/3SKmsUUE9MT4F8RPZv2mNlNeVW3VA7rkjaUqTNHrCHKT9vXAkn9gM7eAjlcQEUT6yIKeUOxwimjISkMyap7oCbdJpVlMhkUZLRsM2YhfRpfBnnIE2uOUhlOu4X9YA5H5KIFWKE4LloMEo052DcOFdcVGSzK+pt+QyhN1EjXb9k3iq7cM6ZklQr8K80bv+59jZ/Vr+Isa0iVs6T2/hlM+ptpcywnu7ZZlsLplt/6UyhUmkc0USkanahmKPG7UdUC9F2updUd7DDXvqDx+zON10CVaO8qqXaX5FsscWDh22mILA3yvF8b8lCIXcNCWkqSFt+vcFuu3udPfST+6SVKLEFSxamyhWktrttC1ZeTOCQxjfV7ak7gy+ezjiEQUHHXfyN/Qh7JnxgppoG1xKKe1O/qMHOv+kyazhjTniDf2NS973/d4vTuK/92Jv1bk1d49LT1u1luImdGFuYxkwQzuMeqB+YJOPATmzRfPl8JcrqbYtAKubntWr8JuYOfpcoBACKsvA6zBjw42e+7Gx7RAzSA9/4uWuVAJi48t2vspVXrg4I2MzFjTv75S9/2d78ZrVdSHlhWrdund19990e441gzOnp/vvv92Db1157rc2dO3f0EgG477rrLlu0aJH93u+NCUCAoL733nttw4YNHvj7zDPPHL2HUAw/+tGP3BT51a9+9TiNV7byCMpNUG+ChxNIPL3eowWnHZRKk9tcO0sCAZmO6s2EFwC8IC7tEeACw3o3YbKZz25GKQEawrNuARMQv42+dvS4tDI5RFiD39qwhBeVc2qNwOijL+yEvM/3T4KCI7hhbqGNZm2aLi0YBnHDYmowt+vHHFDao05pxPZJczQsrRlmc6xlvtLI3g6t46CYxH718ZDMDkmEde3XeltSKkGM+oIUrEz61H6YS7keONU9kGOQTnWP5sr7HesBdnrIymBBDTaZE19Mg7u1SIs4BXK1TJJ17KCJn4F2gMRiDVhEiOgVLN5+afQDswNMwvpSIAhhvUYzZDgY0UZZOCIYZUnbIViHJWXvU8yIwD8orFlwI62FiYNQTn9++nGGR4yeojS0RgfaRYgPTJdkc9DyZzxipZXdYrgEEawHdBxpE0pQpy29RNL9VL+GBbBv0S/UYarPDO89mW+kipheEO9kKn15Ms/IdE/4LOLXHBJSGHF/aqJBwMikEz2S+OraCSX1bdhnzFPGgvGcmLgCAzYoj/mwHuTkuF/amYd3b5Bm66e2vH6xxw55fN9Wm1k9w86oa5C5TsTu3fmU3b7xAS92SAzvnshc+79kuc3o2m1nl0VsjaLOr5L0d1vvekWZ1xwXgz0s6XZEyJBzpTkaP+M038QoVR/tsbr9HdY5q9hqBo7YvJEua5IpVrSk3PaI6dpYMFeUuLC7ROyR9q/fbf/13pvthz/8oX31k192wrRIjN2LOaFFueeee+ytb3qrve/Wj1j9gjFwjB/903es60iHXf6WV9iC8844oW4Y1SBNC+Dife6IUfLvFCGZqUBMhEWpujAHiHbEKYcE0MBMyjTzCjTfSqf3a7xhrAKtYlhuRPDUl7/5FXau4qHd+58/s7U/esi+97dft0e+e6/VN2ZHuQzvJ6j2X//1XxvBk0NG4+abb7Zvf/vb9sY3vtH+5m/+xh555BH7u7/7O7/lsssu83yXXnqpwTh973vfs1WrVtnPfvYze9e73uV/H/zgB/2eT3ziE37PO9/5TtuzZ4/74BFo+cc//rEH/yYwN0HA3/e+99njjz9uAJg8+uijrtHIVt6zzz7rzyU4NIzS5z//eR9b0OeyJSwLomKOYGj6tF5hFoupGEIMcRRilGSCJ6FWmUzqQIBkfFhDhjWGgixIMVFAyo1/AxFgFFcIjRQ7XkG8U9xvMoXaQeYblgr9+UlvIyaDrjkTM4QgCUAKqsZcGVEfFAhFFZ8rOZMGGiO1izJoHkKdgb5+tUk/lTdf7ULL5ubFaXMaU2m/5zfZ4NyzTpseyDFIp81Qv/gbiiYBG+1wf8D/IiLpFc78rvnR70EtyrEUkTblHpHINN4r2N/uekn58qxm1m452CqApMyVMCXokxkVUltgpyMKhBlqbtLLH+hXXIw+hZnURjFYENdir9rls/orl1eYgwlJG0qeHLpLhfhVIuYI+3TyuxZJ7QhR+SbcddI/2Xfa2ypt765mOQ2rbfWPWl7pXmlopBUScwQBzha3e/0Of0bzCiHYwQhBaKUSm3VKsRCeel6/Ma/ANCWQL2Z+FAQJfUzdnZnVMW05VYlYIa19nW4SUyWTO54UgoVM9Rn0G9LiMCYOABf4/HigxjSCIL289DbQGsYpKWJk85E9tunQLp+PQC/PrJxu9dIofe7eW1xSi2knZZMAQYDJbxMDfrCo2XbEO21J7LCtEsF1fu00dWtM6GsyAVX8k6Ri5CS5bWy4vQw+FNbFFh3eZlX1UZsZFdBCfo0dlQ/UevlS7C6abf0CCshXOWqm9Xb02G3/8F2X/i9dunS0jNPh4C1veYs1NzfbFVdeYR+55zNWJJj8x374oG26T2aLy5vtZe+49oS7oad1TIPkN2sygEzmvkjHKY3xYO5BjDP/+iIj9sgFc+3iX++xLR1ddvPGzfaPq88W8y9GeVm5LWsotPbeI7ZDgTchckNNUvgYNF/XffAP7cI/vNzu+tKP7dkH1ltMZnn2njDH+G+0OmhfqEM6g8xvmEkYpMWLF9sFF1xgr3nNa5xBevLJJ41wBTt37vTC6M8///M/9yDfH/jAB+y73/2uXXzxxfae97zHmpqaDEbpwIEDromCQWI9oMxPfvKTjlh6++23O3MGg0SaN2+eM0qAmWQr75ZbbnH47k9/+tN+z/XXX2//9V//Ze9+97v9d6YP+nh/T6v2EFYiMTquitM7K4Yzgdmp2hz4IAUohawj6APR8EXFNLHWxZNxveN6j9IegEleSbXeOU/pV9IyPZ+Hqt/IYLC2DmlPG1I9YVpoHmqyDSPtOk7aDJneaXdUgOU8j/dURGiAXuVTfxBIO69I+7XQVVma0Rqxn4pTDFD5dM4ZobTmEYSW/Yf8uZTrgeejB3IM0vPRq7kyf+M9gCahQshswHcn5POB/0uJpHUwMGNJtt1JSaV84zmBVXVYzE1smsW7GqTyr5SDaY0VzttstVUjbm9dNCTpq/w1kG7xj/InpkjxsPUqQGBLS73srxdKatZlxWWd2ih6ZVct07WI0Hu8SsGmyCZeohg1bCJIHtM3gaD+AYE78TnP5XdXV5Xt3b5UDrGFVjptnUUqt6u4fNeWAe8ctmuMQZI/ieqZlGQ8JNZpeVKBNovk7M2GDzJYPhvd85SoU0TlwwyH9Ut/FP4zaPvYSAlSitYF4mRQRMUg0lv9PdcUjLkkwDIZgWktlzljsZ577CzI/CT6CaYFUxodKskMRcQqAAllHkNqcnNFpk2VzJJWzZ5nT+7bBemlIlwu7ePSL23jwa59VlkW+PqU5wliWIlRmVdda7W6dwgJr373RmptrQkwobfLGmOdVlsoVC2VVSgmsFa7RWMG5oiyCtWfi+sVU0cIXLv6EtZWMMMOFS+wXpU9orZE1C8QThCDe9ftcun76cYc0U+kyy+/3K645ko7sHmvRSsFqf35/7WS8lID0huJ+ImmnrYuJx7dLE/zx98DTYrwnZxYHmZPmIPiZ8bcY6agefT3Qb+fOLtBoBn59siXf2rf3rHTXrV0gZW/9GzrW1lol+iey8pGrCq203YqvGdXROAALqBg3RpL0+fV2xv/+V2268ltduc//3DswoQjAAbe/va324033jjOrA1i+LbbAjNQ0BdhlM4991y/+7HHHrPzzz9/tCRM5TCDg9nasWOHa4i4SBDuBQsW+DUYKrRELizRNRiov/qrv/IyYKRI9MWdd95pXV1dzkBNVt7atWvHMUPUYfPmzV5Otg8Y0I6+bmcIgrWB9dEHSrcEozWk/ugcJGaWzgjmmn4oFTCBWCbl0Lso02UEgYzVYErgIBma9R3qtkR8QIFppcUu0YsaPCBbVaZ8Pn2uZLvJ11YJUPJkFgez48aDbGapOTggZmftSIcVCqUuIsZdQOQeUBaGb0h1x+QuT+AS+FYmFQYAJqlQMN/K5I9kXDIlZ5hSFzjmj7z+T7ekz8dM9+fO5XrgeD0QzMDj5cpdz/XA73QPSPooCZsvrGJUCAKL5B2tjhMLqboj6R+QT0iwFU2tQeQdEcpQbcNWq5qx2xK91dbbPtcO7V5qgw3yr5jRrU0L5iFI6c8b/wRJB6MdVjdX5li9CiqpuCNODcu/JzmozU+bYZFEhUUK3ghseYE2CTQCYbnpZbHws7mcSDvS78903J8osn075yn6e7EVle+xyLSnvQ5ILrErT0+7NwSS2/nLF6jekWNMyQZkPpIcloOuNntALapKtCWqvs9Hoi8gGJxRE9GQvilCDGHSEjJ3zIhiEXjyIFPXq9+lbYSpweH3uaZwLCBwYkkxOlYmU8sxpnKy8oPNPWhH4EsVjjvyY+qbaRaMlchV4k1dsmSFrWpeINAG2e2rHkGddJX/KiasI4y8z1Odj0grCQMLYRH0nVDPVF6vAqdukx9ShcASIhp/iOiCin77vVn3WenBXvvejt32avl9VOKIrxuTZfm2tibPuvPmW3/NdJVZJOJv2CpULnGEbCTqZojdeQoQ25uw+fXHN7saa+GL76hhpuI/dcbs/z7933JeH7TXfPRN0kzXnlRDYwJpiMof0JkrxlrMKuMJYMQo0ahzozD2ysNgQ9jyhynUaBIDTL6Ni+rsV00y2Xvc7J7rV0q71SQmWLa3saN2QTTPrpxeLyf8btvR22LPDpXbocg0mVah5VDRlJ9KzecssgXnnhH+POYbrdHrXve6Y86HJ2KxmDMr7e3ths8RCR+hj3zkI7Zr1y73Pfra175mBD7etm2bM1khE0TeGkGYE+YAzdG0adKIplJtba3f4/OeSivh/4T26UMf+pDnpXzQ9zKVh8boG9/4hl1zzTVuYoepKMzY8VKhBCe84zyXFwctCIwq/+h3/rz7NA4jAi5gHwMMBlCWmJBb4xKiIDDD1LpCKHcI5vqJr1Uphqkvab0Huq1sVoUVoHlhkE8yBfXT+iCNT572JeIRsWZQf9YkGDTWmAgmbpwRJYmYCmS68uISKxWzM4B9nOZdnqZXj0AmOmId1q8qJYQWm6+9OKweoAtFWkf8t26R+MrbPXo9NT6ZmkJfsfYD9sI6T/8l1bcIfBA6Odx8phtz53I9MIUeyDFIU+ikXJbf7R6ISIIJIRwyJyF6Wvib2rNVIN3HxGqqGweEd7FswfvFVGHenS/zgbKqFgWhPSr/nHJJ7KqtJyZ0N4VNYb+bLLHhaK9QktapXLC8eYFZjN+jjRJ0s0KZ55Vr0wtypdfeT41+cAXbdL6n2pbRmzMcYE53YM9CxTqqtdJoj+KZ7JJpnYgd1Ted+eNW2rFn406b1jjdymsr1Df9ToSpKqPJzdhSipmkmwIOyVIiAIwYzXQKD+gDiPikCM3RXVdHmJFxPuzJoIqpimrTFQsqZlpgG5I8My6nKkFM9OqfMNrEJE1Nk4TvWqEI2nBDZ77CyEDkTqlmGpeEfBiSIjxKBH1eKGKBsoaksUnvk0xtdGIo7QLPRg6sqI0yqZM5TIEIMa6Lcb/nDy61Q3/zNfvII4+awrnYmxcttL7yYvvFH15oydoZzlAV8jL4c4Ne9TmqvJikIgGnPaHfAsWejomxWfvjR+3orsN27qtfYstffs5Jd0NPW49Nb6ofd3/Y55yESRLtqv+KSyMC0hdDHwSNT+H4NcTzco/+4QNCipSK2dV8GJRGe2PebNsn7eKCWLstjRbY8tp6W6ax3iezzA3SPO/OV7BZmTUzh05FKi8vt4MHDzpzhN/R3r17bdasWfbRj37U1qxZ421705ve5NqiqqoqN9VKf+7AgLQqAlGAEeM4TBxTdthezn/zm9+0z3zmM870zJkzx4OGY/qVnsLyXv7ylxumfjBFlPPKV75SgDax9KxZj3mnmf8eaFXj4mOl3JwPmDEEfsW+F1QUl1uVmCMYoWL2B4VoIEYd7xJ7QHuiS8xIqdU01FiPAjDv/fVWG6yU1yBapJMYBGfetFEBtLB8+hk2vaxGs6bANrdtc1+gRVXztKYW2oGeI3Yk3mpLpy10n1vqiXkw602JmKO2ng6bWVFng/KXbdUxa9Ivtz1q7bE2GxTEN4xhkYQ6eVof1TAvO+ywQAslQY0Yn0xtCPc9pjBrJswRpugETnbQGl/3MBsNNqFwfUsf6/BZue9cD0zWA5qBuZTrgRduD7BY5mvDYCENN5qQIE5vldvYQ8xnWnGVkfNj1yQtF8FaJuk5f0WS4IVljsjcTldlGhe38pqDNlTY6eYpoPPwjz1prJyxGgyAPIZpi/7BDHk5lMWffpPQcMFQHC95W1TeqUg8ORY3i1u7ldVtsxmNW23ODLMZpTPcUTglzxx91JFdh6xPJhH4H9FSkIrCDWg004QDYn2E/Tfh0in5ycbnZoiqT5h8NHV+7Ex4ZezbR0z1P5XMUVi6M0nyF0ikS+fDixm+0bCJRRp3xdswaQuC7MMiaHoS0lzFRcYmBYQgQgoNGeMCrxJ8c5z5b9xD9YN+od+QFuO/l54GFODy6x1H/VTNay6z+284z/7vnS+13lrBF8MUiTjJ1p8wXU6gpxd4mh4PCY59+6832/TmmXbtX7zmpHsh3iWIZGlsKxUDyQdNBKkncbTps593BAIc0yV3bBfj6+OstQct0ijxqIGHMEWr0a+4PaSImAvGjTtg2ntkhvlk0Tz7gUyNf9jSbdu6OoVUWGFX1UTtovxWIRXKn0b38XeyqV/Qzj/5yU9Gb8csccmSJfbQQw/5OXx9MKfbsmWLvf71r7empiarr6+3eDxumOSF6dChQ36tsbHROA4TTFdzc7P/fPjhh92niR8zZ850X6f77rtv0vIw3/uP//gP2759u2uu6urqpqRB4hn0daGYjFBzxLkwAZE9p2qWLa+bb4tr51lD+TQxRbI2UG8WiRGoFIOEX2GnfAX3dh+0tni7UCn7pN2Tr2H5dFt56WqjrXl9etuSqbnAyzxJYl3AnBCgG+4ZScqnSc+aWznLHtzwa9vfetiaa+bZmWKGth/aYw88+7jNKW+wVTPOlAxlyH6x7kH5FhXZHU/+3Lp6FPqif8g+/7Ov2OGuo7a39aD9651fkdl20srLZI1QEbXScsV3ipZrXmkuyrSuSMwTpndoolKqbjrJ5yvaocCSIphN/AasiBh73IP5NGb0+Pb2qR/6AECSGf2ATEaHwjYxdzXPMRd8TpNykj7MXXpx9sD43e/F2cZcq17EPQAR0C+QhGEtyqUpn6NMGzNO86FEaWJ3YAYGIwTBwD83HYA4lB+Tfjoqmz/Dieng7pCpQWLfNdAtwkEADSzy0mYVaRGHaYNoZ29Cst8rYpmNaLLk5lkDChBYCFM2ZrY38Z5BmYQNSjqWTgCl5wnbke16mHdEZcSkHRsp7rOZ8/apfvJ7kuRyeLjK2xKNVMgELeZaibCsXSmAhiaZ13nrUntwWGam70FJSzHjgeB+PhLtpb+QbOLATF055wAHemDWXtemOXicMTnZ+vJMYHsH8ge0gaN/OQ6Volq6L9UgG3lQYzZ0fKSQHk9sA3Gp4rFamWk1ihAoUTv6RWy0W370iCXy2zUPj89oZ2sbBHKpiI4S+RPxbtCXYeo40m7bnthizSulObpylcnoajS5xkp+XhqJcfeQgbmPnwvvwlTTAw88IEFEsTvoh/dMBsecDfa5ra3N/Vkg8m+44QbXNoTlTQYjTZ5MdQAcAMf+Sy65xM4+++ywqNFvzMFuvfVWe+973zt6buJBMjHgUvQb5XcUEVDDyaYQoKFqRo3icZV7PzvYh7R/2aa2CxTwddKwchyuF6N1YKrqbyAeALKXRCWhV74woU1iRicLy22H1oidGteZbYfsgpKknSWAjljPQVs3Um/9Eiwdf96HpY7/Ztw/9rGP+XNf9apX2caNGw3kuJUrV7ppHSh0W7du9fkBghzod2hkrrvuOvu3f/s3N5PDn4hzzc3NNn36dAdtwFcJgIavfOUrdvXVV/tDGWPOf+tb33JzORgzACEmK+9zn/uc1+NLX/qSdXZ2umkeSHrPNaEhqi2tCpBQ1eWYsvVJU0QQaHWG72EtfW2KixRD3ODMbb8YUmIF4adEQFr+Wjcd8jAEZXMFLrSrW2at0qSdId/ZcrSBKlhjz/vqcarGXm9n2jC5zROjjdxu6+Fdtr/rsL39stcrfECJ3fX0Pfbs4Z12QdMKmz99nv3w2dvt8Z1P22vPuVZMC+bhgE4MW4+QKwf1Pai6dfd2S0lUaOfOOcuZOYAo+DekPYF4TzA4zC4sPHa077WYghfPr2qU9mqG76G8t0elrcL0bnZ5o9b1oB8QDPVJ6FkiZqlYJukIGHv7+2x7x15r6WlzE0XGEAEADwiZJJ7tD3yug5W7/0XfAzkN0ot+iE+PBg5oISZgJo7uLJQTE8xOVOZrvjimXWRhRiKFKR1/ADsQwRxTIJz6ewd7vVyXPqXdN/EQ9DyIvz4FXOxWPbr6u/yP417Zjh+POQrKAzhAcS+S3WJc+o4hMslDfbWLiXDNbLLG9aQ2nl4xWpMxUeyQMcU68iCmbJACVUCCNwBRr42KJ2F+RsDbYvVdSCTv3rBD18yaVsz38sX6+O/JPtB4eeTzoPaTZT2pa7SZTbASjZ8ksEhmMUGBYZ10J/TODMjDk3qwbgr7hWeCHDZmFqIrSEGdsPQHTfoIcvgcSxGiPiSicNFMZmoDcVGKS2IC+uiwotJ2K5++2Qpr14lBOiTiJjNzlE7kTqyMt0OVKJJvA1Jq+hEtati+MP/jP/uVH57/yovCU6PfEGzZQC+41sOc1PyaSgJuGcL4iSeeGM2+e/duj4cDwwNRi1YhNIHC/Aqo6I6ODgeAePrpp/0+HO5x6H/mmWccApp8CQWtJAEjDUAAASqBkf6Hf/gHPx9+ZKrD97//fSPuDkQbyGn4wkxMwExDQE+WCqTJueQNV9jMhY2TZTvutRDiu6quWqZNIGgGzHQazZu9DI034+trk27g25lcjdGwzEQHUhokIKQzzR1YqwK92/l61w6VzrN7k7W2LtZvl1aU2sUj+61CccKmVI8sNWR8QIk755xzDIju73znOx7bqLm52d761rc6c3reeec5UxMCLjAHQJMjBtL73/9++/rXv+7aGjQ+n/3sZ+3CCy80wEEw1Qshw2FkMZ0766yzjPIwn2NsSdnKY4xh0ACOgFkDKW/58uVZWjL108D3w8AwDr0i/rvRiPQJQEOaHXzVWmXaGDJHzuio6ITytA90SXsSd9M9Yq+VLKq0aIOQR2XKVjqz3KKNAlDp7HWNj9dGY896xbrFsowPLGZvEQlFoopJlieGIy5fytXNK2xf6wE9X+Z8sS5r6xNjprrt1bk+nXtm/2Zb1LjIykvLhZZZb8VikgRXqQLHSEvW5irFiesXw93a1mLrd26xn639ue05tN/K8kpt7fan7edP3mu93T12QcNZdvmc821e2WzbsGOT3aF8W/Zts8U1C+yiWattSOZ5W/fttCe2rrN9h/fbirolFh0usgc3/srufuJ+S/YNqowVVl893cd9bD0OxuB4+/jURyqX83TogedHpHs69Fyujb9TPcBmwWacEGIXUquq4qpAcpSqJRs8mhmAHIBKxVYZ8gDzOYJs9qUYEocZ1RV8a/iD2Qo3olRR4760twSS2mCfSV0T0aFNZFDIPkEi11ST2iFChc1pWMxSVER/wAwF99PGEhGx+XmVgpWOuWnBsfUjErvAB2SuVyp/AJg+GMN0YhdtGv008V42kITupR/oMzbR8oicrIQMOKDzINixqc5d2uT9GxFRlvAQfpO3D6k29c5EaE1+59Su0sOYX0Rlj18qxs5BLFT/9DZnKikq6SOMAPb8aAORSk5ltBiH4JkFrr0iMC7PR6Hm5iqw12JUXXqZ6cHhORUE8xBPgr4obZ4zRFwMau6+QGHe9G89vLAoYVV1e1QRfNJkYtcvDZqemS2NlT0+B22hD6ISFKA1mjhX0nM/dsevfAxXX31h+mk/pnxMLjEIGp9A5RtwQUGK/xt/ecKvL3zhC07MNjc3j7uSDY4ZbUM22Gdi2hAslDJJaBhgcoitkw1GmnzZ6vDVr37VGSk0FjBwq1evtn/8x38MGGPdd8stt7jPDGVMliIlEb1D49s3Wf5s10INUuV0+d9ovegFSVEaHebPiQCjwPDBFIVzhHWhXz5IhTKDiuBAnyGRd/T90r0dVmEPyDyrPN5mq6fNsJLOo/aIM8TMsOOndNM4cqOhw/wNJhf/ovT093//9w7NjS9Pqfwlw4R2CLM7NI1ojdITvkoAQvAcGKYwAcRAwFd8iCgLrUOYspWH39HPfy6TMtUNH6eTXde8v/Uu09+8+jAfHh9Ja4IDIcgUk0WFdblnOCahW7cNC7whfB7nKaNDvkgE964aqvQ9C1PtiHwDuZZfV2LDLWJ4j0rfW6uHBBZ7voB5W9VcygNWG19ekD87+3rssMZxTl2j9ei4W8KNXUf32vSqaTZbvoabD+2wZY1LZEZ3xM5fuNrXzVvu/4697pIbbEXDMpUX9mDwXSBf0Cd2PmO3PvpDu2ixEAi1Tn1epnd1ldNs5ZxlDvjxz7f/m33yxv9n82rn2Md+8mmLJeK2au5y+/5jP7UNB7fZh675U3tqzyb78i9usZVzl9hrV19nR7ta7dM/+7LNqWnQGpZnn7n9X+3Pr363za+YY539PWI0g/WQfmIt5g/mk31NXZ5LuR6YtAdyDNKk3ZO7+ELrAd9ofNs+dlNmM4fwr1TUeBZJFk1+wxAg3eYOzMbYLEJzPMrLlrgfB39C/akwwX/PsJFElRWWtUlyF5Otv8yN0CyI+GQ1DrQJwVPGygzqObG2PBWNFAQnSHIEnw3z8M0mVp5XYT2CTs2knaHeED29w4qbIcKpVI723EOibN98VfbExDWP1aSNJXCox8erwJ3vOyTB3L9lrzUsmC1o8sAvC6aATcc3+omFpf32qOrqJ8xAns9E/fPY/KaQGGfqUyZp/rCYN8YcR1+YJY/qHnZ4hrLYjIthKNSngSlfwIwhN42I6SLhAD9pLBoRL2j5PLiia+38ttEP5isM20hBtopAVKnFugyCFJrQIY038/JEEn1GGwLmKMVUqkw/Ujv5R12O7DlsezftsiUXnCnGbIzATH/WIIxmgZzENedhtEiMPbHHnHnjYcdJTU1NhukbMWjSUzY4ZhieTLDP3Itp1k033TRaDPDOaIb+6I/+KCuMNJmz1QETLxDLKAfEM/xiXEqte3bt2uWMFeZbkyGzjVbmFBwA8U0qn4bApN+RAocFq+yM+QQAhmyPY51w0IzUNHNCUtqEpDQXRXrPJybMssL8zIswMUvi+ZX2cykwE22Hbbkg5Et6DtttI2PgCGHeE/meyByF96bHTQrPhd8TmaPwPNrCdOYoPM83TE+2lK28bHXLVk76efowRBzkVeE9a5dvUYG0+VXao/LYU7QexRVUnP0pLgEK77YT9xSkrmes+eZdI0B1i0AQYHoQYo0yUWJeCytkDXBGrWIN6UFjQ+bVoTwC02Kqhlk4PjwJmewd7Wm3CxpXSrBVbLuO7LMNB561M6bPtZnTGuy+TQ/brrY92qOGrKlutiUkbCsUE+TzLr2RQTVHzzTr/rdccpNNq6gRkMPHrUbfb1kj8z3V+T3/9WFr6WqxDmmSDna02Eeuf78zPqsXnm2f+cm/yhfqgNdv5ewl9pHr3m8LpjfZF37+H1ZRXGZvvuy1QvorsyM/arVfbV1rrzz/FTL3K7Q+7WPsTfhWEaOJPvbtWiaEvj5NYT0arXzu4LTrgRyDdNoN+Yulwazy2Vc3Nu6QsJvYYs6HmiKuYSvNrsF5pPlsIEHJ2cvHVKhHWh58a4aHBS8aa7ZEy2obGdDGVthr+UXdQn86aPnlRxQMMohzVCSiwzcQle97FN+S/sOUFcl/hm/qHRAdGLwh7RqUKZz8gMTQ4WM1zrRO1aMcX/RpSMaE9L7fN9aq/CrfNCk/IGBpr9dk3J0BkxgQt+EFpNFtO4+4Iy/mdSR6h7uD+nImW8JcD5+sqTEu2Up5vs5Tf5egyk6eeTEkgsCJBBGc2ZgNj3gvgiIYs/F9MNof6qBsY8OmDXME/C2+Z8emYHAxT8yUNG187BgDVZ4P1SV1fOyQciVjCucCUO7Mt7DuAbMofy6VzXkscR67/WEv4/xrX5K1LExdBxNirsVw0pf4hHUIDrpPRJ5PmIx3jj/5+7//+34iG9M9EY45G+xzX1+fYZaXDu8M7HNofsdDMsFIcz5bHYCAJmgpZlqY6qHhIEHsUi98UtAo/KZSqEEqrSlz5ggEMOacm0zpfXMNZIb54Hk0qEOCZQ6ZnfAcYA6MOyZRxQoQyzF+cT7X1DCfE8oDY+VxfFR+OG/QocYKqu2XCjzc23HAzqmZZmt//ritW7nONW6/qX75XXsOfRUKqKibM0ZigNRxPl5sOyQYosODR9y3hrUFawe0r3Q+jAxrKP0fMqmMmV5Pv+57C4OkPz9PgSQ9Y0imZ4UCWOHaxKTLEoYFsOBosOIK8IxgJi6rAUyV59Q12MbDz9r2o3vs9Rdeb3OmNzogw1M710m4JGQ9mc+xP4kTmVi0Pzv14dcAoeiRsCQ6IE2/4MCry6qtW+tDdXGFrucJzEFBq/uO2JxpM7WGROyZIxvld9SgvKWK5XbU1+OyYoWNUJtB0ttycKvtadlnH/3eP3u/tPS0WH1l3bh6IAwleZwmOiOXcj0wxR7IMUhT7Khctt+lHsizrrYZQpE7LMk3RN34VR+itpdFGF8iEWmZlsRwQ6dVIOGQJylGgk0JjUmeS8A5JwdYmSukbzg8DUhT4ufkyaRhqO1s6+9aIGjVdsWfOGpD/VWSWMnmOrHKrF2+SZGEzrdYYVQMU0mLpHiC+S6Qs7qi5IGIZ0OK4ZAn+NaRMuvvL5OJlojLiu2C3BaBog0KtikhXygCsOI8j1kgGgzamZm4plXpKdBisbEGCUhxYKUjzjylt43rLkFGK+S9krpFXzvWbfMfTSsWjp4M8zijpzLZJB1BTTnCctGc4UTL0zONxWhhJ3qQKmy0Wd5Tz+0JtIf6Ah0LaAImS+PixKTqCMGIf1CgFTzRipNfvZGJoEgVFfSVyFuNMcRKPhJhrql5kjs7SlO/NIPMV5hX6jEgQgAC50QSpXIvbQ3HkrahjQARSoX7c3n2o2KQQEBbumaViGpJsuW34O2Y8ECEDJisxmQS1O0MIHXy2k/IeXI/J8Ix/8mf/Il99KMftTVr1jiRFMI+Yy6F+d1EeOd0BgatwUQYadDQsqVLL73UPvzhDxs+KI888oj7n4BkBqIZgUgxC8Ph/zeVQh+kclDsRGS7NkvEozO7WZjrsG6Y1EG4M6d8HsAYaUyDfzIzlg9SVV2N/BCjPh9G3wMNZbhG+PxUOc4oqWCfQyLy+yXNf2RonsU79tlfvGONPfnE2vCxp9035p/4AhXLN4t3w98o+lB7l/d/Wo8wbiR8WHn30OgURLQf6d9oYrx0zYOp6mSoUXJhysQ1RflAOeze1WaVTQJpqDxWI8iagT9qhcaMPQ1ACJZyTP3whV3SsMR+8PhPxaRErUGMy/SyaTajarr9bP19dm7TSmnSi7Q3SVPjFUzVM/jhjDWHCDu4Egg9gpXG547OI3yhL1xcJ/CZKgV871JQdcmPbEbZdPkZDsrPasAqSgTLzjN0D/fyo1gIfxcsXm03nHudM3PMwFKBSXTKjxchjz8P5tMfzs1BCscg/J37zvVAph4I3sZMV3Lncj3wO9oDmBW177nQWo/OEQMjtTni9AkJs7JubTIs/Cyak6c8jzlRLb+lqpJqN8EjQCa+NwXyLcmUIizoiTmWOHCFDXQ1W7Ec5Etm32VFjfdYedMdVr/4AZtzxq+sZs4Gi1YeFvFSYgPtSyxx8OXWv1/3HLzUBg7reO+1lth3jXXseIUd2XGpde0/23pbFlu8vdm1C10yreiT6QT7XqBNiktzpajpksjDvNF20OdsUAwI5lYZEmfzpR0Zd1U/iFw+buNVPrYxNmU2LdLwYLCx8XPL05v93Lzl8/2bD3xvKmXiUKFNrYqYHSXqNzn5Iyn0oILOiMGMHYvENlrICR4wmmjwMDnpEwOD/05cfhf4XoQb8QkWeWx2+kcMJMQhvlMTE1s8jGCw8068evzfolvE3AdxgSbLjQaGORCTVDeu44SIFkA/uqW9pL2gOOF7ANRvUr9PJNGPEFrFah8MsyedBCKXsrmWmgZ2YMs+a9lzxBa9ZJkNFY94nQD0yKYV5M5hzcuRpNAhJSw4FSkbHDNlZ4J95vxEeOdDKdjn48FIc+/ExL0wUwAGQNDBDK1atcoZJRDMvvjFL7qZFo77BCaF+cIfbbJEOS75nyzTJNd62oJ4ahXT5JAPE+2MdKCJznqbxhhmh7nlWiCNs8fggUHin36DnDjYL9Pc8lIRmvKHUX4nStML1eSg/g5ZDbPs/70ELVZas6SJfbKwyea9fKH96Me32alAeUt//AvhGH+n+fPn28prz1O/jtWYPg5h12F0/E9WBDBD/NGn+ASF4zl2p44oJ62sUr2/1WIe0MIAf03Zvj6lPsla3TTdigSznV6H9DJhjDqFPNcR73KrBjRHGI+3yA9pScMCOyxo/zmV092Md1jmaYsbF9tRnVvcsFDrD5YUijGoTSpggNhHWF2U9MXexYf/8x+p6us8NUXIicCP7YsAr2fPWW6dvT324JZfS9A4Ync8c4+VlZbZ3NoG1Uj5xNSz/vdr3btoyYX21O4Ntr1lp9athP3i2Qdt25FdHiSW58GQekpVh9lJoo983qZ3pF/JfeR6YKwHchqksb7IHb2geiBifYfOsfaChFXXHBGRd6ymiDURIAMQ5mB4su4OqXYD1Q2KEMQhCGhuhqb1NFxUycaCDuGXaFskBmepxHd9Vtp4v5VU7ndCsyRfm4gkWKWydY/KFyM50ipn0b2CH01aPEGsBsUU6a9UrIg6Gx7Q6ycgh7z8fotUHpVDdIflFfdYcWm3zAuEJiemho0LQiah9hVLcwRjRlyhnpG4bNWLrL97nvV0zFLQvbjVzV2fasmEL20GbEDU3ncsv4xTrkzKhgRQkKZ1gOECojypevbESqyiTDE2IpLgiRDftu5ZixRHbPaiOaMPYKPB9C9gFjgt0IIUdzUU0RaFGY76jHynIjGm+Af1iEkIgDbGSmWcIPajIswwgTveeI/dmfmIZ8EsUmbiGOZDrUptupnvPv5ZugTmy+NfZSGkeYQDSAgII09jwO9gJE9Ff2qsR0SMaZ5hZuraJ1UK6N2Q0AlbsU5mUqSVrzjXvx1lS2Ogt0S+C5ovaXPIM6imI4rJ1N9yhuB2+61oxq+D08/hMxscM74/mWCfedT1119vACsA7w2xiv/Qt7/9bdcsZYORzlZFApQuW7bMzepAw4NZAhDgZS97mT8nvA8NEkh31Ct70nsjYhZobhhSGN2JfZ793rEraJBKK6NaOzIDKYzlTB1pAmFSF2ouYM7yCtEiBrJS3lM0AnJ88RsIEhtLQAAHv1FwhFqm0bI1FfF7GRF4QAj0gKnfEJp3ram7KhfYp77zDvu7v/0L+9H/3mpVNdOtpnaaz+XRMvwgNaf5coJ6/NXj/Rp7I8Ij3pYwaXWYdA0K3yzy63jcrWF5QVlePea350nLqPKDa/JH27HTZs1usH/93BfsTz/3flu45kwJNxBgjC8rKDFgNJ1ZzXI9zJfpm3qwd1VKOMWaiOaHdxnfP9SK+WK4RhR/vGewx816Rys5oTB8T+En0BIHeUasta/TVlQvskvOOF9/F0gw0yPEvE5b3qBzSy+whTPnKxZTp/spzaufa9XRCo9rtEDnozKLw0d14cxm90+qK6+12fJXAkYc5mV2baNNq6rVniZgGNV/4YwFPvdmVs2wd8gv6ftrf2L3b3xIJnxl9seX3SgNkgRxgpGfO2O29tVh29G2y84Vyl6nIL2/9+vbnYGfWzfTLlywOjB/F8AF89HDS6jbfW5KG4/GnXoh3IsPCxhH53Ip1wOZeiDHIGXqldy5F0APsKiJUTm6wroUa6ayWtG6JfWauNSxZaFtIWFCwMofblHp/h1snqjkgcfGj8KTa2QkBRcRiZIqKWZicLDYelrmS8Mzz8pq91ptw7OSbg2JeZmrhV5+RCqHOkDsJERTyHhJ8NPVMhuQWVRUhL02qa7EAV3boQWbjBEnwosiMBrFgleWxkKACpi/DUjyDqRrDG2BiNYBMXvIeNlc2MHzhkttICbiNF5lZTUH1B0qUAEDJybMNgpEBE9MMIBF0iINCI53tFdUdKJHJg69dSJkgJCWdgYY2a4OO7xTwRXPWhhsoKnCaGdQn/TSqR+jw0dAeHF4KhL1hJAAZGK0zmkFw8gMSHodhUmVhgYJd1CbtEwneJiJcGWc2WSPbftUCg9rFGjrAODAZO0YCX2qqPR2hnN3Kk85Xh7KBcoehCo6ibZAKE+sB+1ff/eTHq9nyaUrRovFrAZUrUEr0/xPm1/ePBHI+X2WV3rEhuMzfZ5bFvjx0QKPcwAcM7DcwDFD5INIBxwzjvch7HM0GnX/oBD2GbS52267zWPfkA9NExoeEjDSmMthnoc5XggjPVk1iLnziU98wu9DOwSc98k46jOOwOcXqr/jmq/4AqFRONGED1LNrFq/zQk9FTwZI8C7kz6fyRvm5ztAMiyWJqHdyywoEfOsuoVzEMaHBJM0MXE/xHXoHwOxrVkg+OgCSyxcZe/+YqWVbt1r3QcPWFnJfuuHiOddFrHbq/hf+/PKrLtQKGx6xq6jh+1wT5dfD59DvWECeE5MGtOQyQuujyh+UJmI8VlWWjKmGeceCGMYOEy30Gxzf/gGwuUkiTGkE/Q/ZqvdmtO829FCrcVaR2gTMc0I7kviHcGnrqNP9dO9EPxFeiZrjvvuSaAVr9OeNHPQPnHXF6y8vsq64oRdGFS5MAfBGFF/1ifqg8amQGZ4CKICM9lj+9cfnuGDOlfmizGRAC2qfYRdJ3ibdaTyD67f45qg/AYJeloFBa7xLJ8llFcBNqj5nsI5AdS3948uMOadYpDilQl739Vv03qeb08f3SStfZ+tmnmmfeC698ocr8+eObTJ2/7Hl79OTFFU4EFR+7Or/tj3Q/bYt7/8jQJx6LMVC1bob7kd7W2zg4KDf/UFr3QN2aHeFquSKd+7rnqz1p4Re6ptszXNnG3/7/oP6j3HnzFiHRqTJ49utrObV9q5C84WGEWL7VbMpAH118tWXGZXLn+p9z2IrftjB21j6zbtn4HvFg2kTYwv651mhO/ThLEAXTUpBunk1vGg73KfL94eSNvVXryNzLXsxdoDWsQVc2Gwr8Z6SkSIFQ87xLNWw9QWEbSb7WJAG1o8KbQe+ZZgftcnaR5mAeHGH24K8QEtn8lyITgp+OaQ4v/o2BRnYThZLE2ONsCkbLiHC23anKcVvX6vL94VYoBILLIs8Okp+KUrOgApbFpxrVVFKkWUxkVcdjqxUlc6TfWSSRq+T5SjvGxYLPbUtyIZ1QbX7iZlY2YM2uRFgBZNXyvzvp2KXSHiagJzxLN5ZhTNU0pql143agwjViBfKEwRhoci1tvaYIl4tc2cfUjmNQNi5gR3LpS/Xeu3e52aVywYX8Rv4VfQp5kfHPQfkNe9NqANsExSeoiPrIm+1j86PmA+j82ZzjDwbJgjxgrt0okmiIyI6gU4BuYkPBtJpvhod1728sSQS12kQ1rz/KeQOOJJ6W0Nn7znmZ3WdaTDtUdFaUFNeXcCoAkJFdSGchGf9GFSggZnVEW85JeJqNS8QpuUVyyCJYsZaPis9O9bbrkl/adNBsecDfYZMxrQ5oBjhnmCSQrTZDDSYZ6JdQC9Drjx7u7urGAMaJkm1x6FpatrREA6cyxiOR15bCxH9qP+XgHsK+BshfyPQsaHMWEty5ZcYOALTGreawpzD+edOZJGk9ehoyNgkAhiC2EZQIYHRLMGedJEO9BKsqaE9UGU0Fm70PJWV8sssc1mau0qVrml0laVKBRBuYKjxvpEBAs57/5Y1HZsEhGr72LaovoCcEAdPn712622pNI+fd+3bHfHYW83ehLmcL/eycYVS61p+oxxfRAybMTCqxesdJWeRb24B6YHps/fAbWrJdFmHb2dWjilSSuS6ZrMrsvytWf0CdlSzBBtgsgGQhqAFZgv+rtUmo3yCvnwwOxq/lM+a3qp1p6uuDQ3Ok+/OmCACHKYFPqxUBp5mCaug8IGrLqHoQg1dpP2NBfzVMdKxS6r1LrE+8sKxV8qaX5VNtYKXVXWAlExu3GEf+rPvGI3mxupYAyKJZwLzO8wSceKAosLzCwxY157ZL3VqM+lIPTfaI03Ht1qNaXVGkP1UVmVbW7bLvhxmbSW1do0nY8qiDCMyJ72w3ag+6D7YOWL0WHqsDZwDYEgDFVcTBZ9KjEeA+nWAUXar8olKCxQ/7FO9nhojiH1kc6pzQjtENDsbN1r+9r3m3pa9dN6JOTGPgXNhskM3wPWWNa1EZmLM87MZ9bgsJ98T1V9WJtVdC7lemC0B3IM0mhX5A5eUD2gxXpE2pfB+AwFj6u2ofgsG6zZbP1lR6XiDxgDiNhhAR4MxMutUJqQYUmx+iWpQobEAs0mFib2FX4VSjI6kicTuyI2uV6dCQgF3aDzLM06UAkFEUkw0SyxqCtR4lQSCzQ0IgLYci323IXmydHpuJZWCL/Ij/kSZi+YernJnTYwCKKIiD+eX+Swyvj4jLWHtqGZKBVQxTjku7TyaTHPjuSVKNp5vnUeWaQNv0CmehtsOBKXFJkyg1J3b9jpdzal+R+NK+o3+GN8L2V+MO0n6O6Q0LSIHZ/pHvoWkAvg1Pmmfx1MImUiiNZwkP4XwTOW6A/5XUCwZSl3LO+xRxBDBCJGCg2xBIOBCSgaPoea15we7p0rhkKIhZU7NFEE5vFbTuvuChzsz7oq0LykV4c+gPgAaWukH38CQeuKoQ6k++qrQpnhle/TCxK8J9y764mt9uunf2Gf/fQ/pxc15eNscMyTwT5PpuWZ7Fq2SqUDPWTLM9l5QDegx+gn5gFzkX7M5tOVqawQ4rtCEN/cr0nuTFamvKPneKyYISfiU8wqcxGzVAhW6gPh39kRwIeXlGkeyoSSeqFVgZiEmPfnjRaa4cCbBzk8lgo0z7sKp9lDhTUyDxZBLAK3QAxegUzxmrr22wVC/1tTK21YfJ/dIyJXwRL0T5p79c9l0hpcu/giu2bhS5ygL9c7dNuW++22DY9ImxR35onMmd5zZ9g0LyH8ETR52AIxI0OCyEYz5NpoMTkRvYMwnP39AyL8EYgl7UDskOUrH36vgKXwriLc0Alp0WR+K5AANGQFWovR/rCmBrUG5EBw2X3yHYwDvS/CXKZuCBAGBxjvYWnnJYCDOdO/Qf1DmwGzkq99gTaNmjWOdeExR/h/VpcQ84+eypAwmasocJPSPAnCKpqqrETocX3tPTawp097UIUtLW+ymbWzXHiwoxvo7gFbVN2s/siXr2GP7ezeZ0tr5qvmhdYQrRMAQsyGtDgCGLRp/7O2aFqzHpJvR+NH+dKeErFCve8H2lqtuXa27e04aIkRaZPFbKkQZ1wQDMDAROQ7i5lxEGgdH8vAr7Zf2tnEYBfZPTFH6aeYLCpIMMuh79uQILzbk50eBFfFykRdMem0PodzlAC7ulWJD8ZN+7aejRCtb0CmrSmtqJrn6zI5cynXA/RAjkHKzYMXXA/gJxNtfMwGOueJMaqXSYfghHvmWjImJqn8oBXUbBJq3CExECJuO86y2MHVktR1yiRun1XM2C2tT78W3nDpDZof/ipATJYvkwsxSZOmUYIPViuQPmXcnP05QR5Qz4gTkxCTRlBS6oCWCMI80708P5BuwawFGwsbqDDvvGpBnScS/wHTQ4BYoJZJ2crm2rDEfv3dDda+v9miZZ1WPXuj5Ql1zx3s05jIXRtErCs1/Q5okLwiU/iA6SC+Rrb2c54NGcQ2NdUJlIQIKcbDmWud7JOZBj5AYXLyR5sr108mQTyw2ZNglsQa+0YOgxZIklURaVwGus6QeZoIjkKZhwLCkS2pLmz2+Ho9HwlJ94Z7n3Y/l4UXyucuQ6JPIEZgkpzAGc3DFdWrSISO3heP2aRrK8VoPXEgPprrdDzYtHmzXfGK33NTwZCQcxhirW2h5Pt4/RJCfFcoSKyPARz9FBIMQz4AGhD5zB19w4QUsDaJYIz3K8i0gsSSyirK3U8qIgaJ9wXCHa2JHjjleqZXifngRIfezRERsUlptwdUh40jdXZYplEXDhyVBqJSQoQOrUHyYVKTqO/5s5fatUsvliZDYBTKf2nzKmuV78svtz0lho65pNq5L0m4kqc/NTiGqIYZOhJvEfMjoZOEEd0CJuge7nGmqVBrYVePfFbRZ4h5G5LZHwwT7yaMjR4solzaBzQh+oZAh8n18crQ9TBYIAEO61kwV6GJnorRfiSxjRhOVdvnAD44oEY6GpyofARhMKv0OSZmdVH56qi/qIsLVvTNMlJTXO1CrmNbO3amKxGTn1C7h2hgjcEUsEIARE3LFshnqFKxjc6w/3n0x2rrkF1x9iXyO62wp3Y8Yw/veNredvmNdmbdGRbr7bLvPvIT+7Mr327f+vX/2grFIrpo3mr72i+/Yze95HqLVpc7iENEqvABTY8N+9fbnU/ebR/4vfeJ8ZI2UQNJnLU8zTWAZkbUPh26xq1Se2AhAb4j6ncxrPhQwSzSTrRN7K8k4jGx7sJcJnQ/TL63R7G68oUASxyoWFz+cmJAh6SBL9JeKdbe5wVrEyaxmBViDtlPOAIx+swtnzfMM8Y4l3I9kNYDOQYprTNyhy+UHhixafW7rEdQ2H2d821QxORQQpJHEWHJnnlilBoEk33ABit22lDnbJmgbLdyMUeR0pg2NRifKSyEKenqZD1CKSzggyOdgukW2yLCGkKCBZ3FH+0AjspDklAN6hsJMX8kFmMW+1LZuaORYCPMlCCmMVeRB5JfJp/IGm0w8neS5sgpiLQbkSSWyTwCQjxbmWF2nphIFNvRI/UKnthts5t2abMXwSKTQpgCTBvccVf5dq/fITS+MpsxV/4kL4gk3ZoIkMA0KHOF6VvgvBkHgDloK39JSRxHCc7UsAS9rjIlIgUWPrtWLvOzOMvzMFvxslPj7WOkicR4oc0b0sadV9xuhYKDzxcAyaRzVfdh5pfuS5f96Sd3ZcfaLRbvjNm5v3+x+2Icr5TMb5Za6SaDwd1NqxbYLU99yT71qU9Z6Ct0vHJfTNf/8i//UjDGPTZrQaNCCEj4AcOStgZMlVALIb7RIKEV0sSaciJ/uBYxByHIeQc88KjKcam7SquorHCtKnmI0TMgyGUnNMUgnIi269iKBS8WVYZoVu2to6TR7pXTfGHndkGS5NsKIaQlFLS0XGZYxTIB60nExaxpvdTavLvzsO3rbLFlM5ukQS9wM6/Wno6UqQaHLQAAQABJREFUJoWys3SGTvdL6HG4/4jniPdK+6R32rVjMELF0gqJaSNhilUi5Dc0DDBE+AihfeLG9HfYX2UxAKz59BMMJ4IFvuljthL8mDyQqsYayG/KhtEcEuGuxwIdKUZR5ZJXz2BO+DzQCczf0BIVydwstRx5/fjgGdkSjBv+QqHWBT8smALQ6rrztBeK4eoZ6rHZlfU+ls8c3mTX2EutvLDMfrXzKXtgwwN29fI1dk7TcntaDNMh9TmatUsWnmczKhV0VnXl6aw/9aW1Vl1aoWaoD1X/7SO7vN3shQ0CXZhTKSAhmbUx04mvBLDDzLK6wMRbczEqJqlMTFKvrDxgYuNCJ8Us/EDsqG1p32mzK2ZaU9VsH3vQ/Vr7Omxb526bGZ1u8yoavJ/RXuMX9szBzTLDrBbowzy55dLfCtegsB/P7N/k4EZUPESXZE3Oj4wJC7L1Ze786dkDOQbp9Bz3F3yrsaGOFss0SvDaheV7nElKdi0WMhzR0BVVvLtJTh1ztVgPWLnQ3coq27QRaXObAuOTrXPYsNgAxye0QkPa0IHjLtCiLvs+bVo45PoGmZJ+aS9RCj7Dw4hs26dCaJdog3R0IohnylAbOtvm6Cjfqqbt0gKPCUFQNhsSEjg2i+Ml7ogq1tKSpdu1YWPyQNVljqF7MTVDmpkc6LbOlnbrONxuy14y5qB/vLKfv+vHjkDmZ6UIOhF+k2noICIwLQLSGyljv/LTbhLMFX3CJkqC+UTjF4CBTJwHnsU/GCP+MRbpibGGCTqmBZovyRFJqp3YEfsbUaDh6GERbmKKJ5mvEIoBkZu9LunPP5njMfS61Sdze8Z7QFz767s+Zf/+vq/Y/kP7bfnS5Vn9eTIW8AI9SdDan/7sdvvVQ4/YFx7+qpuu9YuQDgj04P09kaaFGiSPgZR2uxPNTAmdc+2GDjkXaFh0Tva9nA/nNc/kOhJ77inW+5AnX0xSKQyC/rHGwayMIkdqaoNaxzw/VSkfgZKYkz1FjVZTVWIfWfNWJ+h/tvVh++baH1mZNDY3rHiZPSFC92trfyzY53r72zVv8TpTh7+/5z9VU9bo0VOcHp90kX5AO4N5nZZpvwMwiqIUYzLuBjUPRrACRDYJqlgP0GpV6nc/feIMDp0hJlPrRlx9hGaDRN8Qh6uipNRq5adTWRJVXDWZ3emePq0z8f4+Z4pGhG5KrB89xoqUv0Rme8XSMBGagVhjMB/FavuQ6u2jQiU48h/+KB2O/x2uPwCwuElkKjPnQ8YWJq5Vpml7uw46lPcvNz+kuvVbu5iXI91tNk0BV3e17rKz5p5pG/dts7nTm6yytNz2HNmr/pOQMlrjpSLcaaqea2t3P2U/XnunjAXl4yStF8x2pZitWfVn2q+2P2EPPfuIGMJhW7P8Erty6WW2bt8me3Dro86wLZm10JbPXGyP71sv/6K4Pbt/izUK5e4PLrzOXj73At2XZ3euv1/12KS+L7PfX32NvWL2JY5W96Mn7rYdh7cK4KjErjn7Krtu8UuFTjdgP33qbtt4YKt0Wvl27TlX2MXN0ly3bhATJWj8CdM2fE+C3sx95nog6IHjU1G5nsr1wO9gD2g7DzYImUnkRWIOVlBQtkuwwhfbYGymJHDBJjU8VGyxjgaLVrQp/4RVccrtGhHDICdQSf0Sksiltqlxd7PxYEgHoAGJ3+nf/iP9Q/tZv6SlwGwjlctUZpgdwjwqk4hhMSttLa22/cmtVlUruNUDZ0orpo23brci3ndq86aUgPAhhpNLlcNCTuI7qbYQKHXL2iD+UW1Dne3fsvckSjrxW5CgAileN3vGuHbAQwSQ4lAHk48nzAPwyUC2uzlLlmp4r6mPgSvH6dh9QlQ0Y+j/UtLc8GnkR/rbfqjVJczpxbLR4mOE8VygkUJCjL+b6i3HZSvsSc/ux/2q45F4qxOgUF9yM5bjRbcQ4NEQBvP4mJtO8QnqXSx/E4f4TZWdFDT9pvuecRCAprMXntInlskk5w03v8u2PLzRHr/rViuvwo8GAlTO6mr/nDyBbIi02S3TGXz/gpf9uVfh+LPmuT8jWwm8O8uvONs+8Zk3WJ4c5nHodyKdSX0SaVSDRJDYtMScZRY5EEDqPL8hjEOToiCwc8D4h7eyviFMiEpDOpwIhATFZTJHgqAXYe8aJld3BL5T8P9oO05louYAsR0VUEKngoVeJOIcQcXONvxbgrAHP9n4gOoZsXnSKBRJAzyvut4ely/MEaHelVVU+zubrU70A/+dQVTOAmmMImJG3Fwu003KG8HHSMxK6OdDGIcK9VFlkeLxCQK9T5o3BCsA/7Dm0P/4bQEEMEPmgnX6o770FEKShIAo6FMEKIUCDSlEuwQktRhU6oVVAto61m+gskdUR6wafZZorgyKmRKXJ62W6kSdpVEZTkFaO3OsU16O1u5OxTXCXC0iocRIgXYHle9CFbpBZenpzmSc4T5GI3ZQwBe9sZiAfYrsipWX286jewXz3u1AC5eecaHfT3yi8yTQgalhvMrFsBzqPmpfvPM/bcXcZbZi3hK7Qz6GtKGurMbu2/mofU8mfNetukplxew/fvltW1TXZG2xdvvBYz8VCt0ltkyw4fs7Dtkt999qrzpPzM+Kl9rXHvxvq62aZm+9+Ea7+edfFbLhXjFAV/x/9s4DPtKrOvtHdTSaUS8rbdcWr9frXRvvrjvuFVxiwKYFJ/wooSSBQGiB5EtIKKGXQMBgMBgwvRniBraxjXHDvex6e99Vl0Yajfr3/M87r3Y0q9FWA7Z0pWlvueXc+957zj3nPMf+uOkxu+aO6+0zr/wP+/F9N9ra3RvtihMutAc3PWLf+t0N9oXXfMR+/tht9rs1v7dXnfwK27Rng1131/ftfTL3q5Kw2an2OC2h3XSapsAkFJgWkCYhzvSpv1wKJAe1A6edpmCi0zQtzUd+tNUiDb+zgpZTbCAxR5X35VD29BWCIyW+B4vCobRJjAMgCRJk0ACgrg93CbNzY3E80MSCmJDDKymnkKTs0BQQDf3r7/wfa9m6x9avXWdnn3+O2oKZjJZInc9T8D6EQoQk3eGvA68JNdg3BdSTdkOM8sqVKy2vbdju+ept+174HByBkUskhBQleNxL/+kVtuiEJUEp3qgDb5mbDhUOCfJ7ciGUzGkvDAS2/sFv/9jn7Vdf/qk9dstDtnXDFps9b7bQq9Bahom+GF8/GJGg2uOP+x06554GhzYww0IP+xPBiDhBq15+mh132UkuKK2950kBnPTbqstPHSekHnZh6QxiVWX2oktO8hfPDaAreXLanmV77CWRHbZDKJL/N6rnWOhj9M7hJH8qRH6YbGKChehxh5vvodQJN/9uOYi7WZ0/r4eSixTkioFEwsRuXFI7GYOY5rqwr91+F46kjQi1Jw7TnTEcYf4xEUY4wuQ01SshXWlE5kf4+Lg/jPIZ1w0w7ap/9ngfV5dD+iGwjzwharK5oWfxlLnL7aeKh4MZHMijvZozo0JMvHXd/bahY4e9/ZRXOLCE5DuNIkSGcA7ct3Cni4QXLkEEjAg1bqLNkzETRF2HNt4FEc9ZQZL7euSrlXLfIMYRwk5PGmUN4QO0NEzyWCM6BCqAAFWK76i01JTlmjgJDz7fUEX6KiKEuZT8+OT7xXHaOqrjBDQmv6riChdm8EEakS8NC5mb4amvMJ1DyMJyIphoqOiokFIT8sUZEcJp1Pt1QPUksHaBND4INkOSuph20DLFFWi2vrzetrbtsLbOdptXO9NWzTvWvnHPj21Di8zZ+/psfs18f26YK3iOPKmO+Bg9tuVJhbsotZeffJlVxaskHI3YLY/8VuuT2a2P3m6L6xfYgrq5EmiL7Xb15WNbn5HPa6mtkC/T3572KptTNcM2tWy3JbMW2ctWvsTqKuvskW1PWo+E3ubuFvvDuj/a5SsvklapUT5UUfvCLdcIxXCr/Lb6XONWEau0V512hXX0dFtJSYnTGG1/tTRex6y80E5cvNoq5G+1Q2aZqtJYCgVKDhz5cTxWzPSX5ykFpgWk52nHTfVqw+SgxmfnbmydR0iSQ3hxwx1aPE62/i7tcGkBH0xWWW+y1IorcOY9+B1PN43Sgs1kGhGjXRDBppl4SXud9w+1P9CGEOeIFApJapov4MODOBUr1ox2Ad924mvsqle+0u699W6/dqq8ERz0zDPPtA/9+KM25+h56ms0ZBBorNcnJQWLHowBSEkHmjIX0Ox7bv3ar+zGL//E9uzZY/X19dmnn9e/ga4+6+yz7Q8/+p297Xvvt9C8biL0uiPRUGcEtaMe0y55VOamMJrd2mEuEBx/UZ5ifIm7GhWjeGA9PXmNYPpxEnd/PjHeMHD+kOndmVoYTsaWynuuE+WQaP84bu0gC060yVRICZjvCZOKgXmGb0aQCYUjF9hHxCJnmMjhj4ITfABdP2r45pDySwL/DO4JTfQ47gKt94/o5s8jR/cmv16N41zY3r1nJ/4WPncw7cWSdvDmxLRvQFrFAD2O+/BXidolR58ukIZ2u3fLU9I0aZOJctLaLPLZ75jRBWh5JkquuREtAAKgacUSKDx/5YoZXUqa9aJ8IL1lWq3fxJKLyfm/W/N0CBmOQCl8PMW4Gsb42vIkb9Iuf1OeTpdMuukcpqc+XwEn7j5MykO+SXv6mq2joNO1UIUan2inGccE9GYupK1RARUUaXxLdPENl24JkSnFHasolT+q1i7ADxCuqAJw50Cs94ymXIAmMHRK1gyLZy6wNS3rrVNCxlUrX2pz4vUWk1D3h2f/KCHRrK68yrVR3o4swu3saLG6slr1gaDSFdcIc2EAEoakeezu7bbdgvve2SpEQG184UNUIyGqX0iFjDt8krb07NangpKrXSmZx/Vq85NeREvWCxKgfPZue/J39oe1D3jnzpTfVEQC0N+dfbV9857v21d++03BjOfb5cedZyfMXO5CFpr5a3//Ax9DZy87TYFpGx2ZEHpBBxL0ZqzSX+FBFzyha2b/BJdPv08xCkw8Q0wxIkw39/lHARhe0H365GPUp4kVm2hPaFR0rHDG7/UpNKaO5VpsxHz1VFpKZmiAIjhjchBNLpbmCHt97uOPSbxM8KgJD+Ca0jTOlHvoicWfvJihC8UY9iUj1tZaKw2KzOTyUvbQHV+0K191ld3w3e8deiHP0zvPOOMM+/73v28f/cx/29uv+WenEXGDRooVXFK7h5PRnr5iJ5b+y1wUD5UUW5/eZI/e9IA7+DrjeagZ/YXeB3T1w3/8o81f0GQP33ifPXvvU1Y9u9ZmLZ33nNWY/isRg1mr+CmOXCUwk/6RdsECpxTYUz56YhaH0xq9w6lEsfLAfJLdezZVGBskGCNHZeNnWpD4szJGqgcMGwN2f/VAgwRUdKQ04m3J+cbgF/8XMoHQPPu5wRwqMdrrZmH44vQkgk2b4miJC5Dc6/WCTHDB6Skvs46cdz8m5zVpiC7WdZjuIXRklxnWl3MIsDjnk9B27U602oekJXj9yh32quPOd+Q1ghEDUX3CnGX2g8duFyPeaScp8Oivnr3Hfv7E3bZTfjNz65fnLCcsL+en6ktdCShOfRzeX8doE+2HX4ZO+NyA/lacp00X0YJ2DWlMgYLX3tshsUi+TcB3I4DqplDEx5wSVNJQSEI4YMyN0UX5F0iTFJXgxvjkXqwHnO5OUyG8aS2zVK1AieoEpCFwjkizFcaE3DoqUPQizXfKkLmJzUN8cgjEmxiSuaoEOUzzoHW+rgMwISYTwQBOfFBmZz121Myj7P8eu1PauVKbX99kFWXVtqhxof38of+zlUINLJEWrF/5eBsyiagmzZY/2B83P6x2j1hDWZ09M7LW12TMDEHFW734BLty9WUqV2EABPfNNTc9gYZJNyt5W0WJ8Lkcy150jAqYo1IC1evOuMpWzj8uTS/5QAm44p4ND9hVJ15uf3/m6+2uNQ9IILreTp23Qn5VLXbBsjPtlSf/lUzynrAvSYA6esZRwUYZHZkuNywbmvn4RTCVxs4Tl+lvOk1dCkwLSFO375/XLWfaYmFxFDItUgSScwbAW6VdKo3svPqHtC0n6OHmldIiNWpiflZClYQdVqUDTOzIwVhlTpTB4gWamYQtLZ4DwNHq73ASQlJnL3EzFJ9jUAtF4W4ra5RvVWTQmtc9bh96+/sOJ/vn9b2vlObsHe96x1gbWEwJoMsIAG0vgEJXr2jRw2CN4wixEdn3AziBOciRWOY2PLrO/vq1fx3syo/V5oX35ZP//Qn7jy9+xJHMVlyw6jlrIM8MYCZdqYR2gwW6oh3hQglLSTGebYptUiefqKggp7vllcT2xOEkxggwyjjIM0r8DyY23FiBUU37mh1OOYdzL3VxAUOZHIgADkhDTu1RVkWcAdVzA9OOgIOJHYy7u2WKtNADEIAhaRIA+E6mBSRMv0J4arKEwQ5MrKSZklaKe/QAer2dltndxGniCFGu7s1OXI7WKiatEPkBAU1dQUJr7u6yNa2bPXDq34vRJZAtc/Frjr/ATpi11LViFTIN+/IffiJUNPxKAv+f7DIO9Ddx5WIy3yIekpsOij5oIQZkIpeZ6hQLKE+AP+hjRDGmG4+pVK2A4fnxfIfUBnIaeoRCUnh/sEo45+0+YtBynJkiBNFpTB0xy4MWHAjviyl4anQkbi09ihOVEjjRkHoxXzDv+NzmJV0rxprIXEjQV6DGPUvelCgrBGmA7gRXJf/WvjZbUDPbN3/mSjNeKbr2CERiqeDVv3v3j23pzIUOjR2RdodWM2JIvv6pjFULjpOf0S/thj/8TBDgx8gH6Tc2oOcNU8PzVpxt1935HZnCyac0Xmf3rLvP3vji12jMIPWlK5bO0YVBzzk4hVa5Pl5jy+cvs+/f+zNZgiTcJHBz83Z71/lvtt8Iaa+tp8OuXv0Ka+1pERBGmTTSZfbwxt/ag1sfsytWX2RtgigvF02KNeYTPPOUSbEBUdOl6adojVaR8/4cBvL62PnpL1OPAtMC0tTr8xdUi5mscSwmJeQbBCOE1qBcUNd9+bLfrn7UIgNlNtQrSN1+aZIUAwkTjb3Tcm5yYMxAdPNcjsgsMARiHZa5HQ63h5OYq0clzEXje7SLGSy6Ws1UT/kGyE4eu+qpnEB3ykwwdzACpheMCsIxfe/mUjpXoh1BYouwEk7W1073zIwn+U6sofJ4lr/HJNc/X0+VlpZa984Or362gOQ70Br3IGMdiQTrh6lqc7LNd7Vh20tLqi2Z6rKImE+FwJSAdPgJRst349OjwZlXGCXx7I74mMUsHX6JB5cDTJlv8GgaQYsRMMa588AvMNXTZw2LZua+KPOM2ufzWLqd5I+woYIkAIC8xkwT8Iw8L8TvIRVHg+eOfgoZSDYn0OBzvZucSSvn05/qjjaOZxBak8KnL1P48xPhG12gerjplTQz1LFQ7aebgO9OiMl/es8WWzHzaNsjM6zHdm3w+DarZi1W/Yvs/u1P2prmzc7QumZr0qc9LHTfT9oGjDZzOjWHBqTwM/NHUuARQmSQ1gZ9jYAexPijseHGiqIyK44VWbMEDkzxMhPPTkgPp6cEcvrdGXZdmNnnfp1oiAkddQg2/0aFIqcyFTy6QAHM8wu6rCCtdZMkFghVEvBg7nsRjtzPKehT6kE5BbrOzfKUrw743EkBwGMXV8v/RwAJyxqP0pgYtCceedwWHrPIXnPay+x4+YFhtkccvpMXrbIF9fPdZ+0UATfEhM5XJqHkref/jf38/ptkkveAnbxEPqsKTItv1ukLT3BB6q5n7pOWeK2dtOg4m1XZKO1Vn520eJWv35iSz62apd+rRctiD5GxfM5Spwnj82oBNdz06G1251O/t6hQAc899gw1Oc/efNbf2o1/vNm+/+CvZE4Yt388501WV1xuf3vS5TK3L7Q7nrpX+RXam85+nVUKwGP97m1OB+ifK3k/5D6d67bp4y9ACkwLSC/ATp1qTWIxcShnTfgISUyIOPey2GoOtUT1kzbYO8dGupdYsuAZKy4dcqYoc/EL5sMAmpnJE+EoJuGoZFKEORbVYkc/65EZw2ST7oH0CXVlFxXACV8VD+Sm6WucSWHHeS/9nb0QCTN7eF9CeSBZMWWDYsTxU9p7/77XcgQzzr1ayomveSEcpY34tzQsnmX1TXvjXmHSilCKINoz2hfssh6BBtNPmOaURWMKBCroYAGwdKdkRjm01soVsDnPsZj31T4cVNEaCpnjwZlVPWs+RP4CmCGYMjfzEdKYBuJ+UwjQEBdAAwJJIByMvy1kvMnPx3Y6X+ZF/LGimtsQHMfrR4I8BpIBcx+Rbwv3OsJdMWZZ0rCkHfQHZTLWr76CmYa21AGNAUFoXYCmKWlBKbNm2f3AuKIM0Nswl+7vD2oEo//btYKH3vC4w2QDiz23RqEbVM6n7+oQNPagtQuymbAGCCqYBuajlTiEBK2SEipoC2tJsdYQhgf1YgMG0hGXB5O6XmnZ+oTiVqh5unRUJmT4KDE8dT2vUkGVz4zVW4dQR3u1LsiwzvNBQ8n5EF3QzfAQKtXOYvyPyD+dAhpJP6V6ocECIQ9xbFCIeP3STiUGhIIn6GtRPchb44c1z2MISfBAOCJ5l/NG3ZR4dgNNX3CAdjP28IPd3r3TLlp5rlXkl9p2+T2NVhKzqN8uO/mlrkl7skUx0USj05edpJzyrEXXnPeiM71+9+54yGaWzbB3XPJ3yg/fWYUtUKFberfLV6zLls5ZZKsXvsjrQx5rO9ZbjQSWC487wzZ3CRhC2sIF6ts5DTNttxA9hwRWcdyiZa7herjtKS/v7OPPsItXnq+1WwF9tSl5x7Z7bXW8yf7x5KtUHfWX/gb7u61l/YPWUlJkF59wrl0pmHA1WBswnfZoy9PWqfOZgig0yU7+3Eh7NPb8ZF8w/XvKUGBaQJoyXf3CbigLCou+Zr90QzVd6itmcBbTDml8u/XtOdGGQLerW29V1QrESdBYLeZMrGiCHIJV9tEszGiOJheO9tITtJxBMXH9cnYlrz9X+vKXv2x/8zd/Y7FYzKvQ1tZmv/71r8dV5zWveY1D2nZ2dtpPfvITZ/ivuOIKq62tHbvu6aeftltuucUWL15sl1xyydhxguvdfvvt9uSTT9qFF15oy5YtGztHfjfeeKPH/bj00kstKuSkZDJpP/zhD8euCb+cdtpptm7dOmtubg4P+eesWbPs/PPPH3fsYH4wBvhzxC7diNlimkXYJxtM8KIyYykRM4NwxGI4KE3G4fbf7373O4N+L33pS23u3Llj5W7ZssV+8Ytf2OrVq+2UU04ZO36wNOXGXP166623TkhT6J2rH+jjXCnUHkFTmFI0LfhfYBpTpF1+N0PJdfNBHIfmxA+L86yKmRkU9H1nv0Aa9HzmKd7Zc5X+4naKNXUc6PgbB9AgJtshnDPmHsZzqM1B8HLmXIREe4DmhbnN+fU045xNY9DUSNEyBWkVDHaU2Dy6Bw0LTDimZ8T8wYQL7REClDj4IKkdDpuNMKBrnSFPn+IjTwARVBXzMkeQ03fCCfSClidBOSbT2IZYXL8lsMgkSg+ntSgILFVtkW+SDliHTK0QwmhbscYlz/oJ1WV2bqTDWmSC1p1fpjKU8UEkFePz+ID83goViJty+AtzwQcn0LrtzTQpM7KR0YTVFtW4aR6bC5gUsiY0SOvfroCmnRLiAGzw3lWdqDOgCQiPw6IfbR5VmxFcqTL0pUxiEgEUAQ1dK6d+69P3pAQgh1z3ugW1Y9xw3cBIv5uSUo9CaVD6W/qsr0Ww3XME5KFyUj0SXCqHPAAw5uOj+Nyo3yjzcQlAuwSwgEkbwmGZwjps2LXZWvd02bBM+GjX7q5mezx/TUAAXVOkegM0NKwbuqRhqtC6iRDJ+EM2HpRw1ypt8LbETp9DqC3t91h7MqsldUiA6tf6uU0awjLNAUdVNwk6vFLgRAl7umODB7qlH55VwFjaGZUfGnkUSosaGdlhPb3tPp44NzTQb4nuhN2f6LSCoZ1C/gu0kB6vSnkwfknklytxDvROhP3pNLUpMC0gTe3+H2s9ExpM76c//Wlbvnz52PHMLzCvp59+uv2///f/Mg//xXxnyiPeBGnvBChTLC3uo7XbrFWBYwf7ZljXlnqBN8heuXaDlVbsluOvdsaxgdcEi0YIeFaY7L15eJY532C0ShUQj53AIWfKc176nJ34+Mc/bh/4wAfsyiuvHBOQ7rjjDvvwhz/sfRYWfNVVVzmcM4z65Zdf7oIM/Y3QU1NTYzfddJP93d/9nb/e85732L333msf/ehH/fY3v/nNBqMPg3+20M5+/vOf26mnnmobNmzwMt74xjc6LO073vEOe/zxx33xvPPOO8Oi/RyACwhfjzzyiAtJ4UmOIYwdnoCk/hdCU6nMK9WVDmk7ICYDQxI/kC4sEI5KxwTgQjEepfrr0QJP3x8okxrWPfwEUALh9MUvfrGdd955LpQcf/zx9vnPf96+9KUv2Rve8AZ73/veZxdddJH9y7/8i992sDStq6uzXP2ai6b0da5+mFxACoLDQg8XILVTP6JNCIQlkLD6hS7G8SOb8B8csLp4m5VIiB3UBsaRQrI7svU89NygGCAADlutOWNSraQudhprPGfufPeEEN9CsPPzui7zPMd4ZY9lNAhoamCI0ZQAUz1RgkGEwY7J3BLfH5DHxKU7094nJrR/MNhUYCzkFapyE/GSOgwjOyY4qSCup90IGsyVMPrUAb8f4ukMy9QKX7TTliy1o3vm2Ijm1jRP69X0GGi0VXkoez3b6aQ8LizptDPrKu1xOeg/oJhaybxSvya85EA/odlEwj/0lH7MNRiAH/DHdUkJd9CosqTS+3VQ56gzgmBlQZmEnxFpPLolIum4t0dCkto7DACJxz8SWp/iTtVFqnyjjnWnuAi6CRJcG3bEywLAxBFNJURyDIHJpZgMDR1w4ghe1HNEPnz9Et6G5B8bqVT/CXk11SqBa0u3+kSxjyTUJZ7SBlVMgEOLJNyVKrCr7kX4QlMOgESngoNveHCNFS6W2WCZhBnGIG8qmjJI1AntfVVJuZ0wY7n1CXEupfGBrxPCeE11jdoxao81r7Gdvc0StAOkPWiBF5daqWDkmlcERz4iIay6rEoauZg9vOEJO/2oEy1eKAFI2iJoOaSYcCAt8mL8NsofKy6EPqmfqZAqJw2b8sK/brYAJlpkG9AtNDzQ8UIQpzy1y/2M1IZgrvdmjHtDA6bKe5/sHWDjLpn+MUUoMC0gTZGOnqiZqVTKd6M5x4R322232bPPPmvV1dX7XL5z50675557xmkN9rnoL/ZAnpWVdVv+ortkalcnB+R6qfCrrHnzSiuJd1hj4x6L1nSJMVM0c/2xs3ZwSUydFgmEq0FBlvoicnAZHPLVaCAQbOm/Yi0+mQmGGY3Sv/7rv2Yets997nN27rnn2qc+9Sk/jubmscces3POOcfe/e532w033GBoHd7+9rfb/PnzDUFpx44dPj4QkDBPOuqoo+xjH/uYa41g/t/2treNlQNc9LXXXmvvf//77brrrhsrG+Hgta99rV1wwQX+Ck/cf//9rplCyDvUBM1ZOGMSVGHCYDLKi+NiLCIyT0kFYA7axwXyFm1hpnYQRguGPybBCshZdrwxq9FT4S/e99enDz/8sG3fvt02btyoq82amprsn/7pn1yY+eIXv+hIfKtWrXI6NTQ0uLDU0tJySDTN1a8f/OAHvWzeMmlaWVmZsx/Gbsj6QmDYyobMeUA0EeMHPDYQwZhZwUS5BiHr3sP9WSDmKlakvpJwZAVRMZVapjCze4GkAjFfUQmazBeYGwFrTHJBCT5PDF443jgGE46GJnSu51oAGkjlQHwzgGFaCQTqP8Tf6RkloZ3ITjDXAzqOaZp42EDDQx7pe/nW35sSOl6JhBYAMsQsStMAHDSCUaDNwAw5KIPrDzSVClkt6gzukPWImfZnrUBjSs7xaFAQBAYLFbtHPof4tuDjBL28opMUghHb+oEia5LW4TiBe3QmWuypvJk2qOfdm5Z5Lwegl8ZZSK/M07m+o4WYXdpo9aXVcvbvti4JKw6dLSUacZGGIxqzeiaGpWkZlvkfENUjQkSLjUadlp1DnR5wl7kJAY8+pZ/c5E7DW6CrEmxYg2QyXiaBS/6OKWm1HTxDQgAxjNr79uZRLYGsQO1LDEgDI01TCPbAczkqmvYnlVextFIR+Zl1yve2vsyijWWqkwQKtb/0aGmK1Fh8KzvWtFjJDPnTqtzuLR167CScRQct/qJ6CS4QSxdmENLHl34zBlh70C4Pay361K+/bB2JdrfcYA4dFQ1eddKldvz85TJb1KajrgUJT6R3rTGm6WgmizQe0QzVK7Bsm+7/yX2/tGNnL9EzEpFWqlxFB+OVMUvQYnzWqqRd3rtSi2oS8PpSgzLVjdgpGjtPSyh9UCZ1Y0+Ahiu0ZywXa7xpcGgs64iOZzTNBTtiO6XUF9NpalNgWkCawv0/IDtmmLbdu3ePUeEVr3jF2PeJvqA5eD4mFo9YXExFWadV1G/UAhZRANkaG0nWWUtzg3W211pVbauVxnukUWJXDPMsTajs0DF7skDkTEK9EdNxJEy0chaR4wQMFJobkN7KymRWkpEeffRR12b827/9mx1zzDH2spe9zIUoNBDc8+Mf/1g7fn32+te/3k3jELbQBoUmYDDWCxcudJMxmH+0RSHjhQCFAET6zGc+EzB36bK3bt06zryMw/fdd58LCWiWMhOBEBHirrnmGtdgZZ7L/k43sKCRYOzCZY3d2Kh2nTFrIbEIBp84esOIKl6WFla0ScDOZgpHfiFvys8XapmQwQDyYnd0SJ/sWmPCMxkz9cADD9iJJ544lh3mh5jatba2GpsLxx13nJ+jj2bPnm1r18qcZdeuQ6Jprn4NC5+Mprn6Ibw3/CyvE+OdkaCoMxeiCXDL7LJi2iR2NuOqw/9KOfmidbECqY4iJEnLUSgOxl0qvM8Pv4zJcoCBI2VqYya7/qDPqQ0wk2gx81QWmzE8Uzx7PMuMsXCcITxQH0yxQrM0nfSUaEsHiVU/uZZG1Q7HfVgn8p2sHWTlAkpaiMLkLUxokEpiArNRHZIS4FJizsM4OpPlGd4/0SflBSZOQhQUk4tgQB0RAAGJQAPfK0EDISku89dYSczy8AvSb86FdJkob44liqrsD4qJVCkB88RSMf0SJrYVVolBxj8lnfSld1uXjexS+YVaExZXWWE88IEKL8n1iV8PGwIytFNsJmkvIgJG0CYMjHmBysT8lHmjT30xKCEpT/Ue0hpbJP+iymiZlYxE5I/T4RoRrsuXlqgkLsuFJMy91g/pmAoVLBnBidWH+YeJKZx74jJf87EjQRKNSE20yucshNg25dsrPyI3K9bkWCSzSNKAzNCG+yU4bJTJmUzGiqpknqb70Z4URqV9SRMGwSzV1if/v1Fr3bTDGpbNsj7FUWLdTE+nEuokFOu5D/shNNtkfmSc8tclxLirhDj44qNP1vUFduvjt9s3fvc9+8/a99nqGce5cNKtmEZ5GmtlghPfnWyxqnq0oDxzAE2UWOtIq0OKU+5xdUv8HIJYQgLPfXsedwAKghoj5AxIA0esQ0z9EPppY0mJBCd9P1r0Hi1S6ILBhCVFW+o7rOP56quUBFh0Wfm6l3hWbHCGtKAtBdKeRuWLFawzTsrptylIgWkBaQp2ethk4p6gLcBvgvTv//7vzizPmzcvvMQ/WRBBUXvRi150WCZQ4zL9M/wYZauIl1JhccripW2C0u7XYrNDZmel1p+KWEeLnMQ1GRdpF7NMwlRxiSbPQjGB6ZmSiXyi5KYQR8CHJTvvsYU9+0T6N1qjV7/61ROehZGOaCcWUzr6+ZOf/KT9UXFu0AZ94hOfcG0giwGmeWhAent7XcgKhSAyraqqcgEazREmeGFCy4gPkTNwok14zw9+8AM3r/vud78bXuqf//Vf/2V///d/bxUV4xlvrmccYnY2WaIckJnchFHlxSQM5Y+AHiWIYDEOaICyGUTyC48hJPHKPOY/st5gAEImAIGJhCkNjCIaqlwJGmM2t2nTJhcOv/GNbzh9MLnDxI3fmC7yrKGl3bx5s9P1UGiaq1/Duk1G01z9EN6b+clQD8cfTBHCKbFh2BlmTnDBs0BsnUsvmXce7ncxzHmKJyOzG5OPWLEc4ZMyHwrrcri5T3S/s3dpCGD3p5nooiN0DDOonmExs8ovHFsIR4yxkOmkKGjsdUFuyewM/Qw1SGUCafAk4oSMa3AgfVh55EouHKXLDZ/f8Fp8kIAQ75agCqMePufkRl1J0IxnJeyYicr3C7PeABlwMywapQzRkKAdQUga0hyqD0ukNBeV5FlcoBB9Q3k6H5j0UWaucgo0NndFZtldPZvsvOpye/Fgq/1mSDGVCirF6KOtEWx3t8zhmgvsklOvsPUb19sTzRsUU01iqkzQqM5kiXLXJ7Zay0CHVQssISKzbJj6QjHcpZoboEVPSlolCVFDmHopM8wUCzTvIFgxfzTEa4XGN2qdwJKn4yRFJST1p/qtOdVmpQqYjJlZkQTCrt4+CTOYmKpkli29MIucEavzatK1jB+EimLBZ7cmC6XV6vI5kroWaW3IQ0sl177ocdIEYranxBhDQEcwZQyQKo6ux+bMBaKiEyKWUHBblLbQeyy54kl9r3IZLw7AQSMzEjSgPvgjcc15y86wWxSzamBg2FIS1r71++/Zuj3bZAqXtFNlQvfaU68UQEObfUYxrwCimFNea5eufImPfcCWOhLd9k0JWGcuPcWOW7DChVDGiiQtmeBKuNEG27C0dGUVEvokcEelPeKZGZAAhEC/uLDcogob8PhwpyglSxK1u0umwV0qq1D0IHbVTM0vLWpsSvNN2BzaMSIt3HSa2hSYFpCmdv/bWWed5S8WQHb3//mf/9m1DS90srhmSN6po4pnwTIQjyclHAi+VakvGbXNG+bbzq3zhSLdb+UVbVZRKRjiEu0eRgY08XMVfhm+Vrh2AgEp18LN1QeT2BHzv+EiAR2Uu7brYO4Pr12zZo3aFffF5nWve53NmTPH0HTA4MC0A+pAQoP0ve99z/BPAhkqM6FlRIBBEON7mPge5h0e++pXv2qYyf3mN79xwSo8jvbpTvkifetb3woPjX1+7Wtfc1O+sQM5vtBfnR0ztCUqVK2huCW141cQbZaNe4/s34lzlLGQ58jjYA5n5ke/wlRkmjhl59XY2OgbDDxPMLZXX321oYEDrAKavPe973V/MDR5+CfNmDHD2tvbD4mmufo11GDloulk/ZDdnqiYv+popRjkHmdaneGSf191sYC3xRACbMGuK7vAfXLYx5eEOeRIJAwko54Vu93yf9Bz2hdyLkeigInyoDxeKudIPccTFUMZiJhjSb9d4Egfchqm6zGuLlntD1HsDjQO0lh56S8wxmF/wVBmCmbUZ0jMbLEC0CIcoaFCW4ivHpMePkgE3JXErLaIydZ85c+HxgNjf8IEXWkrGhbdj8CA7wptxMQrkdTcq3kV8zA2JkrQCEhYAimuNlpt+TL56tM9CADOIEMjXZ/dV8zm64vmWrUc+k+tqbUTutvt/r4CK2+WlkfnNsel/ZFfTk+yXeZYPap7wPBPWOfsgyqzWKaRRA9oS3VbVVSCkfxgoA0WBAmB0nQn9LyIUUc7WKg5s1Dao2K1RbKQz60IDdXSdKEdBYEPzSFCVLE0PjDkgFWkhA4XHU64mVpcJsMRaaa4b5g5SH2RLcD7+JEwU5onwWRUmkVoQzfo5WAZfJUAmNwlsAX5OpXKzA5hKfQPYxw4UATXYTEhQYgswjkwpDF97IIRfUz+EyWdA767REJJvuhy77qHfJzNrKy1+zY8qM2UUXv3S94isIc99sWbv2anzl+luEUxe3rHOnvJqgvtr1acrzEHOIvZ9s49iq30U1tY12Qr5i2z9Z2KiSXBiioSzRB8ReqJMJRUXCiPtaUNsyGEI2mKOIcIOU8CW0O+TAXVzqjWClaxnfJL6hD3K4NsWyBAju0aaw+PdFhCwpMXrjIYi7kbSt7T6YVOgWkB6YXewwfYPhY2UM0mS5gL4TexdOnSyS77izzHfB5MmHurp/lyLMGAu9CkIyXRlC1ZttZ2bptl27fOEypOpe3eMVcLnbROZV1WWdUp04g+Mb/aZctXPJJhOYFqVdHyMZbfoX4ZlTNq/0DMUt31luxstFRvvWzJx2tjDiRvzKwwp4IZJ7GwNTU1ufYIQQnTyjCtWLHCNUv/8A//4MhzaJJCJDzMwObPn2+g1OGjFibMxsgvTB/5yEfsO9/5jmtIMtHbOH/99de7eV+mtoTj69evd3AIzAP3m6Qt6t96vpgTmayUbbOCimdsVAJS14CYlIGI4nAoaG9Gf+43v+fgAvyweKEhQJMEqh8JYfTuu+92DR10hd6YLuKrdbA0naxfKWsymubqB+7LTmiHGrRTXaH4JkDjEpC3SpHrMfPBlCdMCEmYQwFtjAagW9cebjfATBZrB7dQeZbqO0Fk2UlnR/i5Ssx/MFiHXflDqKCXjZChOYg/GFM+M5MzsbRfVcRHCRS7ApkYRculHjiEBLObXUaYDf5HpIgEJK4B3ROUQfxrYMZFKjHX2mGXbwpQ1dQbaO+sKnseCETUuVwmZhXFEnbVj22pTqGWBSh5nIPhdcd4jZ9i7fDXF1dLQNJ4EtNK2NoaBS0dFehCadGQw4AnZRbsQDpi8vcVyKTVUj0fG2m0qkSzLduaZ4tufsq1B1QIIe32pfX2kz/cIrVKvlUsrQs0Kzq+v0SbgblnzCMUEp8Hc90BaSEGpAFK9qA9CkASigT8gx8RviwxNEgSJof6JPzI7xfhs2hQtJTpW35RAFpB2QUILXqW6OuU8kaQ7FCsoxnROj1jiscHrXjLSKFw4/0CMUVuhANMzTJpMyrtWlFJsYKmq47VlIu4GCSu84C1KjfMz8cZHap/1g40Kvtb3gp5ZpXXD//wc7vt8TtUFczXBuzlqy+xuoo6O3fp6dZY2WCPbn3chUn8troVU6pUWsIZFTV2yfIzrb6i0tbs3mRAun/xpmtsft0ce+3JL7MtyV22oXNLUD/VKYapNIAxWi8HZR4ImiDjkxhaAHtkJl2iPtObyMN4LlbfLQIxU9f1a65GSJ6r/MpHK+2B/F7bMxqM/8w8pr9PTQocPkc3Nen2gmz1tm3bDBjoRYsWCbig0XAm5wVyFloEPjHf+ctJexeLXMs9zAbIZkVy9g53xPZX/1BQapiz1WY0/VFaoy7dWyDBJS6fktm2ft2xtvbJFfb0U8fY1k2N1tUppKIh9rMOPdGS4cFia999lO1ed6a1bl0pIWmmFifFvyhOHnTGaHzQBoI0R0I7+MQTT7gp28tf/nLXGMHIw3AjGIO8xo4iEN2ALpBuvvlmP9bU1OSmlQ8++KD71bDr+ZWvfGXMLO66667zcfH73/9+H98j8sGsD/+l7MRxzDYPKAhu/pACGT5jJbPvsOKZt1tBbIfWN/yEhm13T7MYc4FjpDvAxwLf9eIYDED6VHYVjthvBCKeGxgVzBo/+9nPOqIgBYD8iGkdwhHaNc4fKk0n61fKmoymufqB+7JT+KwQVLkxXi9UqEYxqFEXjoB4zqQo9CVGTIk0TDC2h5uGxCS3yXegULGWZoy2WUyMcoGeYRic5zLRDpjBP2nSwKRMdvqBFc4EaKC97OzzvLmPkr4zvjiGBqms9rkJWhwGiY0I7IBxgHawW9oW4KqJMzeE7ZVohS/LmEZD/HbmmICG7lskgQHhtiJSLkQy7dcPBMG3Gce0m/tnxGpsUd1cWyxNwdzKmTJ9jrtWJRaNW40AEUbll0O8JWf8MwSxUBgJx2rYb3kSyvo1fjZulWb51wq8LY1IoQQ5XgUSVM59eo+dODdudSfN1WYLQuD4RH0ZC6QwbwLBzi5rsLmxRgE1zLCG0loXlEakYRvAf0exm0aUPwk/q2Eh+7VL26UOk3AkLYfmWkkZ0pbpkN7QzCLEsK5iCue0ED0BP4GuIK1hAkZ/7+lrUcBcrQHIKAgqGYl6ItwUS/gplBaqUNqqAlAFVZWw7n6N1q+SylKrOrZeJneii+gQng+zC8c/ZSOsMR7RorjGanyx4S3+Sas57WZp+rzkhAvsXS99q73vkn+wT7763+3M5af5GLr5qbvsq3d8y/a0NytfhNu9dAbxjrhaOwQzDhpfVyqBxZ+1yvwOGPCINkuKRJewsyolVRfpgog0dBXlcYtFNe/ot4Mu0Da9PIkUrh1D+NMBXeHjCI0fYwrtJQlhrkoAImcV19jMgiBMhp+YfpvSFJjWIE3p7h/feEytfvvb37oTOeZTaIyAgMahPJFI2MUXX+xmWOPv+vP80vQtpozdvGCSZYLFBGNA2pzxSTuKMlHALlqztBB08GVg8QsWiOxFYty9moTLa3bI1KTLBnoqtPtXJmCHCqEAKe5RvxDPumss2SUkoLyjLBKTXfqcRywa79SCPslqMq6AvT+oUZ5Q9Eord/nBfiHtFZZ0C6Vqk0WiAWLV3qv3/43F7gtf+IL7FwH1jfD79a9/3U2+6GdQzpYsWeKM1znnnOOgDeSKORhCEmZaMC/f/OY3nXnDXAzUu5NPPtnNwxAGQMMj/cd//If71GRqiDDp+/a3v+3nASt45zvf6d8z35555hk79thjMw/l/i6I1+KGu3Vey5zTd+8O6ID6dHfPHp2r89hG/TiAawHEVGMozQhUiUFDEzFpf+cufb9nmpqa3FQRga9U0MhoWUMQC2gK9DmCIDTFP4vPQ6Vprn6lkpPRNFc/TNY4p5dIDvPTLzRAglbi95DNDDPeSgpL9UwW267hZmeOJ8t333NoTeB/tNOuzYzd0SVWmXjS5hZ3WIcEgta8KjnG73vXkTxCG/5sSUWPY35F80wfETd9SlduWP4cvR09NufY+c9JdQfSGiRM7MKEZgFTJphNGHiH9mYUiOnPHgtcG8JNU2/M0ArlR5SSf44z4TDfwwL50JhaWrPYZkbqrXNXm5ub1jfUW5HM4HbJzAxzM+4nHpDTQjRBYGAK8BdjTrGJ+O5ADkgf6S4E5mDJMzLH0qXZvYoWaeUft9uG+VVB85SPX6N6L6iaa42lMsfSxsuzXZutXQFGEV6WVi202dEGa9/Zqnb026yZ2jgsG7ANXdukxZDwo3nGTaP1OSJZPjkiLasKalUcpIpIhQQCAUFQiOqPeWJKWoqYAFviYsp7JPyUCNq6OlrhPjadMt9rT8kHT21AWMHHr62/TYKUBE2h1uVK4fB1GkuwQRhAUCC+GIImPljd0jxu2bLZiuujVhhDMEv7EiIsOLVCkogmYYa5Csw4Tmwt+oq+n1nVYFWVVbZFAWC3dOx2pMZVDcvtzmfusRMXrrLXnfYya+lps5se/a1rDzWg9I+Po/pRptvQvrK0wt5z2T/Yz+670b519w/tbee93prK59i6js3eVxpRLpgOS5tapP6JCVAkIq3doEAb+hTkmPlf4rsERwl7EiC9LWoP40GN1nn/NtYCzqMhrJYgfLyVWZtM8OTxqvPjrxu7YfrLlKDAtIA0Jbp5/40kqCdBQHEk/9///V/70Y9+ZG9605tcYAIhBgd0gk0uWLBg/5n9Ca7AMZ9dpcyEvXeXzBcC9B/Ng5pKi7Q4R+XYKiMBOfPHhegj2E+ZGxRrlyimHfHJEgvMiPTzxSUJK452WdznSvlfDORbd68QvAajNiKBaai3yU3h2rcvsxkLH9Lum6yctVgcbMqXRqQ0pnKEtjcyvF4LLOYsWnz3WeInzhnTuMx05plnehwjAosCqhAuePTntdde6yZfLGgIw2ECvhuBGFNKNIaZCb8aACEoB+Y+TGhPJksw5hMlQEEOKsmUZVQOtb5oOW1giGDWce4OhKQCMQYeo4WFLb228TEsv4PGWMMYDQ6q3AO8mPhgAF7AHOJ7FKazzjrLAFbATDGTbpw/FJrm6lfym4ymufqB+w4kFedHFAcJh/rApDS8h2cLh3WCMvPsVcosr00IYgeTfEdX9xZqM4P+HJCQtKlkns0YfMYa8/psvfzxEvJrkE3XwWT7/L1W0wdCtHi8sXEcmqt1p2MgxUOAhiPcylQoIMnh3ZMeoFBz5UKc9n8QKZg7fKdev0PhzoWjtJkZ14DgVi4TOfffE7dRLISxfD2rBTIxW1gx26oHY/aDb37Hdu3YIw26EBKlCXndG662+UfNldO+BByVMSShDH8k9vrLSsokOPXYbsXUAQJ6UdU8wUcXS7PVYzu6d1mvfEFnSLtToTJn9qzRyNw3MTNXJwZtSc0CmfzJdFBaG4B51EqbFa23NY+ssYbGBjuqssmeGl5ntRIuaqzcfnDN92zLhi1Oi0Ix41ddfZUtWbTAwwhgXkYbu4WilxAAx8zSmEIKKEip/HFq5cuHZnUITVOxTOekgZ1vc2U+mLIOaZnKi2R+qDhCAM2QakoFKqG/dpkioiFHu4hJIb+LxcCXaiNCpB1LTiPlTYpHohY3CT8qu1dMfj4+XKXEV5I2UGtSW0+L5Sn2UX4EZD+CBhNXSP6l0lKSz8Em7ojI1K1EGyPIU6wxIC4297bamtaN2lTpd7NczgHbfceae1WHNtslwWlb6w6JIJgpIjxKiFFbiSFF2zGXw5z3TWdfbf/2k4/brU/cbhe96Hxr7e9U3h16LqTdUv1HJFUNShjCdBNzRjReaL9SyQG3jujrGxZ6rcI6yM/LDVehm65Hq4c8TULIL9azlq/XoOagagWqnjkasfXaDDp4igR5Tr+/MCgwLSC9MPrxsFtB/BYmSAKNMsmdcMIJ7iPBjjQ+EwQL/elPf+oahbe+9a2HXd7hZcDEHph/hPkw2fcrirgjLjHBaqetVAwbMM8kJl2Qe8pkB4+AlH1/mA+f5DUohpoAc9znwo4WmjBpzRcaW1LC2B4biclsI77bRnecbQO9jdax6yirnfNkeOlBf7JQRyW8RWR2AdPIwtimXUs0eIeaMjU7mXmEfkaZx8Lv2cJReBzhKpvJD889t5+KxZJYYoNtx4gbk1BUoMW/QLbi+TL3KtLOtL4PF0lALEjKJBEnX1broEZ8dAsVK5LfKeYjvWv8HFUW06FcKRfdDpWmufo1V/mHexyaRiW4wAyHO/r4YvBcEfgTBh6GAnjfg0k8Y0AoExCy1DUCYr5VRp/in3T16zkW41Qi2GQXFg4m4xfKtelxHAohyc4eb9mhAjRMShZ1YOiDVBwVMqTWhDFtEDOjmElennSt97lQxPBHYnzgk8Q9fMc0C8Yc4aBQPkTiaD2vfG10zIjU2uzy2XbjN3+qsTRi73jvO6y+sc6++oWv2n1332eXlNe4IH7jz39pO7fvsFtuvMnOvvBc35ypqKpQOAbiM+Xb77tutp7uHmnuFdC2QiZ8KvMJxcJpa2mzmXtaLC6/IATuzOS/Ksqt9dM/dbCIXt0PYMTMhkbFT+qyxx5+zCqrK23B4gWWwsRZQknnjjbbvW2nHb18qVVXVcvEeo397yf+x0B8BbI8qU0jBKDa2morU/wi5msQ5NAmD2B+p/EL/HR3j8wUezQXyRwuKh8lhCnKRjbBPKy6ocZWn3uy1cyo9iqHQhL0JMDvnmSrBMD6wCJCV3j/SKOIoBCV6W5dbLZrY3rlv5QUkh70KJCAlWjptpbWZuuLy1RZ8a3IL6K53C0rMolzIN/V/ZjI4Xc2IKuNqJ595oFiPbtvOPM11iRzyV4JfyAQDvXhN5ayTV3b7bJVL7VZVTNtS9tOW7ngRXbBcefYnJpZNqN8hr3+jNfIlLfOdiR2yR+pzl51+svVHm26KDbSO1/yVoE67Na8I4Fbcw2aumeHe2wuwuCQNs20IQUdRiQA6hJvV6SiSEJSgcA4UunzmLBqXtK1KfVFaFpHPKoi0SiPzdSwyiMAAEAASURBVAglBH5E5WME/bc9rzdcQvzc9NvUo8C0gDT1+nzCFgPnTAp3vpuamhy5jKCUCEgk/EjwY/hLSC64pCsyJtAI4SZM7OaxO5Z5Hd+JIyG343HHw3vCzz6Z6bFLjq09eWcnFthC7WaXFMStb0SMeqTFInUPW9+u0623vUnq/i4rrdmqSTvYv+T6YJHeN6/svNF6sYuez46amETtbwp6vN0Zg+xrp9LvgZRMJ3aerhUsZL7TtGRFVG8qwoV/5heL+Wi82wpKt2ZcyxWC1k3Jll1mduVCTYIhIWWOj+BI7venH3rSmgu3u29X7que/2dgNsZs+LObI3KXoLkNuyGLgjDM/WKIdHhMQM3OIvs3zxhmez3ybymTlhdfJ/qHLMT/6Isc24XQpZKzbz3g397PwVBRaemxc8B3/+kvdFMyFQsjyyszhQh22bGqMq85nO/EQCIVSYOE7xOmU/zBbPMKU1g3xooLRuoxrnMTPJk+cZ7+HB0Qcp18BDF1QsMLM10jE6qi/jzbuWWHnXfB+ZZfXmBdQwn7q1deLhhRsy2bt9q7/vGdrq35J5nnduxuswvOPC8s+jn9POe0s/bN//jxh1Yfc8L4A0fgFxrDp9c8bR98xbvsg9f9l81cONsFmPa+LmnNkv6MAEbQqr/60jrNZdpEc+EovTGhYYImBl+efrR46hc3hdTDtHPTNmvRBlFUfl2sjQWCNgdYBdM2tEfB0zZ5I3iGxlAGJXR1JkG4BB1Q5u3SFG3v3m6zGmZaQsG2W/vbtTkpbY7WMDY/1rSu1/OdtKbGeXb07KMkpGjd1HgolaZtQL6G58r0brBlm+3Ys8taqxQrrq7RtvXusLbWDkF/z7J5M+fZ1p5dmsMV8F3ldaq8p4d67MS8Mh9ntLmY50Qv5i9SROMXbZLkd/cBK5AgLmWkzgeqI0zq8C3zx0v3DCkPTLJFOGmk5AfmotLkNJk++8KmwLSA9MLu3wNu3axZszwGDk79CEJM1phb4VxOIE/SU0895YhcB5zpc3whbANLQ0q+EW72k574WKTxS0GjFJotZFYlmD4zjwTfuS+pyb1HJhx852+yFNOOGag9mHWMxjYKRKDaBlqOs9adS2xGiZhx+SPJJkmaC3GTug47eWfUcmRKvQg26ChJupLE9ee9+mK79hvX5ox35Be+gN/uuusu7azKlKZik8iYtosYa68WdwU09IVxKGZDyUYb7Fiq8Dm7dYyFf28fQv+2VLsuhYmDmQuE6LGs9vPl3CsvsG9/+Gv7uer5f/q+B+6TqejMgHQTPCyTjWE0S/1CrjqYFOaHrwVCLHlE5ZuBlSpGLkVioPJG95osHkze4bVsjMAMYQrFTj2+VDBEGcMjvPTP+yl6ozVG4HCN0QQr9N4YSONjih2pivdr150UkeO7C0dojPgPNUdZBWXOk65hQjjSn2uPNJ+NaHNjFCZcJlDwnKDvARU/IiaeTh7RM93dlxRaZ7811c+y2dKCfPZjn7YOweDjB0sihtpUSRddcJFhlvvlO79lDXMbZSIe9c0D0CST2rhD0MjPa7Maof0Bg56ZsKBIidYOc61xHvpsVS+cYYOCOxfch6/toH7St8l+rZ16XnkmPKmf0czRP+oYPYsyvdMJntFSPZNRbToiJIEyh78Qwm6/BI8ivZ5s3yB0Oq2d0sqUl5ZZmTY6auRXBUAFwBfbO3bZuuaNmqM1X0s4WThjllXULpDGp8KGE+3W07zZaqT1elIodl1RtEIMulHbhVmgSzGqm55fEkLZhoGE/MKiNkeiDO1lV2VU1+museRmdxJ65Jqktqgl4hH8vOqDGR/CEiacfk5tYKD7+qBzRW7OnZnbWLbTX6YIBSaYfqdIy6ebuQ8F3vWud7nDPXFWfvnLX9pll11m//3f/+1O+cA6g2IGnPNfRhKTo8m7TztRA9pNCtLeyYwdadC2iouxo09P/s9BxdnFQ6BJysQrv1pwsv3VMgWbY507l9usRU9YvES7dTILoA5J7QJif67pmGl4XG2oIbbYMcG5ci5kGrnowtdeYq/+yKX2xS9+0YDinkoJ5D18bv7602+VZui3yEFZSZQLhSbFtBrqa7SR7vnyNatTnKSdIjvUxAFXO4LqJ2BniaXC7ma46KIRyaQ3BWT3AbuSy168QrDv2+3N8tO75qtfzarHC+MnABDXf/+79uavvMuZspj8HWBKoA80IWXTKmw5NGJjIpfgAb1d+FeXuRCg6zmGH4gH8dXvhCDEiVPTWDjDYvnypSie5QE2S1Kya9X5Q03UTbyW77o7E8lushg3NCLhODjUvI/ofSIxPhwismvpQppnlpFoEzqa0nOCYqeiBxQklgSEODF6ciZdCzM97H6S+i6mcwyFT/XHT7REZs6DeuaGde2gNPKD+ovlSYOrTEcEWa3DMk0bsFKZhwGk0tfVb+ub19k999zjwDI5y34Bn2C+e+/73mt/uOkuu+RvrpC2p1A+SmWiZ2mAJujzV0RrG5YGEvjF4CPgIAwh7Ay6CZkoDJGVELYdjnxjtw2X5VvlvDr31+nYIQAUaWiiDXFZQWid0vwYK1Gfaa4Eljwl6wiy4HkHDANES8zc6K+EUA09b5ULhLib+GFm64F9B6yzp8tm18+w02ev8uC3Gia2vnubPdT8hHXmt9qiWLWtrFsq5DjF6VNGvQLZQftcFYvbCpX14DBWE5hHakwpYHAoGHmheuMeQXfYZpnazSkUUJJkG+YdNiwzFwmfMnSMoLOFos+gni1HG9SJAW3IjIp2rnHS2AW8AQBAjx3FvCS/x+k0tSkwyew3tQkzFVv/wQ9+0PoUYwKmlPSe97zHQRpA4SIRO+cs7Wz9+ZPirchfgYUXQWgiJoJjMMODowNSvYd+IcGKkV43JmwGDNxE+U14cfogC0tcKESlBQThW2MtqRrrTcyw7uZ+LUZbfDZnNwzhBzSjlHYBB8VIBuwB7yCABU7umA9kM6AEEbzmnu/Y/7z7U/bdH37PYXCrawIb9cnq5YuDzPywzQ6hy/16ESBPdc0Xxxgyh75IqOQDSfu7isVrf4k8aHdYfub11OXhhx62hUcttNv+71Z769f+2RatOkr9qbCUeo1PKi1tysjxgtIdVhjdrQVbGgcdpwx2PhFk2XllcRwuREAt8oUxJaEVMxDMGlmgEbgpH1M8tHnskMKA4LxL+V+6/5v2xbd90s487yybM2u2gCzqx1dHv7L7L7yAuhxcypXT+FzI1fOGOTjE9Pu771Fsr6jd9dvf2Qdu/bjlyeRpR/duxZeKiXGtlIAZ+B25EzT7tyoruz3UdgxNbIJ6QNcwlhHfYXrKI3E7Vkhm8cK4HNoTtrZzk3ae47a0osmDTVZVNVm+tLpzhAa2u32LYjJ1qWx2zYNRSIuVFXKwU9eRtJwMe0epf4N5FCoaJkHc6zvs5MHJQyebbj7yyZ8JmpijXmMapNrnRoM0LLRPUpngk70Oe0npxzPfEIgYE+OSric4alzC9ZDCCAwo/s+Ixk+nCYCmsMx9dfo0L5fUymdmVp2tfXatLXvRsVZfVWPfvP46627tFANfNGbuPS7vKfJj1cpVdsPNP/K5a1D+XQhACDpl8k+NS3B1LQ9MvRJmZB4jSd95FkCmC/XsmNkhOOEbOW+W/KUc5bXA2veArlemXTnNbRpnBHUFBQ7ABtbVHmmI2MSgHLQwxH9inhyRz1FK/k1oXPhjDuCZYogwDipkwheRpr4rmbCqokp/lmVo59euqD7a5gnwon37o1atz0KCtEtodhh7mWAWyuSOOEZLBFrRKrClJ2XJ0a/NEhe6i1VS1vxG65slcCclHZXqh6Zp3NxyJjRbgDmMSKAfoP4IR8qTTRI0y5j88cjxGmIbU+2fTlObApONp6lNmSnYehYlNEYwLyScyoltg98R8XKAeA4jc/+5yQPkcMCi5eAiVEGEp5SYIiKUM9mxy8UuJw7lOJb7BM+2shICBL/x/eHckCbmnByK3zH+jVoUaJGJlinCesMz1rb9Rda6SzE94l1WXdfhdYWsESGBFWlHEAjbIZkAFlAXLSAlYshpT1Cb8Xnzq0YOzB+6/qO2ff1Wa9vV6nEv9r0qaEeiW0hPiTI5DpcLjpzI79qhrd4hBrjNEnsWWUEkYZUzNmrBk8ZKTAzCGo60f+qEj1VpYYkzyphKYu5AQFIQq2pOnGmVDdX20g+/MtgplRBaIqGOeEeYYOVMMjmBhnn5+KOFwiaxXAb9xaIaLOgBpVkIh8RAgCCIeWUKc0n9AS0Ms01dGEODGj+UiwD9lq++23Y+I3v5dVstER9vTgZDAi3JMzOxtjPuQNxSL2We2ue72B3fsUWT0DWYsF4hYU2WsHxCSwmDQqwQhD3qiVkZDA7tmSwNqY2Vx8+w2Sua7Kx/u9wDSvpTpTdM0bryu6xI0eZ9M0LcFD4M9F1UmjcEyTDBwICexWc4h4Tnwk+E0DAhfIJ8Z50j9tvbb7FjT1thtdU1Vig872ceeMZ62jtswdw627TuWVt04otsTsVMG+5SX6lfMJejPxg3PDvFaivCWY/6sECCMYweNMHnhTHVJfMkzrNpAjmCZ10CdA6zsbCOf45PN1MLJb4JKhD6IJUdaRQ7H6Py21QAU1JJaVRP0P5Gq1+69020dSTD/HLLE0M/KP8j+qh7pNv6FBy2Kr9Spk1F3g+M6/MvvcBu+Pr37Gv/83VHaOtobbfLLr/MfnPzrXvznILfEGqiolOZQAo62VDT5gxAD3QIGzcknjFevg5mjGPGDzGMuN7v0bUFEmQbFjf6eN+5fbe1P7vbhhZLQzsnaikBOBSk9CxKk4Spep80RMPSrrjWRhOmm6lrPA6xIan5zU3KM6YU32zQ/MnGBfUp0RqXFxdktvzM4BdA3iOx9laNllt+tFq6H1l/dGyzwnitm18C7e2CipvBmp1coADVeV22Yajb+iVg5wschmfZB6TnFnxlq6tLdYxrPiKwMMIWZWYLU+lbfDCDVlciiXII4Uh18udt7AL8i+Ubpzm8tS/h80TGqemvU4wC0wLSFOvwA2lu5uSCadKJJ554ILf9Sa9hUdhf4hpgRnmNMYla+/uH5HsijQ2M1UCyVLtzMgeJoTkImL9y7awlZQrXL22CM4UHUFZYF1jysrotmtQrhBy00LZvWShb7W1WVS2n1YiELk3moDjFZS4h3CHlHPyN1S/MaIJP+mLekiZ/7XM6TY6u1nJ7ds1y2YAXWpV8cEqrd1pFwxorUZyIgeQxQsRb5ih7RTI9JPhtTAsPzH8ocO6T75/gQNiX0IC/8Hd20TC8xVr8kgMTg2eMvz4gCHmx+wpwAEdY1/F1QWCG0UeAAJEJxEBnnslEF+G/RjBHGAIPaMhxJYSr/oJBm7digS08frHXl4wDzR9Mi8xFnMnYV+DEDh/o2ogWeuoRJuoY9j/fYYCApA9gghO2LSGURDLOkcJ7yZTvMDYI+hXS/lRHq1x7lut2rkezMvuMRd42iuD5R+NWqucD7SiJ68J+gXZFuiYq4ZZaheVzHt+hkv6I9cmZXD9zJs9PzxsCU6InYU89+ZTNXSaAE2lFhiTIbN+23Zq377Lzz1pp9XW1FqtuENTyoM0pbaBA7LWE9Ch/CO36dnUnrE/mOCVlisME8pqYyQLl3S9NyKA2dkrKS6xlpNPWdmxMC5vKgD4TnQ4n4TOz/anN9tgtD9qSU5cdTlYHdW/zxt3O1G16dL3aMAmRDyJXaMGzxdjbsWar37ntafmCdMmcj8GjckC1m71svjaBJNTmSqoOYwaGd9CfU7Ou0V4Jrr3qKwUxlSBbUCS6S0m1vn2rzaqttze+68224en1UgGYHb1MSJXqs0wwiFxFvdCP+7yk+Qet+bCcaHwOEH0RenyTSPTyZ4+xrLmFl68v+gQQgzQiPGs0MJjpsWnDvfEKBeBdOds6BhSzTwgGuDF1b+yw2soah/H3ALzKOdw84Fnuy5PZpe4H/W1Ygm8w6oJ3nuFeaZzCjRHqiVDMHALMO3NsmApkKlgUr7Shlo3+7I8oHABhGUhAbZOxb6Go3qukSWL93aUNvoG+AcUaZF7bmxfzAGtXh16zBJGOhghhbVhaqSKERM2z/nioPmi8mOMZy2jC0BYxd2QnZuKUfOPWJTo0p2gOY66ZTlOWAtMC0pTt+qnVcGfu0BbpH5jvpHbmU3II3bX+WBsaKLXZ8zZZdW2bFhkxmBIcymQOh09QEu2Bm8MdxEwpk4jKhmc1qVdasqdOsTOWWPPOXiuvVBycut0yketTAMDANBDeI2QwD6dHmNhHJHj19FbqU5oD7egVlnZ78Noixd4Y1TEMIcprNlpRpFe/g4UGgAtaFjK/h1OHQ703s/2T1YMF2LUX6eX5QMrDERfzOBZHlnPaSnmgFRWKcXCzOgk0+MCw+LpZhS7CPh27rYkYUFCZukcFDeyrrzQpEiTicnoOBawiLfQpBcbMFGooE0ENbUaJGMXwHAwpO7SYvlA23/HdwORjUEwmPgVe6UkaC828D9XAkH4wCR193a4JqykR9DC2/qpvJq3JEi0ZaI1hfTgGg4uDPdqg7Ov9Hr0hgMH3oDHLTMDrY0qK0HWgCTpi4oNAOE8O+gntGq9Tf6ERe/Sprdayc7fNnN1pT6x5xuYumScmT74HazbZeeeeJ5SrVvvFjTfKob/DGmc32hVX/JVr0H7+q19Yy+5maVH7bO68OXbeFefbzIoZtkFmegGtAubuQOuYfd3udTvs+nf8r517/rn28I332eq5WTBn2Tccwd9XXHyZ91fxjtB0+PAzH6OGAE9OPGqlYJiPl6mUtIPbgjPsuu/atdNu+9wv7dIPvtLmLG/ap1DGQsDMK7CpHPELIoJqVyyjTplO5stMCwaWjQrGFs9dS1+77UzusRnSIlQfWy1hvloAOfJB2r7eGex9Csg60C4Qh5/97Gf2hje8YewM8ds4Brz25Zdf7sBD4cktW7bYL37xCwcaOuWUU8LDrnUgBuCTTz5pF154oS1btlfYJYYc/rhodF7+8pfvE+JgojpMdg+xyG655RZbvHixXXLJJWN1mOjLgJ7/tt5O0Up9wL8+Gfts8PghH8i6U5/uh4SNma5DUHKzOwkAPNcER+9NBSEr2Dzo7u/1uFH0gUP0V0cN6PREZ6/1xWT6rXvcbFJ5kXwO0DH+fB6V8MFcwsvrpc9sYBbmaUeIC7IYe+eWkspZNpiQz1FSWl1pqFV5CVNiRVVviqR84MMrBQhxfHymdQ81W0dHl0AmJCQJotwvIkddzLWtkrYH8rDACBJC3IC07wWyAsEqBvqggdPgFKqfNsXSmz5+te4n8T4k2iJgpTRHtyksRHCUs9NpqlJgWkCaqj2vdv/nf/6n/frXvz4oCrzxjW80Xs+vJOZUWqNhLfgEGh2Uw/fgQLlQkyq0S6RdKh3f+Owx1q3gdfWztsksjgCFsr0Ws1ouu2w0UEk5j/sO1AE0HDmsqETBVBufstbNJ2r3r0TRvcstmSyzlj0zFK+j02bUtlhFNbb20ir5RB9O75MXEDLA4VVM7AGym9ooT+jeXnZ3WbwUlyLarl0yIedh660UichUoUQLZVo4YgHIjijuFx7iG3Vh0WWZC/50gLYdYn7Zt7FAE9QRQYZy9pe4jntw3g2py2cgaAVCBbVDSMSUzs/pHdOv/aXAl8Up7QIFO7reN8oE5gATNwSpMHGOxTwlgadwSLb+EshKpIHB8dk1XCPqGxlbRoX8BNPCDixaPVDduC/NIznz47855pkHmh2PS6IcoAuCVuCLAzCI2ja4x5LRPqsuQZukvDObp/oi1KCdHCZ6on7TlpR2jfOlDRq3Yxs2RhcFWoLMjIKTCDsEYO5CMM1o/9itWV+gOalVMWt+eO0PbMasBkvJpGbXzl22fNmxisXWY817mmXeu0oQwDvs5p/f7PQ9/bTT6Ui7657f26Jli+2M88+0W35xs92vGDqLFy12DdOLzz/DGmc22h033WFb1m+xhpPmBYUd5vuuZ7fbl173cQ/C7Iz2DYeZ4fPo9gceeMBOOukke+t177VZS+fuW3PGv4QhxkdvoTaXCiT0a5yHwnmrhCJMHQuktkhJS8uGwabObbala4fNLKsXMEfctXz7e74JuvyKV7zCBZdQQNq8ebMjsAJk89BDD9lnPvMZu//++51J/vznP29f+tKXXJh63/veZxdddJEHP6cBb37zmw3hib48++yzLURyRXuG9cSll15q27dvN/Kg/SUlAdz8RHWY7J6bbrrJA7ETjB3/3nvvvdfjC+5LxOAI8ZWGpK0pUlBXN5dj06sEWGrNsGhy9PJpUI8hswHPEk8k5nQuvPBdAkF7V6fATxKaUzQ/pzVRPj/LDI/E9/Zd7datV9XSGYFQET6YfkXwRp5uYk8hWefJI0zMT0UqFxjxYWmsmE/dlE3365QsKcqtqEyoehJCRoWEx9xDHKIwB4S4Qo2hIgnYEbXFhoN6MieSd9g2L1M06JLppjBjrVr5+7ajbsEPC2AGEpowNErDbMJoXtJlngZDtD9NiAPyeRqUUMa8GZUQtkimoN15AYJicPX0+1SkwLSANBV7Pd1mYDp7FeDuYNLgIL45z6/U2zbXulrn2qAEFXlqiPFTcL6ihExyWq28dov1djZasm2+GLHZ1tlVqd3qLVZb36aFItAigADUr4V8SLv8mQvBpFTQRFta0WqVM5+0ZOcsLWYsDprAByPW06md0o5a7XL2WFVtq14tckiWWYk0T+PAFNIFUKZEGZkTYN4Q+EbBuAYTvTQNfTFpqkqlPYpZoqtCx7UK6RWJdWpxkN5I2iNfQLUwsLY9V6lfu4FJLeqsP5iTsRhhxMb3kNFGeKIOIXsfLnYHUifyRXPBwpfyctIr3QQ3QzMW5UwmnXILdYw4OwhaY3WgTqJtSBvqhPklghX+FBOlzHEg0TTYWU1fiAkHqE/cH5YR5uFIU/K9iMvkcQyxUAJNgYRxgiCiQeIeTJQ6UgntpMqcUM0sSNfJ66XrCRoZmLqJHhK2HJVP7aAV7DAzXtFowZBIf2btyS7d02+1co6OCWnKBah0pdjpjUlQG0g/2zCn5E8vxYAD1l9mgkEL4onRlyHVwitkiiVfK4S/QcUpybo1vGjsM7g738oqymz1aatt4ZKF1pPosUfufzi4hsYLTatUzPbpq5favb+7y4akgVh5ykrbtnGrzINGbYHuqW6otTlNc233hh3W3tmugJ21Eo5mWv2MWgX95Jmgj7PrOlaNg/ry0A/vsS9/+cvOUB/UjS+AixEYvvGNb9hXfvwNm/Wv4wUkGFHGRZhAI3TmWE7wYYKpJ65P8NwHzC4+dyTMtIolfDC+JkvE5gNhdenSpQ41HV7LZt8HPvCBMaRPgrgiKCH4gAD6/e9/34GG3va2t1lDQ4MLS2icbrvtNheQmC8IbfGxj33MbpRWEgELLc/nPvc5LwJB6Uc/+pG97nWvs1x1mOyed7/73XbDDTfYaaedZm9/+9tt/vz5LiiFMQjDdoSfbJxg1ojJG/N+YZHmCM19EdFYRzQ3aH5C4BGDjykaG3jlJXpe1Q4XnpQRmiWWA4K6IrTkyexNl+mEjqtfmC+YR2LVcYvrNSCzbO+b8Y98WKXgc7JzugLhpE7aQDZK2LjBf5l5D0GIhC9RRLGN+rv3WITdGgQ6PxO8DehadnEG9dknwWVEL+YZhO7Q7C+8nEc6pXlrrXXbcqEjRtX2YpUfAi6E1xEsNyg9OIKvEnRVYz1PYM3z5F8Zbj7Nj8dth+bAYJyGuUx/TjUK7J3NplrLp9vrGiS0SC/UxKSblOYm0V0lP4RWqyhtVWyPPu2qaXdcmpUgSZCRoNSvwK4dexZaSsIMJnEdbZjsbLXyioQmUS1CMkM62AT7WFm/ySr0QruDVmpkWD403bVCuDtGdauw5JZya97dKK1Vwqrr91h5ebcWQjmsareQRQG7cXwyBoT6BLPPQhimYFnJs0R7hTVvWaGFEIaDOV8Md6ECppYq5o/Q2jCXQDsxqB3bcTuzEAjVhMo5nMTdMOVJmc8EAkWeysKWG2FJf6qU+/uMMVAsfkCy5vsiGi5C5IP2AgEjPJZdL9oXA5Zbq3xgBpd9BTy5mHQtiDD9/fn90toEfYeQFpXJRUQCxb6M/fh8inRtqZiJhAIxTnYt9UTog4ph4lhEWplBlZVK29eH5/jE5A8mEW1LXHb2XB/AaTNi+FNcGPk/9SpwKtwNDCP2/IHfGp5j+o2Ap0KdvnoP68g+bKGEO0wGk4OCn5cGyeumfJISzHaN7rGq4cognokYDoIpwzqUCiwB0xvXPukORh/0LZaQl00vN59R+8Iyw7ZRb8YrgAg4ewcFh2f3/aReaNrgnwlQPf/oJt/BjiXKbdbOZmveplhWSii2kgKJ2CNwklFgesUQ7di8w8pkRoUQnuxRvcVE9XZDLwm3cmyHQXRzL33CEB7ICA/HKIyp+3h46fu+4Xd04ecu3PfEFDmC9uUjn/nYAbV2/JMR3KIuUtq3RxjzBBxVB0+aN0wsAgyhJz75yU+OXYvQQeL8zTff7P5TCDzEUuLa4447zs+XlSkQ6ezZtnbtWpkN7nKtE8IRCeHl/e9/v38n7t+rXvUq/x6eQ+BCQMpVh1z3vPrVr7YNGzaMCdUAIC1cuNAwuaPMiRJgL61dAuQRCmtMY71E/jxRCUk8dymNd3y8QlCYPf2tCr5bbnUFAubRgPdZRNMeAlKhntWInomYNi1AowxJD8QJyJ4Emy2KKyR5h4TUlEBOKtGQeSdNVK3cx9SllFwjTfWJ9UutXBslbskgX8FBzYMedFid70ikqlNR+RzVb7MmfWDlg/HQr2c7Jd++wUEJalpDOnSOILl+dgK52WkhOj0z0mu92tA8W5DfbIJxPeVgGkrKbE2gOdI8KlqwJiBMQdu+ogFrlUnuOlmLbJVZeo+0n9NpalNgWkCa2v3/gm49k2RJpMdK5j2RFoiCxQFBJTQ7CwkQKe2y+nmPWLJyp3W1LLburjrr64lbXeN2q2vYpf06V96Hlx/wJ2WRWH9ds1M4YEV1O6TG75VZw9GWSjRooRNSUVuJdXXUWCzeLT+hNquqalMMkj7rHVbsChY8NQbGYl+GY0TodC3aee1UDKAKacb6FL9Efk4VLVZVQUTw8mC3XzenZGbYK5QvFncYU5hjTMUwMctcQA64ceGFqhsmaiAf7a3f3hxZxAlQKCJqhzLQgNEgbdi5dolAiDDXmJTgsOuwshKC8lTHcOEMiyJXdiLLC0BckvCDJkVtyEwsmtCLxbG0oNSi/CDp5r31Cw7lfBe9XDMjE0gW7YkS5SAcaYnd5zRCT6CFYmcXunBNUDo+cGjAdvco2GNU/mol5U6HkDGHaeno7/C+0S2e9qm38k+forXjyuc35eMbFdKV3VeQ3vB/GlF9erWDCuPlGjn5QYH65shwYpbCjGF2gPx1s5SMEvCxIv/MBIlh6NrkdJ0QBP/e2mVeNf479wR9p93tYsWokolLc3eLjfbJRFAPTBBQVONUMVP2NHfZw488aieuXi7t2JA9/MeH7IILLrB6Ofk//sAT2iRI2Oa1G23FsSusvqHetu7c7gIo9WC8IHRPltBylkrrR5uBMdbHGB2y7yuXv0bIUGefmyq/x/lxHKlGa0hh5tSdwu9m70ZQdvYnnHCCH0LoYS7LTgQ2R1Pz3ve+12pqavz06tWrXfOFeRvBz5999lnDJG/37t1j13BhtYJ9Nzc3e76cD+/nHJqeRx99lK+Wqw657tm2bZv7Q2WOG/Kj/FwJM9etbdutRuAJsfwSbXoEc0hfKmX9emlataSsGlr62lwLUx2p8LE+oB0FpsRhzaWsHbI9cJNeVyVB1vSjAK0RFpgvWN+KU9L2bO22/Jg0PJobwusmfBZU9pgpcroLEEhYU1YrvtGi8tl65qgEgBtC7xTMOMmFI76oXkVlMy2POFmKjzScbNc62G993YprqMpTxVbV6olRrWuyrAC50oEnKCtj6qH/wzFQqa0etEdeHR1nky6ijUZffClTifK5PSJodI6HWbEJ1VaUZw9GkrazV6h+/MnML3v9IY/pNHUoMC0gTZ2+npItzRPENwkzs8kSggw8X7x6lxDfZI/dNkevJtu1tUkoWRUWrxXDWdEsxi3w75gsL86F83iwdohh1R8LGoVg3lQk87faeY9Z566EJdoWaOuNnUFpgxKV1qPyWnY3SLPVYcVl2yTcyeE9Hx8ZEMq08wVqqueltrn9hBamWJt2AuOC714rgIh1mvthiCt8wQq1Tpg9sSDgdxTRd3baYFBhovGzOhCmVrfvm5RpREz2gGC42bmnDDep0xcXIGizFi7XDPnSI4FJQkKfFuikmAA3PURA0nfSsKCBhwsFcytTKhz3A5ObgJJ+gd6oK6ZyCHoJaVpAKaLcMCH4uVmKiJXNzIfX7O/TNU7Y0csPIJepHWocmGvqM05QUWXQzMQjEv6om2iAxohrcBjGDwMatPa2uXBZXVIhQVW29KluR8Fj0dflSuxy6l6VcbAJU5eomH6gvxGQss3iAGfoAxZbcYfUQeqfvRTkG3VwraWYmVDAgCbKaVx7aVNSiI97ki0uXBwwvVUIDFy8Km4vPu9smbXWWuuwvAkkxC059mhrmj/P6uvrZSanwJYlxYqVs9SOWTBD95g9uX6njkXsJZdcbHfffY9t3bTVTjz1JFt94iqZyXbbsvzl0sjWuInS8pXL9bxFLCH6egqHUrq5wBAHoBQCOZGWDdNIBtMhPw8H21HT14/rFzYKwi46FNJ8+9vftk984hN28cUX25w5c+wtb3mLEcsPgenDH/6wHXPMMXbeeed5AHRAFjA1DxPf4zKvYgxHIkI5zTpXXl4eXjrhZ657OJ5tnk7ek+WXaOmyTY+st52RrfaUnroiaU8BdcmTNQKC/IiY/6Q2t4b1SfyhwWiHnvM8bRxpU0caJkzIgPseliakeqaQIGdXBgFnhVzKvZhE8wj4ONf+Vc38ehtVUNYu03yqvwJ8V3UB30Fe9ec6/cz4pl0/GmNZNUhLhY8U882pTcfZipqFbi48qrlbNn0qIbjXARP0K1NIKpS2KV+hJlIFm61v+watQ9o8UttatM6uK+jVcTbygvmLOWxMKMuifkRlzVZgaTToY0lr0YjmzcyZk7k6PbGOXcYX6Pn4YKe15iluYqxY8bs0P6cw7ZtOU5kCk3ONU5ky022fkhRAs1RQPGhVjeusUMJJ956jFN29yfoSqxW5foOV12+W8ygxdnInFvgRYjLAPLNz7VokTdwjkmwkCA0PFWsHULv7I4L6luCWLxjTkZGIMoQp1pSsSwdSWvDkW2StM7W+aCHTLhoJlL1gCZCwVAjDxw6ZFoIBmdJpgYzXbNMxYlZoR1/wuuyeZy4RCEYhMw8DDMNbrMUlzTpSxEEn6oOWoUIO1iyYtBmm3hui98zvYebsJ0YK5SujHUxM8ULQA87DHqFNgFHFbh6wDCBgYc1pfND+4MqgLJ1j3eOQEsIYi7maN9bW4MxBvitDfJXQuvSgWZlgufS6SqOB9gUxKTNRB/yK9trNB4wfTE5UGhvMDHslWHSgdQFSXH+gKDnplBEmX1HtvBbLHAXY40NhG8kjiF0W3J2ZB9/R/IFANZFGwOuPmYzqEowZYoQQb0njmIPBUPX72xTItV8MnzNRmUTI8d3zUwdhVtUc7bSZgh3uTPXY7q4WF3ybZs3V7m+pCdvPYnViSjWmKhpqBEssZ371dclxM61FNOkR/PApF59uZ6hO/RpHzf3tNhIbseqj6rSz3mnDKfllNMmUVVq53V0KK6m+op9CgRMfCfy32KGGDmgwYeA4DzzyoaaJ0M1gkEEw27hxozPvIJmFiQDdP/jBD5xhBkktFtOzn065kM8wWcqFvrZu3ToDFACfIeLXZaZf/epXbl5GOccee+zYqcnQ18YuOiJf0oMnKy+YUbTQOOlP9KxlXb7PT2L24XeE+Rw+RoA43HnnnS4goUG6++673ecW2q5YscJN3Lq7u90HKcwMrVRTU5P/nDVrlpvghecwx5s/f374c8LPXPfMmDFDJtXJsfK5eX/5FXQL7GCtfHCkAWL2D9n1YFQG7zyHCAW9Yuy3WIfPUK5RCSY/PY8SkETTB9bfZcORUXvLJ96ldUImdxKcigX4kLCkCUTbgRmiMsOrrqm1tm3tll8uTXN6zfHnXPMwwhdrmyeVS77DaTM/5q6q8io7bsZRMm/WuqZ5J5gkgst555nKFpJGtV6AJjsSmWmDFb32bGqNbZNZdG9EpoHS8sQVU6lEczD3JvV8DnKtU2Nvvgg31dJ41WheDdOQ5lESG4DjIOPDyTW8UJ+aTgT0oLmYa72x0EbWFTLzm05TmwLTAtLU7v/p1k9EATFL7P/HYtrLmv2g9ZWtt8HOFZZoXWz9iXorb1xrpeV7NPEGkzAiiy8b2mUDPrpfgS5TfQpkOSxfmaG4TOq1Qy/UvJEhxVzS79Fh+W8MA8GKdoQKpDlNVrsgJx0X++rntNCMSAsBz+Bn0wsU3/sVCd0TWgzBotY95mZ5CF3cOqDFh6B/cWlashnj9I1+XR67kv4tPHrwn9QKQYhgqJllkVNQ4731DnLHoVvO/HIqjmrha+1lcR9/DY69/dIm9WvxJ/hpICwBi61pK73QwQBUKKZUoGVSzk6zva3JzjMo+yDelV+J2jQiWHZomZkfpbBYow3KH5J/k9qDaRjJq5EuJvMeDvlv1d/bob5JjCTdh4ub0s1Se2XyRUwhmayk70jndvAf2eWPy0EkJ1AsCwG7wiSuR7CqVMySCiFOEUCXdopF8h3cbvkYobnDPI9rEe56FMA3rLtncoBvaJ6ealmXJpgqo/+EfKGapVnzevMQ6FnARDEmJm1xX7O1dbbY7shc65mhnWoxu1A86AvdIQaOurYntRuckrCkMcQmAHmx040al1E26hsN2khASO1Hi6mYZ+w464WQt1eoPcCGZFw2EboZp8855xwHAcAv5vzzz3eHfxj3NWvWuEbjqquuMgSlz372s/ab3/zGNRiTIZ/lQl8DKOA73/mOXX311Y6SRnuAtyYBUIDvDSAHV155pX3oQx+y1772te6vMxlim998qG8QPJ0QSImFhOnmGLOdPsczAwN8qPFn7rrrLvfpuf76652OtBkhiXT66ad7EPQzzzxzjLZNTU0O5oHvEkIo/fKVr3zFEe6454orrrBrrrnG4b0BM/rpT3/qdOVcrpTrHjaqAHkASQ9NFj5SHKMOudLZZ51tn/rUp3KdPujj+FO9/oQr7buP/Ez+QMyhpjmm1CoKFdSXzQD9o4lJbe6xwkWlDqntGx46HtdGTb7m4F5tNPAEsTFVEJcVgoRZNC39/QPyDS1VyAytfdr4Ki7WJpkEquyUKSTxrJEiyhv48i1F/fZ0SVIbOgoyGy23KoU7YPNClZPPpgLGJhM+T2aDNTC8ilX/Ac0TmFOP6jkPA3WP0yh5afu+MXd0aQ6X7lgn99a5ULGjODedpi4FWBen0zQFpikwAQUANogXigkub7G8ktstP7FQgtJSQXevspg0NfGaTRKCJOwIHW9Ir1SfTBcGy9ynSFtiEo7E3BKFL0yuHZKpXL58UgS5XaCdMpMZAQKQXy8By32WYAq5b1SPpzMX+j02T4998UOIZnkFKYvEW1WfHePLU7mDgo8eEQRqrome7Il3AxM5md1/2IT9fQbsZ+6rKI+I6wRLjSh2BWACKQl3iUJpULS4IWSxKLO45uErputBY3OwCgX+TEljAIMVEQACAgaMOgvoc5kQejDBYq8RbVcmnaArv5NC4BpUAFnMw4rFSLgGYm+nTVg9ull6P/cVSsKgp3dn3R9GSHPY8++PnhNmPMlBBA3XdClA5HAh1MV8UF4K2g3mRZUZCyDsEZeG0RaRmSHCEaY8bfIVQOvjmlGd41q+u/+OshuWUI7p4IEmH5djQ1pfxr7zVaNbzwxlEMepPD9mWzcOy3er3oakyRqSD1f9UmlE5b/ku+YqlLFDXT3oqcZF6D1GXjCkoN4xqJzxo5L6HgpGXpaYM/4y63GgbeG6XOhmzzzzjPuzXHvttZ4d6Gn4ySAgXXfddf+fvfeOr/Q67zsf9N7b9M6ZYS9DUaIKScWmIss1ShwnWieKE5fsrh1F+dib/azXf6w//mPl3ew6jp0tdmQ7Ci1HG8clttxkiSoUSbFIJEVSnCGH0zswKBflou73e977AhcYAFM4o4gDnBkA977lvKe95zy/p/xOAimf+MQn0jmFbK8TzKzEfHby5Mll2dekqP7VX/3VJIDv378/fvqnfzq5mb3++uupjQRcL730UnIje+ihh5KVyYeuxr6WCnW5X7Tjsm1W1r5q8qWxl+VwBPcsFQvlSVBaCwlBZek9KD93JZ+tq1tQSMagFVBA8vGPfzzdqovdxz72sUTR7Th47LHH0niQLEEQopVNK8+ePXvmWesEkO6BJHDS8mF/3H///asWZbV7LINl+o3f+I307N/6rd8qWXdXzfK6nZTF79SZU/Hc48/EOx59MOVrWJPudrLc+S7UNNbF9tt3Rz/WKMzfnkxzWV9zZ2bxBiDNJ663LasamX/Z/FfmOkNMdR30uO/Y/Hs2fxNzBvOpMUlaVD0vQYvzXPVobWxu7UYpkxFKGB01zhgZhIHz3BgWapQHMuDlyo08S0HQaRQtnydqaS9eGVuxOjUyZzhv5CQNDs9FqTTGtNirfhlASSIFktfNT0GX3LQoh/Uva6AF1gHSGujk9SpeewuorWohRmNEd7WObxFYejJmB+6M8Qu3QdW9JS0qMYPVJMUwMaMKgphoK6RLrUGrXgkBQmLNQ6iEXjxqhvnOJqPGFfGjDcIpmSWDW7E6AapmsEYkwGS+AK0KLFEVcw1YKdwzB22blio0gFqZGpouRlP7yRQ3VQGLz1KacK0CCsAK7SsJ2y5Suk9kO6TPLw/X3mjL3GmrCMR0z6pnAZMAIQnALk+UsblOlyKXquxfeRb1CE26E7lvioQJuvFN4SOulUPKai083HZDk4utIECl6PgyxBA+XIFPkCHwFfhJfFBOe7xsAckvxTCRv2ZCPzeh1bVOK/XXsvlc0UGIIwBdNYyd6QnakPEyVccPFqQCbHc52YX7IqnB1Roo+NMl0CRQtd8ayEP3QIZNcodrr29PjIHGKgwVR+LCGNafaxRyl1bDPm6ta47upq6YHDbguyFuv21/Ci5/+QybMaO5Vgte3laZYCZwpk0pU3lydJWPFcuZgBGS4nLCXPm9V/LZ/JZjWJOSWvBiMmBfSupf+IVfSN+feeaZJHynL/xyo1IBlWN+JeYz9+V597vfnYRN78vZ1xRMdeFTCDW5L8/Fi1hnKZfkBFJea7F66qmn4od+6Ifm9wJaiX1Nxrblkn3fADuZAqaB/r6TWbvTwp4sS8lSwPO1iDo/2VdahL3H+Sn1CddbxkoUUkwSXHH59KEPfSj8yZPsdLopFgqFJHTbFnl65JFHEsGC1j1BUXnS0ibLnFai8nO6pgpibUM3ns3dw8rvXVqG1e4RaGm9Exz39PSUZ/Nt+/yRv/eR+OuXvpwAkq/HGHF57kmVKYAoBs2/aQd7kR0dT1s2BEqUHuaCbqzJ5wAq9p39af/ZzbJe2lm1EBrs6tsRHe2dKK9qYwISCUGq7ZG5+C6uomPEuCz73OT8+p4N98W+pp4YHToTQ7BgXmS+5wUHdE0Qf0VZ8SZIBvVFWTnWXEPwRvcenMXfjIbYG/WxcQ4FHGV1D6TkQsylPs8Y3FksyXyx6Gntm6oD6BVdjT2S5bnoMetf1mQLrAOkNdnt65W+0hZwulTIVUiTypqAELRsr8b5Yg9kChswXuBeVXexBIKkEAcE1cIEJBiqgM0LJroKLUUJNDHLM5NnIMbZ2ok4SziSsUpwmjW9Cl9xJ33naa/AczsBCPfI8Z5ZtHpTMNJJ2FBTa/wIrkFJA7iQXylbcgEgUW4B0kpJq43PcMecG5VkVKuvaqIttV9kQlK2PNFcAIk6wGGuUc6P52XxDmmuq7Gozc6V9gbimMK7jG+ztQBFVs4lcll++3X766LeUIrhGsOSlC/uPsAyp3qx6Bo7pfeI7kRaiOzNlZILtTu3C07o0RLgWxnMrpTP5Y9nhA047SVKbAO9ayQuYQwVqylvyeqTBBfaul5mQdrXlPeH4GhjY29M1ME2JX04w60Zy45uMFq/KnQZVejg53oknytJRzOuNnW6L2JoHUJF/dWnv8B4Jph6W3dyA1rueY4ZSScW2yiWKRV1SNrzS1+dZS6+/KGV2M3yOxXgdY0z/uh7v/d702EtRr/zO7+T4pJ0sdOVa/fu3QlIKfTnYMeLc+YzNzYtZ1grZ1/Lr1eQ1X1M1z2f97u/+7vx4osvJquKgEqA5Z4/utgdWYWxLS97+V8FWucjWTHd7NU+8NhycVueS3tjAbhHeW9UImhp1S2W4UdaGC9eOz0xGS8990L5467qsyQLK6VyAFR+jeBnpXNtbW3ll17R59XuuRJwZB/m/XhFD7zCiwQrCcDS8BI8DEwOw6TZBqTQQp4lPScqzkxHYW4ounb1xsaWLvo2m2+T+xqA2M1r67GqjwFKsvWFGCAUJbW0oxakBIrJzs8CpRxc+mz72PMCWOvI13RMBVRfTScWoyPRAYHMTqzEs4yRSdywj0Hj/SyWrkE2hS33ytBS7PBJ5EDMYSoqT4wX4zREEztRpuytxhKOUrEGIO8rvjDSmPooiwQQFQDyO5y7amfjzCx7Q/JsFUA6VK+ntd0C6wBpbff/eu2voAUU1Fz86xDyTYKOSggRYoRdx5tORW3fE6AagQriGJO4C0A2FTMlC1zS1OzCAPpZcc712iWn07U8l0VHsoB0loVNr7J6/LxNiQFOtqEVkkWZmsN9gEUid4u69FLjYSBqQGi+IYmFSKuELnHGh+QCd/4sBaUmrHQVBAxrzci0yvnZ7G/WB5YT60WZVcC21r1tlsXNfT7My2tvUE1SV2oZkvksd7XzrwpJU3KTUyvu4rsKKPVay+6eSO5zpQCihj2L4fLs1aasxqnu6WOpBdJYFBzVEyOFBXIcIgg0sTaQgK52AisRuLuGsVtEJJChzv2WtGRl43hJObhPkDivcabeWZ3pB/YrGYLi+3omIZrlsI2r62piw60boqtnOLZMX4z+9t44lSTsUl3LHmz7Z+9d2cFlPubWi2VO3ZBDP/IjP5JiW37+538+PvzhD8df//Vfx4/+6I/G888/n0CRwr1WCa0gqzGf6aKk8JknP+fsax4TaH3kIx9JpwVfJtvRPYGkqlZQ1sXul37plxJAWol9Ld243C/ycmNX6eplaUzp0m7IDqe+wNKEoKywPAEBi3OR75FgyRnBgHhdrmb4W9/aFN0wF67lJMlHOVHH9WwLe2tkmm0miuzFxvK0lKDFOWTT/q0xeXouurEe1QJUhibG41wBym3Zf0hS/QtyJUaRPEIFz8nCGeKGYE5F2eX7l88f9rl964+ASLDkOX/8rJufm+CqCpxh/ldRNsdPCotiXaojr514WNTUtMXj0+djMgvLTK93I2tylfMs4EjwrYdB1eRm8p6NQ3Un4wQu5ntQzN1Z3RL15JMP0TnKUeeDqYepnvH4DvIvck2RObnI/Re5uJzZM124/mtNtcA6QFpT3b1e2bfSArngPeEGr4NbmOwRKFvewFqE6wEgJVmGEiB6K0/JBFdWGCWaxGLmjuRLU2aFWnr00u8uCO4bU1kxwp5Ai7XRC1cLAG/kVKCAS3X4t1LSlco4E4klJtlPZwJ3Lu8oTwKnom4XS5L5juOKoRXEuB3BhgKYdjGTTWkyt9LH9P2SX6XH5U/N7susXYvu40Rmocjyz/IpuyJ/nkLAJQ9ZOCCw0G1NAbMJOnD3TbqyxANKz9Dq5GfjZozh8K8xOMmaxdPd30QyBS1sIM+YJaB6aUPUTePa6WaOWEO1ljbCQrVawVOtyiqmoONmju7HosCct/eKdfHeUvlXvKZ0Qve3HIhapkqEspa22ujBDXWKPcXOzqLBZk8seylPlkegnZgRr+Q5V3JNnvk1/tXiI2uZsS6Cm5/4iZ9IDHIKj1oujEvRLUmh2M27jYdZjflMV7G/+qu/mi9NOfuazGzf933fl6xGkgzkrmayu917773zLk8yuQmW1OavxL42/4AlH9K7iEBqs+diZy70ZuB04Qa/a1XNYglR7NDeCsENaPi1r46zOal1n57KhO+WjlbmgMn42Z/92etKUrBQou/sTwIJ45OMqcrTZz/72bQ/U/7dv/aZlsDPfOYz5YfTZ4+XsySWXyCoOQ8JyixEJR2QsEhyozuq48C3aA4QVAWLm+Pv+MtHY6oHdsfmuUTEwmRC9znX4KbLupIlCBIgsHn82FNxbORU3N97Z2ysR3kIuEl58j5mliL6GuAumBeQF4vsY0e/19XpQYASDZA0k9x4ASnESE5i9ZnlGb6ejo1xQFgxxQxJGJPNvZZXt2eekJGw4AVR1XgmJs8fiMrihii2fCteYe3Tffy+2nbsZBlwq3WSKoEj62A+Y7jrGtPajLtgK6d7zduT62nNtsCNlIrWbKOuV/zt1QJOjtki76fV0wzC5OCp23FTQihr6I+qhrPgGKdRp/GrS1ql5oW/0q1p+VGt56SP+txYFnO+tGTLH12uBF7pnkOBe1oDmjStAws5ZgDAzUxzULZcHm/pGIVXUL98IkYGt51aLAUzbBapdSVPAqxxtZW4d+QCWX4u+4urGoKFGkQFMgGXC6cxZJI6ZKCJzyXpPQlxuiumlsWqQmMbT0FURNKG2jeZO6D3Z5/zUZI/d3GflH0r+5hfu/SvdbBs5tl4heDINjDuTOrwxmQtAwhRtgSOqGvWq+Zsj2cph2gKr9NF6obgUXa6dBGWJNwXW+qIs0AbW4N1Ib8vz2elv45f96ESHE2mtl/+ytQkvCfG2aWxlzYMvnxDJaE7ZZldO4clcjTYXJJ8GhGia1BSTCc67uy8dTe2RSEwj6lavkTf3qMKg8b8SL+t25wB8wIUwcu/+lf/Kt588834tV/7tRD4GPei0Ou5lZjPdNNaiX3NeJoDBw4kNrzyWurSp+XKuCZd+HyOgrTC60rsa+X3L/7M+FXAZNA5Bla0IpWGot7EUvr73gnk3Yx3dBz2RgC7DGYK6NW4Otk20jv/s//4P8cvf+/PJ8pu2deWi2NZXJ63/zfHiPFpxom9733vi3/xL/5F7Nq1K7lCSv7h2MmTdPGCYEk+Hn/88fxwAh2OLc+vBJDGYIl0D6SWxqb0ruu2XY+brLagRIYjCOGHmTh62KS2nutmhiAEP8v6sY11D0IGXcZHAToSPMwM4ZZ2ejjadnbGoYtH4kThbNzdfWvcxYaxnaw3TrECJUGRf1M8KcDIPvVH4gUVBag1YpayOZacS2YmjGrMxpYqn1MoznR7k3KofA6bY0xNcM69/DLShdGobHs+ps99NztkdETD5qfiLG7rr7Mf1B346dZoraR+1fx1M1hnDodpcZz1g/mkCYuTJEHOPetpbbfAOkBa2/2/pmqfT4QZOMgm2TncymYgQ6jAxaiKzUnniO9ZmH+dNhcmSefLwfO72BeJvYmYbGubjuO3PMQlK7u4Ld/ACKQsCu6FI+NXikFhgTAlwZTHumCo+S8XdvO8ZIGrQlCWUvxKkzWREQhxNsUOCCASNTYnisSTSICgxepGpCxX2rasLVd6jldli+XiskyjWUzWifKVcUkm1tGUwACALz2POpuSbYVFLwEf20/3igSQZHBjGWbhTgHH6ersV972CnXG3zThI39Z0oWy+1f8SNWq6f+uuvZoIdZnGHeXyybu0RXPzWSrAQmSXTRhcRLv2V4KPB7TFXNxy2XtMcs+TjNjWVss96xKaOfd48jnQ/0JAABAAElEQVR6pgzyxlzu4rJj7h3UPz5QYqQqO1H2cY79v2Yn+mJ2rC+Vt7rlMNR4uKguLWjZPQsfMwuSQ9O6+muC/pPepGZumNiCQoxVdJViWTyvxZSxAkBKcVFXWI+F592YTwboaxFR+BVYSNrw2GOPpYf91E/9VHK3kyHNvvy5n/u5+f2JVmI+0+q0HPvas88+G1ob/PmVX/mV+crIxibY8tgjjzySYpl8TySLMK3GvjafyTIf3P9Md1PnDpUMyY0OTb+dmxxdOe4/GezsP9+lHEwlAZR3sgpgVFdfH+3NKG8QmKV5r2aPnp/69z8Xn/mPfxi/8n//alImeK+KDu/zn4mP/i79VSHCe+2D8sQFjgP/CcSmRifT5sP56fK/IyNs2s2P/aMlL49l0t3RZwreTFrrjP9S4Ncq6Getgs4hntu4cWP6LBmDny23BBBaT7q7uxPpg9caT2bS7VEmNwGQ13/yk5+MH/uxHws3vDVGTNIPgW2enn766bT/lWPDcfDbv/3b+an4l//yXyaXyQ984APzx5Z+0JpnH7hh+SS06oMzAB9sMrWyyXF8hnnGjberiTPq2rGR2/kMkGg7eRErDQRBfB+tZINp5os5AJIuuU26ygFdxkYnIGq5GE8Wn4s3h47FOzfcFXs79iR3SoGR7ejfBI5oZ7vPY7ZRXS3xS3SdsbW6ASc2zKybed9n4zRMn1Jv5/saOZc7HtxzMNuCIRWVeuEeXD0SNT3PxuSFe5knmrFWFuMI1uapuam4h7gklUrTbG7rHlPuYSeAr4S1b4zxwVa79H99nCQWrpfnX+3qvrS917+/fVuAmFpG53pab4G3UQuosfzNV37vikpcPrilIM7Ya5zysd6wN9FkYUOyTLRA2502bOWMk3UzbkbVLN66fGWJRWGoL86/+QDaNQRTmOjqNz3OXhAnUY9d3RSq5aC1pK2fYTEYn5yAoWf8kvoo7LbVo7GjPCmxIOi20IAQK6hSEMyFeOuZripdmlaeS3JMokSWFVe7wHi5gs2lyTPlrXfpFSsdmS9L6QK/S9LQXJPv27TSndlxNf/Dk0OpXN6r69wQQpMuHXl9V89h5bO5YGU+5Z9XviNrBVtDa15rfdNbLkP+rLxfr2QK9hoFx3EAkou7riDt9W1YkhpY9NH9Mk6BfbDKNS121aMBZxAMZwoIPVArpw7PC5D+UjPG4BzkI5XNAvfMRXHRJSt8sW/GCdI+OXImWW0uvYwrUB7MjG2K4pn3EsCPO03vM1HZdILjtujqyf7RVbKroQNWvY40Xuf4XjdxMW6bOhZtMwPxau2OONOwgxaxNFkaYp+mczDpKYhdWt/8qmv/+9h/93/FZ//Tn8SOHTuuOhMFY4XlXNguz0C2tNZW9qTJ3/eykysxn+mOtZR9rey2ZT9aBmNcFNaXptUY2/JrBQUPf/BvxD/6f3+GWDTj8dhUk3dTUDqFpdqA+dTudIlgw7GaW5B97wSBlsExrYBbj3tnCyyWCr5D44VkXTImSQG+hk1N8/ZISp3UzczPDewpRz6DheEYH9M9bzpa21qjC0KFzDLrEKuIEfIrjI0m1sv+Y+fi5f/wdHz581/Kq7LoryyDxmVJra5lRlrv8mR53b9IC51WOL9v27YtAZ6chGDfvn3JXdI2kmxDUg6T12sVEkC5N5NWsXyPJoGO10uasdI9eTm0MkljLtD94Ac/mB9Of2UmNMZNIo6VSCJ+8zd/M373id+Ph/7xB2hXZhL3HHIfJPRjAoUK9i8ahbxBV+YNDT0p5hPUlNrSmXDg4kCcfPFI1HQ3QODQE/0nYaxk+4Vtm3cQK1sXA4DC0wd5N+9EIQJunh6cjIduf2cc2HY3eyZlSjmBlyyk5tUEAUNhrBDtrRBFNDRjpXolxgePxOBAIcWn+VqrJjxJeb4y3R8snGkN1PXWmM2mmsa0qbhWbMFdcvtj+Hm+BkbE6fGt0cbG0Q2NxRieGE3r5vtqu+IWYl6zTW61bBH/xFiRYGZ4JHMBrAfwDgL+7nnH32YMr9sRFg20NfRlvefXUGevlaq6hip+CaSmcYkrjvRgsmeRriRWqGocgIO2b2RHTI5vQFN5IWp7v4ngSaB/ZsTBvI4fMoJnNYQAAhHN7bOTtTF0bm8CR+QcldxX2XCej2gsryIpIMjWI02qsGQSoWKcPRjUZXlO0KJg6OckGJSEJb9L0VzPIpbqRWE9liXOubghJqKP5TcLE3WfJEDVRbw8LdyTtU/5uewzOVAGfyZ1u1tyf/n1llJyhxQkW3bCZ+qyJ/BCb8tVlmz5qcYa5EClXJrNS51qSD5clHJJH8qedbUfy+tf/nm1fLIyCiQza1MdQGmhzKvdufq5pX2z+tVYnQDMVYxHu8TgdvckGsc9z0Bl6+IYmkZDGmhyTeY/qya2gDXFw/lwSWf9xQEGS1UdvcP+J1UIS1dTL7NznGgNS4LJJflbBtxnYHysrBmN2u7nUCgcR5C5MoWCdXIc+J7kySNTuBeOIn110BYNM7jToCjAVyZdYh9NYE1TCL+0vnkub+3vq8+9nFzhriUX3dmWA0fmtZJQ67mVmM8UzFdiX/O+5ZJlWA4cee1qZVial+PNTXZHsLBowZwlzsMZSAFYi0M1c1JfUwcAfjoGx0dSPxrc71CcBCC551ETe97U059MsUkZleYMJzA63r6UudJ5UBY8XfPm6NfM8oFbF+BnfEw2SWJSEIbdqiB/p/1rmYq48kkF73etD46nlZIukKaV3suPfvSjyS3RjV5zBkGBlBYfrYDSqB88eDCOHDkSZ86cmb/GPMtZBj2f3+85LUnGgq3GTJiDRAGXIHopODIfCTeMW7pcH2qxq+Bdt0PcPPnC1CBroXTfWFUqeG+cE7gGWoTogrjAfgXR0i7Q+tNXO27dQ98x70/DLEq/zbCvX5VzPgxwbV3t0fogIJX5fmJ4PE4dORZvthyLnpbuOPz1N6KxuSFuvQsa+xe/GVO4tN171z3x5JNfiVv33xa7du5ivXafJfoSNz4w73w6o/sce5jVMt9wmiLKoqjrNH/xxKgh9lGSmTRGAEp29BTuxFX1JwB9bShB83235uKl2UL0zTVGB3VcREzEOGttrgfw4k0AOOrCmrnMlDZfpvUPN38LLC+13Pz1Xq/hTdkCmTuFLgRTuM5NFDpjYmB/TI5sZsJkYsW/uAJKbLXaxg3Vd76AJuwbTLgEpSLkVTCxJs0mi8E5hE8nWWlLpRhOWtGm19FeDcbcZHtUM+lXkN/Vu9exoJDxNELDLCBnZBzLCBp+Z2I1cLp+ubCbXBQXJmhjKxAKWDUEHYKk+cRFtWy6KrsYRU4pCS9kM4FbwfzB+RtW+oDGFsDTiN94NeWYwLLl/YKthXJk9yoK1SPsGNPkPeVJIVuhRapU3TVmqYdCUHlS0DVfrXrWUm2m9XXh82EJlJYAqwCsDSFe4oYJgoEX1b080xv6mTo5dJKYd0MftGzmtk29wJp+cSzadpIQGDNgn+f9k9qP77b/7AR9MCIJRNkF87nbyAhC9bjVNTP2FT6VgK4yZTFQ2RDLy1Cexdw0wi9KhOru5wFHJ64YHOV5JJCXhDPK5gMo4xyKCwESkJExKExnTCDOKWRrwSgSj5DqslyB8ozfwt9b7t437371FrJ5296qFUOaZ9tYIDpNm6tLERTV6AKF8CxD3cbGDkgAmplLBwHSiBoAHmNEBEGClabE2giYp58ceUkxA3irBkCrOFIWTomTxsd1QCOte/EUc4CWoVGUXcnC5N1Ym2pxeeM1Scn5bwLwVsRNSkBYV18bBQTi7EnZNVf7W5e3X/7lX0507Fu3bo1/+k//aWj9ETD94i/+Ytx2223x3d/93YncQAvdSiyDuuYtPSfouRwzoeWVzMPYs6XJfbGMRcoZC5eeL/+upUhmVIkLXIec0pxT52P2WDtn6dMLxQvs+8fmvpWluRurjKmhHdIg1pbx0bGoa2ETadZOwXCac9j/Ty91Pze3Nsfed90B+QLtTsfce+CepORrb4Is4da72FvKve8q4j3vfiiRPAycw4uDzZ+riSk0/tNxYXeO8f6fhYm1Che8fJ4yTrUG0FzDdVOcd++lSbRAc6UYy+lJiYlYzwA5lkXSD8er+V0ETL1RWYgD1TDulcaYx00VrGlNgKQp1tlan5efyE6v/15jLbAOkNZYh9+01WUSHGNSn4DtZnqiJaYG97Kx5C5mfhdggBExQxWVasecRLHEdAOOOl5JpngX1xTcWSYgJgGLxjLuRc2UC2ttB+4EbUz2eaD5VccemUuJHpe9keZYoAxGVahVAE5aOYS+SXWsrEWL9wwScHg4U6uVQydmfsADwgJadDVqJs+7iapFn8BlImWYzqz8y41cG3E9UDNnORu5v2pGd77RpN31Oeaslli3GtnOFGq8dmkS8LjHBKtadt6FhsuyP5bXOBFpvTMUZK5qgKsBo7qNSUld4Ll53rrNNHJMyln375gCVObnlj77xnwHQCAgTGK5kYr7v0ZywZeljyECuJaUwqDlEoqkQPNrOe0snfdUYTlwlF1FV0c17ktVjWiTRRaXduFlqihAM1A7GxvLCxKMFJnxWg9HRd0A4KgkjVwm56WnBaXlxdPN7iJ7OJ0BABYnhmK6BvphhBlVD+7LMqHLVXLH5BB9VgGoVGhfaKClT7i671vu2Rk/889+Jv7ss392dTfeJFf/zr//nehkfxyBRwVxG4msgSEkWHYcSCLSDiOl4+NU4SLzMq53KEqKzM8qPrzPDjVuxPdfy7hueB5zHkyCOvO5ShiTfe975xzhvljVzD1zVeyJM3MRAZ8pHWCme57zpbqAyjQfapnPQJaApJK5SGtJysxMryI98cQTsX379kQYsWHDhuQaJxgRIGlB+vKXv5zcHI1bknhDAgyZBFdiGVyJMdDjK91jcV9//fX45je/mdzolhb/U5/6VIpjK7dMLb0m/67rdhP9I7EBeIb3h81UcTObo79Soi0T7wl9OVw5Sr/SN7TsJP3n/mlVrDXsm86yao+wVjkvNbCNBCB0CmVjkbWtCpBrtJI2mPO8k4ePHo++5p7Y17ErdhTnor2NvapgopSlrqO9I8YKQ/HkU1+N6umRuGPXBqzaACDiJlWkvTE7FmNYvKpw/6NIPI61hThM1zhj3lwH6gBp49RrWoDGQqn7XIVgnTFh3FGudEyxV4yFQ1PDsRng14nybdFszthxRtWCtpT+PLXN+q811QLrAGlNdffNVVkXTidMAY4m9JECpAdDe2NqeA8n8EHGylNVA4lCzRiT5QiLJJM9l89gAaqCYCEJ2NybskjCf/q46NcCEGGqdmNNU2LgSh/S16v95RNdrBUEco2/vuBuvKgQ7DE1oII0xYSshNlTFsqz+KnGoLjgNc5Tgnul+wux9w3/ioCKle5NOfGQagR/N5TNgYft68JTDT34FBo4NXVzLEBuKtsEiLFg+bWLS5N/y6xIUi5ndaBEfFB4HcenXK1lXiZrSheS1PxlbhO13Ce4y68xDwPCDfCdAOiOU99k2aMUNzr57NQfABP/5WV6a891+c/7N2uhy0lwqb2prlrRKTTyWiHzlHIqZeNwTkNaibV0zI9KPrqvVNbiIsNPOneVzWe/2fYXASeFku9//oy8LNlfSlTFu1eNQFV6zxafv/w3BWZFLf+a/FscHY8zb0zGaydwg0VJUaw4j1UJ0gcKkd4YhKYaymjSWlFsZExtAVx3NyrLveX00D/5m/G/PPTx+Ne/+q/jZ376ZzKB/y3n+vbIQBeuX//1X4//4b/8Uiqw/bFoc1iaHV7BOD18gbYvDULbvDTGdNcSkGuMcP7TgqzgLdmDc6JWUQVcFQBVSUrPhqgMZdPMB16nxX2aGBZdwBTunVR0uxtX6cKPA182S+e9GgRtLRzJQsK4uJb0pS99KV555ZUQhEi08Ed/9Efz8UPvfe974xOf+EQ8/PDD8bnPfS4RN+zcuTO5MK7EMrgSY+CePXtWZCa03M8991yiaa+H0GJp8pzWqytJglXb37WhCJjV8tJIHJjzbupP3jgwElOFsxyWezwXJgCbk6x7EsXMoHyBIRzrjPTckHQAg0aIoZ1lbZhpEPxykj73bvNz3vTn6PDJOMZPW11L7GjZGjsaN0RPQzd03IyZkXPR1tmMS96FGBvDVa+lkbikxhgmn9NsIVCFW7xznklXYF0uHVQemRM8A47qAcrFIvZkXCr1BBFIURKsdayNzBnSiFM1Rk0Vm8HOxBcnz0c7VPOdeJPsInazmzxnULAa2ybg1jK6ntZ2C5QkvrXdCOu1f/u1gC5yU8V6AtAbYmKcHb1HOmIalqy5qeaoaT0S1R0vEifUzySJhslZ0hk7/QAEageZVbWSXGsyr+uQLADriZOxVgk1e074SaPPBzWsarHqOedCc7k0Ns0ihf6rvkqCCbV+yg7kDfByDxIXlJUTViHNCktSVkQ3dcz2WlfocOG7XFKQV2s3PqOVaBmrFxlckg/ZzpebhrEexi8sBgHZfY0GhyP4KKirmVYA+nYkCSMU7JZji7vi59MnBh5rFbN/HJ9JsOcDy/Oi+i6Xp30iw5PCpD1hrIYb8SbwxP1auirrecY04wktrOxM7hZfhVuUnk5pLHnjasNhmQcr5BQRloaLIzGo5QaBNg3LVYeDAtIymV3BIevj2G1041raycpahoEjZ6Npojke/OCjsWnjptQG5ZVZGFcIS1iAv/7Cc/HVY1+Pyfoim5DihnqtBSqVWaH7Z//oF+NTv/7p+D//za8k1yhZ2G6GNKn1DYGyAQFVy1vetS89/2L0bd4QdW0N8Quf/9+jDpavS5LjmLaVFMS+S8KxF5X1f8oPK8TcHIQtKDl0U/ZaQZKkGrO4Ns0kTQm9WLI0OZ5VhCjI17PhdYop4nt7SwcCLfEzzG3mIVGD8XC6otrF5tfR0A6RRAMEJyMI0tc2RwgKf/zHfzyRI+hSKBvgxz/+8VR9Xew+9rGPhaBFS9pjjz2W/q7EMuhNqzEGLsdMmB7Er1dffXWe3TA/lv8VwP3zf/7P86+r/nU+vjg2lNzSdE2TSdOtEExS5Kc+ZD6Vya4BV7xmLPeoyZjLsdxTx+k65kCIGQRNExWZ8kPVxNw0bsC61Grt4d8cKCq9a6X+V9GhBWdwbDieGX4hnp97kY1l2+OW+g2xEW+Eis762Nm4LZpcu9SksR4dlz0CS08V8UpaG323FxHJUM4CY9b5X7e7ZCXkGV7nv1QX6zSFxZ21op5YS6913h1hPA3zc5SyH4O57r3RxT9BIuUUrNMejqP8HUgNtP5rTbXAOovdmurum6Oy0rb+b1/4Woxc2MmCCjUpbmBKatX156K685vEBx3hu25qiKFKcExyLqDfUYniJLBB+fwna47MeS7hugmN4z6VnXGfnPrEAuf3yyXrKQFEI24rtcT9eI8C9AiscLq8LJ+07FSyYaAMUAiibymxsNI/ReuwxEp02WxpC/eg0AqW9dccbTHGDulYIVaou72qpm+MxW8yaYhvXD9bJpm0momHELRe7ZgSENUSP6OVTuArSHLc5knhYVx3EtputeSiL2OYWlvdippqYa4rEUdofayvIfAdzSiSAAOflkPeSKDbTK+peRA+EU5GJgtxsTiUWMauBLCvVocrPdcBU193Y1cCzj5TIfjci8fjtu498fBDD6d2TEIYGWYCOb1ivUvf/Xvy+In486f/Kt6sPRdNm1vnz3vuraYiJAHFwur99VafcU330wQCedvGdkk/WlpWeI/yZ/zR//rpeO2Jl+Onfuvnom9Db2IQNDB/YqIY7Z1tUd/UmAht+gHIbg68KPFMhc/0DIb1LEDHf/mYy7YtQKk1uiOmh2/BvfNU1La/ilbE9svY7exfYVlmlcr+OjdZ/t7m7mhFaTIxApMjdalraYBifjDODZ2HlqQ6tnZsjtamZiwZc3GOWBZZH7vqO2CebMGyVIznoUB/8jf+Or7yhS8vKvaVfpHuWzru5FK45Cb3r1qOLGM1lsGVGANXu2fJY6/6qyx2v/fUH8b7/smjSUFjBg3EgknVzYuB4oOYWAEFx7UytcMs5/YBrgoCq+HiWBpX3pcsgAAXgaj7CenGOD+8nNYw2KncSiBFcMp7yXAkLbyjObDpbu6M3vbOKLwxEHsBuDs2dcYQ8YUvMB8Oo/gbGIZgifjhjNhDAiWd93gI+Y1NjMcYlj29LSx0N6B4cKKQCCd0lXOe1uIoc57jprYhA7OWJC+vNe5izXykpis6kBvSFhqsl1vv+QHqtW5HSG21Bn+t9/wa7PS3e5V11xk8cTfVYILEQlQhQ1bbQWKKXGxHmDSZqP0pJSfI77hE0XP3Oss2iWAwxJ4uuoO4QKXJ3xNcN8kCpFuAwbWXS96n28oIC1Mj1RZsqH2vgcQBGMFZl7qF9nD/myqianW3MgYoO+fflZL3rnQ+i9ExZqmo20Pp30o5XXoczSNlnU88qiTrzh9a+sGSyGLkJpNjWNykTL+R/Z0WW9rX2KqrSQqHjQh3OVnFcmVUU56RLmQa0JXyV6go4upiX/GRxK9S1ymQSr3tAUk7koVK0UFB2UtN6UPpW2ko5Oeyr4oamfZVtxZjSAbZuHcEgRhypySsZhnduN+2j2OhjngTQWl5SmAvjRMsRGxW6T4ygvLuThjTeI8Gh4hJQrgxEL0d2ucUGwMgLcOi5dm9pc91aKT9mU+rvR7zF93gD+m9oQ99eexYftJcw6s1P6+sUISkgedc99ae2L91b2xuYGuDwQtRqAMM4R5XjSF6V9uW2NDYHQcHjyY3S8eYKVkuS/3iuEljPLlW0pdYAeaKG4mL2wXJTSuvTwESkU3Eyg1B+36cPmIfOgRsg/21Ruhip+Dtnjam3PV4Gvc7+7G2Hrpn5sqWinpiXOZiR9+22NjUHWPFcQTtLuZABHcZHXmnVBAJAhqJPX3i8a+k/K7lV74v0nL3LgeOvG41lsGV2OZWu2e5Z1/tMd2Um4k1ndZG4nuSYldpVMzL0rYXJjKLv67QrkuJQZBe8X1UgeYYSlZ9FT4tzIPcmrYSQEGVj7kp3NxmyCeb57igPPkoOrGmjvuJD0vWVwBPge0KJgBFT09AJT5Xl2KBJui7MazAk8zr1ZRtptoYXpWHpNIvlUQNgGXLsL15Szy08f54uf9QPHfhm4wBrEWCIsaLFvRZNsuedhNa6iWoy+PnhFv9WMiOV05EJ4rCWuqiz8V6WtstsA6Q1nb/v41rjwiHe0Z185nkTlfVeDqrC65z5SnXLpcf+078rNBrsHINi9AsoK8W9xYXMt0SEkvcVUt3WCMIppV4oQ4AoTVJJh/kEJjJWbaUOZGfasdZJKRdxnd7CmGzkg0a9bbIZJ6FhY11CqFDLaELTpLKswxKjWn5JQ3IrEaZK8TVtTMaYRZctZXZoio4ws2BRfNyyesFfo1YTkxjLKYZ0Etfr9svBYOkDUV4S9Y/V2gEwOQJX+qfhRZbeKzCndZBhf28bgtn80/kQiMr1K0sxJJ7+s8YyVSx6WZFUf/nyWdIgJFEGZ6tdU2BJgs6NqaHJ1he/is4p+fxWfWuwuQk1xrvISOccU66MElikqrodTc4paL4DNo2/Vv2mZnF4dlnvhZf+vKXsFjOxAMPvAMtfmu89OLLcebsWaozEx949FH2aNluZje01Lr8ViTyFhGk4PU6Jou+bBus8AyuTYBo8VS4wsWLD2sRM9WhZddd7bVTb8QfPv0naSx0tXXHMIBmY/uG+N57PxDb2jalcjWzF43xk76vo256THnddLiIYKvlpgWBs7q4HesDrpJdw9EA1XtNLa58hU0xNbafPWoaiIkjnm26kNynDMBX0BaQ6xrXxN5j7fWt0VPficcA47iJUYEb1yQC8TjPEzA3sS/S80dfimff+Hr88IM/FMVqYxlVKsGshwDdjEV159YdsWvPrsUVXmPfJiYmogPXxK0tfcmtsYHYI1nmUkwj731TFf2OOi5tng1EqGVMd2HF1Z15DGDRXNOaWmwYa7IWZa337iOklVHF3gRrSKbg4zLWMAkz3I/KJNRVWVGN4qKhAdZVtihwjZNJz/dcy1nd5ib2S6qLIaiRKnDZsxxuZK7bZaXKUMhYklWSvBwj/pvkGd6/v2N3PLLpAVwGm+OdvXcn9+yXBl8jDwAfRdDqVNlInDJ5TgPgprCKzlIW2Rc97wQ3QF4qWSQYqoXDvFR0Tq6ntdgC1zCFrsVmWq/zd1YLoJFs6MdidBB3uoPMvOh6yixG31llvfLSOEfrP69FxOSkb3IRuJbkomcMkIKOWrZ6NKi4WqfFIPcPryxpaJFuiOECBbGZqHuKVMJwVi0HammFKLIP1KkTW4m3mIqNm9H4wk6GQjktrLpaTM2x5wiCtGXOy33lZUabyILUyMImmMiTMCxz2Fk4lp9b7q9XuSGtYMC9cG5U0kInYFA7raXMgGDp2etKrnM+t7zECovNWI+mMb9kwcPlV5T6FjCQxVvl4HNx6RX2dM2r4WcGRkY3RlTPq9Y+ubGgeS1Pxg/oDjcq0x0WoDSEygqV91ECStyYWwEUblKyb/mQepP7yrolO38Dfht/ZuC47GWyMgrQMhEoE4DKH+k40e3rxMlTccedd6W9X14/9Ebs3rU7fvInfjyeffaZOPzmYfYP6k23LW6d8pyux2c06mMbsYwQwdB4MirrLpBpWWO/lUekfuCXwy1ZeK8gM+8pCY+pF5dUPgPHlM/Xe0k53Q+nWmIDLLImx0NPa098150PxSP7H4xvnnwt/tMz/yVe5e+jdz8SPXVY7YhZGpoYSTEtnW27sELUE+MynFF+a3IkFk7LeFWNvdmKO1RNbG7dkDbuHB6FsnuiI7oBX424r7m30bmh/jQH7W7bhvA7Ge0E9Svjeve58fMoeCpiA9aiixXD8UqBTYpR2Oi+qtIgUeDzPhZwBdMNVSrxjU290YpgX729Kg6/fjief/75uO+++66gIW++S/7zH/9BvOuHH47iGGAHYNrMRq1E3KDcooGxwM9gYWkLrEsqapiztPDUY/0TZM4gLdYken33Q2JzX5jwBpljbOtZ1oNm2tr517m3iKIr81xQxZdZnrQ+uZWFVirfjgIWmyE3b+V6h2h6YxguY2eGo7GbDdKZU50T04auLDYzKOeSJXzpZMSytadje7xvw4EEjrIY0Zp494b78JqYiUNDh1lf6mJrcx/jpicGsIafHe9nb64hLI4ojwBfUnrXAqa7knaQeZ25p3wtuvlGwnqNrqQF1gHSlbTS+jXfUS1QgVDYsPXPmUDHmDBZ5W8CcGQDKwCUWwb8/laTfuNjWBMa5ohHwrCCHJ5SBW51S4WjtEIhWM1AwzrDYjnH/jg1TUwRFKO+YTKa2/rj+OFbsChMR9vGVxCa9S9XdrOclwqxV1r2ROFdha87Qk55nZPAjOZ3ZBatdHrG5XN0UdOtULKDREubLbuXv/EqrnABTju3c08OKNR2FhES6tCISiyQqIw5b3MbXH5qAksni6/7wSigKjZkf2lfVavUT5cW67+0X6xTU8kCZTOMoDVXW18SKcS2lyQFCYOSJSnIBOJLLsmeY/9x7Rx9aZp/NgUvDZVLb7zOR6yzJBO6SPU19ESBvbcGx4fj/Gx/9j5Yv0sKg5IEAaoKoWaoMAJ7FTFZheFkBTVW5BhxR81NLbF92/Y4d+bcdS5xeXY2IKB1bAuB4AibzUc4uWyBy2+6ss9mQ3I7gFmARhXzXOrL7PCKv+172camEXZl5MpS1oBpfPFR96KM4W2x+2JxdIIYjQWXQceD7/cErmvD7Nnm3mgqM1rY36izri2++sYz8ecvfAGQU0hj/p07D8QP3vvB+A9f/Uy8e88D8a5bDsSnn/rPcWbwbHz0vX8vCZ2//fh/jA+/4/viK4eejueOvYzbZkX844d+JPrYTPTTX/v9ODvMHkIIzVs6NsV/856/g/W1JT7xF78awygFtDJcGOmPd+0+EI/e837IEZpwucISwBsvk12edNEbnRyLzU19CO0N8YfP/mm8dPxb8f6f/f44cOBAIjzYv39/fvlN/1fL0e133BHbbt8Z+w7cBuiYjEmAZj8AYXISGIHCR6WKGFyXtGqAUQ0/ItPBERlgRdNposraiuvc5LcBwDNWNxED4wMA3jH6CldGYjTdIsK4yASaUOpUk6cKtVFA0eDYKMqbbHNhM0tzTqnrpAIaegMXbTwZqlohUmL4TmM1nE+ldyLdx7zo3LWrc0t8YOv7MuWKdQCI+Z60onB7/9Z3xva2jdELW14fbqGuNS5aBayT53XlK5yl7pCSUO722pboYt6ZHDyVrOZpT0SetzCq5kux/mGNtMA6QFojHX3TVRNf4bmbBBjlfZNijXDP0SVOQeZ6pSKa1MoJFo0FmXr1rF0RWERmxnBT0U+b0Cfdv2pbj0X7BiwTZ/dgDSlER99hFqJ8AVlYRrg1HVw4svLjdPtqBATVlrnWlV/t3k7VsF5JMT4vvJdfsMxnNZXNgKQhFv0MSCxz0Vs4ZDPOAZJM5WWSPleQI1CqByhZp4X4GTf6xdKW7D7p1vl7zcMFPWlH+WwqNWH2uTQUvE5L3XBxOLmJaMHymEDSu8pHjEKOgqF9MUUsR2qHUodke1RBClJih1PwVCBNlqj8Gu5L8qaZlo6lwtyAX2qaJb5ooDxj1M86tdQ1YZ1jrzBE3+WSgpHMYXfffXd89ekn42svPhubYbQzTuTgoUMxxiaW+/buTTEgy91/3Y7RNrOQxMyhXq+oIjYiude9xQaz7f2HsJf6je/JwneF2WppktK4ulqNOzXNf/io0JflTrfSwQkwlXWwLnblMVUKmwMAks9+43Px7NEX4tj5E9HX0Rf37bwrAZkvH3wmdm3YET9w3wfj5RMH40uvfDWBqLbG9jgxcDrOQ/f95rljcejMG3w+D5hh42nq0dHUEaMI1N0NbfF3H/zBuGfLbfGv/+I3KFRV/Pff/WMpFunX/vI344lDX4vvue39gKLB2LvllvjBAx+Ibxx9Mf4CUHb/6H3pHUvxLzkhRN6x1FmmR126+kcuJiH4H773R2LrD26Mj03OxQe+/4PJLayJ/XhsW9vZtpDgxPfJcvpOatH3vZA0RxdZ3yup431X/Xdp0tk366jlwKz3ZEqw5e7NcuO1jvoUB7T0GvKFnRK1FPOIdp/SgOCPz/JfKhO35RZhc3z6iaeip68n9gKMPvoLP5ncFC3/KBZYx1g+h1fjamf8k+DZrRQq2Q5gmr2OZgATU4CoGqwsiYiBPG1X900yHrgBioy+uu44PwNIghijCRdu92ubYD4sTsCqSnvaJkPMMyNYm4yf9J1P7UNZnRfd36q5ognK7baYuZ0tHJomk9VxRusgLuAZA6E1X6pAAryjgJrBgu5Gu9YnV05Z91bA9T09t/uRYc/d6YUI5r6m9LODmKVyy+wsCqVhyjTVf5z3umRNz+5e/70GW2AdIK3BTr85qlxaHL4TKqMVK6GPay+Mi5uWArWzaZG79qyW3Im1YpLyIRSklXDJ2dW+qr2bQWCqaiO2h+aWxKEVUASdUAye3YvAgFtFz1EWnUyzyBOgenVR8VNatVVHps8uwpckDrohrMQFy9cZkIYwwppHbstlcEmO8we01Bh/4Ea/V3vvfCYrfFipJPlzcqBUQ/uomRQo5ffk15Rnbd3zhdvjuuS5aCs46CbpRo2pbfmsy1wBzbgZmpeCkGMmHUhXZTl7vAP2Llm8ClOjuMGg/Yei27wFH21oS1PwNX3QSnyH2nb3NJpEeEkumQgsjkeB0zhAhYKkvshyv36/rXsNFrd24hy0sFlfk59bcK2aosyrpe07tiVXvGkEuC2bN0V7R3u8+PI3o5lYpB27dq1263U6R88QUD5H3IR7rVVUvXWhyjaRLEFhz35OGnH2BFpu7KxUCYXPOoR9NfwKowrlGe0+QnFJSCwbLvPZSPPd2tM2/11LTBPgdc/GXXHr5n3xZsfROHzuSBw5RxyRygv6aU/vfiwSHbG55W4YB4/EhaELsbd7R3zr7KH45vFXo72pNbZ1bYkTF8/ESUDTZgBWK65dxpfs33xLbO7cGCfZB+dI/7H40L1/k87HEa+RTVe33h7HAWQF3O5asEjs6d2eyBa2tG1OrqbGkmjZqEKwXwpGbEOTcVC9HV3xnr3vim8cfzmefPO5qN/XGd/zwA/HD93ygfjdJ/5TvHD6Nabvufgnj3wkbt9yaxRGR+PffO43YgOuhTs6tybrylfeeCr+1v3fH1u6NrDH07lknS1gmVe5oBW5BuHcd5a3HQc1Yq2ABB4TdGTvZiqOPRtDxFq5+bgW7gwA827R35X2MX314FNH45bXBxIEyu7KfvtmFHY3Rev7O+N1rKbfiJ7AGY3nVkYrbHNu8C3Mcy+fRsgraogZNXbngz/5g9G3bRNkCAII55MUoYYChOcBoqXPNg6nqTFzcbblLItNWA1IcmyPOzdghapFKSFIcgi5WXcyC6XiVbCnUVfU4optfFIFXuIp5pK8+5lbjE2ias5YaZNXXbxdjwTslrtpjn2PZtsSkKrqrIviueGoa8USDyirg2BBwOb+WBkQzFYYH6sC6uTImXju7Ivx0JYHkrItFaf0a36slx/ks3TtkoB4Xma8HCRV8r5Udu2ME6OnohJmvK1L7lv/urZaYB0gra3+Xq/t9WwBV5JZFx2Eo5oCXzxwbUkhqMnJmQk/X9yvLacld1GkKpjq1OBdWekyUZ61K13P+lbSyqHhQ+tWobzae5i9SOqj//StCCeTUd9+hoWG/BXqFOi5xIUnaThdkD2glSOBpYXySUphvMKK9aXACnUSB1yNcOgTfGYdC28RXetb6ZeF0l75p7ysWm4qIJkwwLlcSFotJ/tfy497fUxCky5Ico8sXUOmiPEamhhOi3smKGA9MrZjmTHjviUCD4XjLiySbXWtqS3NRwulnWu7208SeRgE3wog4UAqnvkj76Ug+yEsVmOTxcvSj69Wr8udy9us/DrLLq7PRpKDKGvFJAQiXOoaM4oQc6EfgXzf3rjrjjsTmNi9e2c0Qfds4L4CoZscKxAhu96QNOdWA+zPU1Gl9Us3yays1/ow20Ka6yS0kVW5NeBK87TNtGZOC2IYIzMAzSKadgHPSqVLG7UST1RuQTIfAdL+jbfEO3GXux0rzmee/ON47fTrsb1nC+NSAbohxke7EKAHeVchh8EKuHfz7vjqka/HFw8+FQe23x27e3bGG+ePYE06Ht9z999A8IbUgbFtzJAW7glcemd1+52uwcKgPsfYPsqfJiBqTaETcQjH0nzA+PTZblYqsYtu13my3Zogjmidbo6epq5449zReAwgtLNvV9y1ZV8c6z+JUFwXG7ZujIaelthUtYG2guKajcQ3bdkUI2MQQ3Q1xdZNWwFle1L73X/nvXH/rnsR/Cvi+dPfTHnUTNZH3QxWT+j2edEgt4FkBmtHC++SMYfVCPc1kCBk7KBZ6bSYd+HrPArgGMTNTHddmjj1lf3se/euieMQKTTn1Vn0d4j4rVN9HfHoto7ohV7+GWK6xnFPbqWPjE807koWxwrIihqJu1I91cieUwIWx389bnECW+fHSdqyODtB20PGQqxqLfCumrXCOUGljGUxVdVqTRKgMJfm84OKDP7nre6VnmqrbcViVBNCQOf3OeKGatjaoLOetkmrEBYpQNukCwl9NgpFd+OUJO2SE+HWjbLBlWr83AgxscQ5Uc/culcNC10Dbn/VuOPqPpzGBs+1nF8/83JsauyL27v3pjnPci+XBGQCo8x9DuUMFrMcHJmP7ffk+ZfiucIJCCZm4z7KstgJdblc14/drC2wDpBu1p5dr9eNbQEWAwWD2Ql2Am8kKFsLUvJJuvrHKhAZuOrCpUByXROL0FQtWm2yrTbKdsXss8VQLV+V5AzQfqNaVH29sICwiLnnDp7k0bHpNRY6KHZP3hE9upS10AYsKJWAEhd6hbN5oaW08C+qF4tRspSk5XD5Qnk0265v0Z2X/eJ9ru21MDI11kBUwaLnov9fIynMqSmXSvdyfes40NqUWXYQZij/HK4jHjdYWYHKzYBdyM1LUC34Uh9cnrfntZ4JMDxu1e0T4wL4umxbJKHIBrLhUmLcILwl5kOOGVslm10ulJQuuk5/8mdemp2Wj7zn/JSEUOITjp09HodePxjbiDF68IF3Jnec1C5cf9u+21Id87ikb73+rThbvBBVPcRU5Jld+qhrPjI3i4V11veEcVYmqF9zhjRH0vGv3CxXlLXWVwU+x2CKSfKd5N9KqYj1yFTbmLFB+tmrZTUcwoozWBiMU8QSDYwOxnbiPra2b4Y57pU4Ofxq3LN9S5w/c4wxeiHasFwaP+SzDsGC9/13Pxpbu7fGF197MuWxqa3PrFO57A7jJFsbW6KzrT1egvxhR89e6Jhnk2veLViuGgC61iVPeQ0knmmBCa1RqwbjXeuLjGWTgPktHRsSFfmOli3x1Nnn6JvqeHDPgdiKterL3/pqGgcS1GglffTOh6O3pSd+/2t/Ejs7tmBtemdswnK0jTq+f/97ohnrzPnRgehq7kgWrG/VvRGj9HWBbRl4IdKzNeLW4oJnsD+iO6ACcgmsZNVumloaE7ZHA6Cho7IlzlBxrcFJUC8NyhkVKgCtIvTXK6UJrClPFHnOXCHuZLPeYuE8ewUZJ8b+UICGkXFc2LDWOE/0Q6BQxzzeggVvU3NXIrPoZz88N031kYwK/jJXAIak0u4fo451nVGJS/MM11RDquF8kAhosD7NUMlKwJIm/TlAqBvHCpJSzKUjhXfPfayMlett7ASMMZeppEpgN5uHEgjnphbcaVt0WcRlcHhkPJF8yGYHVEtWqba9PRklN22SNQ+WHtjyurFSjWKhGgXQpsRjk4II4PPm6VdiOzGMrTxb0JPP+TkY8m/+41zh/Ok1bhXgZxUvXzv7Qnz9/MsJnGeqvpV6Yv34WmiBdYC0Fnp5vY7XvQVmAUczI3uY4C+wqElt66LGgnIVSaHVH12kkrbtKu69mktn0eJN1bPQ4ClVBaPUYhmOFcb//FTWsGg0oJFN7HU8AXl6aZW4Au1sE4ep85aX48Lxu2Lo/E5cLwahe0UIx6VMze4ELk+6dCUXkqWZkK0WrYX4nJVrky9yK19RfkbQhUCCxQVPeqxb7INDIPmFsX4ohCE2YGHPyrNwj0KLi6Vp6bmFq67tkwK9Ar4ud+7Zkj1l9bzUjjomvNd/phkEhyE25hwYvzi/6FtuIBDCjVP44nGnrlbWpqXpyttSdzrjLsZK7nWluIslz1ma/zV/p42W1sG8hIFjuAfablK4Cxz90ri1jQDrM/HHn/8zBO9NsX/ffqi8txF/1JSAkux3g0ND8ebhQ/HKwefjOEI7nNRscoq1Nz3L3FdP9oEvinJ53g/L3sF7rwXJER3EIGX1uJKeXja3634wWZEADSbHzGppnuK7bF8nWcfGcZH60xf+Kp6EkGForBA9LZ1x5/ZbU+zRHRf2xJcOPh2Hzx4hbmcMV7pN0drajAA9F7t7N2MhGI4eGOo2tffGJkBTZ1M7m4/CSsf4qsMFzX4dIX8BzqN3vD9+HzKFT3319wBNbvxZEQ/segDlEW5WWg4SCDK+iuB/SCJUJhRhW0s0zgyhRso6Aiva7z35ByhyYI3kGXdt2h/vuYU8uPZTX/y95K51/MLJuHPrHSmfFsCcboL37rgr+gsD8fnXvpLc7P72gQ9BNPH/4SZ4OI0D8/tH7/6RuAVLmNZYY5Omm4jLxGW1g/q01uMqjMV2CFfW0yMDyfJamC1E9VQGdtSdTUFw0VPVHbe3b2SepTcQ4kcBJskqDAiVDbASQPXKvt7ouXCE2JvF7/UM17+6H7e6mp74InN5RcVY3C+Jztj5eGUCshJc6tyqwfldtzTdFHtbO9nstyVZ04/hxqgbrZug+m45Ipyrq4nXFGxKXKACrAnr1xzuczOCI9wdZwBgabNUvs+w2aouu6NVWP0A346pNuJ8mnDp04NARjgJHrJ5bzpZp2t5l8YrMnBeRf18tdKeWeQriHTT7ckLkKzocghsk3nO67xm+MjFaNrQQnthWWdOK2JVL0AWUge4FcZrHW2g/3ZR7k3kVzx/NCb6AF70tykHR+lL6ZdgyLHkj+Ao22+LvmDMvdx/MLPQUy//r6e13QLrAGlt9/967a+6BYwPYHEcuAthDPeAlvMsVMboLIgfRbRokhqUJ+da3adcFKVMdVHWtckFSs3njU6zBLsW6yGAwGepuujikS0AYoMcGFXhPpLcDVw7F6/Ni4pneZsFSY0IP9ufZRFCUwi4yvZC4UYWezWnjbge6iY2qXvTosTCOwM4RLu5mvCpMHulAq31URPayGIt4Mx7Q61kA1rdqiriWbCAGDisW4sLZxV9QHekxbxcQ72oqG/hi2Ww/ApwyfXwMv1sWygglLeJ5RzGctQ/PpgAnv2j8KHmu1qNLnku7Sr3FnFsledz5dXIwNEYm826h43lN0B9grazLPPJh5bG/LU9Zz6nZB0YReMtAMqsXgw/nusGtaOUQ8ZAz9WjceYEQhKMinvbomlnX1w8NRh/+bXPw9JYEzs2bYuOto44efZUHDl9PDqbh+LOzcXoa22Mb+H2o4i22sCWtMA2lQVRQVEXsCHaXs38snUUQM0AulCWyOhYmVzsVnvCQp2/nZ+W1lqFQAXtWNabqTiTMNiZ6rQgcZMxMjvZgPVH3/t3E0udfdJE/NrGjt7kuvryxYNx5+7bY3vvtjjRfyrasAJtw1J0Yuwswu5YPLTvwTiAW1oNbl0DjN8Pv+ODyV1XF7yzoxfiA3e/n3ZujhE2ln7x7CtxC7Ef/+3f+IcpxgnbaOxsP0AsTS/KFu594IcQ+BvTvLoBsPX33/PhaG9mz6v+15KV073PbsV9rrulK1lD6BSAwGy0YT3Z3r0lfvL9/yBeOXMQKyqud7Ab+n40IZz/rQe+B0G8IoanCvEeaMy3921N+8Q9uOu+2AMYevUU8UkCqG23Ec/XniwkvbVdiRFtlnpKS7+ZfYUE0qchszh58ULaoLiZsqkAmp9XeF8GC7C3AZqaG5qihbr0VnVSVmL+mLcm2ZdnAuBSRVlevKMvtp8Yip2AA8e7yTIe3Up83R0bsNDMxGBtT3xh4ly8f06QxLs+fCKen+0hsom5mP7raG7DkgerInn3l1z5igCY3sYexqoWJ+Y//qrwqqWcndRNi3V92lCcsqDgkqTA+NIUC+d75+avlNf5VdbJcZ6tW+SF2QEAUH204dKXAVkRECCM/ItYB3mriTtivgfMOKamAFHOY9WJcGI2BqCEn2CdyMlmJOVhBUl08yMF9kEqEBfXSHwS90xB7HFXAPyqicWiaWpx/XO+c0XTuj05ciqKAPgaLEm54is1IL+s7eDkcLLStdW0QUDBdhC46BqDZKza66cPxzDulYJ3QdTS+/N81v+unRZYB0hrp6/Xa3odWiCBowv3sXigaet9Cc0hLmcsIgohJqlMp2aG04KJLSPT0BlIzIJSwwSfQFJamLI7lhW8sqyu/28EumId2mT+VhFM635HVWiLrxQYlRdIwby+qimm6lhw0oICIQIuF8YUuBCllOpZfpefsZjBjFTD82fdawOLFfKHEsDSC1f+zqXKDQt3LIAjXc5s07xdiwi3uooJKAwaFhS57wbbBPpQyisgWCoqrvzoqzujppa+R0i5ksXWdhO8KYh6vX9HiQ04x54dHq9H426cgZYuTvNZq5S64EyIsmxaoASq2XHrtdBKV1J28x5P4Ej3H7bNAqQIkHwEwxfBQesUQgnlqOZHt7sCLi8LJbiSpyxcYzl1H+zHhUkgKamE+esidJGYloxlC7IInqO7n8+x7n5owMVo8x3bY3bflhg+PxSvHzkZI6dfjdrO+mi5vxfK8JrYVjUYfeR7gT1PTlf3LtsaCkMKhzIfCowSW5kP8RkcG5i4mPZ6UXC6NPEuNQzgljoUFXUD19wOl+Z7/Y6o0NDFM1PGoBCgFdzgU8tmeb8tWJAQlIntGUKY9Hwz+xO1IaA6lgT6bxSOxXncsQTN3ZBrbGnZELds242AOhVHRk8QpD8SFyovJmsyYjH7Gr2ZaMI3NPekPd7OYfFowN2zA+vuyOgZxvcAAGoImuhCbGndGBu6e5OAemzgYpw53h69uIch88Jw+CqxToPQMbcC1OriBMLwIMK1hAQDWH9mm4ifaq2LduJYTL5Dej4/debrvCu10detax9xJpSzsnIm3hw8RuwOQAZr18GBI8wLU+TbECfGT0f7cFtsa9kUO+7YnPLS0iCI8V3bCMj43u2PxMnRs3GscBIB/2KcgoCiH5r5pqam2NLZB+BojjHaZ4j4JBUaieyEeBv3uFP8ryNWaRbrk2QNMq0NV49g5adcKI3srz/90K0ApIHYzo/pKLE4h3d2lAY/xkrG4lBtbzxePBuPENP0jhasq4UL8RIWqgmsW24OXRgeT3NImufo9e6GTtarZsAN8UT0o+Wam0aBA006FxqsFJOQjGi4kj7fQ7pJy2bn5qnTgCNj+nQFb2K+HsINrx4wJjBRmTE5OZCo35srmxlvekXUpvi/CxeHsNZButLaMv9cGoTNfI0tnYph3vUdHVuTtct1ZYJWmXFt4DnFvon46umvY92Bjpzx+q5KyFd4puCOTkzltk+0kc7xvYq5pNiP9W0jIJg4NOdQHsIahUsgIOwrF56LM0PnYzt9ixka74dCfNeDj2AFnolnvvFMDDYMRm1PQ5qzU8Ov/1rTLbAOkNZ0969X/spbQMsRi0E/m88VtkX9lr9kAncBcsFjci5l5ILSSJC9qQZgpICscJ5m6bS8plNln7Lv377fgCRikqqIbTFgtx6rkeDEdeRqkpenuBrYh9T+u3jlaV5gJ9PF2aKtBBxVF2kzTkyP4vXNPhyVzSW3vtSSeS789SJ+XNzy5AJay8aFxibNshiyvrPg69onK1sGjvJrteJpbbBubu6qNlNBW8aopSXL77mefxV0dJ10vxBHAsVYPVHNcjAlg9tFBEfdpHQn0n1Rl5KFjKzF4lzd7FCBPwEt2k6LTJYW2nClQphXijuyL8lWdi77VcCgVcW6aMlRyFNAUUM+jiBmO48aqH75Ryz7aG/THcqNG7Xy6T41jGtWkcD9PE+BVOl/ysNyaVmTwEIWxPaNCH8b2xHU3HgSyxcX92MtPcbY3I/Qt6d2LgawahQrYf0qazPbVe25jHkCMweLLZoEK/5KItJX2cNzdHEcpC8ASXk9GZcVlVAWt7zhHfz3RH6Sj99BybppgZPYQlKBCeJ0rKkscDl4X4hBQqMOWDCI/6KkIAjAS5PvYQdkBH1swloDA4BskbZbZ1077YkVD/BycOAYbYItACDtHHh2/EJya5MuWmbEU1h0CtCxG3fjuC5gxXl14lBC4lUI2NuatsUegMHcRF0cOYkrXj1U2639MVCLEEu/b2zujfdsvj96atqhky7G0xdfijeHTlBuxizP3NOxAxDWypiaicPDxxJTo13kdNyM5WpTfQ9jDUs40vW+jl3xysU34vWBo8wtc9FZ3RbdALjKCpjdaCNJPvJ3zdg23bI2RhexfpXxxhDMfcRnNePStrN7A0AEUgTaYhg2POccLSMy47nfUAeAsh7SAucDaBVignqMM2a7iJtBu5EUIvaHHgbHd/dkoMiGXSZllqS+eHzifDxMTNIDrQ3RUzgV3yi2xZmqNt5lrctZhQXHugCqcJD4xlggQdIc1hzBX7IpMfa1HqaNwumT+bHM8VkAje3mr2nc7ySgqeO9M65RS9M0c8IE7XKGPt5Ie3VAklJH2xTGAVVOwLD5TdAWjoMa4pimp7Da4Vo5UkRxRWzRXkhAeqF+T+/5krq6cfAXv/lEtOzYOLQrVwAAQABJREFUFH3NlI/WS01Seld9Z1XMWUetVLOSytAObd23pDmqwBxwASXTK0OvMw6Ox+jASLz+lVeiaW9ndHd2xMujb8Qt7duj78C26D+LtZjY2zlcC5cry5KirX+9yVtgHSDd5B28Xr3r0wJSnepWNz2yI+q6Xoiq+vPMywvBzPlTnFTVvpryBTVb31ZY5fIbv81/Z6rU+o0BM9BmYnWoQqCQbcl/WbldDS+TEMBbapqTUD3OIpQLWsvfxaKv5QhwtGAtYmFDFp8ZAcRMYZnQnz6twi7NaAVZ9NRmlic10gqt1VwnY5bCG6I66++lLmW6cxSxfowjdCskKfBf70Vvob0WSmmRBSbuM6QAJjhTGLlcsm659UfXQPcUkX7bhV9QotCUC+7L5SUYl01wHAHY/ZJsRUFNHdaRUrMud9vCMQquFYDog/Qcy9CCRcXAaIGE/ZvGBtf51zoZoN3Z2JGE0hQLspDbVX2yHXX7kcJcsJWes8oQ9LxugMavaFVL7kyUXcHNfXGSIFbTGWexavYANLdDJHIMy8bRkjus98vm11XfiStSxva1XNt6THChJama/rCOl4yh72BgZCfYT1pNFfyLAKMEjqiXQLo8SfFt0kUrjdcSLlouVtA2kNa5AQXRq2++FhdHL6YxX4fAfNf222MvgEMRUyBUR/v5LNsyMafx0gsYihMExzuW0HII3CQDqEZYlq3McXcr7m5HTj8P8NgYdzXeFd84cS8uUVBGV/Snd2FX81aAze6YGZ9O7l7v7Ls7XisAcoaOQdDQA+FAByQRh2P/pj3YKabi6PDJNGdoQ9M1rgnrvxsw/4evfCb2b9kbm3o2ZXT4c1jCK+ln5kPjVFRQ5GNDN9P5uBXq5/49lcShtQEIdnB/J+5zvvvON5NYXapltuOfxAiygG5kM1xBvXOEIAmbdhq7TbjcyTRXMc57AKhMfUYe6UI7xXayz3gHpdm2HI7h3N3uiygDJqeH4pa23tiC0uIQAOGF2ZY4V9HCO61VCs8G3o3hIayCvB/2n4qnbF5gBjXGi/YXQM26URUd47O0sLvZsG2QlYWnOpdxSTPkGHzBkgjNOXNTMy59NewJNs3co7V5in6dxDJTT2xgTX25YkcMDEMl87MKh80tvcR16Ynhf1tmITnn3Lflzjj64pu4JHbjrtkeFS4azFHJxM38b9mkHJ/ioY61GlzuDg4eZh3GWkhZjtHv/ViBkzIHYFjfDunHpraowXuiUFeMJ049Fy9eeAVbHnmNz8Twaxei++6NuABmcUwLpVn/tNZaYB0grbUeX6/v1bcAC8n02CYW+elkOarElSaRMrAILJeWTvLLXfOdcMxyTgBsEJmST341C3ct2k7d0DKhyAq6YC2tqHe6+E3FCD71Uwimq4OjrLZJHMNnfVF2Zo1fokJOJexNuvspHCSXFABcEtSy29NvLQ1jUyMI/iy6LIZqmrPSLF5YFSbGCLodRtjOgZFCgUmhQDBRnrfnshwW55NuWOWXz740IRpyWC13C7FaWq1kfEouWkmYXu6ezHpku6eyI+RchJjB7JMLGIt+1heXPi0/giiDECC4yMCYdRqjHdwTyrJcWlbLkbWJeUgGke87ZH8Kft2fSKuWZfLn0kRMG+fbscDoJvVW3BXz/rm0nJc+1WvtV+mSDfTXPU6XIcFRshLyucj7OgDdcS280e/CfWk/cXL90yNRqGqnTdhEkr2gWrFW2QLL1cynek5XNN0O83Hk8bdbSkIk76lDQ4tIiidbUunimKDaGKRLCT6Wq6/j8jCbwP7Fi5+H2ropdnRvj6MDp+LxV5+IjxK3dNfGfXER1jTHtODHvvJ91Lozh0VvuhVqbdzrqgGqzVjd3c/I2cix2tMAjXVjb3yt8I0YIbbr/o27Y393N9bvu6O25TTgBXEWkDBOTEpiZUM43toAQQQApZlxa19pgTwBpffWzs0ca4xdbdvSswUmznUyPWrlPdl/Jnpae2Nr71YIDdqJRxoBECPs49LqWHTc5/Obn51z/DHVgmq2AYy6w7EEiAbwdNa2sXHqprijlXHFQJskPmqoHmCC1X62BgKC9MoxfyKQTxIb6gEPae2qp61ODLHPEqBeCFS6NFnIbMMG9ipy/lLwT+XiiuRuV9Mbn5tujEP95+M+CA3u6sLF9PypOPVcf/Qcx+LFva/t7owXdnSlQa0rbiOW7UQwQZ6NDYLiDLikd1hgZN3FQq4JzLVF/tmHY7i7zQKg3OzXMrfjgmcC1vGjpY3YHsCPijDBkmyl2RuWapM+J8WWz2MMbQQgqfxZLlnHTW0b4sc//NHUp1UUSFw/h8VS6vqJ0eGYwlJZgRWOS5MLoC6k43Pj8aWjX8Y6qXsp6xoKnhbe9yJEKqNYulr2dMXEAAQwxMK6V1VBpQyTdk0z7dLVnPZcmq1VQ7DkJVmukOvHbtoWWH5U3rTVXa/YegtcvgXUAKbFwRmX5IJU03ySheKwSwZzpouji1o+4afL3pa/8joIPKYAJBPUKZFHsCCiy2Vh1HKRCQNW0Pq7r8xE8gl3zxeF8TyX1ZqgJLa7ll6y5tiOC+1ZZLEancmsCJfmrMYSzSMuJZJAuBmm9y5NLtXjCCYKhi7C/pOpyaBlhZ0ioIVLUsqsDcREqYlUa3sNyXKmscG9flZYMBbDtmvAtamhqiEt8FplBGb+yyxpC42hpWmSRd/7M3ezzK1F4UGN68KVqxVQoWqhPXSD1H0pL1t+p1pgXZHUGGdxEQoz2b406X6yEBhZ1ipi7JZL5iHwEzxYNjclHWdsLOeStdz9b/WY5UzUxrjaKfDLwlXgs26CabRRqFn6+vBsY2wi8HsrQvk2xtUruIVWYPlK8YBlbXVpeQDZWEB0cxwujqS2WvXySzP4jjmSzVsUh351LPkO2Pf+y8dLuQVpuYLn9yXFQj4YmSM3tPfBQPdwPLD3vhSv9n/8yb+NlyE32IfbVAXhLYO4PGmZvGPDrTHVMBUHzxyOcyNo6Vu744Ht9xFT1BKH+4/CjoeFgH2DKtDyHxs4yZwLi922e3mXZiBkmCTW57U0Fs9eIF4NAbh9U3vMNmjhq4pzPOMgFM0TWBQ3wRLX3qpVczru33kPsS1dyb1wcGwItr2jKT5H0LSxeUNiRkuuWQrdjnXmvL1t22N/+45kfbUdbCstSTlQyj8LknQX21+5I47jwqfuY1MDFpxmrA9QgMroZuxOEZDeTvxNA8xyF+eGYNW8kOK3JmF2E7G6X5vEPb5EY1iCGnAh1o6rG6ltPYFlTxe/evPgHXPfqHRxUrZYQPpUqxNKo0PsiXQMeu/3DJ6Me/5wKLoKzH9O0aTNZwux51B/fPr9O3BrhhmwRTIH8mSOOAVQ1U1SC5fxeOA05i4ULMQJOS9UYlwcZ304k+Ihp6O93Zg0gBBlbMZtVXDVCNlBA2DXuhSK43G6cA5X2dFo4r3swvqT7wdHtyTrj2uszHQ9uGTaB9Z/uWS7S/5w8o1jcXF4MO647a6obtJBEeBW3431qyVGz74KSBpDscb6BGiuhFGVbkvzv21XBFDn5BLNANnNrRvi1a99I8a6iTvbipulG+Lqr01jtu/vTgq6oRfPxdz9HFtY/pYr3vqxm7gF1gHSTdy561W7thZYqgVPwkXaxG5BUFSoSDufuzrdJCkXlDKwNA1YYm2YVsAnVgkNvTVV+B1FW+c1LiZ+F1S4Vrs45nks1ySz7No+V1wQyOav4V4XZOS2JIQoHJQLbvPXldpaKCKYKPDjtQ3Q0mabMeZ9kbnnCUYadR1By+uiLThysR1lwU4bh5Yy1vJg0LrBxy70uYBvXVLfp+eusHqTh644ArDkniLwIXmf7lhusjo914ArDiQd5K/wYwtY/ikCkVM78nyT4y7R8HKfrnU+NrVnXq101ZX/EujqXpfKxlPz5AacYwCbSYR/BbAaWAiNIyGSIJU7v24asDaGIlimscyiuJCH7aj7VG6xUogUCFpiiR3yNszzulF/7TstbYPEyiTmSAdiWbsp2wzBrnUQa8LG6qm4BTemU+MjMVTZTSfZV9Zp+QZ2nxop4h0vb6UfblTd30q+9pfjtnzfpjwGaSULkmMlxQOWNxefBaeCZPcKcty3QAQgKD82cCJ+/a8+mUDzg7DZ7e3eEX/w/J/HK6cORSfMbyew3Lxv7wMhpfYfPPOnuMLtje+7+wNxkFigf/elx+Kn3/uP489f+nyKi3n09vfFJ5/+LVjGEOKb++LYxSOxtWdD/E8f/GcQMVTEv/niv0vvjEoQ6bp/6uGPYhXqik8/8QfxD7FmtcFc98kvfpry865Tjz8e/ov4iff/aBzYeidDgHZgGBi7NjI9TMxZJ0oD57usogIh22tKkgIvJCVwJMkN70wT77WbLPfWdePaB5ECgGgcOuzxcRQ0uLV5bZ17AvHTATgfmHADZCxJgPRe3EA7iXWSwv/188dxPRyPNhjoGgE6Z0bOxOAgMYjELtU1NSRCIJUWuhY7dJONh7/2o+UTbCnQTcLQ1vT4EUgbFsARhxNt+Lbzo3H/6bE4eA+MfJRhDICj9SS5XkJCcTr6o5vNdVUeCNykgRmH7U1vAcGQJA3Oow1sTDvFZDk5MRLNkKXQDFiVAJIyoXJvgXfnfOEiz8Ctb1yAPBNboIDXsq47pYoUN6k1PlPK9PQaWshVUkdnZ5w6ezIuDEJaQ5ts3rSZq4mlbQYkxd44d+R59lQqJNrvuTraiGflfZitU8QLEjN4V8+t8fDmB6L5rur4ysDXsc7RvuzzNI3beXIrBNg2ESf2zp07WTsW1vxVirZ+6iZtgXWAdJN27Hq1rncLlEsFTLwsSLL0ZMslz3Iy5hK/L77yepdjcX7586/3M/OFRUuHJAwK9Q1od7XIKGCk8zy8WBLm5xdUQcjiIs5/U3Zlqw5AF4fmL3JBRQNK3IEgyUVb8JA/P79ZQVjXKZN03j7P/PQr1zWsseRyl7e+oECff7XCWV6KbllC71j6lP3xvO46suppPUzCI3kn1yCeJd1zEkooQ9KeL7qbqqiJx+UkASWsLUmQJE//FhEsdAXU1cP9eSyXpAe68DQAnIqCDKwagiMeidAxHSO4+GSlzcCk9b2WpPhmKtnu0ifB7BjMeGqnfZ7t5TNl9Vva5raXFq1qNLONuArmbZtbn3TPzOtqTnZkBpIAT99GS5JCa9Ze1CirVCrO/C/Gyina+hga4t2ApF0MwBcRzrQONdEOiT58/uLsQxoD+bES6Mq/vt3+2q9Z+ywpeWouBUDHGX09qmUCFzsF3hVSyoeBkY8VVQNjuF29dvoNQEVNnBu+gIXojfgHu6DoRqlSj4X3h9/1A/GhO74rXjj2crx84lvxkff8nXj37gPx3NGX4lPE/7xv9zvirq23Q8N9KG1W+o2jL7NfUicApxuriO+cI5E60FfvZRPXH7zzbwGyDsZjT30yLkCt/bU3v55q+D9+8KdjF25+//YLn4zTbGjbQx51WH6MM2qubIhH9z8cOzZs5T2N+JXP/j+Jwvu23j1p/nHeMZ7tAmC7euRk7G7fieJloR1UqKS4H8qiBcm9mCqYdxT2WyCIubUtI4mhKRM4GhuXCAEQBDiqJ1anAbbOGkw5lcSttkAK0lqhexrkICgfpiFAmBvm/S8ezeZFylfLpt5106B5aVEBHi1slmuczjjvo++c/aCFyrHvPJUBpKzTdEPbchRQn+lqFvWkeyvd8uZAfPP2DQAUyAxg1vN97sPy1Y7L3Bx09ZkyJJuLbfnZRPmNFaZExFEHyYZkMKPMvQKmSdpA18IZylqkLpOAo4tjbEtAmzpOBFQXYRsUeNVhMdJ9+uz4WSxWkNDggrm/aw/tvZ2RtNzLmxXfera0tMU7DjwYz8E2NzzCZuUdnfH64ddjuDASu/ta4uDhs/HaiXPx7lu3xmwj/ZPXPBs+SUF1a+fueN/Gd0RxaCL2790Xrx89FScvnErX1qBMkzDE+XwfIPOezRm1eJ7N+t+11wLrAGnt9fl6ja9DCziZTxLv4N4SqM7IEbGblbfO3cfV6F2HZ5hFmtsRPH1eWhZZKPK8PeeTXeFzzaZfr3/SWkA8ELvbCyJKpWIxRQSnzmrdaIQEMoxfys5fWgpBQm0TsTRjWIDQSiZpllur8JmvYS8Pv08jBJVb8Kxt0jhC0Zoxb8lahyMMeRlHUMfiK2yaJRaqtcJ4GctC8DSCSfNcE0KwGyNmCzUnkiBRhyCnQCSbk+53AhDbT1KIZPkgC1tcSUrCjUSLS/2Ma1AYEFwIqMqTwpPaXdtCDaqgyt4RYLovViI5IFfBipYbiQV0ZWmokFIWjTPta6xLqr9CUUrk5VgqCUBX28cSNYwQf6MLnXEdAk/BWHl7lB5EyWy35ZMWIeuiL7/tMjVXxE1JULfQrvN3ko0WR9M4hAC6Gt7opECTBMQVqlBJ344ixH4LAbgPAegW3G9Ow0h3WjZFCif9cT3uQQlx54WlC+x766Lrkf34dk22jeDFd7U82ecK25NYOUzTE9nfuqYri0HyHvMeYePOr7/5IrE8p4jrqY2//cD3xzt23ROHzx/B+tgQXQjegvCXTr4SGyER2NqxkXE5DONbJhSfuHg6bsV69NVDzwCSXmdz1kNxz5Y7ErDwXauHWEN6+SosNRsBIpOVIzCtKaRDI835N6B13tWzg/gj9jpDIfFj7/z7bB0AKB46k4CE89G2zq3xGpu+/uevfRb34GIcHzwTuzdA8MB7muZR2qaWe3yvT7OhqhszS0OeC+0CJH/mwZFzHrE104CUKogqdIAVFE3hIqcixE2pbRtdw5oAR1Vs1g20wuugNna0bsvGK+1nnuNjbsiMtYn3iYxwEeO9Yc7gFuYT5ifY4PqaO2BarI8isZrJUi044hkCFC03PsufLEGwkE8hpSPlf6p45hxl5LVIsUzeZps08I9ZNeXpvEP2gDxmLMphO/tjY9XjouY9znm2n/FSqHuiknxH2FfI5ByTKsN74xyrYu3iyGB0Qdk+hLvqOO+U+htZRp858yJsiF3RWtOS7nWeS3mTnwDTH+t24sypOHH8aOzbd2vaw8qLe6GEd7osjAzHpu4mrG9bEnvetO5yrBGyKFbRr7248d3atTfu6t4ftWjp/uTJz8U+ANKtgLNzF8/FJH23tWMLhDOwHkI3fxv0GcsBzFTA9V9rpgXWAdKa6er1iq7WAk7AuQDqMqMguJpQNM2sPF7ojLnxXjR5uHHVTERV8/GYbsblAPYyc7jmRFm0NCjQKDwLCCpYjGdcpPBlmJEUgX/VCAy6Aii0D88U0rFrfuZlbrRtJhCuTT5b4DI9WQPQYWGs1kcety0EaQFKBpKWZEhzSG9bhxVKBr25ETWgiAwQM1Sj7TPXzDKR0Q9nz2ABRUtpvrIdZf2SaTZlZKrwh8W6HmCSpfI2l02QRY42HJvO4lLys2pI9eUXzMjCZrC2Wuq0kSyCg4u7C3oVx2YUxKhTsvxIc831kwSNjyH8K/SVJ4UF2ZwUtrmVfDLyCsHRQrKerNv+MlEoz1dXtsTI3EgMAvRybX9WXkEo15UuT/dcxS/jN2Qr1FKVBA9GtW17Ncny5HlYEIuyLDjKMyV72942HUObfCNTEhYR8lN8zCr18v0+XdEah6aG497aSaxIbHBJu4xw3P5uRZMv2UMi/mB8WMfU65xPbmjX2P6r1r2Upy063ydX1zWrZl9+UpDvmM+yX3hIeq8rBcAoInALM6WNYtOny/9SEeDGrd91+0Pxjj33Mk7Yf4d9sU6PnwMEjSaAzOtD4l3HkjrBOyt72RwHB4mV0W1LcNArkxnC81cOPYUb3Vjs6tuBu1YWA5cEf/OgvZR7sbHixTZCiel3pGytEgPsmeWmwm24uhVwAa4iTjS5XHKVffqnL38+/vLlL8TfPfADcfvmffGJP/v1BIDzGjLDprlAHzA3hs2E++yswro/Wo0ESHnK3mPeBQCEypWxscyiZHn90XLUDNh0n6WMoi6fp6gKN3uNjHjOZbqb+U65BcEslnLXngL1UVnUxyZQnQ24LTLP2QzOM55PoA3rjtGigojydGxLW+w+3E87LBz9zOEj5FMXt7yrKbpmBmOAPYVmmR9N54lBco4zHmx2BlBSwtKGHwqinessi27lbTL1cW0+h+k2l/oovTXmVpHo3gU/if6duqo8cjx43yBsewIw6d9pgjg+ehqGweNxW+fetCbk4MicyuvVhBWtlj4wD6/xmZ1Ykbo6u+LC0W/E0FAFpBN18eY5GOvYGLyhvQ4gGHGg9/a4q/fWEiELVOowKG7ftj22bAQQzXXF+Q39CQzfu+n26IZufejCm1E8f5CKL57fLc96WlstsPC2r616r9d2vQUWtUDZOpJcAgyM1yc9re2Lrix98cQUC8xEX1S3HoRZ6SQ+5rO4ehHguvJdy+U0f0yBLGn7k6aRxZjFy0VgPj8EaS0QUq+6skh1LUMZ0IXA5hVLOp//9f3AAo/lbOTC7qjpQAiuQQvHwg5jNxS6maBpm2alQoPNYtiAX7+LqhsP1rZi0UDaqarN6ygYUkuZWSXU5LoRpZuULnLjKlVC0OhmkxmlukKQgGdxDX2+JAUVCMbjuK25J0m6hF8KjAZY+93rBEvup6OlRU2ptMhLrR8JGnCDoErGPctW5NpcUPDpCTRRr3rq2iJ1LU9QC53BCq/I0tLv9rMU3QLN8uS9ChdLry+/5nKfHT+2ocnSZMlaX11KLHylW+bH5ApZeN6g7EmErUybvMKF13g4ac8ZS0nQpOMvWx6unSJW7U2E520IuTt5V0+MQfs92wCIQ4OPMKogLbBzs9gm+s82S3sqce91T2Rp2ZMFw/wZVwqouvgI9q5nSu8cef7/7L0HYJ1ndf9/pCvdpT0tW952HMdJHDubLLLIIhDKSlkNlNF/Cz9+LaWDlv67S2lLB6WUQilQyoawyg4JSZzhONN2bMd729pbuvdq/b6f895XvpIlWbblkER6pLve99nP8z7POc8553uQlELI584lTvdLCor8AKK3W3ZvCoUiMk8qaN4CHLC1daftaNvr4B+Ly+rdiJ75268y2wWesVwSm4e3b7DH9j5tF+WvtfU7n9B6V2AVpZVihvJtzcKV9qmff84uXnahpE6BjYyvfzndT8/4HJbRPTMaAnrV/LPtp1t+YY/vf9pW1Z1lX37kbltRt9zWSgoVzoyWrlYdXMiOJ1kiG6UWa+hosEWyiUEKTUCLMl/zCIZrmdDuamRLRN39nsYHxiiXWOc6DAqEOoElmZXE68taIuaopFi2keIeWNF4/NTVLNsjgWc9JUABl8JIYhRKpZl3rXLSi11dUVyAAuUAHHDIgmRIGeiFeh0MLQxVBK2FMWHdFYts0YF2FiQ/6OH2h598Sr5RU3b36+bbHXKI+pRsg3ZYhfXkyxWBOKHGviaXtlRhE5RtO+lQFeSAhee4SG2ql20XiHocNPXoekwHX9h2hbXQ8ZKcvwohTtcKJb0Bzt1t15Rta6pVEOpSlxMsOgw79kdlPG9Ip30M5ChWdXRgHTosJ5QqzRI5JGYc6Hv6OgwFcvwLA8thUokAJLpSBba6eKEdenavmOaoJedwOBDEx4/V0sVL5NRXci+573jNypsd8p+8eFZwyM2RAd9nw8zugVkGaWaP/2zrwx7IWQxZGDEuPbb8hpFyPiV/LyzfarGy7drc5VtBSD74VSHNKS2rSuhORWXrES7k4ZYTfgalQzAHNaOcfo7I2NhFAIVEcE4tz9hXapAflYRESHLdhy+y+Lx1kiTJGaIYC1ENkhQJ8jZbLwh8mAonHpSOrkbdzg9js51F3dPyP8LJqPvy0alyr1DoAgInaC8nleizcxIdF8FAf9PhnCBD0OZumGHDyT4qZjeik1Hrlx8bMUlIqsKQLd5/0s/kQb4AKkAQsAeP7n/91jUAEIrVxki/HCCKSAiJGzKCyRsc6tF4wHCJsPGNPhzVYH6MzRNCC5Qo8gnbQYqxRFlY71P5hAlEAgbjd8wG6VRymkIa+kjjRPtHOVedQtITRaHvwj9RsereYP7z3PI3UYBNbc4vs52ZZrsslpHz2DxrEiHXK2egjAp9gnSDk27qzVxDqngmAvV04jo7FZ2AlBDg2Cw5yVJptvp8vEBZ+IxiXvEshPH8t+Y6xvjtkrL2ZRmkiUAaxubNc5yUBLemTLYlkgzzbIEOybNM3qjbAZQA47lbfmlqhHZ3zfnX2EPbHrF1zz3G0Nlta2+02jL5qxI62op5y9wW6VIhz6WkxtkmCVOpIKhLBVrA81hbVuPgADx/HGRUllVLQhGxy5ZdZnsFCPH1Df+rMUxLnW6eXbTwfNntlFqd0hQq7ivOudp2Nu6yf/7Zp6w8gW2JILNFmIOehq1TmYAlsGuEYF9cXD+iJkqbw2eQ8WKOkZb2+XzTb75DsPObIUCtDuYoXwvWkPLsEwodecTxBZQNpOmX9AeUO9KBxoiyH+tfW6ZdKJadWiMjVi+47iJU2nQ9X0Av5ZJ0DoohauxttG6p0BLGG/YuIdR96c4L7Ir1+23BAcHva739wK/dbn/wmW/Zr37ga/b9L7zLblpVZ+eIcVwv5nVX3hxJ9SIuiaOuHO4gsRoUI4baL/ZGQ2pPhcAuElq4uRcvxLYSDQcd3GmtJHCI0iQmqEPMnfcV81LaFvQPTEdEB0sLyuZIrbVUc1FjoEOpZSWLBLxRr/kgkBzZQCFVI34iIaU/vQjeR7KXQrJfIBU5xgDHtHExP+nOw5bpbbOo/BYliwSxvmKhXZSs0z3ZbM1bo2dY2g1KKydaVlpSKvulTtuydYtdfdU1Giee/SD/wGGuHNhqL23R/l6hMmbDzO4BMfl6OmfDbA+8iHqADfgjG/79DNY4IFMmI7YonBPfpE6bOHV20ABtcKcWUJfTpiTDUKRCx3Lh23jbX24p1HLQkbwCY+bce9PzfaJawMi0Hl1uXUdXWWHpHqkY7tKGqfqA+KeNrkAbagRkIBnGx0SMYuif1Iboqm+j2iXiFMJUUh7Ot1HLALI57AgpfPgJblJMUJHQkwq1gTlogiJw4hv0/4n6iVNeMWE66QainFPbEwVyPDYWE8RWhLRU6ZAmsXmH8cM+cyevIiIwWM+VDOB4tEgn92GgXoe7j6rtInpUMOlhaDhlxanldASIymLp+TNfQGaDIZhCC0+9aDUCpL6udMD4nXpGx1IiOYK49KAPvnKw4IyYCHSX/OUwwMdSBt+A/a7ItNg1sT6r1Fx9IBWzXfk16uvRMf3ZV/1Hyhp9+/R/KW+ISdpDcBVBHX+fNIOk5NTV84FZ1LMxXqCUiNpeJPXf0JE1fZbU2oXqVKsI8r9/25/LIedu+4uHP+6+ksbLJ7xGPetL5tiS0gXyBVQo5qjfdncdsANdR5yYrROy2Mqy5U5Io6a1sWGbGJWInVtzttvW9PSlrbRIDIqu7RZENvPxrIpF6hQ90eqH7a17rEJ2I0WCx8cxNP562mXoD5He2d+tAyn57dEzHBU4S6q3QqpsUu1Lt+gZTAtsQM5ENbY4ih0UamZ1UqAISt8pRqBVSHsl8RK3L8FPUkprFU5EUd063NugQ5EBu7LuEpUtGGs6LTsv/ACjt88lLEiHIJtCQp7vfbK9AbEO5qi4WKiVIq6H9dxnJOXp7pZLAjmCDYn9sA+53it1QlQBt7bvssM9jdYi27jGnmZdG7a5sq9ZUjXHD4OQbeEqoEcofs0dbVKJa7cmISxyiBOV36qopH4jU1j1dgmLJrX/5Uzup374pH3rz//LSivL7T8/+W67fpWAGQbb7BcdA7ajYL5lJFmH+SnROgtSnbrHWjtbxLB1+5w4Z/5imys1NFTkDgmIAfU+LSfufJYKwNSirsecHJA92KBsIOnGfCH+UcdFFXOsXvZGPLeFOqxZLinPPM0hzU7vU/qws1Ood9m+LC/XWBJZoaWlxW3M6H+kRb09Yuo7Dktd+6DuCqhHjFe5fG9FNf46nvH8wrS7dj1nz27batdcdZ2Vl5VZk/xFlYj5jikvAmNJmbR9S9du23DocbtAEudLznuNmLFjjK1Hnn2bMT0wO/IzZqhnGzr1HnDyaNLobDxF2gxdbcy3A7aBY8F/+dmDYo7sXMfu537DTiapDR+VOk4QHX5Zp5XoaHOKPda4OjetdgExFiJAReRQp+kOtCM4RUdlKteWRluQ6lZb22iVxbLz6SqxVPfFUqeQhELe1GF0hqJdlp/cb5Hy7YK17faTeZxEcoJbLgQnIHmDfgqMhJFssLEDCgDRIbbIirVJY9OVFDOByhZ96d2qejFKtPnEoxX0CsSjO4Ac0qmjTkTTMkwO+i231+jDYCyD99x743xXdPc1pLaAWBc6KQ2YVYAfYMSQSknVReWTp9c5h4inPZy8479HN7MhaBsM1sm0MUw99jNAGYxn66C566h0fSoTNdKgUPox6NsptXxsEcf/VrY6X3YGplcSgVzJ3fGRT3zFJS6K5vVV3swFmKOkmEiklNFhwZXrdDulcYBgx1B+7NwQfS3Ho0XWKMlRrewwivMqRXoyRmyFx9odlnHiWp1iDNXd0cL0iY1TOAa0cf3X7rcDG3bbxoeesqWrlp9iAeMng2D0P5UbBL4w7iLyW3qsWs5YP/+uj4c3J/08lldWmpLNJ0zkTJ/KI2/WNcp1H2ua04yiS5og4sUQrbhsld38zjusUFIWnqF2GfIfFMx1UkwBljeoxsEcAfwBrHtCzH59SZ0OTtqto1Mw1a3ylVPULEq8z3b1HHAggKQkvAAtLB1cYEvzFmrNKbWFMTEBUvnKiDlqEUT1uiOP23AsT+tMkSC+u21lqVDtNB16BBft6rIwsGoDzFhGEp+SkmJvD+sUYwVRjcoWAcI9oVcBiJaS2AAYARNEXCQeucH7ROl9LDR3Ueh1tWKtfaydpSUlAqSQ/yateQQYwsiQ7HgkBUGbugDpDQ+AXq4KyIPLbwWf9fS5pD8qQP1HD+pPfb32tguts7HVfvbv37Hf+uA37c8+9j67bVmp3VzebVGh922LLLA6MSxI5eF8BrVuFco+bE6xpHdq2zxJBCujFWq3JCwVte4XqbdPADOqdUYw4a2SSLF/wfiGzJHbmQr5rkZgHZWSHNF2QGqQHNUk5uq32q9xDZ9vb4TeQkkdv0nDayToa1rzo6thuySBhVZWt8jKa5dIm0N2Rz5mQdwwzbJlZzu4BCqd3Nm7d5cYpUpbsnip5+tjpPUZ27n1R5+yRqHrtUd6ba3KDJQwR0qe/TKDemCWQZpBgz3b1OnrAd+btPFMFCCQORWFiYApgEBlswq2sNGpkBqBVIZRP5IEjJYhKJCOgBwGXPX4KQWrKikANjNsgNMZ2EQgaDmRRzqi3VWQtGIGdOIMY1OYF9Mmp5cO4PJLRZjUNevEUI47U0kxSnIYmhZDU3TE2myPmBCpN+gYmc2qT4RyRjYA2BdVx4HhFdCDTlBpOxsbkOKoRAChXpEQFG68NLDBUdpg4x/dSq6dXJA9gcakQAxCRP5/0pSHmqLygZCA0CbQpyeTN8RukYgWABqQzICQlxFhFIwK48u34BNGCd9MYWCsXU1P8XOHMSBAJ55jYfoTfTI3UFGCwQ3bRH2L1QeDUgMMAwRrSnMP5iLo1pPt2zCnY580GwYGaRiMb8AwHrt/Mt8g8Lxe+qBNPBsAK0BIeU11PYrPK/mbcWJTRDCMZ67tFP2LU02AN4Z55tDX4uIvK6ho2kKAQPzFv/3QDjy2y777ne/6NRiWl3Jg7Nrb2+1Df/Qh+8NXvNf++qf/Yh3Dsl/RfGFMgYdOyZ9QBaiJgsmG+XU7PVEuZdFSVwGbVxe1nUelxif7p/5Ig3pTjIH+Wbeae1ttV/t+qy7eKuevS8UgyTms4LNZi55t2Gl7Ww7K6WjUygUhzVzZmHrO0j398mlUrvKF0CYGKECvDJjuOqmiLYst0tohX0aSOvAiL5ijqGwaC8VQ5EmiBsJdBkfVSg+z4I5QcwaS9iFRov1tkmr1yhYJX2ysfQkdvM2R3VGxiH1mB8xRTOtts5D/8D1WoPmdL0kbDwPPF1OYvgpmUXY+6Qf+oXjeB4W2yk3Jhvzz5W+/0Toam+yxbz1kf/dXX7DMX77fXrvgsF1fPmCLYXVKFtiubQetW9IqmCRn3/XMzF0y31aVrrLt+3bYL35+r1117dW2aP5c649LrVKopH2SFjemWuR0VeXKDpOllO95sjlFTXC+mCuANPIkmamO14h5rbJNmzfbiuUr1HeBCjb9FQakRAT6Cgkd/exron4PSiUzL9Xg0qCi6gVWCiIi5dERerZheAj0fRgi6s+jzQ3GGHZLSrVk0XK/RZmouHZLxfnBw4+7BAwgCBwNBz0b5jD7OdN6YJZBmmkjPsPbCzESEolnqitYo4e1obhzPWlepyWij4lwRtc/YJRCkiioAURjV6bLNy+IVAIxIJz91B0dFY6+xwQ2DNCPwtPZMbdP+SclQawB5ewqX/o9LCYCEIWaeJXUAWH4gg06iBsUxQZVVNxjxSU9utDqhEVvp1CD0mqNIrpaGwm073X0CcFKUpxyqbKQF3n3CiWvv39QhHtSRtpVUjlM+liFfRKUMk3vIhjw4o5NhvtXUr2wmeA0FhU8v3aSRSEJQO0SvXoYEvyGAAwBIAQn5zAoUZhKEfYwDGHAj1MKJjQnMP78BfZmdNqpB/oXSHHKzM2J3xGIuZwACh9MOtI17PBGJciJd1JfVQ7+kSBWsCsLVPumlgMEEafNMJUwsn5yr0rRL0gUITBzQ/hsA0gQE/IXjC42RcwvdacHegGWiieNQ/ZhV23L7ZncHJ+/749980E79MRe2/7c9uev0BdASVVVVfb1r33drrr6Ktvw3w/Yzf/nDqnY9uggo0B2Nl3WKjWtDLDXAnLgOcLmrDRrM/Slh75hV519mZWX11ksBWS+bDgF4MAcGxKAAUwCUG7NYkLu72yy5GDUlggKGrnLc3JIiz0PtjCgLWYkCWqR2trBpoNarwPmhPUXdV7U4JDsVPSW222Ra60+VusSE7oP5qhABz0FguNG4i99Mh32BIwcUsyo0PhAfxsbOBCCwTrY3eBAIYNaP2hjRXGpVcVlA6Q5zxoguagUyAK3BNFEXAwPDmDl503rY0p2SLhbcM6AT4I+SMehk6/Tuj6odXVYbQ2Zjtt/905Jkjps24Mb7bP/8hkr/NAb7MayRlspII39kqxt3bTZfQ2tu+chW3LWYquZV2flUlUcWjxgjz8q+zExL0899pS9buHrxPR02Xe+8327+oar7XI5BG6R6l1kQHVX3/cLPOGQfB5VCGyCg6lmqXI2C6kzlie/TvnN9o//8nH78B98yJYtXZqVxgmgQcAOqCAXctik/iko1EEGTIzSwzz6dTkwL5SvqrjU5Epki5Yn5oxDxl4xagNSW0wmYT4D5og1BObzyOHD9vgzT9uN110n+6OXK78CtwNjr5OszJ5s3mS7Ow64KmHYhyOLRtCzs+8zrAdmGaQZNuAzvbkhAXX6/XD8hhfmyR0M09lQg41q0Pplh5ESoRzTxoJEySUVWriJS52Iy39urnxnU2DfG0u+kSb0yRPkEpZ++p+cwsEc4asizJtPZ1SyDByljK1T0BZdF9FJe/ATFUoMRpgj0bPBSSBMkRwGdjd5GbQHIrhctgL4pQHNj3hnMlAmBIT77cn2MYhNofQobPvJ1oFqBxIaPIsEZcCgJEXQUB7lhoE2Mo5IkEYNviLQH7yOxQ5Tndwn7eDUfUATiZNRn1DZLHLrwiXqRz2jUkOESewbkjNYERCnGzjlxpkkRvDMiZNhepGgViXK/YQfiQCSASS0oR3aeOPE/MNwHOKIMlGlDOeityX77J1uu6Yz/ZFn9tlnP/Of05nliyqvr37lq3bz7bfY+/74/S71S+tZTEelBlslw3/ZFyUleSjRXGBM8a8EJHW/1hiYpzL5GlpbD9DCHIG9SM2ufZ/bVfE8c2hBwGaya6jXnmre4sxTvhj2mBgOVPxgMHjWsLtxJ0Iqg2T5WrOzCmr+fPbp8GRzy3YrqohbkZ7uQql3wfjDHPlhhohuFkBnkFwaonylbueZ6Z26w+QjEeHVg3NaAQwgrRguELqb1r+qZFlgJ8Yc1zyWQwE9i0osCXW+8k4JTAMUzznJGmu3bkeM43lCCkL+LBisKwNKlCd9Qb7rtqN+hmtMvup051/9un32vR+3Z+9bb1+qK7HB37zWrj68xc5ZVGfvv+ta64jU2r5d++3m195qa664ULZcFdYlu5/imnLr2HvAaqtqVEa/3X/fA/a9b3xXqospu+sdd1mZtAfu+cV9YrC6bfWaVXbFKqn1ye7vQG+T1nxAKWTzo1ZhE5ZWH+hhdgnaAw+ts+e2b7ey6nK76YbrrUMok5s2brRrrrzabbsefPRhu3D1BXZ43y47sP+gNR6VzZgY4VtuuVWSrHprb+2we+671w4eOWJXXHKprVmz1plXCuyV/di8ufPstpo5zqx2d6eEOos/PIHG4+hYICJPNm31dckBU9SNp73wKovZ8OLugVkG6cU9frO1f957AMSswHg+qo1xLIEZVicQ8EPastLyro1Rp5A98jSOYTDSBNTLOFULmKOADMaHUJAiXJ+5G+iqBzH07tkGBCAbI8Qim7uXEuyPI3l44SfxRtacPAKaMJbw5FR2l07YaouqZcQr9B+vR9A26oAqiqujKH2/mJ+0TvVQGSEfNmSCb+D+LUjHV/oQGHCMsitkn4Q6yplmjoIqcDIMoQ0REdg/cVJLG8a2PVvl8T98wIJRgwHh3De/j7khNUnBSRdKfQTijraPnS+cXHZrg85FwaMQys9z6Ug4G8YveipXnQgY6LJC2YbBeCaAovf5Mn5q6gjyWFKSLuwIRMqdXH+Mn61fJe+xfTBJdCdYetQ/SKBKNeciRSIK0+2SuMnOYZI2kGdYDs8athQwVsBS4DhWnmPUyWLWUP3UuJx+L0/WiuBeSLweq9noNDhPrqysHH1xBv2i7fioKSkoliPXQ4IBf8rR0JbXLLWLl5wn5qHcHtr5mAAD5GhUr6vPulw8Q7DuVQqQ4bkjO5z5wM9Ra6xdBLhQK/H2qXUqBGUBWTES17Mp6RLfq0sqNK8krdFa3q350S4noRJQ6dmTjyIxXqwFuQHiOSOpTbwoIeeoSS/PGSTlxWGWh+x6EqaLcA/GRSEtJ7A9vT3WkwLxs1/AEE3WmG6TPy75sdMaCUpdKSqpxFU+KTGABXKUi7Q7LlvMvh4dtBkSeqmTJgV4ozhd3TrE0DqLJkGgbsrCjHqZHLSmA5S8AiG85QkogT+30dH9wnjU3vax/88+/a6P2aNfucfK68qt//VrLLPvB3Z+zUr5GLrIYkiR1YVN3c0uubv3R/fZhnWP2IUvu9R+8P3/tUG1Bx99UaHJFWhtQQr3+U9/Xo6/AatI2hf/44v2wT/+oEWqcbgcQLOzLnrQc0i/FMQKbN1DD9hPfvYzW33xBfbD7//IhO1jZ69caZ/93Ods2YrltnThEvvu3d+1uto5tm7dQ/bze++1V7zyFfbEU09ac3Ozvfc332uf+tS/q4wBm7dwvv3Lxz9uf/D7f2CrV692WzDsxADQ0H/wW5LsPqGmbu3Yac9KktgsySHB+0f1Yv9hzoRriN+cfZtxPTDLIM24IZ9t8Kn2AIs5TA2G4RCQk4WYNlxU63xjljoESj1BQBKTr5N5fEtIBYLdWIsxqhhs2KU6GQ03WrZUpCxSUnOjWSC0WbLZsVAR4dSRDZ1LqHC4ypEIPxgMEKuQF2T35WzZJ/5QVbJ2GwFTNjYFpYOyBNoS/eFqWioPRshVFbIMG+movxMG+kJtxgtcxyC4WvCsZVH0/oPNaby4030NpgQHqEhKvFw6UmGiuo4uH9Uv2RwAX86fmofUyBm7Xm2uqLTI+BhmKapdecR+JicT4nZp/DpkW5AbqAv9Foxh7p1T/04dYZSoFyFZgDPjSYK6AqfEAyIGp9Yfk+R1ire8X1U6tiEdUvvB/g2bo1jBHJ9rqJeipglhmB26cUsiH5gkJHWDoJwN91p5vlRGMQ53JotnM0u0jZvD6V9EMod9GgR2AEJyfHkQrtMhrTv92v5ycgjtTw63N9iX1n1LdkFSs40n7RsbvqvhHbIbVl5lP3jiZ1JJa7HLlpyvSuqh80dWwBa7n7B7Nt5v1517tUtUQMEMVV59HgnZILdvC0XQ1wjtrF5lcNDVnsbBrZgPzScOEIoxrpQkiufFpTOUpYC67FkVS/0gB9cFrvrFOqg8gsDzJTY8K3WFYeEwgrKRGHX1dtvhrgY71HPUoc07BgVkI+jrUqHclUqtjIMA1oxOqbniIPvsiuVCelvsEjPa2l4o30X9u+1Qf5MVJHSIIaYaddLuFvk8Yt2XOhqHUdR5UMxRf0p1EWgEa41L01RXQCpQY4vo5ZKkv/l1+/z7PmE//qdvWqIkaV1XLRNS3ma7+OxVLmnr6+6RNEiIdX15dt/3f2bLzlluNTXVNm/xfHv88afsN3/rPXbvz++xK15+pe3YvtM2b3zWXv2rr7bSigpb/+BjtvHpTTb/woXyGThkZUNSm0a1sCctd7+dlpYKXUNzo0ulLr/qZf4sl1WW2d5de21e/Ty3ZdrVuE8HHLJfVX+0d7Y7Y/myqy+3O974KzZ3wXx74Ef32o7dO+yRDY/b29/2dluwoN7Wr1tv23futJVisnrFkNL/MLK8UDOEUX2sbZNtaNw4MobZAfS+ApF0sjUljDv7+dLugcmpvJd222dbN9sDU+qBgMCSepw2LxgktsqAlJ44eQHqdPkJ6+qS3na6Wgu9jq7kvyEvIoJTp5sFAjAY1qnhgHxEkD+hXyeKfdrcioSypVXar0Esu7qbNm6+jwR9xWs9CznE9ICMYkOpT0Bca/MT84UtTMLrHDJoIzkc94XcB116NLkEhXhuyB/mwAU1IWwHTNNUA2lKMLSHiNCm7gzVVBOfRjwYV5gjVNvC2ob1P1G2yIhiEDMipI5JMSRBEzE1KAPvwXRA/Ho3iCAeL4Tj2ippSC7hRlzqQR+6p3n9pnunK1AuNkZAM2NLNlFgLFAnwsnn+C2YKOXE18kHQs2ZyImjeYOZB0CcBw6bJY0cygjGudttUFBPBSgkL082J3rOQM1y1DpnlLyUUbnTf9gjFOkQYZ58IF0kiO9anVpv7hE8vk7nc9uXncqj0p/uD9oCcwQcPeqbFEgfTHW+nW75L6b0jHe10M5ec8ltkphgU5Rvu5v22uGWIxrnfjHIMbtjzQ1265rr9fxJDVeNe2L/RjvQfMhuueAGu2DxKtkW7RYEtqCmZdNDH6PSBqIcUiOMISMikBPRuM0RgwRz0dLXI8ao3xKaC6wHgOSwzuMzLJ3HwQ9PDepuQ7akbL6gzedrbQ9AViC2j81nDSyMkcY2lRnSeh6sA6i3drT3uaR4X89h296y2w7LKavJJqi6tFw+gCSRV7vaerokWdKaLuatXdKvuclaO1vAEoBREGCwIspybpnsnyQpQV3w8W8/avd89Ye29clnPc6ylcv9c7K3YGsJDmHCeHMkmUkLKv2x/7rXNn79Yfuy+i0auVcSq5Q9/uQzzkgxcXt7+uzpDU/Yt7/4De/7AjFZD/z8PutV3Z567Alfy6jn9q3b9HwGuW9/Vt/ZfrgQFK6vgZYAErHfeOd7fB/DJxT5ASoBw/mtb37Tncb+3q//X6XXoaLU5O790U+cwbnwikvs9e+8Uwc40nSQ6mFba7ulBSrx6KOP2qZNRTa3bp7hDJa+B32QcXLpmsoXm2SH+xvtua49fnAFUwmoBIFxHlGxo8p+dfZtpvbALIM0U0d+tt1T6gGWTeyGAAwI7UeCpfQEyZEM9c631JELtepKdzzRJLWDA/IVdECqDpL6aONFCgTxNLLBKgk62rF8LeiSJoXlhIRU+OklKy7OUtMREeTYWuQs5eSHtICTOggymfOKSULlK8xxgrrrNlItVM5y8xsv9qj7p7iLOLy5CAN1rAhcESJsXuGuOl6h03SNvumTjRXe4U+l6kBJ48+JPoCRYHMd0EntUEpSIw6QczOFXoIwE5JTbkAFsaVPtgci3ML4Pr+UH4QEzDgSwROMWG6WU/6OxCWjPhAJOGpOUO2wPOK4g1e/ktugKRdzShHpU6ShADNgi1YklSPsDEA9RB0RhVPO6qkncyUi6SNodqhCMYdQD2X+Mi7qSY9J7eMipOYNNto5CfnkEnG7vrvfNg3XWErqXBpFj8mzyD2YLyDXKdfVX/3uqb2RJ9IrpIu9Gc05t8HISmdPsVs/+clP2l133WVF8iNEgPj/yU9+Yrt377Zbb73VzjrrrJHKQqx+7Wtfs9JSQTnffPNIGiJs2bLF0xH/9ttvH0mDVOReqTBtFsIYac4999yRezt27LAf/ehHdumll9rll18+cn2yNGGksfUOr+d+wvwyzk/s2WR7GvdaUaLI9jbsk3NR4KBhdHU4IVWuox0NfkjRI1WpjTuetFohpM2vmCdAmF6p4HX4+PM8EVgHB0V8D+swKpoUyqEI6lLZGjHOLWK62/S6rGatLS1bIOnUEdvStNM65ZaAw48BqWam8wRRr3yKNScvqDrbKgUdHoaRtdsvMK5SSZVUp7cvQOXk2e6V1Khb9dzZuc/2dhy0lv522T5FBaddJXXlEp/raAfsa2mwYrW3wu2ZIrZcIATA8VMGTF5aMNqct/Tlp8RI5Nn6ux+wf/39v7eNstM5/3wkajMjMAdXrFhhK1atsDUXX6jxHbR5C+bZ3Pl1dtMtN9qa1Wts337Nmfq5OjgM7BCRHNGPrBkA0Gxs3SbbI6k1sobo2RwsYO0OmEak/RyCBSp2M6NPZ1s5fg+M3rXHjzN7dbYHZmwPsElyUhkyR1PpCC2zIpjjcmJXL+d1By2x4KeWqP+pFVY9bXnRNhHAMCCBqB8fPyG0NHnjb8O9lkMNnCBEtGGjkhGE46ktiE2yAYHpRIHSYBxA+/ITtBMlOM37oFGVqO2gFcEoBQwX77RjsraLzYP49RffiTtZ/NEVJR2IcQ6KMPrWlH+FRVJT4G0zHXI8K2nEccxRmOOY6jEe7dqcMdD25ioetkElgsLFgz1zIqHfx49omOHoT8+eyNrsRzIcHWXUL/oY5b+RoAbBYKQkWUqJcewVglivVJT6JbUJxmMk5ml9cQbdO290NlxnBpTFSuysyiV2ftUKO0+vRaX1TsTiYBTHlRjlo9YYjDepgj9y4zpgGyXYcIiALYuWWWlBiZVIGlupMlenD9pl0R4R2GYPaqyezKu1Pt3HKoxATkDKn1d5ll1ac4Gdq89SORQdTQB71Km/aThCmxBQ0gA9wacYzIQTX0gm9MpWYUr5/u3f/q29973vdQejYYLrr7/evv3tb7uE4RWveIVt2LDBb23bts2ZJQjon8m+45Zbbhnx2QOTw28clf7e7/2e/dEf/VGYnb3nPe+xj370o9ba2mrXXXedPfzww37vH//xH+3OO+90KcHf/M3f2B133HHCNGGE8eod3sv95Pm8b9vD9tzRXfbaS263993467Zm0Xk6MAoOeGAQmEKDOnRwyat+vOqSW235nCX2k4336l6eLalYKGmdnLlmO7ZA8NvYDMVLhKQmUIWoJNZI89rEtPRoXM4X03NO9TKBI1TYBdWr7PbF19sr5l1p19Zfbrcuvlq/b/Brty++zlaU1ulggfU0mDe5dec7GqwwRxDmQ7J/YpxbMp22uWOH7ZEj3baBDqGuFdvymnpJjiosIQhvpLntksx0yZ8Q6KehTztUufOz7hFggjVZdLiGq4Q+a2/rsK99/Mt2RIAEM4k5oo9h6Ds6Ouyjf/I31iW47orqCptTN8duu+N2u/vub9lH/+Hv7MsC/GiRVCmUzvMZqENG5Ouoyf03HVvbxOi1u1AAAEAASURBVDiJMUflsECHX74fa50Y0nM6G2Z2D8xKkGb2+M+2/gQ9gCQHNbVwsz1BdL+dB9yzpEBlc7dYJCZNaxHCGXZOqdgRWJijOsUsEXOA6g+IRN0iTDOcLusPVbmUVPEcXW2Cjdgz0j1Ud9iqMyJmh3QCBvE9snX7F1RMlK/UOSYLEII4Oh0cVB0l8cqTk7wTBdrBCRxkeZg79Z8KUem2XNRd5cIg4SU+on4DypkTQdS/gpxza4F6WEYw3PhVCq5z2pfIF+qaj1Fu3PG/Q4DBCAYZUPOTD+Th7YTJwNcIAogJs1LMQEDhBSEl69Ypd1tKNgO5Qe1hno0gbnkJuRFGf6dvYNqBjWdDB2uLOmCXgz3YZIG6035nNCUjgSlOSV0HlDfyDe4H83SyfE76nojXrCZLTlJOdfOtMl5u55Qtt4G2lO3bvteSCflKWbnCEqUJ90vSLwmQKqxKUUPqGEiISAtzxYhAWBKi6pMAFER2ffKVsiCzx5YILCMtaOHN6ZjtEaPFiTzzDRW9ABTEhJRXYZmGXtt2YL/VLZtr5YJbbpM04nQChBkSrZGQnQvM+xFJraZRKO0YiTfmC8Qd0hzS4TMmDFu3bjVgsj/72c/6paamJvvKV75il1xyiX3+85+3t7zlLc7scPNXfuVXPN5v/dZv2e/+7u96vCuvvNIZrsWLFzujdOjQIWem9u3b58wdJ/Uf+chHBOP8Hfu4DN9//OMfu13H+973Ptl6LLCdO3e6GhQM2Ng03//+950oHa/eYf3HfvrcYx2Q9O5Au+x0hHK56cA2u3TZWl8nUD0V2LdsWObKMbDmvoA2VtbKTueCV9in7/mcrX/uMbvpgmtdPfRgp1DO9KwzX1Cj0hTx79gX9Up6DJOFlHZuUW3AUPn8QmNAUODxBQ6aENbP1ynNQRgYYVzr8vEPPOtYph/VOqn06a9dkqkGgRs09bVax4B8GOX12RyNVV1xmcqVpFLzNCq1PvaGvAxrIE5mI3oW5fJAgAYcUmj2uMNX5itw4im1XwIQ2/T4Jrvooousrq4urOKM+kQi+r73v8+a21vsljtfaYfSDbbqmvPs7AtW2EDXkC1dsMiSghbv6urykQKkgcOKqLRBDvQddSkSHca4gsTnNlnq+5GgudIvjQDmzGyYuT0wyyDN3LGfbfkEPcDWx7oI8R/PnuSf1DqpyPmF/dq82VAl5ZEt0pDUIkJVOFT28GFB/izQICiV5BVJdUKn9/IoTuC0GR89bJiTlc3mX6QNP2ExnZZJ31qbPnZEEBJs2Hpzotvb4zkf/wZRktLG3tNdYYPtSy2/ZJ9UAQF/UPoJAuUm5HgP6RplAHhAPvzxnfrDSIwXaHc+kgBvWKCCRNxO+dOgj8gpKWNepEthYEwwsu8ZEOLbGIJzCM/1+ZIuiNil/IkDd8k9q+I0ccQT3gnLASJYzdE4jpNEN/w+6nXhfcWFCcRHSy6NBWNL27EbC6OOk6Nfou85IY8ViKnU94BJDeYSJ+wDgz3KY+JcmHM4bMxonhAAqaBXyJcQfvqPaXyjRmJPR+XItYQAI5aWLrCGbQfs7q98x8rKy7xPH7jvQXvPe99tK6sXO1MJ3DEdjRocDBMw34JLcbsM4aBYt5hDmL5iIQbKp6hMPPqsMq/TSorPEx8bl82G1Pbyq22N5tAh2YIMKG5dQsSxfFMNSqpbIt86W7dslg+YLRYrl2S2NJTOjqry1H+ocbnjQL8zLMwJGDgktbn3J8sYRutd73qXS3BKSkpGop5zzjnOvHDhwIED9oMf/MD+5E/+xO8jSYIZCgOqcjBUMFu7du2yl73sZX6rvLzcli1b5ip3Bw8etCuuuMKJSW7CQP3hH/6hG7ejwgeRSeAEv62tzdevZ599dtw0xJuo3twbL/AMrFmyWoxpl927+QErE3jL2fNW2JySOf58nz1nldUkJEFolx2QputZc863svg8OSFdZG+56vX2wHOPSMUtLaanRih2Xdalec4BEf2uf68/Drz7ZSfoKqxisFC3Ddbm4L6rY/EoMF4KtCEl2yANmQBXUK0N+sBv5rwxvqhRHulutMMCYWhJdziap2SG1iPnt3UV1VKpk983z1dqXZq07Trsae8SWIEOp4plc4XdVUZrAT6QeJYJ1AfmiM8BrdNpta+9s8PKysqDCDP0PSkV0+2tu6wmtdC62sQIab0tFwpqeWmJ5fcX2txIlUvKOTLkXkz7Vb8Whv2dhzSmwXo3oH5Py87Kne8C+c5irgAjXCg7xeySOEN7eLbZswzS7Bx48fYA+1d2EznVRoTJg60wIA6RGnHSDxETSI9OJXcI1iAdOvNIiTgZhIBLIjnSQhyWySeEMd7SsVFgs+aF+gdqaF4rj8+ifnyAyOI6EOFJJ7CDE+ZcQnciQgw6vTcVta6mekt3nqOT1k4533tMO8R4JQVlky+e0ZNSUwnbEPj6CNLAsAxogwGKObcOYc25JhmVfgapIdDTw+j5B5sW8XAay6k6qjDE4p5/qlPH5skpMY4AsS0YPwRpYNcYEydUx484tavZPHwvhVaCAcoCMwQZqG36z5edQEGxCHg5f/TK66YOx30uIPkK60G7ArhxwWvn9EuQ1/jvbOSFEFHZ2947KtOZB9mlnci+ipPpVFbSRH8yGmcyUD/GiVP7MHCNMS6W+ly++PH1D663c9acY29+11usSz5Nfvit/7UtTz9rMAFNrc22+KzFUiNLWcPhI+7TJJlI2BNPPmV7d++x+YL2XXvRWp0QR+3pp5+27VuetbnVJXb15VfK6D5qm3fukqF/g3ylbLT5i+rtvAtWSl0p33Zs2WlPb9nu8NqXXXGZ0MlKBR2t2SlGIOzbsL6n8+njo6bDHI2o1Po0mVrPIzV605veNGEVsDNCNQ71o1e+8pUeD4nRF77wBbdLwhbp7rvvdkYIRgomK2R2iFwhxLGjR4+6FAiJVBiA3m5sbPS5GsaHYUDN741vfKOXh3rfRGlOVO+wnPCTw5WDzR122zmvtVeuutMlRPnDAnHRaAz359stK98sdiNj2xpAcRu0Oy+/VUyFpLJCdVtRt8SW1i50hv9AzxG3VWIce8S0QBD7/GNtVWGMR0YSd6SnLT3t1peQXxytSqz5qFmFbaVe3d3dbudVVlYqAnp85ojnETW4g11HbHPrDuWb8rjE75Q6bbJYfpskFWUByihPQBaGtBgMyO1DJh3sC9VieHCs2iXUtbml1To4QFKFNgKSDc0TranAaHd0dis9jnBpycwNSNU6hQJ6qPMoJy/qbzHuYor3qUs22jarkJrt/ESd1RfW2LziOZYUQt+u9r12FMmiEtCv6V7ZdelBZy3m5Y6FNcQ4nS0UHPzUns6ZOwYv9ZZPRFG81Ns9274Xew8MScd8QBuI4Hrz9BqWvrezHFCgBFa9SVY3FHNkBh/EDRLIv4TU2gTJXKSTeRgZMpgki5y0J/4KKk+RGC8nlBR9POLLlYUgnFnsFQdVu3YZC0elG+1KVNrsXa3K7ypG8D+q8DB/LuZ+z40Ulj00UGCd7VXW1bxcNjR1It4yVlgtxKEIzvsmXhr8NE5tyQ1BnsE796OS5qSdFMiNFXxnI+oTfHREKjLEDRmF3N6m/3sHe3VqKrQ1J0ogLHXqnhN/JGcVy4Z3fKA+UtcR0RWq7bn8iLlxioE6MgYjhJI208G4pF6S3hUMosYDASWiRkyTM0e50iPd8fRiZMnjmCQsqE8IK3CiqjGu2AxxMop6WW6gXqjqDMI0Kk542k2a0TGnc3bn1iD4Tou8n/TpKom6kJLaFIx/bkCKgv1Qj06AW0UYv+yGq+QbptElTWedfbY1H2q2J4WatWf/XiuvrbAOSS0ef+RxWysnkA0NR+3pTRvd/uChe9dZf1fKikT433/vPWKgamzrs3vEUOVZ/aJF9r3v/lhMgey7Skpt3fZ1kjqUStLQZ7+49z6rmVtrzzy90Xo7uq1+3jyH25/o2cmt+8l+d8kR0oexA3GyGY0TH9sgGKI//uM/tte+9rX285//3N761rfak08+6UxRcXGx3XbbbU7s4w/GbVpy8skIbhm1JRgavoeB76TluSPAaL35zW/27zBfhBOl8UhTfZPEfdvOFbZvT6Wk50hrdPAjUJt4cbMM6Vt12NBpBXGpPSZBNiwQHHVCoAZFIna1pohg7nZkT/lx0zzjecL3DlWPq119Qpbj4IYQSu+Ym22S9KR1GBWTDRxSGl5hgBlE4sa1gFEJ74z+JN6wXgA4lInhb/HDMJgylac1oFzgC6jUIR3iGISTEoe7Ftz0kFTyqF+5VO/2th+21q42m180x0okKY3oGXbRlXaAjEAaQDoN1L7FxGfHZHRNgl8wDw888IBLBbEVmz9//ki09vZ2Q/2RefCqV73KEjpoCMNEIBwtLS32ve99z6Vpr3vd6wypY27AXg1G+Z3vfOfI5VOtw/333+/1htFfuHDhSH7jfWG1zZPeLszikEtkg1gDGvdDkhTvHdyv/TxpS8Q4rxpabs817nK7O9/dUY/WX1Q+ovLFFKOGh+NfEGiP9W0w78cre/baS78HmF+zYbYHpr0H0P396U9/etwrd2Nm43nkkUfsS1/6kiPxTLUSGOL2H73C+g7fZOmGa6y/8WU22LpausdLbKiv1oYzMq4WAzUZJYJK29nRpbY8ushWFC6xpQWL3GEg6GQECM1ji6RfOu23ExFdSJVwmOrMnUojPn3UK/WOLsG+dui0rFMOBvH83Qe08TgE50SVhGDlhaQCaPCe3kJrPHCetR+4TMzRXDW4X9Dj+y0i9TobOkYgjJdf0C/Ojo5320tiEx85KR8Ti3alRHhhdxUyR2Oi+E9sSgZkcxQyTnyCPDW2H4N2BfZbYT6o0YEMxeltl4ykO/u7Best9Tz12akH1AHl9DVapJPtoB6cR2eEcpWKi2CLiU3TCfBwRExZXEh5UvHCCWy/YIODdqqmzsDDplHrMKhl2oflxSS8cMJPmB+YsrBvwgRs50Alx0VcAhMO84EEE6S3sXHDNNP9CSGI/RwgCajPwSgBPuKqTuMVxpwUkTMsIicSlT2e5jkQ7Jzicw1pGwbUPu/0PRYrtFYRbLt27RHDU2xr1q6x8qpyOySD9Y62Vifoly2pt1e+6nq77OorxfDIpmTpInv1q19jb3jjG2yB/LegSrZt81afo+dfcK7V1skBrQzfW5pavdzxqnla1xh6/fE/nQG7H6CNCTAq7373u+3BBx9UXw86EfuZz3zG7YQgfKurq51ZmjNnjhOJOGUNA8b+ixcvtvr6ejf8D68fPnzYlixZ4j87ZRCPPRFSpW8KghkCmzBZGo9wEm95UoFKVO2w4WJJYSL7bLjoWSusfdQiVU9YJvmMtedtt0bZleHUNS3bnU49X0dScrQqKTTfAcOAEe/X2sGaCRCK2/roOeDTg8aCAxieSWwhG+SotXlQNoGS7uGLLjfQj8Rj7sEETRSIB+pjSaTYFpbO8/nPM90vtFKYH9SgM0rPYQ2AE+SH7Uu/XoTSZLH712MN0FNrC4vqHKwFtFMTs8W6xb43rPkPAmXUpUsT1cbsqquusv/8z/901UCAO/77v//bI6NaiUR2+/bt8mH0uC1dutSwWyNMBMKBOiWohc8884wjGF5zzTWeryfSGwzX61//evviF78YXvLPU6kDeQPogfrmjTfe6NLgUZnm/NCqYosHDttZ6X1WIfj+SKpTSKJabwV4AXiObrsGyJAkjLu6D9j/7rjXtgr8Y5C1xrUupd6utSRfmgdoIAwIXCMjdTsHTskpZ/brzO2B0avBzO2H2ZZPcw+wmIJ0xKacG9B7xycBi+qv/dqv+X0WaRZwTrMw/j1h0MaTF2+0aNEhUZVaCLVxhISHM0b5ENXB2XouGRrmC3HqRu3aENOxfoun2bxk86N6jaJbwwTP22e21moOISRugTiGqWGjRk2kH+QrLehEQwWwqBDHtUjDjm8tVzydiGmM8HG6OTigTbZlhaX18g24oNdipXusoPopEaOygZrU9ggCHNWDbCWV/3iB01YQ9rp1Sj9evbiWytpbFUtiFzBdo3PyesvuBEsTBjgw0NYYYYuSE6gLcXkF+QRgDt1iihjrsK59Ol0eK3HJyWbSrxAuAGIksG8RcUO/YjeEDx7UgpzgKZBUR3CxnE5zeg1sLCEtJ5VxXY9JsoPqW6uc7OYSW0FPignwL8ePoWcy6i1gpPMnsLmiLnGpccalmhT2K2qMMFX00fQH9bDqDlxuFFQuEW8Qo/R7ocqDQSoUEwlx2C2iVZdHBeoYSwhdTCe53e1ddtaKedYvYqVJkMsFeiYDezXlRtW9b/OcQOvs6JRaWLMNpJkbZmeftczWnH+2nFjG7aH1T1nrg0/YNde+3Cp12h0R4TssKQPObykf4hQfLAf27LOH73vEpVwXnL9a6nWFdrhRKjvTHMJxmOZs/dT7Na95jcEAoTb31a9+1VavXu0Sj4997GO2Z88e+8QnPuHrLeANX//61/0ea+2//du/2e///u878AISkiVLlqjvalx9DghwABo+9alPOdod9UbFD2CAf/qnfxrVDAhwVO7GSzMq4hR+5EkToH5esxiVdiEqam3Xbx42pAP5/SjmyuEn46f1cEBrP6rLST2TqypW6gnNFzpZkx3qbrCjAnfok/PXhGyGcETN/BzmTQGpEePP3EItmTx3CYJ7TlG11JyPHSTwrMD4MHZj1e5ymxLGYx2IyofRHKuxPbJzQTKViqSFhljshxa9OrAp0uEKaxCAOhmpi2KLmBADVSIbo149nyWxYquprrQFxfNd5U/yaVVcxz3Km0nerjyRfBbqwGCi8LBQB2F+OXgkrF271j74wQ/6fsuYY5cW2qnB9ALwAZLhRCAcMD7AwP/zP/+z58fc+cY3vmFve9vb7KmnntLBw6ud6cqVPJ5KHW666SY/uNi9e7eXw3z8nd/5Hbvvvvv899g3emC57IZeW1cmxjhtjQLEOCh1xSPSTGiWawspi9uQpHmaTE4iZGBGff3TXFLiQvU5PDMSvMG0+lnjgqYHh14FaFDMig/GdvmM+z3LIM24IX9+GsyGjVEwC/J4gUV37ty59h//8R9+m1NQFuk3vOENxgnnZAHytKDqmUmi+G7opPH4kaC0AiK2cFCn1Np8OvBNxOVfckCNDB8wcW3ecU79tZJH+uVZnZPMbAUhPMMA4cv1Yl0YyySxceMAMSUJBps30iPPYqDMBjqXqQskgSiUCl+lTmkrtvjvyZkjEeYiIEGBCpmEsB5jP6khABeoevVJ3WGiAJOECl2A2Dc6Fnm4bxvVu8CJm0CCJIv6URFpP9KqgAhFpU6+SCSByGWOSEC/ndoQi4BXW5JS5SGQL6fFfbKTov9HgqrFPRxUEsJx4hcSkV4ZjHcJQps2jyWYaRFSyxPVT1u45kbMicKxeVBmGLyHsgQhtYKBmJaQzdPVQclQ+TJfCwRVjHSNeRH0s/eE30d6hW0UsPSgLeb6fnI1KDGNCTm/rJdkZ8NDj9uSpUust7PHNkrt7bqrXi5CUsyMIJCxkWltESKYTpeXL15iCxfNt3mLl9orbr3DBjOCT44O2XPbd1mHYLzf9Pa77J4f3ysbo+1iuJZnx0J1EnGMNKuotNjq8uZZXqLAbrrjFn8uYOgP7toPBU2zTjgW09Kfp5kJTAzELwdPMDlIB0LC+Dd+4zdc3e7iiy92Qp/19bzzzvMSOaWH0EXCRLrPfe5zzgSgOvUP//AP7uOIdXj58uVOGCNt+OEPf+ivkFAmI9SuyGe8NKfSNJjpeXKQ2ikghbQJxQ30DQ+jnwxs2fryUlKVrLQ1NavchxHzcJnAGhpLW21P+z470NNgXQPdInfxexYcMjEhsfsZwomrkD1R+WSNOSBQhZ2yT1ldfY6rqFJkKD2COeI10fOGlJ9XGiAHEeN700dsZ9d+98dUJPXEpNbLAj2AxQLrSWQBQVABG1AdeC4rirB7i0mdrs/Kk6W2qGCuxaRq6Hawqi+KtK7eJ+laY3eLz18OxiYKgGxghxcGpIzhwQhSotzDmf3797saG3MAxiS0vRoLwvGrv/qrYXYO3MF8gEEiX9T1kDT+/d///UicU6nDY4895pKqMBPoB5juiQIszbb+qD0mn2ZV8qBbJb9SC7Q25guspU++pxozTXIIa9YgbZJDw2XWKoRWsdeys9UeK6bUGSAxqv1pDo4kgY2JxdY449duqFBjM8lB4UR1mr3+0uqBWQbppTWeL5jWwCCdLRuCicLLX/5y14kP72MkTEC0PpZBQgUAFKEwsAlJjyn8OeVPNjg24AIRazE/OdSpt04lu/K6tHDqpNDJoilndwYiihHQSXeZThGHBotE9Ol3nNNC1VeoXX3SkR67SVNnYJ27ZUGVyySB8IXEBDQ5iMKAbFWVtSEPoYLIRiHntdHqZ4RYtzegBifZEEhfJO/zgCZQh9HkyvhdQbyEpEOghQFhDtHpFchJTZzwD5J6bEDNblDETaEkItyH2IbIRhJGOgJ54EuE3wFTKG/0ku6E98fmebK/aS32Qk7yq19himDATqoMNY10/fSD6js2eD+Mcz2MR8+QCiIeKRbM1FRJeDZ/xuDUQwAsEIXJcWKNM3D9wbzzmR3DcPzCz1HlqfIJES+V8QprHGz2U3zyIC6qo93JlF15/ZX2va9+1z7xt/8mO5hA1eWd736npXr7bMOmx+1rX/yapAf5Vls7x+bVz7PSylL77nd/aB//6EekTpa0m2+40kplZ/Tgw+tlf7HeT9mvvOoKq6uvkwPRlBXKOSdG+CUytq+uqbYV55xl3/n29+yz//hpixXF7OqrrrSqymqrrKmUREt+zDTmL8SQqxpH/WCQPvCBD7jUIBfhDtsh1JwhdrEvyp13MFbPPfecq1chNcoNSPaRFlFOaGsCkxUS2blxw+/jpQnvhZ9j6x1ez/1kPhzubZG0U2uGGBcn5rOTH6uiMKA0AJO+qvzswF+WpKkwKYN6VeQXW+3ctXa2mOYHjmyw3Z0HHPkNpmpQ0oL+lNYOzQOeIZ7H8MBie/4eoSkuFMQ8PpT0dOnB4QXzMBGDRP2QnOBPCklEr9bcHe175IBYa5bmW1FcYDZuRyk/XXpukWLBoCNB4mAOoBF8n5F/dX6lVRSWWTwjVEXqKkYdxigva4fZLdhwfJWRJ5wVdZwohIwOgBx/9md/Zv/6r/86EjW8B7AHPrJChjq8TptyQTj27t07CoSDvTpkwC68UI7QFWCQxs6PML+p1oE9Hn9cSD2xPfqv//ovBwjB7i3XTmqkIRL/9BYvta2lF6j/22yoq9kWSHukWszSfKHEVsmmbL6WSWRCLb0d9pTGZutgpfb7Ype8+vqjPlbFHUgnX4eSqNq55B9JYsHx6/RI2bNfZkQPzDJIM2KYn/9GwiChow5ELA4LOdlEfQ59dQJqIAQMI1lsMfjlGhv32PChD33I9erD64sXL7Zr/vLV4c8TfkIYQJxhfFmoDccR4waPIbBl0PN+gQRIz4EB+X45sEqcTMRqFj0tPem0NlkZVkck/NfmOjawjGOPJBmYM0n4dkGVq1dEJvfYCHJDfqLB4vU/0QYrBkxM0vAkgAykgygtEvwsUpSTDWySJdqsuofx6cG+HoAtkCfSEDybYzNDXcYLbLqoRQUkC8wQIARFzpyEJ6GQ6RExTuThhI02xOkM5Em/p6TaAjQCfUtJY/t1sjJpR0ZjhHrPeAH1tNGjNCaWKuFw8Biki4nm1PtEATss+ghG2f1kTVD2ZPnQRsY9LkYXGPWATQtS5I5Z7veJ8oMgHEtEkT9qirva99vKqmX2tv/7Dms92mKdzW32pNTkOEG+7OrL7E3vfJNAHFp1yivpmRDBJI6y2mip/dpvvsNaDqUFA50v55vyNyYJZ/nit1pLc5clkgmrrq30Ppi7aJ7bhqV10HDJDZc7o1QYL7DXvuO11tbU4ZC+NbW1qvqwVS2bI1jmPtvRtXeipkz/dY3vM+uedKhuTs5PNvhzJhW78UJZWdl4l/3aWOYojIgadMgchddO9HkqaXLzZJ3mWTvY2eyXEcS6FEeqkW44H4pBs8/ChbXn2orypRIERWTLExw+kNDBD+Rr7InGZ21H016pdXbLjAfmSM+e5iA0cVR+kZiLA0KT6xf4QUSQzqhhonJHHbgXri8wLxysjQ3Ul/0LAh7mjLUNcJqkpET5knwVSCKRBLZbz2pK9SkvlBRJqKS0i7xB2CtNJi0pNcD6kjqrTFS79KKjH99bejIoU/XhO/GHUkO2vGyRACDa7BmVdaIA/DqqcajToQaXG9DcQIp4zz33OIJheG88EA728Vz1Ob7DcE8lnGwdYOauvfZaZ+ZhupmD4zJH2cLTYhgHtC6nxHAORirsiGDUm9U323QYNdxzyG2T6iMDtqKk3G5YUG0Xiol6or3Vtg5UCAAJcAqtu1HZfUmihH30kFTtOCcsYG6g1u6zYSotnY3zUuyBWQbppTiqv+Q2AdCAOgxO7DiJxFgTo15Opf7nf/7HjajDKqKigZoHG81f/uVfjoj4w/t8Xn755aM2a05/T4YERv2qSBIIiLFgwWMLJLDJnByh68nO8FueYJpLKg4L6niBdTQusar67b55A6vdLaPjsPa51aBtLOhdYkS0uzhhMeEWKie2kXhAhITMURh3vLzx2xTAbY93N7cWx38nX/q/VFIx7269wRrlhsk2IWL2y0h5QBsWzBSZAACRkNpEj5ybkhXqJu43ZNyeyS3p1L8jQQJ6PKwr/X0ygXShI9PcdFyH+KJpk+XppKO6n7gJSXLwYTRZfKSGSNnSqAGKQJssbm59xn5HoolqIQxc0PapzAHijO4fCM4eqXq2yGmmE545t4mNb5qNjVutXOhypcUlkhLV2lsueKvbkexo2ysD/C6LlGKWjQ+bJvnJ6XSVxbriuVZWM8cK0oes5+hTtsfKraviPIvXJqxXTM5zHXuc2I2pHW09nXLa2eZ9jdQVRrdIzDvwvzCuzzXsV1wRz2KyYCqxl8qVuoztm+n8Tf9c+qorhczXMJ3Zvqjy4lCtpKrUJSswOf640wIt9gCfaAL6eGAjAnzzqoqzgEa0zqEut2tF0gNDhapbi4AX9jTscekZUiWfj9k55/kqr4wkSQNijpDqYIkU1TqFXSHzk3ycidE9QELGTOeRfg3jhsxdRKKtmGDlyQ9wECQ+zNW4Drjyi6X1MBA8R8CO54swp+zyeJkkq1WuqioFVC8vJlsm2oORDHkjXQHBbm5xjZVZkdaAiVXsqNz69esd1RDJEahzueGv//qvfR8GLS4XJQ57JBgqoOI//elPB+Ur4VgQjhDQIzfP8b6fSh2wj+JF/yNJQn1voqAh9IMyADv6ZUM8JNU4iQetQJoOfXqeugoqrSlSadt1uPVkV4ut7Gy01TpEuHFBjV3sjFK7PTcsiZLAZKA/ME/0NQ7xJJnzmg0zugdmGaQZPfxnpvGodmDECdoRyEqEVatW2V133eXws8COhgGbI+BpQV768Ic/7CL2W26RTUBOwEFiboCY+ciGf8+9dMLvAXF3LBprnyTxWgN1XJRDrB2L8cv7FtGJV0n1AdllNFi6u1I2GEmpAHWJcJM/JRHGaamcTUTwYmtEWye6T6uQ2LitiNoNwR0RASC5jhOSSJ10VjnSeAhj1NpOd7fIJTTHjsVIYRN8CdHsCqTLH6aN67sODbVBZly9boKkp3zZe5Cj3pxNMiz7VDLNpx/V7xDm44WAbQwZ+HFiiEhCpa8p1SqbBgFF6PTZFdx87gajHVYVYjuteYLdE4zdZHNhnJJGX/JnhG4Icx99O/zlc4a46jOqRHtzA3XvFMpUvwgfNWVUCOuHVKyxp8WO9jTbvvZDVltcobhSgZVvE/JnrsIII4nDKBvQibRgfEvze6y9QZLQI73WJACS0jmP2Pw6GeIXVVlfdK4N6kRfZgruI6Ut1a40Ou1XDSjXQURUXvCLdlK5sA3Eeh6Cupb2nXfbxfb2t7/dbXpYO2dSQAJz08032cvecYOrODHfYFbDACPiqJhc0wsAhrZWMbvydROXKltMzAa+a2AkWC9qBLhwRf2Fciz9sMA+FM+T0dHBTMYOiUAZEaE+cHV78z4rj5TZBbJDKi7UoYAYFNS5mbvdsh3Exg7mGRCWMCA141mEoCcg9aksLrfSwRIbEMBEH8S72sZzmBqQM2sYG5XJAQZSdGyPSqUKBqiJ+0Lz50PXBQiDhCncnMifvTQmlbxEflKAEjX23NgHyWsQqLthFwYgx7XXXpu9Gnx8/vOfN1TrHnroId+fc29OBMLB/gzDBKOFmiT+tDjonCygcneydYAhuu666xxhD6kVYCDQBxMHaRfoWU6xZ6GyqD5F5uPSfq0PuihGVUHD1RWttfVD1fZcV5Ot6mqw8yQBu2F+lV3U02pPdrTbs/2l1i5360iUNDw+nnkj9m9kMhtmYg/MMkgzcdTPcJshhpEe5QaQ6lDn4PRpbECFgYURL/Ag1oxlkMbGP9nfIQEWpmMBzERSIrJkWK6/YMsM774wPoelXheRSl1ReYMWfhnva1PmIDMpVUEAAsZT1XJJhHYDZ5G0WeQGtnRHxVN6TtPZyINtPngnLnkCH35MPCdpjZxpBipwubk9v98h+AXAKiw7GLWw1lLdk7rKwBBOd6E5GNXpCRD3SKny1O+gG0JwHeulUyuD9EhjIvKVNFZNkvkZONo9cd4wBR2yrUDlCAILlSD/1G9UR2GbBmEcJAE5beZI1YFwR1XPGWh9HgvHeoR5kxIzlpZtGMPA3OLEHNQ+GHFGhjGk7sdSHcsp/EY/sHZAFoLWeEgnvkHQNW8bxupAhgeqejDvIDMOFvQJvSzfFtZebhdXz7HWfQ/b4lSTVSX7bL/yOJw4y3plzA+96UxWzqHI+IqNk9UyrO00fqo42rJ47TL7lQ+/xa66/mp7x1vfbmWlZSMHTNNY2gsqq507d7p9CzZUb/z/77Jzb73QGSRfs7OPNLYgvrZpbmBDlBL62xERuYcSR626uNSKE1orhWjXJzW6foEfFIiJQQWsulCS+LZS2ZwISVN5IZVCzdPBamTj4+uk+BrskfhLK+36hqf9ebp47mqhy0nqrcCzBvHdKgS5+IAYGl3nmSOEc9F/6A0UuwXxeXawX/UTmh7zk0MD0OqA/Hcn4W7rqbVVPnfml9bJBkkqkMqPuiHJwOF1oVQAkR7pzZ8dGAYYNp4PmLoypWHOjBcA0cBulz01DHEhtqE+9+d//ue2d4xNEWAL73//+ycE4YBJQdMD9XcYQiQ82KRNFk6lDiDZvuMd73DUvaRUD1HLR0V/okA/wIAGaKHBZPE+pM/1x9rjY60M8sWgsk90xubYw0M1tgVGabjRzpXq3fXzqm1td6NU79pta3+5dYhRGkyTnxIE2U5UhdnrL/EemGWQXuID/MtoHgvwn/7pn9pf/dVf2YIFC7wKMEYs2qEN0m//9m87Gk7uCREey6eq2zzVdrHRjiWeuSbPEtZS2Oan8Nz3DXmqmT6P8WCOcgMnkNhT4R0+N6BmBvPExg1hjIEvBCnEK4KQmO5FRaBD/If9kd1SjmWjDSWmfHp04slGjEpbXKfv4/XhsURn/pu2KVcfHJCaTeB3lSvB3oX069QDabMbYfYTxigutCm3t9KtzHDMiX9svMJ+O6XyVBTMDD5Qchkk+pYxi+aMy6T5Kx/SMMYwEULc8OhBPiIUIbQUJ2BGaN/phkAXX9l6D/mzQlt0NgsBAvMIYAUqaSPPka51a+6hGolhOrZTJxtoD3NwJGgsIGkxXs+56vObsRnKE4Hc227tLUPW0Je2eN+QjPWTdlahnpPMXtsrv0z5DuSh/lGmuXmMlPFL/gITcNGrXmYLzlti969/zDqfbLNYMj5BrWgBLZk4jIqhqMHY5bSca6Iy+ePf+zvndm7/Ey/87Wm0voTxqTfB8xlTHS9zkt4+uG2/LTh/sf3GZz+odi8OUjPXVB5rF4wL/8yHAaGNpYHGVtn58m1zZOCIzR+ukrqtDjOE9NnXKzUrIVzmy9YHn1t7OvZLrTKA1OdwohCHoOKSkVaRP21mTnnz9VumTtoVhu3ptm22oLzeigQRTfnETUhFGwkW0kumpddPDA15hQHmqKhIgAvyY1QktVTmKgxU2E/dUiMtk8pdLE/rtJig6kS51UkS5L7vlEkohYIZQhqWO0s5RCSEfUx/TBT+7u/+zniNF5DSTBS8Tya4CUQ8YB8wLjBJYwNOiHmF4VTrAN2AzTF9MZntUViOFiD/CngMYwlDWqy+j2utTel7Wr72kFqHYYRRiopRGq6xzR09do720tUCZ7mxPt8u7mkSo9RmW/plo2TJMNns5wztgVkGaYYO/Jls9uLFi40TK3xogLCE2sMnP/lJNwa94YYbvOgrr7zS0XNAwcHL949//GPDoPMv/uIvprVq4YYyXqZsMr5BjnfzJK+xTE+8ZZ1kZieIDoNEu9LSSWcjgQDFFxIqIFwXKC0UrH/39qtyEDF8998T5A/N4K0QBcAf+RZqY54szQRZTfvlflRUBoGhEAEiQmWyEGyZTvdMMCYBUwKxBFHg80DEGMwn/oMAI/A2a0Axui4oLLYuQWAAJkDcUw2i80QMCUBD7HkwEthV5TszFhiHhzWfWglj6zLCNCn52HtTy/H4WDBAqOoRqB39BWPk6kayheoXgwZzRBhbpvvvgmDRH0TiicbNMznB23i9L3mqFdWXWcPeDttz+IhVL5lnrQvX2LaevbZyYK8ARqTOJPuniJx40t/j5XGCYp/X27VL6ozXRIFnGWnwkFS4kCaPT9hm57j6HRWx4+JoMFn7ctXFmJMQ9CD9jTA9Yka4RuC6E/s8Mz5vC33uQpQyB2BcRoK+epnqbE8zcmP0F+bMeOsLaUZJSJQPax1zr7qs3BZW1Tqq5ta23bazab+V6K8sKtU2QBAyeVLL7LWtB3c4UR+RM1AcEBcLMIHyemSX18/hgvJ0BkyfzE2YKPIvkYQokCBT+aC+tIU5z9qakd0Skh6uhW2DaShKFMlRtJ4PuY44R+ARTbK3O9x91CVXKsiZKdSja4qrbU5ZhdVjP1cYgB3AaAESACMUSopye4p6wzC2SkV0uH9YqG09x49pboIz8H0ysI/pLC5Uy59SntoKCgTSUSrH72mppsMwoW6HijF9zfPhgXFkTuqPvtQxIkNi3fESW58/1zYfjtmqSINdUJtnNwhH6sKeRntGYA5SfAzSz77PyB6YZZBm5LCf+Ubj4A1mB/1lAip2OCzkBIoAqs6mTZvs7W9/u6uRsDGQJlctwCO+wN8gCYZRm9ILL/ARjiFZidlbcXJ4BgILPKATcRH0eI2HWAqZI4rLJTiIy3/utYmqNMimIjUT9hLIFnewqG1kKmknynO6rlMnfJngbDQp1a2YdPe9YccVQP+rvSJeIChoDKeLGgxvF4Qf7Yq5REEEn6KTgvwJISMZ/AreSYkBN87ZTyuoDgUas4KCfje4Jl9sD2LZ0+HTyjubOGjldOR0LA/vx2M/1a9AyAs5Sn+TBfoUpi0EQ6iQmtuATtV7lXY6A3YIhcWFtuTSFepRlar6DUqMltKhAYqZhfS7CoQhxs/YizlEJeGNyxYFdTEg/BmLcO6G7aIPcHibxI5Fc79PUouMDlNGjaMShcxBmI4HwfuPZSs8g1A8mABfA7IFAT2Nb5+EjOHp+0zWz1ru3Aufv5DRGikj5wuHAgUaD5cAqh2TBt2OidEpKxUUdlGxAFP67bB8YrVKqtGT6vOxTQppsTZZYfPFePBcNfW0SdIkibCkcKViXnAFgHSVg5+xTGOB+hWH1YiRQN3kEAomkNUhVKODQeOwD+aI/QpCnnuxqBBSJRHK5GXscHujA5GsqjrLrqu/3O7b/4gd7Drq/Tqo/QBp0QXVK2VDVOXX6CcCc5N+Dhkkv5h9owxU9LDR2916QEdEcdu0+Vm3JQr9CObGnynfkcSDPEi/ReU3Cj9THJZkeqWQrTmf1ngwb1Fx5PCLAwXU8Rz8IttJzijFWq2vpsgebl9tG3fl2+rkJlszN8+uFUY483M2zNwemGWQZu7Yn9GWr1y50r785S9bc3Ozi+THnj6hRgADhVod6Dn4PspduM5o5aY588FM1JoPCZpXm28s3ivfRS2WKAY6GEIwS1VMc5lkx4lnkV6E02ViILTw4YHaFnYsSI6iep1uvl65aXqjJ7Gv6R7q8RNgV9/SBhaSVpBxGW2aIFFBeKAO44AWilMkhgqmqKhAgBf6DjHnbVOmuSM0UXsBC6BfRC6dVms4oU7qJLpThCWjhud2CLGJyj2tws5g4lxieLxiIIyJE56w02tFIqrzimvl96gtmGsiOH2sxstgitcoA1QzwEWKClJifrNQ9CKQ0+rrtOZCRBKw/Py0M78OHpE74FMs54UQDYYmcBCaL7VPSUH0LIwdB34XCFiAQxN8CQ3peYYxwsYtInVdt4nJlfSM6Qsfr5xr/M6L6EL4kNER+sk8hknrF1IieY6tB3EgRh20Q3HHhnzVrySWEIMhVVE9CzxXI9Ks46N78oikNN1yAtrZLmfLSHF65cZAzzmqbzzNMN57OnttX/dhv4ZUp6yoRIwcTHLAHDmzkW0MTQqLEkutqwGz2TPQI0ezAsmp0Johdbghn6e5HSD+Uc8tfZCnTwe9ke5vr1S1ovKrtyBWJ0CWuJD2iu3ldZfafYPr7Uiq0dckyG1XOVV2uc88DFKgWhfWKOgxmDJgtVnPKG9BcZ0jWN7xmlfbJ3J8GwWxZ9b7hic22Pl3vUxgGALB0OEkgWdER4dCXY1bx0CX7M949sXtq+NhMrNDP7qjJIHKl51aovIZS0eX2IPNt9nG7UK9K3rMbl+u8ZrlkUb31wz6NcsgzaDB/mU0tbq6etJiQbzjNV3BN2rtMeHJ3HTlO1E+bGf58rqdLOG0slenimKQYt1CP0LcMHqzmyiPU70+ess+1VyCdF5TbcB+Qg0zoRPV44ie0yti2lJDWKDSMyjiLxFJaAPjpHxYRKN8P0l9xglCbYoJEcnE7Un3qT06SVYNaBN/ucTJiSoGkYgUCnMn0XynFcgLIjcuRMK+jE72YeLk4T0eEvanlfsLIzGqUQkxooVqU0hb0G66Lql2J0rmOLIXhGhHqkvtDwjAURKOk2gKzzow4dF01Mpj5X7q66ZpeUI6lASpSAqSsbyUhANiHkSInuz4n0RVzmxUiDwxfKhiIbmhHeMF1Ir6UYukwxWFuQ7DChHOBQh+JHvAVztzobEZFcb89HyUF3FHxkhpgZpHzZdrI8wNGYXpKVtjw4vxDwP5wBwhTUmJidNtryv1hIEJpSlh/PDTbfcUF4ZqSCppLp0S0xfRnCrQy5/uwkGpyUoqK+YIO0IHmAEkQcwchyUpSchJTx29Rtk+wrE2Koey4pN9Z9oeOLjB4bnXVp4riRKqecFMph38ufRChPWAbN+ob1zphDFqJfmC4JZfI8qGuakvnmMX155n9x5+1Dr6O30sjvVE2LLgMxif0ddy9zGqWiFI8Hb5SVp5/ip3xA5YwuOPPz460Qz4dd3111lPXtpqltZp1MTeaj4MacxZe8LVPam9IaU4gNF5Pzp/lJ2PikVgzgVzU6ngsZI7LFnXZN2tl9ujXW+2WyWZmiWSvatm5Nvs2M/IYX/pNpoFj//nM0QK0lY+d3tQJDoc2kx9038+K3GaZbFJFIsQgHyE8Hieu/Cka08vw1xggIv6GyhQY4EUoMmw+enTPeDPIS5TOoEu1KaXS7BNpXCIuogIugGpE01EmE4lH+JQNpKOjHTmIbR6xcDlxYJrz/vknWqlpxjPEezEHCXEZI83h/ya3rDxkAciG4zKCfCwbJlEaPe4HUtwEjzF4jwa4+Hofn3d1t1V7MxwZXlGUoOYnEfK7khMcyHPpf7zJQnUAEAxnUwRL4y4qnJacz6XaB5bMSf41FYkSEg5YF54RhwCWZ+6oHFRRvp3pkZd4UG/OWHnHqfwYwNgKAmp7XFAgJTZnydJsFBVo/8px30XKV6u9NCZGC+DNyX290C6i74b+SAVBtDA687YTBJgYmAkCuMw34L971kuCWGlfN9I1TjZbNGETOvFK4F6yBC7yhUMpcqgLqizIk2DwfT2Eol/1gf9pSWtQSWxXw5kNxzd6O06r3yF1kaBjcBgqs6sM1393XI02m0Heo9YSbzYVpYtsxKBA2CnVSB0upDZob/qktW6l7T2dKdKoDhdHCdwnTusD6j+EmAYw/FG/Q7VycpCuX4Qc3r/g/fb297yNrv22msdYY7DSGwGQybWJVwam9zyRlQyKYMCeC7CcvntVyeqX/DoZFN67OAxOhafb2F5uSMZxvBr2TEO7+epzi6RpO4a1SAPz95rQ3lh3zy+YYPDgHf39dj/+eaHnSFi7gwI3RBwjkKtJdSAcU/oWU9IkieWWHNMjPyQStQ/hwNeSJZhYsxG7N0GtFdE2uRH7Rc2VFanbeVVym+WTA5GY+a9z478zBvz2RafgR4AlvvFHsJNItzMXujtCTbqwCCXuuZu3GHdYWwgjJyg00UI6YwkFqhghBt5GHeyT/LGB49A0KclcLKN1KhnqM+JmrROraMJ6dOzg79IA3XH1xPSOgi1MHibnDYZ3TaIbtREHaZXUrV8EabHUoWpp/ZJzjjE7e8OpEh5ee02UCCCV84jh0XsFoggjoiao0ziQthBiJ7MHJhaTc5cLCd8J3s4uac2MeeRoEREIEL4F0jK4c6WRUhCIIcE98hcUzry5uXEeZaADVtCfJeHa/4nlK/A5PQcBYcT3o9KD3PkRGc4xPqkHoH9h5iSLHMBYQ/R3y0/RiZVWdKT/0idND6ThZDhApHQBlZYMlZlRaWCvU80W39+t+oPo6X5p/ogKeqT6uWguA0QPnF2TZth6joF+BIwjpoTUklk9WCNQKrGs6nJ4vaYTxzdZDua9si+JelOjMsKS6y9t9MO9ByRXFJOuxWP9Ad7jtrqipU2XzDS9CEBJmlYNk34LasSYt1hwX639bW7P67ywjJnCsK4xGcu9gq2Gsl4VFLxwM6SO0FeMEhMXmyp6DgOI/77f75oT2zcYPeve0AMQqHtadtvRzub3Altney1klrncKSqbpaD5X7r6O2S3yj1hezHCodktzModD79dcvpNnVBFZH1EVaFRJmU3ByIscapbawkasViTF0lOCVJjUQzMCcpuUIoFjgGqoNDA0N2sE/AFHJRMa9sjrKAeR6WawKpuwnmHEad9NiKzU3WaA4INGOg2xJdm22uUAB3y8arKVNukTapUUq3rac06S4D0lKjc8Z8fqHdItjx+ecu8vrCSBb1S+MBJMMRRgaJv8ZU9yqGygSJIzAjHUSlpILbPqg6wLXqn75kPsG85qtv01p/UmK0htWuAVRy4/sU6VRXJCWdDS/6HphlkF70QzjbgNkemNk9MELojdMNqMZgSxVAvQaEWFobelQnjbnEyciOOU4eXKIMHDdOVtYESUUcikDURozEKyhH+Wlzjuk02O03/DugEy/uAIHXL0KkM9M5qiEQRAkBY0T1cqok+56PepT+Mvoj7UQB4todbKr3B5x4E5HoKqDY1PR7Hzq9ky8pQrRbBFClDaWTNpSQyqWIs8xwj07ku5R9vwgiSa4kKYVwBNgEB6Bd6Z7gVHmiCryQr2e7LSRonZkRY5CCKFbbmbH0OX3IOITSBZ/7EoggRXLmSMwBQ+AMyJj2MjYwQBC6vBjjjMpwIl1pYHgI2CohfaJcz19Fw2xAPONiANXStr4Od/ILa4pamw97tg3k4dIrqjxJ4DaHOSXVR21eaZfQ7Arko2hQeWuEVbdBPWcDeqUlOaKA0mSJmPbg+aKfsFfDrifsC+qANEnwC15fEO2GxWjB4HG9eaDNDqfkj07fw8DzWyr7prKiMhfCHO5pEChEq+CiV9q5BcutNFIiHiti/SnNbtlLJYdipulpR1obbXN8m8VrhHonxslhwWF8FGg787JTDEO7fC6VD5eJCdF1jR2AEOF6xXhwsMBhD/Y3569ebavPXS2brIx9f+fPbVfnAYsVx2xBxRwfz3bN717Z+qb7VBc9L3Mqa6w2Xm358h2mgdXYxMUYiGGFedHziPRlQBLdtPwm9WewX8uzstpSK68UM6WG9/ZIpbVbNjuS0CYEjNCnflu5YLEd2CW7LaHX5qltfWJAF5cvsWef3mKVQh3Mr43ak41b1eeaO8r7vNrlFm+K2GPr1tsb3vgW2932kF012GBFPxOgxZ52l/zmC6q/W9L+n736AmuvLbFhmJes8AdmifEoGhJYiPq2UP0DAimqdvSkS0+ZC/pDipSPLy0xUCkNAj4F9ShongzYgrK5tqRkgZjOqDVmmmxj4w7VT64TeBxcuuZDM/s2Q3tglkGaoQM/2+wz3wO+7+uNzTQIfAlIwZFL4a3ZzzPSA/Q96l55bIzZv1wp0sAwiEcirEVwcOIeEiHHVUb54DASAnKEsDou0vEXIOyLCov8xpDOnEdgZ3UFAqwkLlji7F8wM47P48V0ZUR9JafSOst3YiQmu7y4iDHayRgAET4e0ECYlHj0EXDI85N1It3ydbrcotPgAauW5IC+bZM9xt7Og9aZ7naisbRMFFSfmKKM7LwSsgORBVJhnlT+IP1EMOGHalFpvdWaiDb5zOkSkMp22+uEO2PPMzvybPqP7BWI+WMPcljFX+6nquQMkdrlB91UlZBtAPOKS25dI+IXQpuXz1+aI2mJMz4iNJ2ZUvtiIjSJAzPPtWwG2SzDcQv8CFGMz1l9oe9gthhXIrstiPLnuXLUOxH+CTFInXkwqkF8J/JF6GqQPK3fgGnLlua/x3lDUlEs4IUKSTMSQo9T0xzqGUAK7A2RFiAlgHFzQBbVjXpRR5cqSXqF5APJCET2sHwq5UtaIUGjQgDfrca7RElvXv+4QIVClTxI7aSkHcXyeRTV2oI6X0Lto8+eaNpoW9p3WGW81IqGk1YSEfy00AZ3tO119cg8SUy2N++2+dF5QtuTrV5CyHk5gfWlIlpm5QWlPk5I/iD2x65L9BHzHya/PyP1VDFBKUmhkRjqkfE0fWpQZjhtPVJH65P/KGzXqGflUIVVpst1eNAnBqRLTAXjr0FjsiBtlKQp1StbTuWFOmLFnDIrrZBdlcYPH08wn73DYic5aBLjmVH7kNht3rjZdu/Ybe/93fdafnG59XX22Rc++Tl7w9vutIsWrbWLqs/1tEMS+5QVl9j2rdtt05Mb7cY7brJ5tZdY3rd/ZHlbO330C9TvhJLutL367qdt0wfuskhcLh6kAqeBs2HZmTUIMRCJV4WYVGSA+LnqkQ+0qFQcJY92qG+Ah8o1FkgP+1TnDqlGMl+Y24BilIl5fvzeDdbV3mlX3HKVmLqU7WzZ44h3AeALs3w2zNQemGWQZurIz7b7jPYAew2bMZsmBAeBpZZTXD6xERi76RFnNkx/D0BkF+kVMiBsjhkR5wXDgubV+HTrxLZgQEbW2kQTgvod7xSdWnGdE3Fgq09ExIWt4NQcQgbGAeJCZ9uj0ob5hHUL070kPjXRISahvJAW4FAW9R3aCpHOZ9j+idqLT6oqEYzNWw67fch5l5wnBLO0bXxso9SEYrZs7QpLl/Q7AYQzzxI598zIFiFfJ8slBWVyKyBGSs5iyyJlViVGlVPkUsV5dt1mO3rgqJ378gusrKQkGFtJJVC/QtWKRxY7Fb4jgURM0CepDCfwL5QQ9iN9iKrX2L70OQUjhO0FCxIvtWvE9ki/PY5flkWP+jNg2ANENvxYOZNEGs19BzLQ8wLh7GWRt/50U8yD+i083qco1QeJCDaAMT17JQ6brRuKOxL0lUMH1PAGsSERMT6VgDYfr34Rus0i/jszvY4ghy+hjJg/munUAABAAElEQVQFGBmyylO5MBhdkkSEfQHj06+yBsU8DLlEAlU82TFKPc15BNrhBagNKgP47gjOjgW6kCe1K0Q6MHylApmIyYl2gQqK6fmOa47weVBz6Gh3i7XKaTFObWH+cApbLiCi+eVzhKooFE75aErHtP7Egz2APs7dC7zP1Te0g+vjMUj0E/eQhHV16eBFbUc1DwfoTF7UgWOqW5megcRAoTUXtHkfYyclGAmNjEYOlTgxksOa5zh+JpAPkiPGIxaPWWVVuRWWikGTtJd0AK+k5BOOuQQL0ym7qs6OLjta1GCXXX6prbt3nbU2tNgKodj+4pFfyGYqaheev8ZSrWl77N6HrOFoky1atkhOZW+W5E/MpfqtIlZqqb5eSzy6ReUo45yACl2e1PyOfOZbNnzT1XZo/xFrOHDELr38Irvk4kulQtln6+5fZ3v37LPKykq78eYbrLqiyr73vf+1SxTnnPqzbP26R23p/KU+J7ZveNY6urqt6WiDvfKVt1mmJGL3fP8n1tzQbFVzqmzp2uV2oOOQo6QWCWwjd7rmVGv26wzpgVkGaYYM9Gwzp6MHgs2dzTb4NnGebHI9gp3NoOYxEjkgYdjY4vJRUiSUHU5xZ8Pz0wNB7wdEISfKqCFJScULR60E3z5s0AkR0rkES1g71ME4MYXxdZWm8MZkn9rgmS8Qi+6zQ/6yAtJiskQv9nuBHUdMdhQwp9gjZXTajHG7E9HZ5oXjwU/6CDJ2vAAztWPHTqkJ9dqSFUv/H3tvAmXXddb5fjXPs1RVUmm2LFmeY8eJhwQykImEhCSEdIAOvKabRwOLt96iV69erIZFv/cC9OIteJ1+zepmaIZAryY8CJCEJDiDHeN4iBPbsSXHtixbsmaVah5uze/32+ee0q3SrVLZVkKsqi3duveee84+e397n72//zfGww88FM8cfDp+4AffHl0tndFQqMeXqyOB2/bWtggk84VJE28SVax+f0T7tWSEHIvWyYpob23BrKkxnp55koAOmGfxDO7q2BmTw4SOJ9FVe3sr/jv4hhUmYATJCQajbeJPn9OThGo+PHws9aNcO7/bx3Lm2QXGVURmThO4JYWv84RAloaen+a1OIRzvSo7BkMNs2xuI7WojobBAKZhuLOw/85eghPwzGTzPluzNJdKFXlDb5sJ/dMhtTPS0fH38CRgS5Dled4zgQCvo/hd/5q0rtqJS5QU2IRnlYc1RaUzMt0MZmwzBbRegh5uoxjCSKJVaBVS22jqvIBXcKRfGiDPktZfPqo1Seepi1jAHG+B4B4LnYx9b8QE4cgbT0Zl0wnaip+cplvQuQUGugWhSo195PsYzPoEjL7Ayz7VoGWqh45b2jbFpkY0Nvi4nBjth6bzgU4n6prwA+L3lYqCteR3VOYE68/BkRokx+XExOkYJbS12jDTBwjigHEEqUFjhi+U461WpKnJhLeA12mAD+vRfAVCPIRF9t/Q6WrX9Kva1LkpmtpqYwIzQQUOFe0kJ6afSbjB+yx7W4EcVDMzc9E/NhC3X3drbNlG0tVHD8WBq66JR+5/OF5z203U0xn//b//UZwj8er+A1fHX/+Pv46dW7ZBN+aHWilA9Gf/8H/Ez1NnueKMqEXD81sf+0/x3g+/D5+zpvjEH/x53HLtLfG5T38uHnvs8Xjru94aD9x/fwySG+tf/C//Ir7wN5+P3Xv2xO5de+O+e+6PhdczJmid/vLPPxk/+MF3pyAff/T7fxw//ws/G12dXSkoR1NzI8CI8zApFOzWAu42yvqmwAZAWt/jv9H7NVIgbeIwD24y/pfBdqMoW9xosGOeRhrndcuLzIEhnlEopISv5c5Zfs3G98tLARn1AhHpLGlMi9VPcExWQsfqi8aFoTQ08QybeiFpkYoXrfBmvbL9ifOQYWL+aOI1DfNYes8VLn8VHkZzgwRdU5x6NHFKsaWu8x0dQdIele03vydzJyX35Qp0V4puZLH77r43jh49Ft/3ju+Lm267MQb7h+IBGKCDjx+EIa+PH3jLW2L79u3xhX/4Qjz11NNx5x2vj+1beuLBhx+OE6dOR9/OHfGed7+bqGRN6fz2muY4eehYfPnuL8fA+aG45eabUkSwZw8fjr4922LX1bvj/i/9Y7R0tETPzdsTM6yPwkVzo1y7X9Yx14sV6FCmPukpuHFeCvJdd0rBBz8n7Zj+Xn62LG+7S5TXqG2pJNiMc7ZAPQKRfLwSeNWUj6ZZzSxjscD3SsbaYdbvZwY/ILVL1TCiNZo5JbNVwcM8Tvokc03zgeupw/ryulOjbJc1510vtjX/bfm7mo4xApxMA46mxzHxEhjRB26CAoVXsQ3JpJDfNC+bQ+WUAyOIAPiw7TDB+LDMz2AGO9eO7xqBA2ZITTHXQZ8AjOS1a+l5MuabTiatc9b7IBQ4Dv8EhaisA4yQkPTc6HCcGTwfkwaf8FkHmDU3NkRfW3f0NLQCjmZjYBzwQh9ba1uSn4v+h3lJWjmuKx2b0s/5eR7zXPuTNEf2C2oeHT8eD5x+FJM5onSqDYMUo7RxAW0qsRiiEVM+AaRmqg2E+WvUlHJigRyEVZieaX6saR2A2HHl4o42NK6dzWiTMMsrNCTt2uDwWEpOPDqamfMJkDTRrG5hAiCXmMM87w1veEM89NUH48Rtr0fbczze8q63kEB3Nm6865Y4ffxUmiO1AOdzp85F95bu5NN0+vTZeOjJp+Jn2wSl+QTIe8yQMr97b74+9qLie8d730WUwOp49KFH4/jxk/HQ/Q/FBz76wbj9+18fe6/bFx//P387BhkHgaXmga48rrnWoTb4wPXXxbs/+EMxPjgSv/N//afY3NsT173mhug40Rnb9u+IJwafZm+fS8mCy9H/Qqs2Pq0HCmwApPUwyht9fIUUQKuALbmZ2i0unCZqHMNkyKg8F4oMMcwDktdJGOhLlUlst3V6lZnkbaN8lyng5lmuTBIWWk6tMWmSPOPC4CgF148mRVQqYXDK1WP9mu/MEU1Nnwxf1bxwAb7iis+ETHpK3gtjbMmoK7vNv5XAD+cpjS9g8piNh0yiV5ZqGfwc8dhD30iM2lve8wNxzU3XwqROxNcf+Ho8++3n4m3venucPXUmvvGNb8bA4GCcPduP8/r1ccddd8bnP/MZmNjZ+PBHPhDffuaFOHXyVFTgd2EuKs3sHnnkG9Hb1xt3vPmu+PpXH0ILgTZgfCwKhwkQzLP84gvH4sCmG2KGOjTJXM7Y29dXWqyzFobdcMfOGU39lgCdMjfwGvPtNGC+5nVGQFvxmgtTuExNYATWsQnWowTeOTf5El30eLi+4cCPtsawyjV1tBfn9ylMoGYJAJDztrNo4gwqoGaldF2zbZnGfFljuE+6H0upcyA3KVuNzjYtATjAUA2+ZlVoPTTzM5CKZnECI9uqZsjXhQALAiiYbs27pvbFwuRuwFEXLwQiIAl1ZUwOtAiEn28+Ey3dT0dj6wBhvTk8A9iwD9zbe50bHYxzw4Op/imAkf3P7o9vEcEK+lo3xeb6FnyluqKvpjVu6Lo+RWTT7FbtahMmoRbpIuDJNUY5Y64QR/NI6VF63iQmcFOYmabcP2iGjk2eiMeHDiq9ic7ajvRc2JgphHh11CFgqgcEjqFZyqL7YSbIwCSfSvtLu1samohwN5za0tTSGFu3bEITxk8GcqBM8KwNjgwBstAweRzaSoiFFgDfpkZ8eepjlJxmt7z2NfHFz38xPv3Zz6B9aoldO3YAYmfj7r+9G7+m8bjh1hujFs2bfZWOvmY0E6Teh3oJh86z+WfPPhe/iqCiiXF0nBd4P7VzW9Q9fThpb+enGQPWk0n8rgTaTQArgZ2BQEwmrCBlgf5pzuu8MmFy2qe5mUmUebiSlqwC2ilQmOP+M9OzKVjLKOaPBjTRjHKVJYtWbZT1QIENgLQeRnmjj6+IAlVsZoaFTqs5NbmJ1/kdidaE4VH5hxCOfBwyGgtk755MZlirbfB5g8bUJLGYy3SXMhP57xvv/zQUmCxql9RKaFqXjU02otUwOC0VLUiFGWek7pqQudGXKzLY+iw1EUpWHweT2ipxXgqsy135vXlMCqgJECji5o42gCN8bmD+6jDubxnQKWk/z4RS7nJF5lCJrf4WOu3LVFcDtKzFsN0SLTFRMIQyS62YwJ05fjr6XzwX22G++k+ciWPPvRCPEOxifHw8OeVPTExET293HLju2ti2szeu2tMX9937Qtx/38Nx3c03xg033xAPEj3Lik+jVToGAKo8URX9Z8/HGb7v2703Ojo74pmjh+PxR4aiGUave8dm/F1gEOEOcwa2XH9e7jHnl5H5GgA8zieT5xbUDkAD+12uSOeU+wtAKfAu1UiUO38tx2QorTejeskVqRGMI22ahZmUEa3mpTZDhjMNrwNFqSYkdGNDPeO51HzM+a8UX5+jvFNqIGYxEWPipGvXAo7Sif6hGgFNBSDNsRR8GWZ6Bq2H4MJADbnGKI0Z56hVqCacfuXU7pgeeS3ceQtgqBB1DYQKx1dtU+s0GpapFA2xpn4ELdUY89BQ6YJXTNmSQEygqC8T4Mt7FU3q1FyZn6kpaY4ER22xqWFT7G2/Cq1R60U0tY4EaHkGXA8mMG8TWOaBGzQ9s91qVwVQAiPf1Z4lbRz3Ozl9No7NnIxeItPRWczs8H0azawTqDTNCcGQz6g+XnMFnlo0RaOY3Z1XI4SWqYXgB7f0XR/D5JB65twL0dKJNg1N4tQYmlLoa1CGfkKHay6eyS6KoA1w1NLZGJ2NCA+JFMdkxGepM3ZctSv+6pN/Ff/i538aDVt1jI4Nx5FnDifTtgM3HYh7774naZ6s22nV3tEeW7dtjWNvuiP+6Jc/Fl878nz85IH9sR9NW0Htz8/9WMydHnaIk0CxionkatLW0RG79+6KJ7/+ROzs2xmPPPAIJrTt0b2pOxoIY37ixROxafMmNE3HGLfb0xzhslS8r/evQbNq3qpkbotp5bWbro5HzxxMIcnNe+V5G2X9UmADIK3fsd/o+Roo4CLaiN+JYZrd0EpLHZLblJjOjQjzhVlMTKYq8VxQApmW89KzV/qMtBrp2QL7ixJ47/OdYMBWuvvG8ZUpIEgyMae+FI04amcgKdtnZV5aMM8S/Jh8NotOt3R+WLNzRimleU0M1mBwDkHAlNLuNc+Rldv43f0FBpA+NNYa7CDT6sgw6meSPx/ZM+Jf/kGOJB0HRC7AsJYrMj3StclQ0JjFSJOcLoZiz8JJy3TXxOvfeHvc+ZY3xL2f/3Lc9w9fjQ98+ANEw2rD72FrXH/zdUQVa4nNXV3JV+khEkqmUM8w33v3743eTa3x7Asvxt2fuzsm8Deq4V4yjjLMbe1t0b29m/OuTozkNVftixF8Hr756KPxwgvPx1t/8G1R3VYfQ0PHy3XhshxLNISOiW1jDWitI5JZbQUBCMaS9F6NUrkimJrFzMyZluh28RTMJmy5i1c4ltN/8efiOKqxEeCkcN5oI7xVGi18NviQvlVxXOd+1TSZtoUzij9PASgK+OE4J1LEO8Dm9AQ+PQCZWrRRaqSYSIvjv3j/FT44x6bRXGXmfprPOecyAiyuoWmMWcXRHFTVZH6Atazb9Qvt0dB3MqrqCPFeNURQicnks9TbSPpiQOo0fT2LxuP85GjS0tXSnynGRXpnfWW9Rgs1DzgUJKp1aMS3rQWwsImoal11zdGD5uiq1j1E3Gt1ePifnWt3HG/zAo3MjKaQ4Grg1ArlmiQjrNkXj+UaowtmePSD+41XTMRIDEYbYFSfGdcUg09oSmgwGK830EYCkakBRvObjoGRsWgiDH4FURzrCdN91aZdzLWWqG+vjS2be2N0fiSOnD6J6R0R4fBhGkejrl+SI1PJ+tXURDCbDl4tmCgytjWEyG4kT5S+Wbb/jW+4M55/9nDcfOsNcWLgNGG+CZ6A1vcrn/1SPPCV+9HWzaexbsNfsHf7FkBWW7z/Iz8cv/fx30/gaOe2vuj66E/E/SdOxDDP5nt274jW8SM85308r2oHiUS5ZwfzrDb+2Y//WPzJH30i/t//++PQqhAf+vEPYw7bGm94+11xzxfujccefpR2oSFraU5ml33b+5JpZQ1aqW27+gDrFXHNdQfiq1/6ajz6tcfidW99XbRBi/7JgRRCHSKuMPs2Dq8HCmwApPUwyht9dHtI+1pa7/L9fA100QROybibW7kik5UqZvNElEqQWHyTELMlSVu5C8od42TD0xZwAJYZz00vyp26cey7SwG1JDNIbOeJysXWvGQeyIRpHlmFo/PYwhjM40pMrKZZ0wkcyayYd0RApenZq6mYH6YRTZi+VOl5YOpj1JI+Lz4fMnWatQAcMRSDIdO8xV/LaCXsfHq+YLT4l9ex+E799ZpqCWaQJOs4vqWvB+bn++LuT30+vvGPjyR/oxP4IijdVvvRf74/Ob5rSlOBVmVsfD6++JVHiIR1Pq698dro7u6C2SNxLOZstmgrDNPJ06eIjIe0HOZ+eGAozpKrZju+Sg1NRPuiz93be1KOHEMG285LlXytudR5F34HqLF+uNZ4rdoBkwirlRM4jpBkc3ByJIHxTPO4tA3ZN/5ysbRLWp28cg4nBtl16uWUYp1pbvNZBhWP/sxUrjiujqHaG1/VgJwKQOcUoE2GuR4wonDAot+ljHZqI1qoKWieTN+4Xp+hlwKOrM/nT18fl95ZtCKC9aybAqKiqZ0aCD57ru1r4nntFsBsnkTDlZlBF4hgeXoCvytMDCdn8NVhHg0SNn4QcCQgtB8LycwNzQWf1XYySMnPRX+rBXL1dLa0EeyjG+GBwjQCHNQCjtp2A45wznFQKY6LgEdwA/aPQwOH49FzB+O69r2xu64POpHgFm2UGlDPFfgVYPrVijntktbId+7diB9RPe9nSPQ6wN7RVtce9WhRTwwPxNn5c2iZENqxxmTmeTSA/rveFIjE50xoo13gGoQKjbGzo4/GZfOjne+bmHdVAK5Dp47ECL5Vg6PkJaLfani3beqNLnIijcZwDKFBn8T2cLPmis3MXfaxIYDFLrQ6v/TvfwlBIb5Rxw/H+dmReN077ojrXndjundto9FCs7n9no++L05Okc/qhp1xfqA/0enf//b/EQtvfm3sLNwQm7i2fvp07N3VFp3b3p2CW5hf6id+7p8n00oaGj/1v/3zOEsUug40SjVoLw8dfya+751viptee1OaD3UEX2itbU5gqGdvL4ouNIQky/3QT3yI5MIz0YuW+Zd+7ZeShq0aM8ue6Ezh6DG8oz0ZXVLDNv6sOwpsAKR1N+Trr8NunPr7WNwoa9nAdCAu7lurEsRzfF1qmczNPGCnuaD8Fdax2j2NbmSulvJXr9rMf/IfX41tXgvRHDOdfHMNycXXAJxgbNT+TcBYrcRAazJliFzP85UFelgbw33xPb/7RwQbDUR802wqBzC2Ysln5q8aNU0P82h1K9FjeQ9K68l/U8ig6Zj03Xv1VSnPi35/m3d3x11ve2OMD0/E1Qf2YZJUH/fee196tt/4/W+MbUiaZehaOnsAts1xxx23xqMP3BtfvPv+2L3/mrjj+98QA+dw5EYCvuPqndG8qQVp8z1x7+e+HPsOXJMYrVqk073btkQtjFR7T3ucmiT/klo/1o9yxcMCAYUp9l0m2zYIaHw2VivVMLoGtkgMMEysyWy9j1d6rKO+HQ1mQwwWhgh2MJbMpsq3Aj4X5r0UICVfnDIhwFdrz5LfuJHaHjUeFkFGaYe8l32vwpRKMy79f/LF0uTMM5gg12J7bHS55O/h+SbtVNNEmOy0VgJwkmndkhuv7Yv9c4wEZrP4Gun/pBO/35sws1JDICAWJHY0NEc3ARM0Y/S+DE+i8QBA6PzEYALZjpWmjjL7zXXmL8uAhlqcyXEiGwL8kiaKfgpmqgDvmsT1tW0GDDUkkF4HCNsJOKqrbOLqTDAgnYw6p7BAf7xB5tNTg4fRVJyPf+TeIx2jcW0LyVOhyTQgygAIyRzR65W9pZL5qTUDMGrpYwVa7aZCezw7cgow1hF72ndiw1iJudhYnCHUuNq6GgRuJr2doP0mf4X4sad3V1y35WqiG7p2QT8i8Y2Pjac7LDBvFxjjHSSZbcNE8MGnH43h+eE0/ru3bYubd+wjel9zPD9+NirGT6NdK7BnMTdopM0cmhpF4HAkpgtZnjODRJweP4np6vloIKqe/Z8eMlS8xJfaFTE+MxnHnjoSD9/3YOx9zf6ou7Ej7j/1DQBoQ+weP0wY8Kk4Pz4XT1TsiPP4QtXUmQerISb6J2OIwBctCG3a0B4P0W+T4c7PLJC0dxBBCWMPuKwo+lE5UesAcwLQSfI8VUArA0s0tDREszmWMKNEdRi1BOfwWc5C+l/q6U1k2/hzhVJgAyBdoQO70a0LFHBzGieKUios0C31zUjB3egvvfgJrpRMm4m9HBOX6pSJYFPJGDoW2TLF7WM3OSj8tR8GahJTBwzrEjOTbPI5TjVpUzQcraYMMknZBlumwldwKNuWXkEFXGodMn+aQNlGGTwZpCuuMAaJYWV0Vh5/pMkwNlX4FjlfypWUo0TJJYymoEGwlOcEKnf+99Ix29sIE2XSzWzkL26dIZ8Nky5TpqR6rcDo4ppKjvBA6FczMjMS3ddjDgNtj42eglGdiu37SR5LEI3JytnYc9v+2HfbdekBSj5hXHNN9zVx5nxlPHHiVOzDPeNnfuwukls2RX9lC6ZSMFhoEXZur4sXC2eisrMq3vaT70YXhsYKn7MaNIKPPfJoHH3+GPlcbowFmOrBkWMlDbv4o8z+pqZOGDeYYplA1gxztAyj/TGcvMcgykVFbUPSsjAfZOBMfCmdE7NWPNtrPdZFTiefuyFyz6T6ltWWH8tp7/rhupQBr2Unv4SvzvsEuuxCeh54zvnssaS1gclWK5JAznITOR6H0Qk0MWhDNJO0PQbBWOA8z/eVa0YyQGkPX2LhEuuoxbSvps5GFr+zJglY68g31EZggGQqTdWpL/RD7eaZsaE4PVkER8yvcTQ2VQ2ZQMSKBHWaATYEgQVo8zyR6/QLmyX0tdqLBvyNuhraCBdfQyCHQpybGImbN29NWuV8Xbc3+g2l+/LZ8Tk5cjaGGcc5zAtNmPzIuScRsEzGtrotCZA6lk6XnBr6D+lXs4skx7X1BHdg3jhftjVtpT0LsaW52xRNBIPoiX3te5L2awpAVleLHgSwZSJZV6aOlnZM8prJ+2SIbeoo3sBxzb6oBYctBGijXIkbeq6Otop6BDoLcdNufKkAEoKsazuvjms7rk5zewKAMzM3To6nmXiRQCnjo+R5QiBZC3CcqkQzWyPYrIvzhWHaMUH9WclunaVA+OLvfyYdvOMn3xxHyUPUjOa0rnYmDtOHq/ADO3loJM6OoKFCA1Z/TVuM1tMffJ4MM64f8OD0SAqi1FaNKR2BBCeItCc4cn7WowmuVdPIHKmhrYPQfVKQRMQ/Q+B3NnREy3gbwEgtLqaeah+hryaiG2V9U2ADIK3v8V83vS/Dm6yp77AGMLLk9JB7WqkgYYU/SBsWBkFsL0gX+VdamtEa3IpZQycL8BgL7xiapvP4t4wsECKWjeUcmysyQ/YlGEIYq1pt5tmIlPDJRFG5++FLLEWAla6jHuqQkXCjkKHVnt7+uQ9kTNXaNgQ3Wjf7CaT5U2y+bq7VECgLq/oSm/g9frp0EdRkzAP0yUlUMhjmTpLSizzGCn1Si5QFaTBS2UuLZWc7EnMJ8R2z71ZJ/Yf5q0eDkbNQF90bmkzhZzSJCZrFay5XkcE5NX4unhs+DhOWaWUcgzPj/Umqre+EwEFGWMokXx0YRk1fzw+0kw8JM6+xx0gEfDSmW7fE8ZbdMQOImUQS3T8xkHx88j4q4djU0BlbowtwdJwAD31xNUEdjp9rwtG8J6qaDeG89Lm2n2oxWupaCB3enHruM9bA86uZXBOSbhnhkQJPvNJ5zneeqJHUZLEOUz81il7oexOgLyVPTWdae1YEKZ6vVF+BzRjtXw7Y/S5T7jxRnG+/0ue8kpf7XpzzCXDZeL7bBn1JvKf9V8Okb5L/8qKmZGaSyHiY0lWp8fAnX9bHq4E8QVmwGyKSITyYVaNw4fK8mpf0njH6GUBiRSISZW20E7LfRK6uc2Oa0cF0N3B8kgALU+Mz0YSZmmM1B8LQfK0K4VQdr0lM16bGCtEAQNDcsRFNw/gIQgCO6+8kIDMxcRMaqXNooU6jtWhDY9kygwktdfNjarsAJa2RtMF1U/CzheANbTUtMQJ4dLCk48Hzz8VTcQQwiRkfgFIyCYw049O3a2fHDsJvt5OwlXDY/GY9zv+2rmtS/Wq53D9SdDounjaIBHuMWqRmgXJdIfZs3hWb27vSmJUC6gSWbG1FHXXxHDl2XO9c3tWzk2TKjUTmQxvlXHVySUxKPaDNBMMxhz8W19R3Ncbmms6YrsJUkDE9OPo019RFd31rEqal9BapZ8WpQDUnn34xnr7/YPQd2BH777g+zY0JQ5RTf3Xd5vjWscP4g+2LH3/Ph+Kee78Sz/SfjBqEG1X1memkNK3EtI7VAY+skeIj6tVQtXYhJuoJb87c1Gcs+YxiWlkARQmwnK9zgL+FRsZoinxXBQQ9mGu65S6k+W0vN8p6pcAGQFqvI7/R7zVSQEkjoU0xGjfHy4pFpoTFtg579HpBEMt1ziz4SxebaCuAx22vgQO4pEevph5sd+NsNhgyxLdmBt16EvNh8j+vFxwpudQk0I0v81XINgZOLVsSI0NN5qExm7yATTOeCtpV5Tv/lMbPsJnqyO7GohN9BpjcVhIXTt22PNsI8xsJBfQvGQPQmTA1q83zrswikyVDMI2UV4ZD4Juk1dIS4CCjYP6YybkJmJPVgYugdHxmjHEg4BMMprRba1HjZKRD7/PdzKOUmJRFbWb51sqU534uOdNV/syXfjSjkb4fzldNpaAZ/wVO+j9pHiQYWgSckpTvjoSuIoNHzxDGFyZsrjvIJRsd5Iytg2myyN6n/7Q/afMYy0Gew/bW1rjjPXfiljEXLwLMjo/C3A0fiGoY6ZrW50A3GRC0DhlbtT6G2k4AoHjMei1qfjZXdQGYGtH8DPNszwCEaDnPZQIVnOOpPrOGf/Z5t86VSgP1dTdtot4xwhKPJjOgnOYClczQaaWrX+ZxaCqjnpEeWqMNmQb4eN8qTM00mVsOjuxCChhQjPDmuiOBNNezLl+OneuQYM+cca5tlhzkvKTW5iRz/CnOiSb811rxdbHWCQCH4eQHR8ZpeyHGGDMjTLqGWRL4BGwYElsaGnCndro2OvV/o+Oa7E2iUnHNtG+G867BrNCgK2cnhwmRPYpmEzBFyHFN2dIzwTnSKAFItTUU57Gmmp2VHbG/dVdKsDqG5jVfC9S+uuR4mxrW/abGZvya6mN3+464pfuG6ElaxLyzxbnD1dZZINiPfkeQOLsXn62uHiBqDMja+drY2kSEt2J48eys7G/aM9wvWGcWmJvzPDQCCkNm2/4agKDHl5d87rFTkVwZUANI6gKAGU1ufHI8dm7aGicKJzFRPROD0MjxzgA1o0JD1TR95b9/LlX7pv/lnYle6QtdNMJedTPmrWiFpsZOx/PPH4qB0YGoadcc1T0MoQHAe7FwjftmAc2Q92FCRb3RFBm3OfrmTpiCbEg+fnY+tzQ3JYCnJURl9XTKUWXYesGRYdQ3yvqmQMnsWt+E2Oj9BgVWooAbqTlGWjSfWekk1vsq7K3nppEeLyBpJIxqXmSot1Xgv8GKnBmkubFd0ANk7uJL2aJ8w9SfQYdbmXOPqfpPzAUbmVJON5slhXs1Ie2vgZnOeBKvynbM0juoRapj0zazusfdUGbZcARKSof1h5pHuzXPJiYzar/dkDShKqAp0PQpr3fJ/a+wLwKiMUy83FilQ14KGEhW4dydmHNoIWNzKXpIw+Sbw4dLnZvfx/NknM3JJOCdwd7/peme8ppe3rszR38B31ea+7bRAAMyuCtFWyt395XrKz1bzVym+UzgqOQnmW2T/c5PZdxOage/m0+oBql/xTwmjUTiumHfARi2jvjGc4/ja0EglGY0PdRpn7K/WaUeUwv29OCRODJylPEWyPIMNCGxZ6znJ7bELCZDVc3HYCR9vr0aoQgSev1WyhbqUKpfgXZCrUXyzi9S0v5nrwxkCbSsr/Q5LVen2rLNmPO5HqmdGiMaWor2t+IIlatl7cdKaWTAgGnMywy2IJhIOYcAO9kYqW3NhDCpdkDjbAOaBBln/nlO0lSwZLluGWFNXxuDoEjshWrFL9latfbWZWemFYo60riy8PmsjmDONYTmznDfmtM1YyhXPa8mqyoGeabHCMSANwwBIhQmEY4azX0ja7c+LQx88nlz7TfpbTNAyyAOCjksTHWefeYE/VKIUmW4aMBi/xwme7P9sa16W+rj8vXZ774MP76/c28cxnRzcuREAk6pXilA+/WB069mW2tXXNO+L64mVHi9Zt6swTmNEk2lF/8FR/o4gfUp/OGYHxXeuHa5XguuO9FA1jLPlpfFdlG/Ra2TATms13Fe1DAtv7D4Xc1SFVqj2lpM2sgBpfbNazd3dkUPASyeH+kgZxQx9zCXS4GPAK9jE2Nx+tmT8dS934qevVtj/xuvT31z/8kEBQgL7VPPtrix8HwceeLvYqJ7a2zesZN9lD0ZAJUAT7ENrsHSNSl5GaB6AlmkyIhFYpjDzHk2RTh181ipmWsHgGmloTkdMUvxpWMcZ1jXxyAgdSUirtDnjcNXPgU2ANKVP8YbPSyhQLb8lxxY00eTzk2hngeUFAHFImsDk5aYA5iEqqZaIg7BOCeZ5YWKm9iQtnBdBjMuHPeT7RmECX9udpxl3G8szMtKviF6OCWQhKHQNn5KxpmNW4YwK2ysSPk0WxGU5YxW/l48afGt9Ljng++4Jru/kX7Mw6LENG08RYCgpHdxY16s6cr9IKOl5NkxKB0He5zA6wq/XTaKMBwpRDjj4/xJOYK+i3mUHGs1HTIRMzIMKxQZmjpA+fzCJK+Vz8svlyGR2eSN5yc/mn1wLvpMWfwrU1g6V7PjSJ8BL1MTWYJST8/HpwE/ovbqHq5px/RmNg4dehDGCekxOVu6G1EjeVPPvnBjq0zFOhxXHfCVcKdnu2Ysaru+SR08Z7MAL7TEGDBRP1oshBRG5JLBLldst8IGNZDSJW9j6bkesx7pvLyfpect+UwX6mF466o3ExIcB/UCDD/aySzc/JIzX/4X7pHaw7tt97NaoZSzChNCpfcGW0jjRR8Eic1oJ4z8lwr0FXDa/0y7SkXFcVKTIk3ysTVCoctmOfpcqgOOkbl9ZoiSVwdzbnu83yDgSG2XIGwe5/tpfEBrYfZH8ceZg5mvbKzGL4n8Ct6XsZbpVstn1EA1CEac4zBG05g+ktvOca5Do2RiU9uroMr5aaCGOjQVBqrQzEytTz2BFJaDo9J+qIHqau6I6zbvxzxvkDaNlf6c2rkJ37dOQoRvbdyMMAwxWpq3F07LaZW0q/aR3zWjTtYHSUOH2SDtSZH3uCzRuvgs5ddam8AqaZ+glZoowVDps3EpcJRaBM3N4ZT32Zxk1dAlQ2xEi6zvjR/se1M8O300nh5+LqYAN5MIHe/7039Il3//T70jvac/zjf+OY7zANSxys7o3jUYt109H5+frot+fYTwCUNsgkYekASgWlKYSnVozcxJlSZc8Uc1QgU0nwpUnMtdLfoMAnxNYpjOJGAE65fRNyEkyXW9x0ZZzxQov6qvZ4ps9P2Kp4CMmZvJS1n81CRMkQ9C8xiXV03TUiJLJMONVeSFYcOrqmPbaa1LphaVSBRzRrGOhb4OBpJ1/6LiseepdwRpt5ubG5Ov/NqLLuBAvrmlAAmYEyTHf+4vO2NAgWR+UPZu5WqD6YGZSIkpkcZr1jBhXh+BUNpMS7YYCJbfu1xNV+qx1fq82m+Xgx6OgeZfAiPNgAQiampmmMPf6Xvbfp8Rpc+lktpy/VIjqQmgHKVmgKvNX589maM8siQTNlXpX/skY1SL9FrzJUFDMm8smkKV3jvvP4/LYpHxKWCyNDgzjqnrbFy1az76RvA1mmmKoS3b0P5gKgTDrpRan6ZyJa83dd4T5JJ56ivwXTAiWOKePMZ/pfEKTbJnzpPLFdca+2RIaLUZS++7yIy6GJT0pVxNy495uqGrqwksYL+G5/FpKbfQLL9wjd+lZ1oHYLStNzm6Y24mONC8Ll9r9D8UsGnS6zUWGXcFOc6FbIwu7py0Fmws0nyFdvl7Xu+SU2yWNDWsOJp2UCw/uxby0UADjpPHOWxOqUrCWVfr+4RvmG12XGyfdWtaZ7/UGqUAC5hoGdra8TG4wFQKQMJYutbb5uK8lUF3Lhntsg1Q09fSCy14FtZQ9nXsjoNnns58kQRqEor/bQQSaiPqWyt+bWoMbWfZ/ttP+i+t7c0kbTxbGMA/B3Nuo+FhBTBVo8kfpoxowM7gd7e1uQfNKgIDwJDAKAdH3ntkZCRpjPyc2lLsQ6o/7TEXOuV9F8/hs0DK88bGCGRB3eZyklYGdZgiiIIA+kDH3nhh9Hj0Tw3EmSOn48kvP0ZUyt64/s03J+BdgZTOMUj+bajDNKudR3v+PLEddqMx3TTdHwM1vezGzDe0XNJkjJDx3D6tG4aLl/aG8V8s/GY7ZzhvBu2n7W4kgERPe2dKSZDyZ/G7sN529wNY9QNTM7hR1jcFNgDS+h7/ddd7F0rN5dTEaLIg4Flc5Fehhhu0jCpyWhZYzdAumFW5tDYTclUn6yocjObJuN4/MZyk0F43xoZ7jtdOmKnMQCO7Eet2jFPP8/gSuLFXcn0dUjgBS8rOzrWrFX91czbvTAOOsG4WhiYV7GQmP6tfbz9GMM8xKpaMTGLcbBSX2W7psnoNWes8T17BSzfKWikgZWUwMim0oGElCgoQKpk4TURgEyBpxiRTt9o1a23Fpc6zVd5H7ZEmfquNsfNAJlnNyiSgX0ZkefGQpi4F5tsiwyfzTfFv9kmGEwdxmCvvqQYv+RSks1b5w8XZs2zNmK0Rgrireir2N1bFWZznJ2GKZ6hL2o3j9+JzsqYJnm7pBHe8YPYTYMramjn1r85ICfgEj4ZIn07mqUsBknRSQy0YdE260Cj77VfuC0O4UhG8GjDFPE2JaV17p1aqMjtOlwUN/lein0wFedANHuNaVY8PJTxx0lpV80EAf6Go4YNBh+F0LFZcSbjHir+lytSuUS9tSDmU6OtigTbWnYIaYEZnIAMZcqZhKonRJkqZYcDnYI7Nz5SbBGa0hsHm3GQ6R/9SO/iuNlDnfv2qqD69rLsGpts9II1P8R7+nLT6PB/jzNlO8hGp1c+e6tSMFf84VppJ7mneHsf6jwNuSAWAOZ9BDzY3agpHUla0oZUAvClMRTV1y+b3xVUKTGzo2an+GK+eJEltW5wilL15lKYbMM9m3BTyncKXZx/3M/G1vwmOLHm9SeOGcCwvghyLwCHXDvlZrZPvTU2GQs9+N0hEDrY8lua1PkwMiNo4r2+pbuHVBM1n474/+6Inxbt+5n0psqH7j1onx3RxCjOu9utcdXuMzY3GNszgFCjOVbWka50bGXjM5sWi9qs4btaV/rF+qvlLVdOOvq7NtEffxWx+2m8mEDmfRvGdmoyWhcboWGi9xNy0lxvlSqbABkC6kkd3o2/lKcDiaSJDk0vWsekYwltptQv5asU1dwoti8XNNN/Y9YOoxUehiahG1dNIvAtIqJEo5r9PsvAfxWxjW10XV6bln98ENwtxBDOQ8zA3+pkYxrUJu/3JwgS/I3VjQ1u9RbaEDT4BoiyK1wxM0jQA0BweTWxE2cZ3cS2aERnudACJovlK7Htq78WnZjdZ5a89MpdhjZK/UgZmlWvW40/OH8dDE0wZNBnNWrI1Kq2eQOsywzjmc2Y5fabwQasmkbBmPiZr9doC1+hbkXb95Rdchu+ytQoQvKdaK9t/qWL/TJ4rqCoQtrj0Ipl9fSLMe7LSPMmmX/ZXhtx/K9Ekb4uCCcMWyyTKwBrQhFhiUS8DN49/DlL0AYQT09BanncCRlTTL82hLvHI57covtuujOHKf5BGS4/kv1x4F9DaRukH7EtzQOaxtMhk69un1Nq1wKKgpABwso1GESy3PtkizxnBRMu+X4pWqeKV/tgkK8wL3+2bdFXKrvJMI65KqGu+nlYiV9bhv2OS6wk0F5PSXg2ngIY57frqtYttKq07v8cq7zLUpg+wPgU4S0AybXMNS/5FRU1gChjBGpR3Ij1rtIcmJ2CU3UqfPqPbCVirU/oHwd9iG4vt8Vp/d566NxiEwzk2jO+S/ocpVDlj6L+USJp3qdNGoIdaaGMRFFg0PbO+ckWQsbOpL7rIdfXi8KmYRzPVgRaqmXt5DXEQ6TfaoKJGv1xdGTjy7oSAJ2H1trZN0GY2zsQAIIZxIIpgNVHe7OPJEY62jyTzSMcnb1fS+3E/53NOP9srYPEc72E0PoGRQMjvLS0tCSTlwMi+eK7j5vwWLEmDdA9pRQMn2NvqyDE0cnIgnrz7G9G9szcOvOkmNFfDi9d5vWMibQX/c8yryeoOciCdjW4CgtQ5Bgg8XGMUVKae23kFCdzfks+N/DlLeaXQCvm9q7Utepo64gyCSeeVl/jsDJAU11xXNpQm8Lw5lzbKeqbABkBaz6N/hfQ9bd6uctnamHqVfbxglpHWz5L+5huiif8MVa2jtaYyboYusiVVlbmq5BAf3bi1hW7F1G5uHGlf2szdarJalKi/iARwGFvndqWTXKOT6AgRd56bw+zDDZvcFruwN9+SpIZNca5qMr45PRTERltVGmlds/hLjJDb3A3Djcv3MZitjroZmJjW1Ke8xVJEjdMAZgSDRF9yEyrHeOXnr+Vd+qs5aCKc7gS+VDK2SwZjLZVc4ecAiYrBA2T4MB1j883mWWZOafRDAdJKxXEyz5C+Ks5RzUisY4z5I2Ny+QtAh+ehAbAjg+/911qcT41GysK0v4C5ZuKMuNi5Z8k1MOnLKn/y52elU2yTwKOjoT3akZjLKE0hxfe6qQn8j3h+WpCeVxIgZZoX3viJ4S0A0Az3W/4ZL7mbzXVdWdJ3DmK65z38Wf+OaZksVBEypdJKgLO87VnPrW/xE18uFM9Xgq55ItRLoMAAEQWk5WojMi1UqXYpu1YGUXAk6HxFhWbJVFZggqbmxc5JX/2NfL4THZCqV8234+dDVE4E+J31aM0BEWdZc4Zog+teirbJMa9JJmkCq7SeQsdUDe+XILxaVes1RLfaAfu2xBySegQugqPEAMvQAtT0h8rr9hYy2oJM72txKA2rbrACx0nzrRTFrvh7dtaFv2rFTPrqNUYCpSlpreTWqV4DAhhRMq/DMdTkcpZ1fhQzswJAIuWHamvL/HEuVJ0+SRf3Advic1YJOGrEl2kzeYoUns3R/qba5kyrwnfXdgGKWhLNAxMDTx3SQLCvluuaTbvQNFVjsjcRJ89iWkokOdeHakCWJoeDc8PxaP/B2F7bEx217YTIJ2w4/lLVRDbQyLCCMN+znOc13icHGH7X/M53j5kc1/aMjgAy8P2yLwZnyM3sBE1p3Ivt07JhhAAWJ8fOJX+5r6I9cm6981+9N/m1KTYybxGVQ5tsguTPmM+qa14t9zay5Bx9tw0KBgwbnuYCULJiFsFCFQCHy9N6VRxX7zOHD5p165u0q6snmedVT1fEKIBNLaL+a1NEIcx4CWhL3iQD46RJs2zcNr6uHwpsAKT1M9ZXbE+VNZmLJpf4ICeOfZgQzCM9HIZL01fI9HQzMDAupmrtk405x3JGRjMLtUoCpQYYQxlRF8dsqc7Ok/ERfMhIWE/+m4SVOSqY+wIe188XrsyuVZU/DAPcgcZqHnOPMe71NJKwgeqZ6CBHRB+25rcEIGOODQ+J52Y2TeVXD08PX1KTxPYIk5aBEtvkS6bt3OwADJdACbMPJKZqG9zMz5G9fQxH5UXGhfNfbrGfmtq0Au50YCYWLLQmMST32igZBRwPk4Gq+cnnRdrAOZ7eOcG567/8eDnaOe8mZiYS0yQ40i+pfqEekGSAj8tZHFPb21TUHK3AQa5yS/ujbwzcYjK3S/3medJEUAVDUei/Sg2X/sk+q3VtQVtqZCw52EYY5ZkZQjITUKWlFlOZ6nEYqVpk/oAWGM5pnvMJXpprrUY0++8rrQOcKKjShM3n3uI42ScDRZwlJ5MUkmmr5VloRyjRWgdjS19zynmuAEimPGc6U0WpLn/NztT8cB4tgPQT/Hguq1bSLgmUapMJXnalv43ha6WDf7YevcJZQNeS5J22qLXJgBFUFfDMdEbFzGYY40I0NZOolr7pA6lflXPRl4ym81xGdFRBSWJ4L8xxe+gwLZpB5QQovvub5m36lmhqOA+YHEM7lXwtaVMOrJM2RXrlxOV6I66lhM4APByPkhDCevRzU2BjfxSAqQnKBUKuhQKLfCyXNSdpkBpoh+tkfo6man7LzPrm0B7pY8WvzAsZ8cfPPpXA0XWte6OLdXee+6p5WanP3l+Q7WyqgXnfBGDxASnQt2uad0QnQUWS9tF5gBZJ4CFIqgZM1YFU6/AHE7RIu5bG+tiEyZ6hulsQyO1q2ZZyfdl+qk9tsM+Pn3oqnoynY0fn1ri5dn/srdgOXTL/wSm0LGNj4wlcCnjStRCmdM4KPO2PGqJp9jEp0kxkyKZGBGS0zzZaBIc1aM9OobU6Nn4CcGay2oUYON0f3/z7B2Lztp5467vfnjRc5+cHYhhrCmmJiDKZBFoHzWYvg7YVI5iR87xhqTHFOur+NZUWEQjlSQRhmRm8Lioaj0d145m0zswBpiqkL3Srwjepmud5Z2d3tDe0cMlCMmMcKowmEFkg+bSAm8kRTa3mfAKwEpF2o6xvCmwApPU9/ldE7yvZSDUlkKlwQd9HQta7apQow5+xEBpFaZhzlC678TwPg3ZudpQwoReSLbrIWwRKuemdm7QSUfeXegBXE1LxxLAgDVN6pWQrL1SbwoTKYKS8QmnLy+qshZm4GgAxwtfT1F/PJnAIp9UnyMquDfquxs64ahY/hRnayuaeCufuhEE9jJnSCUzwNJBYreTtz8/xu5v68ORYCocqs5eAFDTQJCTf+PLzfc+vKT126c/a0bfCGGqOoiYJYFfZmhi6OSSp0l6aXWi9n4p9vHTlV8QZZmfX7GZF+sJZyjhoVrJ8HJcTQH+karQMDUXzSSWrRpi7XIDUud4IsEmJYfniHHq5RSGEJnKlReZUYGdGqctSoF3ewtTW9AXTOpj4zqlBTF/xG8RfYdrQzcxDw9TrH3WpkvIXmYDWXGXF685hjmoENEcqL85tBS/5uAlg4XgRsmCSpT8h64HF8Z2GaTUPUl5sqvQQiHieYaOlvyDKktfpu6aJExzmdoASTQXxpWQuqD0ySW9+brrwZfxZZICpX0bfoiapktxPs5O9vJMIt20wGhvxl2Sd1V9GzU6LUf34l3zF6KPrVAHGVXAkmHBNtu9qL1gglJ+ULRmAAZQCaqzLZ2FC/5kiAPEeHjPM+IVxpioIoj9UTO7iGWhDu4Cpb+0ITC7hpKsAljDw+qk04n9mJDiq4XpfBJAAuFiX91YbsryotZqpRitoDjz6ormfICutnZw/Y46nal5caOQ42zYFiH5s5GCcGemP1/XeEHs7d6/oOyRwmkDTI8CpxHSsqRGgD/AwmMKNndfG1R27EjiyXZ7juZqs+Tkzd8PfdAoTXWhgm1JgAtYCUzPow7qndVu8ADAZR6sibpR+jofzsqMREN9cj7DsbPQxz1sBSFNEAhwVKEAgNUS2xXuVFk3u/K0ecDa6MBHPkyesE/+glurWGJvEDw5w5Xx2XlfhT3W0cCqeHjiCGeZY1DVpJloZf/sH/19q3wf+13/GBl3MZ4b5q6Pi/RI4d2QMriGHqqChMEhOJH15scRA26Mx6uKcp7+V5AUL8h1Nn7uLCBeHopp8ZRVVtMX+AhwVdGwipHc3AHQ6gVlXJucrpuzjmG8yP9XANbeQdwqgl4Hw0p5vfF6PFNgASOtx1K+QPitp6sWsrYnF+CmSrM6zIe7BCfRWFms3Prc8N69aFskeP8PsVLbujB6AzjkkVocGDqPyP7sELLjoeq05Fozq2wZAavAegiPr4F5KcbVPZ6WFGVCCZuGaSja7BhzUtT0v7ivINQFHbfE6zBlGOfdJ/H7G2XifBxxV054ebM+vwvynA8Yqc4SnXipUmPUCwOhs8kvI7pBu8xL/uFEpQZWxS7XwJwdH9gd+IuVT6sK0opNN6jmA42jmKbGmO+m/1YoEPxGHK6wzmUNgi69fhYkAYTNSG6zQDVJmMJfEe+xKLpnUP4tA57wqV5ypyxmRJedxmcyNc9OxS9HfUDPK+OncL0NzuUo1YM5w3fkcebn1GgBkAga6nF+Mfk1TzINXOgfstjRdZO6Lja2pgfVhzjdi9loNIJpYaEfwgOmQIAOhSAqFvcojleqEAU7/ioyzgGkT0nwvSxqbkrFcZNT4LX22b/6DEbN4zHurHdKnwu8KEwQ9MumaH/lcKFyQAZdBXF68xvOtk9kCQMKPAx8KaZw9dat0aHllK3zP56caAs1+Y7otZkevSvOsuetFwiZjNgYjaT9S+H9obJJX2+xyZwtSSHPWuWSmxwFN9mbxgXE8VDFVUO+CQiCqt0958d4GwDDCqOugATQmMCkVuCRNFpekc6hjSfHr5M6YOX970nLJJDf3PAWwOMLt8NkTcClEgMn2dtahJl1NomBZEGD76RHHl4IB102FSQ34lupb1Iq521xhJs5BH+eQ5nHp+Uabo0mgGi7NA/VzE8YdnjkWO+q2Z3vFkkbTDsZfwCOwWvStAjwOoNF4fc9rYh/gSD8vx9vgAmp1BEX2wfGxSJvcz8l+gBIApTVRIL9QARCh2en+zbvj2cmjSVDmNY6LwR4UXpwew4QbehUaiTzH3NICQvK2kihZEDTHPmU7vY/rgRolwZVzdQLLhIfOPhaPHT9IjqiG2D2yPbpru6K7oSt91zTxROFMfBtwVADUCJb0YTt35mzc89d3R2fPpnjtW25L5nz2fxr6g6vIe8QzQgAHtTlqfQycQJPILVhgn6qL88y9KdpCg+zOYnENrGo+GtND+6Jw5vaoncGsEaBUVTucgLoA2WivZ9FSJb8mLphk7vYPErGOMda0cWvnZjYvAjUQMt+IiBkHsXiLjQ/rkAIbAGkdDvqV0OXtgI69lWhfNONxo0C6Ospsvp1ACMo0NW1wCXXxTYu8mwpS5FkAyf94+C/iwLarY9/mPXEOyZRn6hfihqgdvRe6IbhECgD0p2D9XSxpo2ZrNAiC9ecSXKX4bjC5+Z6b51VsqrdVtWK7Px9tMJ8317TGA5VDXF1NGNfG2FXXER2T5jUiyR4brVItmYx+pMiPzY4k8xrreaVFoFRakqs1m2lfJVnaaWM3bdNzYjN0eGB6IDCQWdNdJat5T6RJafG7ZjdNtZg6Utc8jFLa1zjJcOljgL9ll5RefsV8lir22zmYtAVleiZTKIhcqSTaKoG3IhlM/hUwYVKSL9gsZTRXqmPNx2nw0pFc85WLJ8r8y+AaxezitmXzMAGwV3oj7pglsU1U5p4mjuSZBczUEtSinudZ34Ypn1OCHEwhhNDk1PYtexwW255/sN36v+TF8dPvq6OhI2mMJkgqulLJ+pytH/k52dz3SRYcIUSBOZdBd83wmOM4Ng1DjkZCYUxm2reUQPm14/RjlnDemp9drvFPc4zbJXCEJH2hsDnmR/bDOE5Fy6YXod84AQ3QmkNXz7UtqT1wtZNoskAHgBKAhsCh+LvAZmqykECABDcxZ1UtNOCzawMXJVpII5nwcYRSrA5MQEyBNRmmPaldnkDxfv73+thiXAAAQABJREFUeFag3eymmB25GW1DK42fjtauw9Gw+QUYXf3CCPLAXLBkazswCKZfICTYSACW+hZYtM2PNI/Aq5SeAlWtCFpqDLyguZ4RQrP+W6fNaMLEU/9RNVX2S3M4x9q6G/DRcv+wzfZPrY5R9DxPcKSJmv0TbE4BdCewFlCDZi4pTVE1h5uc4DiaGds9XxJBUfqlqHZU7pj5GQLYLPqa3U/PqWu69sRoP/MeYUEaO+bxwfsej1NPHIsv/dHfx9v/+bvjy3V/H43sA7bTelL+IuthLHOAlCrmj98tQ5iHnxo/l8ba8ZoH0PiLWromwIh0U5AjnPcHqk574wtPPZfM13ZctTM+9buf9Gi2VkjX9FwyN1jj8hDqEtPZ1orv1OOYIJ4GLPZXPpOOcXGitfV7b+8xV/gc44iZomCVaH7VjWcDViEOvPGG6Nu/I53nOuz4jI2OA95n0Nw1xFU92/HHao5jw/3JgoSZmvXNm2yUdUuBDYC0bof+1dtxN8q3dt/JEjbLBqRpV0XcjiQdOWV0weDPY5dfWduRFrgFpKwYfURF3eZkglBJ2NI9m7bH9qae6G3qjduR1iW2hQ0ea/I42P8sC3bG/KgpSqZG1FC6UeeUExg0oLGaF8iwyeXFDdKVWPv8PZj3NHDAbdWDzZhp3EXiuwYACQFoY9tMLUzEEG2rivPYTD8NcBiGsRwi8taEkuW07Oc1v/J3/Vw2I33eTUCFHQBGQRtyugTMZGz2wEzCQsb9gKRs21n5nvZIqR9bIFtxeRpJNxlNBJeLxUS2buIzSBZlVr0vuyO/Fwm3eOar/4P9V8qvuaFmmgLxxOgVu+bvGROSMZ3LeyxZcpCfQEXxBGkuY1Ja1/JrX853x8J/1pu9w9jRBkdGybGjdKki4JsmOINMSGn7nCv65wkOZFgvR5EOagTmSPA4QP6XGhhZNWBVfK9bQOpOmydhlIWfaiRkNNPzeYmbl+0nB1NUP+onoHGiT/lqoB83yWkoHY06KNPobFebm5jHZfSRxiZidr1KUdZYX5YX69InxzklY11K3+XnvqTv9M02a+oVc5gjFroxUxyNlq4TDPwM0nY1YEtN/y7Uz8X8T2kCWEf9nNoJABAA1hrdk6SyFdStRsn5XsWaXQUY0ISuFJSkix0gTNrS4kJdlkrUMmmJKH5Pq85CS8wMvQamGMk/d2zpPBrtvc9FRQ2joxaCe2d+lwZSyDRE6Rmi6sSM04as3dOAEgQ5VTDrmnVR9MnpQJjWjIDHYBNDE0R+49lVeOV6pj+bgE+A1MR8GCkQLZF76I/pyyemjfVVU0hD1s/SHsOEiwuNKqefjqBJoDMwNRTDzImo5ulDu/b04HPRgRVEM4lKJzEzHJ4dw5LgfAywz2T5z/BRpW2vabsBLRHAsExJY8miu7W5N95c3xK9Qz2Yuj0Xn/j1P4invvJ4/Oav/2Z0F9ri/T/0/jJXfwcPve87WHeZqgWPR48djY/94sfiPb/84bj6zms5K9NqOg7NhCnf17udsW4m0MhEnGcvdlw0qUzgrkydG4fWDwU2ANL6Gesrpqdubn/4yKdiBIbnzt23Jfvpe599kKg/Ee/a95Z4/VXXxT8+/804evZE/PC1b2Ljr4z7jjxKpKOKeNs1dwAIdDJlE+TTA9/+OuCkLsbHh+KHbn1HbGvdFGfGz6eNq5aNTx8kN/uViiBonlCs42SxzxlCHY2jQgn6LGYWo7EFsJZrcGRA62nP7dVtRNbC9AMTuhk2spSNHeZRp++TgCTvebnBkRtDLwzkm2s3RYsBJ7iHr4ztyXqorbpSQHmUxJCs1HGOc0oChjoq1yL1XGuRwUiaJQIMKPGfRdsg42FSw8vFOK+1Ld+N8xxLfTZmsLdvhBHLpdrp3kwttYbOnXIlwRSRxaUGo9zFL+tYdi/H37HQ/EszOTUEBm3INBurV5wAH+0tZd4FwppcapK1qjnh6lVf9KsapBFC6As4bGcnOW+cvNUAtBqizRUqG2OyAiYXJnVSoCqosHOrlAvtXvrcp2eSZzfzFcoY/XLVmJvMthgtLXtKsrP0HbIAjzIGPT1B2W8X/gKA0NK4XiR/F4FCKrSK5jge9lUwcqGdF65e/GTT80sXD67wgXNlJNV8pzrn66KhZQiAhGCpCkBLUBk1gvn6tkIt2Rz2vrzUllTir1JLwlIW09R2j8t06u9Rq08QARNS0m6ei+VF81GBk2WeutRAW0/WKSoi6uP88A0xP74bIITvSMdxwNEz3I/0DYAcTaQFkAlI8Tf1bZGW1GJdVONcsF+utW31TdAX7SPmxgb+MLqc5pSnR89SH1HZ+Gfbnb8CtlqEbQbuMTVDPeDJID9GM7U+zcHGmG+HELgZEERtVCvBAcyTVD+bRflLNKcNBs1Rw8OETWH/jw69GOQkjq11W+J04Sxak3MpL1Nu5eBaeX5mKHpbekjn0JgCW9DFxZIEGTxv5jDSVLKzpj3uarglvvQnn40H//qri0EUfuqnfmrxmiv9w4d+5EOxY8eO+Fe/979H33WYZKI5akVjtBfNUQdzcZjxHUIz6949jTlfJfukYH6jrG8KbACk9T3+r87es25tb9kSz2Df/Ct/8+tx664b4vt23RbfPPlU/MYX/p/4n//q4/HNFx+LLz/1tXjfdW8CBlXEl579R8wHKuJNB+6Iv/rWZ+IHrr0rtrV0x5/e98nY3b0z3rjv9e6XMFAyCZYsuWP6uMofr9F5dwFpXzIbo5YU6lYTCTb4F4jcsxVH5/1IEwUjeXF/rsdkwoAQtTAn3tMQ4G/AjrsOrc5TbICXu2A9Hvsx8WulvZlG6+I7yMieRoM1wyasruNSRUZNabaS1JLuXeqy9LsbuTxLLUysWpJxxPy4+XLXS993TTf4HjrJPmkiUw5sz8H0erx8vzkq88q/70bxPpr2OK5Zok9jqGUMrJJVwxGrWV0NZMgM6ssEPEl9EjAJgkdlHlUdXqbhlV4KFKYm1R0T/Qom1XtXwOg3YK5UhwBlqLorJgAmBT4nf8FLgCPr0YdOnwWDSSwW2iwYMzCB4dZXAqxZm2ZT8ATNq3JtgvVIM31XBBvep/x4+xgBqPWRgeGWiS4tMt9J+7EqEalZNMX9kmAGTUkCJoxDueJwZAlWBQv0vx5Trzq1G5gnMl4GpFFDvlJ7L6qTCjUlS030lvltedfx3vDxalOkhX25qOSH7DoYR4d5AyBUE7GtCk27ZX58L/5Re5lP+G01nY7WnqeTOWAFYzePFqYOjdU8oZ21LkjtLjPnBEC1tMM53dmIjxFCHqZ46rNAegKt0Cl8VI1gmMK4owWaASxaTOitRrCKBayGMTKYRwUmj2p1Hbfpytk4PjYbT509EhPj49HY3JhM8doJaPP9va+PnpaupEkyh9SZSXLRIRyrqyBQAnNDLeK3J16I5ydPMgeNVge90PrzVCZBi2bgzoMnzz8Tm+o7CQvemdqU/0mR9txg0nwjghv+is6jv/mLT8Wzzz6bn7au3rdv3x6///u/H5/48l/E9gM7o7OtnYh2PUm4Ogg4GjDYiXQVrBMsqYtcVDXMrY2yvimwAZDW9/i/KnsvY/2R296XQpg++PwjgKC3xw/f+K646fgT8Yt/+e/j7PC5aFrIGDk76H5by0aTbJvZLt2cZYLcQNrIOfGzb/mJ2NG9LY6OnELNPpKOK+0V6KyluMlr+pAXGYtaGIRZNtNpjh8C7GxjM27knvne77ugoIbNvIK2WWRDBSXNZTbzdMIr/NONnfnOSqJSLbbi4gpx+ccRdg05YoqXOhZ4UCRN0MvVeMkQSg89ca7UIpNWA0OVfBJKOunc0Wl4xSKfU/y34jmX8QfnpElrEyPOqJTeO2mA0JTWM6dT3haeH1u3vGR9xXQUZi97+ozMhpZM7vPi05df/tK+5w8UV1l1moMwtwofagAJs0iCp8gBM6GG1/uvodj+WbW5mFbVIkwQ2KgdGJoaTsDnUlpO26Gf0Pz4HH6GbclMy/VGmgo2NLlaS/GpWO1eMvhGwXSdElCNTeuXhqCFMOPtdSTKRQNeB+NuHWcm++PcOIlDWWVKh0B8Ymjurc3dKS+OZohDrFcpEANA2YS6AmZpkh7SvOGlleTHlr+XjI3XqnlRc1ODw77MaAFwmwIw5Ndxjn12nDyePsOwps9+5+UZFdO9+B1dHwvTzVHXOBCdfd8mzPQ4dMYXiDnnmqSZpSAlhW7O6/e92CbDw3fVdyRNtqC6jjVbzWAOUBZm0BQ5X7wnIEsaaibn9woEbdXJV0dbBMOxKwBw/U8dSHebYb4MYsI1M0GAAjRpzfgjaclgUKCDw89ER9NtCTANYNI1SmAG72W/vY+BENQeGmDCtjlG5lbSB0yTxBwgPz9yHNOwQ3FD1wE0U+a7Q6tGHTNoIB3vmpnhaKtsjmb2uMamxnj28LOxbdu21L71+OfAgQMx/TdTzJUWaFWVQFG/Yb4N3IKgskAepBQIQ+I0YkKpWeha5vl6JOY66fPaOMB1QoyNbr56KDDJwmaEtDpsxdswW5icGIIJk8GGmUF9XmGkJLd1V7iiFNEjqZTwSUroqthYDhLR7vDACylxnuYRSjllCtykVyv+XoCJKA357T0N7Y2iPl3fDyNwaH4ibiX8dWlJa2+JhNhmHcH/6THM8rKd/PKtzsg642oS39Vzv5UAkj2dgPkdxDdoLWDH1hmSV4BnPo9M2r06vbikTNHEDJAFc5AYsTJnvNoPyRw1MK9k3vI55bug8JLmUnReCX/ilL7DhHD0BEmWcmPh72pQBBAGKSlncuf8N2qYjHuKYsd3I7TJ5E3LZF6+aZ3amf8RaGrWuoDEv5pojDNzRGSsQuuDqZ2MJeS+5L3ts2Zs/YT0HqkcTZokj40jZU7JZVlL1tJ+mdikbWKNUhvVDlBS05ySp/JbOdrm/Vjru6BmV0Nf1BJuczjG4unRI8mUbV/LDpzam8mL0xpDA1lo8q3t3SlnktpeGW7v75SS/+9qbItNJICdfnEyOjsao6a5Kp4dJCKYEnXbSpedEjylyRnf9qVnnevX2o9cg1UJ/SZg9Flg0nOweD3tEEAJItM4FYkgKEkhwtN3fpvrIFLZLQSRIAQ7UfU6+g5FY+sgewAaP+YcQb3JjYXZ20IT6ZAqSEo6yrxzXaFwDwFECzmqepo2AQzrE9hwrKaYm5MTmPjaBolCMQS07dOXaY4AGhJOWtQaGQ/Q494hQJoAlBmlUP2w9c8S6W6Gdmfa0gVMubJgDYbol2JPnX8utjR1x/72q6IfMKrlwQKA3mKdjfTFhLOJ7jRFQG1AjhQRFO1SivBGIA2tHR488Vg8O3Qsrt+0L/a17kZzyhwjMMamGiMuZv8EuPaxs3OppindcB39kQbSTnPJ9LnYd+lsqWkCkGr+iNZ0hOdJAUM2E7LfN/6uPwpsAKT1N+ZXTI+FL2mbLTJ0dkymUxODOjQl+gKkM5Akm1SObSf13QVQPseN023JxdKSbyiapWhekzOy6ccV/nitpkjpvtSQFcx9AFhVlZlpihvnM0T92YoGZxtMsj4npQuvdWh0M8BG+wgb5hTMp2aBl6tYUw8mfjuJ5OW9VyqeB4uQmKGVzik9br8gdmKSa7B1z+lYes5aPkt37epX1aSspaLv0XPsn6ZWAoYlIw/5lNQvdVIv1wlqYA7LVn+vlMS0EUlNTVLmU7W0bWpRa2DyDN9r0RndaJDzmL4JCC93kcYy1+NIg5vg/KvwUanmxcwClOiPsnZgZl1ObbUJUzDNPjEKDJKwZWk3V+1GahMrjJodfUzUSisEWDIHVq1h5R+tuwn/kyPfejZOHDke++64LuqazbUFMBuZjKcePRTb+/rizIkzcZ5wzre98/Wxk7w45nkTqKagEQRL0WywFSf+84fPxTe//HBcfyu5e+7YF+cROM0SLj2L4ElUzbHBGOSY+Y18zl1jNaNbEnFs5eYmIKGJafLH0fyLkujsBwic6OI6LLGLJQEMv7MeVxDABk+jmBu5MRYm+vAnxcG+51A0tPYTZQ7tPNrZKbU4nD9FAIQZwpoKygxB43t6xlj0OwhpplmamsHS9UrtwXRhOiVrTSHOua0AUiA0h6mce4aJT30GKwnOUEPfBUcms1XrYE4kk8dOA/7muLddyXrJ+kgdItckAOLgJFrEr595Al/X/nju7NE0P5JPFL8Z+Mfw4TMEjODKpL0bJWz3xDgaSdpgtDg7qcCkiiTjVWg5zs6ei6+M9cej1QdjZ/2W2EuCWJOD6+PVQIQ2w3MvN9UsknjdvWkKb1IolqPi+BRJAO2dj5W17GOA3DGihFZN8jQ5kBtl3VJgAyCt26F/dXdc5jxjGLNtSMDjiqc0aBbTij292+L8A+fj7sMPsJ8sxOOY3915DX5GgilP4gK2siRxXbpSZgvl4ua9BjKpFVhekpM1TtqzRMbxduMwaE8g0dbPaIED03zH6CeGYZCNVjcA83AeSeLYZQZHtqsGZnVfVXMKDpFBxuWtvfC9C1v3XWiangbQ0exVizRSQ2Dkn1qua6glStfL2E/chOagQzaipXf188uocNVWf/d/lBlNfjuwPKXMsRHdZFYvWRIZ1NR9b9FCAUMyJaNXAqXSIpjQ5CclEC0+c7DTSO8bk5mZfhaOu6DmlY6yZkjpGXQe8VxNwagGJrY1OvLDbE4RsCHXipW28VKf0xpA42zfyy35OiKDruYt//5y61t+nflxBgfQnmPOFS3wfjDQTc1Nce1NB6K9qS3OnjwDbczn1hw1YwiOqjuiu7c7+vv744XnXsCMiFD/+zdHRQPgAC1fVaEiGoZr4kDjnqgnweZwP3lkADSNzQ0xNDyMD465gwAHgv3i+FUSJTCBx+WNK/2e6AjD6RxOzOkFqlpPMqPjvbQYSSyZORUPLoxfG3OjVzMg9HHzU9HQfhzQ4vjUxxnA2/gY5ouAFQNE5FXN8HwZ39QAD9JDgJS0uNzKddkyjcalwEstr31NY0Q7Te7cQS6hMZKQVrKnVGImaSS+SrQ3mkxmEeoAM8w555faI/PnuLcIVO0NU5P3TDOWC+MUHpyfGIyzE4SUJklp0tJ5MieoJZq2Yb6oT9Dm2KZ6i4ftsZXPM88FrNLIAydmT8ap+VPxTMvzcUvvdXHjlgNRT36f1B/rv0TRP+lzn/tcvO51r4vbb7998Wy1al/96lfj0KFD8b73vW+Jmd7Q0FB8+tOfTgEhfuiHfijlT/JC/ca+/OUvx5NPPhnveMc74rrrrlusL//wu7/7u/GTP/mT0UQkudIygNbzU5/6VPz0T/90Oux9H3744dJT0ucf//EfT2HJDx48GF/4whfimmuuibe97W3p2EUnFw/MTxN1dqYTIHQ+kXH5eZm2EE03URtPq9nLJ9LyEze+rwsKXMzZrYtub3Ty1UwBt55T84MxjobmJgI01KEaPzdPGFY2ituuuoXoQvVx09br4j03vy3+7Ot/G1985r64ac/1sX1THwnxpuKavmtwyu1iD+L8q18TTUQvSqYd7DuWZEqCxHItJbukeOGyCzSp0RcpLyenx+Leqf74wkx/fHbqdNxNIr1/nO6Pb8wOxQsAEsGRkurLXSpY5AtEiDMw8aVq1xb/RkKXt2nPzvlrKQUiRp0mI3vKBbKWCy46Bxt+uYOSoj9ASr6YczElv5V+lKmpVtTLeau1dvE3CLD4ubSi79Bn6a0juNGRSsGRjZCxSmGnLzkqVJIG7lKj9x3qxCrVKp1XI1SOkVBrVJojK5newTG2YJrXTlhdfUYE1ZrplRMyrHLbxZ+ssw2TqW2tW9Orl8ArjYRmTgITGOwZzJrUdn03x3yxcSUfMrb78o+fICJpBwANFjU7586ei3v/4d549uAzMOhoOWBwH//mY/F3n/zbOHXkZJw7eib+7n/+bdz9mS/GZz756fgS7zMw6voinT3XH5/79OfiqW8ejPGB0fjy338paaMMFFBLkITqet4b/YyZWa5BusQzmpPBsVpCAZosMJIBT/5FdqH0xfm2X0BSObcrZseu5bzqqOs4GBXNT8XYHGsmYbCPjZyJF4fO4dNkQlL8iWifL7U8mpfNADKm8AUy75BANaNU9kgZzawwiQWAZnWsk87ZqhpfgiEwJ8KirlY0ToQqFxwlqwRAqJow6zG4QpKysV4pFNO/KktwqkCDUOa0XZM9cy1ZUjJZLpQSGHcn8OpnTb+mCrSDd58lLe5MIjuNuR5KvoSXEvGkCS9DjKsZatG/iGdIM8625tZoaW8mgkRFHBo7HPeceDCOj55Oe9uStSe1ZOmf3/7t344Pf/jDCeT9+q//egJC+RlveMMb4g/+4A8S/QQgf/qnf5p+eu6550K/nmeeeSYeeeSR2LOHvILnzqXffuZnfib+43/8jyHYefOb3xxf+9rX8urS+2/+5m/Gz//8z6d8UKU/CLh+5Ed+JD7xiU8sHj5+/Hjcc889i6//9t/+W/zbf/tvE50ERu95z3vSM/CHf/iH8aEPfWjxurIfCFgx238rKktC2ZcpCegzZmmOFMeszGkbh9YJBS5wb+ukwxvdfPVTwA3k8cGnoxNTiQ/c/oPJ4ffBcwejr3VLfPT7fzRGkRiPjByND93+w/Hu172dxS6FEUiOtCdGT8W7bn2LW1OM4Bf0kTe8Hy3IXAwNISlNOxBrJ5uoYWKbcYC+ZFmy4y89W5OMZjbYUQL7mpFd7Y1R7XCJSBtetkl6zSqVLK3yZX0zr9GDmO4Nc5ubq/BDgglIG0DZ2rCZhzPog4kdIinfmgr1mq/jTMW56G3sTr4WK9dfpkY2/DqY5BmYHwS4SG7J2I7JjMBnHPOkCfyyylKI6xrILWRyRZ2ip9XIwBAnw0kbwEWwOunaakwAYStgUARjs8ncReZ+kRDpBjAqMidlmviyD8nQJNiby5SzmuZpqz4JMi75vHvZ9/gnvnAp85URXoGDDKtmRcuLIZelST0aVkY65sj/opO7zKaapSyn2NpmULo3jIxaUjUgfncMZ4n5Pz+H+B7m1Ah6FfgTXBjsrEWCMsFFkhpzzfLfl7f7e/W7LTdc/jy003ZIUyy1DilwAPPv0LcORvVTT8fr7np93Pz6m+Mzf/3ZGB0fix/+yPvjxaMvxvHDx3jeagGVC9GbtEvn4uTxE2kcTKS5eetmksECMglOYLLcxERKDG4srbNnhlkMIFi18LPKxFS4VmA9R/0zaEJ8BhKAUmRLm60pgT+AQOXs5pgauDUWptqjtv2ZqO54Ck3URDKj1BeO00n22RitrNfOKQGExwYnRotPF88+WqWx8ZEYYV3rRPulNlMtwaSma/xWBRBrpo4Wos3NMZ/0k5oYJSQ9v7XWNEehmu8G3qCts4CYGQIpzC8AmtDypJvRbudSJVH2BHQmBk9giCloQIcak4ATLIQYiFzPNQI3o+xpsigh6XEKZ05/mMmLxwRYUiOZMtJGfZR4dBzmFGCiCz+zZgCSz5OJYAcwMZ2HruNoor5NlFejpL5lx53R02iuqPJFgPrxj388Pv/5zyctzC/8wi+EUd8OHz4cZ8+eJQXGePz5n/95uvg1r3lN/Jt/82/iox/9aPyX//Jf4ud+7ufiV37lV9JvIyMjIUgRsNx9991x9OjRRJN9+/bFb/zGbyRNk5olNUrOGYNRlJZHH3003vve9ybQNV2y97z97W8PXxZB7i233JIi0nn9L//yLyfw9ta3vjV+8Rd/Mf71v/7X7P0j0dq61N83v09F9URMj20lL+KBqOl6DEIuW58cCrSAyc8LoJwmYn7xxvu6o8AGQFp3Q35ldNjN7bGhg2ljkBmTOT4+fipJo5XMu7l2jhLZB0ZbvwSjM8kDKQGsLjEP0TzHCEKaiuVSbNfIqTnyqBhCFsZhtZI2L3esFYogqYXcN+MVbIxstolDcPf/LhZvZ5S9J6bIt1EzE6/DzKSJbdh+liv2ppWdYaXfy13jRjJWmIiz0c9m3J20P9nGX/bsZQc1/cFOHmCmGYtmWRavr8d0C9Y5+ZCVks22NTA25poRgtTj30JWFfa2BsBo8qRK9Zg7RJOWxDQVdzvni+ZhahbwTuBqwRO1wyAKWpK/Sur8S6JAavPKfy7UpTnONMAh+SQU27Tydd/7vyhQMIy2mqAULpqumgx2rIBUfKoF85sCUnXBtuZ0F0Yxnx8+d3UwgnULAN0qTE5h7oxyttYi0JW6SQvMu5/nuI2mS4Kf/D55fWoJ9AdrwC9M88dpHfRhiAVmy8/Nr/lefpeiMs71aBHEKClwCn10DVQr8dQT346t2/tiU083dCFK5eD5OPTEoRgdIXoajPqO7buiDs2QjHtDQ0Ns37EzHnj4gTh14nT0cV1TT0u8MHEqPS+CgDSGEFl6a1aWtC/cN9OIrMxUZpousYFhu3n+iPKZ/EGdE5regWrAYS7SSQNY21ATlfNtMTN4c8xPdkd183HA0RPcCHCEdt5cakYjs+gD2chaoemb9BBs+xwLTmhYCrJgpLIz5DQyIEz7XHvMT6m5ImcR2qG2lhaiymVAQwHLOMBpFibdPUNG3PDcKSpjBYCOgA2FqSnyH0Fv7ut6YyLaNNNsOxcJ9gRKatkUzjgp07iYrM95xnfP80MChminariPpovS1zmtJqqOvF6t9NN9StCnOMVcYubKGgWwTY5OpZDUvQ3taU47/qM+PwiMrOfw0NEUjvzOXrQmKxTB15EjRxKY8ZRhTCkHBwdT++6888547DGARLEIelK7+a7WyfHPy7Fjx1KuIU3evC6NNz/edddd8e/+3b9Lp3n+v/yX/zJpq1qgeWmxXs31Tp48Gb/1W79V+tPi51/91V9N5n+a+gmEvJemdf/1v/7XuP7660Pt0mqlsmY0qhvPEOjj2qiqPx+VzUc5nXEoFteyKTSOdQDaHd34uhX3ovz3jff1RYENgLS+xvuK6K0byk2918bA8QeR9E2kjVWmR4d3Nw7xShtmYm50o/jHqIVwL0qFDUSzpvwz8T2TlKiUcfM3GSUZWY9fimmqgVGvVBvA+eWKm1tLLQ7GMH9G2VLSp3O0m13p4lzu2pdyTLrYGf+m3bR4cfrOZxnGFzDz24lt/dXVzUmjVTxl6Rv1VKe6lh6+1DcvGS1gr89YKLEUHK69EPlPKXbxX36deUbq0XrNYE5zYRz0b6kCIDUl5iIbLa+w3TpQLzWfyK/L36VTDYxxbTEQR+nYy6QXYO4NvOFmyU1fUXHTN/qZDGzKq8N35+kkmsScoX9FN/geuFigN4Y21nmWTET5MDVVF4Mn98fEUB/BA85HU/tJoo2dwwSKCGYQNZ+TefMTmWHeNUVsroW5Zw4ZuvpSAyB9M4Zt6UB5B3mbSjRI6kt9MgUMCjyMUKmQJC+kBo2quqp0P5/N7Oz81+/9d83ISFka25p7YOxqY4SACmpfnV9qLt7yrjcnk7FvfO3h2Lq5J3o398ZrXndLvO297yDkcRPmWfVx7vhZTKUOJ+3q1fv2xj33fSWef/r5uPm2W2K+oSKGx8ZYQIpPGoPnsyEwymgPjSB/CqogzdF0rFTUdCikUmvkiBlkIAs4kAEdtRmzBDmoBDBVo+2ZG7qRfEc7OZdnu+koIbazCJ+OoYKPvOjv5h7gM269+mKZn8hx9vh8A6IQwIqA8HxhMAWr6CA0dhshnztaFKRpAmu/0GpxbYr8VqzcPuaBRVIfYfLV0E3V6j9EWHwCcKQ8UcwvNQ95MRBEIwIcg5hYhxhQxnuWvrtHVaORm8OcQDNUwVACSi6i/JdOvluHffOzxbXJMN7e13VL4d6Z8UFCVU+me9kWhQu5ltax+Pbw89GKGepqJQczAhhN3370R380rr4afy9K/tuLL74Yv/Zrvxb/+T//58Wq8t/+4i/+Ir71rW8lTZP5hrq6uhbPMXqemihpINj8yEc+svhb6Qc1QxYB0uK8KjlB0KbW6oknnkhHNb3Tf+kDH/hAMuP7kz/5k+Qf9Zd/+ZclVy37iMaoZvMjMXfyTVE4dzOCtRH8kQbSST73M5g0Ol929fRFb5ORADfKeqbAhV1iPVNho++vOgoYWrqzvj0BoWlC16oh0pQs5+t916zN8LziliXmH6WrXunnEiq4+SgRz7bbkh8u+pgx9o1ExxnHFIyV/aIzPOBtqt3seCm5nkKCOg0TrtT2lTDKqV7aqZ9LXclGWrqy2xdLkvalTbopZmUmBACU5STwu2YemiFeikH1+iWFi0cIrduC1LOVXCzJAfmiOyy5YvHLSrTOTGZgPhZpewFa2tblFF+pnsUbFT/k5+XvHtb3qRGzyNr52pQDRh8W+3DxXYqVrOHNOsZIPlgPMFUybC4cGcx8XNZQxff8KfkcUoruM1BVDdPeOBaTg9VRGO6LqbHeGGvsj+auY9HYchZ/QcFP+aJGUP+zFOEP8HWp4vAsnQP4HnFQ8yv1v+iIU5RIn48GNJWC1dIxt34BdyVAQWAmE/pKnslLtfdy/l6LhuTcGaKYfeYr0dnVET3dvdGzaRMmZ+RHwvS0oXEhtu/cGdfecn3cd/c98a1vfisxvs+/cCQ++1d/hxN/Y+zasSP6tvRFIxHPcNGIjp4utE2bkNCPRtc23mfGYwoNmzQzIEMKtFDsRD6HE3NvgANAwoqlOEhqXaprqauMACWZktXxHMLYL4zvi+nRPazfrEUNp6MSib/RHDOpPn5APEMC31xzlVXvcXwusQhwrW3leRYU+ds0czKBDT4bHGWOSHHjVfSLtAot85jWCXxYl6fQHBkcwYvs3yg5tIaI2KimiMrTEj+LFmmcRLJVJhOlywI7GyMwSYVjhgNfDCVOG5KZNZtRPveSfxVALy+JHsvIl2nIrBMTOvqk6ffyNdU2FhgfIyVakmmfjUpf2HeY208OPpPolR0s/3eS6H8/9mM/ln4UbJQWNTWazmlOpxlcaVFro0/RF7/4xejo6EggqNREzs/Nzc1FYVbplS/ts35J+jPp62RxP9DHyXt73AAdW7ZsCYGcJoLlC/s6c6mu89tROHsrAPx64tw/yCSaRHsJnfm/tXNzbCb0/dmJUqFc+do2jl7ZFNgASFf2+F6xvatkM7qpdV901bSR82QyTp7/dnwTE7LzgA5NpdwkJwqEe9XUALTkJrrq5g2l3Gjy/Unnf5nltRZNvJRoqiGac/N1IxSZLStpq0tMeHXyv5hFGqiJzxRgzg06rdDLrln5q0wGpkLk8zCMtP3MQES+BS+9sgKmo5bzqwlQUQmjOAXjMz/FJg8TWoU0ONeVTSiVJBfSS2vLhXvZxwnqlh6CLGlTvkUXrln5E5HyYFiXAwqjAM4T2KIZKbOM0OUtSK+hUwu+B5OAm0mTjKaxzGfHS70bwaZp7xivvFyYafmRK+kdiEPUr6aOFxPdpieVXstYwmyONKINRLDRdR4NAfRwspQrHF8rSHFuLdf6+D07pqR96U3KzUXPkPGWmfQ5WnZJuRb+kx9T27Xn+quJWtcSY4AZgwG0t3fENpjDLbv7iEKHeSqMu1rdzs0d8eb3/EDMTk7Hzr7t8cGeH4lvPf5EAinX3XBdaO7U3tsRHa3kQ4KhbWxpjv3XH4jGzqY4PX48gc1EE2UmkMdnWzDgeuM/mfsV5zTE9ZwEIvzMNReBIweg+HhVoUGsmNkSUyP7ecbJb1Q3EjWbHosKAFJCIawqBbUkrO0KHGqKYbQFP/qiCZtcHywVPLfmQ7IF7Qg+2hqaYticQvPZ2m5+oRT6HE6omvDPNiOF06aNlsJCgUij+PWw4QjcKwGBtJ7qyLkFQ24y4mqEU/Y9gaPssrR+MJ2SUEpzQjU7mp2mVAack9NKuuSl2P38a6Kxc9K9aAbbwwwcLdtT8su5WGDkM5PmPnPBqgWHTWqP6N9qaRQ0VxMAqTX6vd/7veTzlDfkoYceive///1Jc/TBD34wP5zeP/axj8Wf/dmfxb333pvM6zzY19eXfJDyE9UI7d69O//6st//+I//OP7Df/gPi9fnSW9f+9rXpmM1CAv0d9KXaSWA5LDOY39b3XYoagsdMTW0B60e86r1SQQKkIlAJJOVM3Fs9Dz7TmYKuXjDjQ/rjgIbAGndDfmrv8NqQv74nv8ZZ4he1EPCvZ/9vp+K/Z17YxPr3KNzY/E85kt5vo8EithT3Jw132FnWixuUv6eNCvsJkbU0hzOTUtTLTUXay3WpR+NRmJu2jL1BTRKM7S1XC3ew+Nqfoi3hGRbPw4iKrHxl3NsX94ON02l7I0AIzVT1peBo+VnLv2uad8gm353dWvKkzFPGNtpTJkKs4AAmIV5Pn9rdiS+vYYw30trvvBNus2yE00QJrWe/Eu6x7/cIsgsFwpb2gk6JmFeqqv0mCpH5Zd71+J1VFkDnYl8nJiNV1jby7+82DU39+9AL19+uy5xZXXNVHT2Pse8zE6c5VkYS2HvYWIxZUSEz/OWnkJmb2nfsmdoLfPZmj0v0/Jl9/Gv/CGssXwhNJOpzGFSsTGe9CouPu+nxohQ1jQXzde0R0NFWyJg5VwtYffrWHdIzIvAqLIGfxV8wF7oP8lag0aprT4eGToEM1gTO+7aC2UW4tgkPhmjJ6K3qzuZ/97zmXvjyNNH4o4fuDMmAbEDE8PJnC75mKklKs7CpDVawxppWw124CD7eUnhq+vdHP5AKXocYEefwLnRXQRloE8wqzVEratuPM1ljCjrciPR9gRoJr01WaqBCCawH2itR++N2S3KKWogaid+pM6DdGMenGZCzDeQC+48EU9N4ivB6ljv9VNsqsMMDkyVay2dgZOcM7QwjubKYDuNADTMuBunYnQMjRrBJQzYsIA2bI5kxAKZJfNVDEWXTQxswATrzR+EZIJIezTHE9RkNGHfmW8h6APfq9BU4euUNEzUmyAPU1g/K59/fat8t2vua97XYA4e0bSQlqTj+nqp6TJwRQt0Wa1o9nbrrbfG7/zO7yw5TXBj+O5PfvKT8aY3vWnJbwIWTevuv//+JUlojXSnmZ7huQUs+ge9853vXHLtS/0iaNe0Tt+mvLS1/f/svXlwpPl53/egG2igcQMDzIG5j53d5d5cLpcmKYmHZEmULVlyHFkVK7aslO2K7f8SVVIpx+VUOU6pnJTKlZRSFVt2uWTFjiTLpi6KFmWJpHjufe/s7pw7F+6jcQONfD6/Fy+m0QPMALM7K+4APxzd/fb7/u7jOb9PV/zgD/5gQtWzPFH19Jd6+umn81tuetXsO/URmsPGPc/jm9Ydi+OPRTOw39W2Kwl0YxrBamVlZvX8TxPopnx2L+yMHthlkHbGON9TrZQ5+IETT+O82hH/5Cv/LP7DS1+Kv//0j0f7eFN8utgTBxdb4oWliRgpcHC5ISpV46SUoPZgzTVJHkzJjp7e0U68DKDDWkqmEm6OHkVbS/nhr/24cWEMFjureYqexzmVWJdVvv1mB79+MY0xjUbMg78+eRBKnOhLIThBc5JcehzefG/9s362JRyncXZ2KEGKd0IstENCigJXauyOUSSwlwIEK8z+ZL7S4Zsy2lr+6Vb+SSyUIDwssYp2TGJjO/2Y5+OBryRYAI6cKLvxnTnaou2NTxpWiDqfqu03r2St9H+epzVn7qQv8mu1Nbi77yVAmwowwMwJmXgBJZzDW9Ws3N3abSV3+jRJ77N7Uw/TpgVMDAVFURjhn/4fMqLG18mk4K5V58zWkjT6uvnBhQTSwIjKHNWO3O1msr38Z9W/tkG/uOT4j+bydhDwmg+/s3Bhdd6u9pUTfK4Pou8jzBlWd+dgFHFKB+Ug5kfYV0bmo9CBpmUv+1OKn+M68I+YbPOTcaLlUOw/sj8O33c4Og73xpmxs2tjJcz1un7ebHhWO9n1lZgonpLYT/47NQPg3ivyXgKvYc9ZqmYamupSbyzO7mdvxmy450y0dl9KdZ1bJOYP+7mMnoKT2hmidqZ5EUaghHYAQVijiJj8TCMwE+TFc0D/M/c/gXtaeX4KUJlJNOXNrKlONNGFZZA0IcT9m5ifinH+mggh0dnSmvLUt2cRhqRBZDl4GOvvHtmwhF8VZ03eNynoK32jyZtMSrZ/wLjQB+6NHA/ZvUxMfZ3SnkR758fRhCwBPNF1Nopdb1AOfk4wV4swkN4ntHiam7bdxpNxArrgQ1MLY4p/TyPIa70ANsh8DWN+tgw4EDwXt9Z0fN24CdH9e7/3e+nvl37pl9a+/eIXvxhf+9rXEnS3Jmx5El5cczy1OefPn1/nb/SzP/uziWH5p//0nyYwhX379sWpU6eiNt88n+28GqOpD9PRWt8mn//lX/7l5C8let7Vq1fjV37lV8IyN0slglcLrjGN8K5QHIP5fi4WBj8di6MfZVgmo1ocIeBvRi+Yxy26bbMidq/fQz2wyyDdQ4O5U5qihuKH7/s+mrtEvKOH4/qY0kXli1k6hbSvn8PwFTQhZ9gIOWIUKW56SEiktSOVNF+PEQ86iRO1Ofos1BLSq0Xc9sV8MofzjmhaIhAh2iS1KslMgxwRLlKf9cQbVxKx2FXsSHWtLzfXdFlfGSq/r7/nthXjBhHtpgQKoPyr5FBY0gTRU5v6EUPqYGkfqF5zKcJ7BfMymbXEZHLv9pLP+SfTtL0ns7vV7klg2G83Z2Dbvb7RdzeXtkKbgO0lwEginSCiEuIaN0pqiWyFc0UioiS4TbbW+t+KuEg3vs//JCoFdGhJcOcQzBJVJMdgAWZ7mijvagI/vCnrYJk9/xZYZ1mbM4bJ/hZhcCvJvpHwFXRjLfF8mev6fAkdj1s2X916HJ1DSuYTSAPPf5DJsjXt68AUqqulAyFOI1qg0RifwwfiFnXJmY/6uja0jEah//moTg/E8uxBtsnemJt8M/ZMN8aDex+NS2NX4uL1wSgdRUOz1lTIw/lKXC2CQnkKBov5dWbibIzOjWNCRt8yZFtaZ+TnPJUZKgJIkBLPOk5JGLXWnlUtB/elzNGOZIlxqhxDe9TLnr0IMMPlAMiNtdqIDw4O9KyLFKA11Xut8qmfxmHwnAv2ocAHChc6mjowmQJFkSbIiMtIWT+FDprmLQO1PQMi3eDCGEwTSH7MgTEYowpgNo2g6LXDHMkE6Vc5h1/S0mKGvLda2aShSX5Tto8fZzYR3KI61wuTwrpFM9GARsj9OmlLuc/yU+LmRpimpbk9MT/2sViZ24+p41S096LNp83L7EfWbZ4gtgmyXf8nH1x9XpPKNCbksziLWTeM0tHegfj84U9HN0zShZEL8er1t7AYqCQfO+u2UdJEbbN5pvboF3/xFzd6LM6dO7fhdS8KA65WSojw7u7uDe/zu43SF77whfCvNhloVgaoPsl8PffccynwsWAQN5lu1j1gH/QDINQwNxQTM5xtDWeiaT9+ypMPcQ1ku/IlxslzAua2unH96rLc/XgP90DNqXIPt3K3afdcD8xjRof4MR0Y6zdFCB0I3nYOw6cLvWhIivGni5iaeJTklG9Nb3itDR8eCdLV4yd96/t5mBoP3I2eq8niFm+zAyxpk3TQh7hV+yXAxDKH/TzxmkQ/0jY8P7zyI38j4sdYHRIT1q22rreowMZfQaQYG6axgXbTfsvUbj/FCJIxxDRFs7YSBI7MWhUtgLbsxrURJTBBJ+cV3qAE6+bhLc3jwZvVdaMH1lq7QS6JbFpjDja8YcsXcdqGSZ1lPDVXMUlYpB/bv0q0lSCoHO+1xK20ZLX+a1fv2hvroxZFxsh6JKIylb5aZ+qqhmGZuTS9ihp31ypzFzK2fbWp9rNjkMyQmGfr76p9Yv1755X9UUKburYH0EcFGK42iWnW1rREr8ywj94i48R8MreX1PZ+kImhVaPdA0G7pwxq1up87ALgRKhmwWe2m9KuU8QHsPtN+oB9DQapOrLCPtcWBwBgmFyYQMuUrc3aMdDU7dIEzNP45VQnv7Nfa++5ZV1oi3nkjJCvuTaFoapbRzCFQmDzZ1JzmGLSVHtjYfooeTD/G6eAuWbPZNub1d8IZqpkbJpNBtLyRubHk4apNUFwq7nShBmwBJghte4oB6KNIvVpFCVRrewCDMgYWs1p1pUCiHmCaje1oM3HDDEzp8NUj3m5uk1k9bVSMiq2GQZKzVYDczHm98TizCmQ947zGZCQfd8Eqe8q85RwD81tmU9jAlpgv3U+LoHUN/YEzNE+fMlm4tSJ89HSsUDIiiL7biFpO5bLHZiMg05HH6jBWiLERWKOaK/WBAq3XAv95d741N4nY6BlH5DvzbFn4NE43XMyJhamEIhNx9V3b2YwUmPu0j/NODdjjt7vItUu3S7JyNrpCj37O/YlKPd5EBOrjeejvHcQ+8qDCBWOMX57GVd6tVF0u10S+Xb9ei9/vzv69/Lo3qNt8zBAnge0LQeDpxZ/njUeOJewG78A8SjhD1ZSMiXziN8seWgKcGCe9UmJskSbNtwbfV9//2afzTk7QDNvHPNqYpMWXjgvYwGm5FZOtOad1fDmem5W7mbXLb+CZg2sJoKuQz5AGHhNxkhI6npABLU/zc1IY4meJCNVAdhBwk2NlmAY9b3rdVGk2gutmHfILEFAcDjd6EOkxzwn3G96No1VdnjV+n1l/ZbFMVqTutY1Kmckb+S9/gav6w+m2aL51RJ7fpczR14XErieGZYo877a59aX8P58asL0Q8QrmbR6xqi2BOuXnNGRgCvt/jClNHM3mL55/9rHOYOw1XbZF83rQDogihE8tKA1wAMwRpabY4m+Mm9NrjSxrU9+59qTRhcm2y1Fib0oeCa/v2uJrFPulJnPRcvSV0ZNyNIsWi32oO3XgCcSEAF+O03D0XpoIS5emo4LXz8XDZjYlY7iU+OGWTceaqcl+A1gKuOWlct/+IH804Z9QT7pOdZ+bbJNtWsqf5+31TKc7+k647Q4cjoFhFWbW2yZwFfK0A2ZYEZmTU2MybISf1KbP9XUH0nzOBELZbqWaUdzqYn9F4ZDhoJrmlNPwjToazI7rd8lY01HOF+KyQeKsAJzeDHNpEGh4e2pjkyf1T6xJzh72NtWyL+gpmhlXyxPH+fvIJojtL6taOg6z4DkOB69rR3RByqaQZArFQAfrDNZVxfbY2H4iViaPhRd3ZU4dewcDMUE6zozqa0QfLurpT1O9x5Nc2BsfoJ9bI589FPVH6sQXaCF9vC3t6UnjnUci95SD32W9ZF93N7SFu0AU7iPHQGt8FZBVGvH7V58PzQ0FKVW/NeAV2+PchzqOhBXq9cRnGXof4Xy5SiUr0cB7d/ixEdicfIE48rY7qYd2wO7DNKOHfoPd8NHsR1v5LArYxLmoScZOwMh/hLgAuermEd4opM8yrJD/ub2lpQqAu3r93V0QrrZJ7cXy+fmMmqvSAjmKXuvRkAfE81GQMCDiDfA4QeR1Bt50GLZHvOYsnBcJ7NCy765xzR50pIfW3cYHcEsZHiEQ55TsiulUpNsW3J2bsqiwstw1SYJBLVzPs/bTAoK8SNDK9CFABl5UuMm05QxYutHUvpOQmXzRL0hSmZEoaION7frxpMSaBLQ3mP9bZPScIzAbtx0B+/yMmvHvj4by27GxLOlmJlz3upen9U8qBk/ig8TgySxZnDefK64EvLRVIAhYa6zfCMEs8AmmrhuhAJZ23e1Y5VfN98Cms5GyppDCjwjsclcbXJ8eU2U6VrJ2VP2twR0e6GcKuW4G8g3xZuxLrxXk3i3knXWzDPVnfepb+icdmKnKWhYmptIDFw+l7ZbD9dYI0FQW0/SFweJEYZQpNCCBj7tNfko3Mi1QY1bqpTrAGJeBDcJxXSx7n7uS+tFQYL3uig3SRL0+fh7SzLd4zX5hJL3CoTpUuVw0h7J/ZTKxK/D1El4a8tw73Fs3HMSFDt7kmZ81jGl9GKdGTtM4arzmNLhL8ToAoONdhDmgqupGWqG5mYwpYI5Esqj6NivgPa20JO0OSvLXew7GXlki1bydvGhAeCLlAmMUAN+U9UVATEwCYQZL5QIRNr1Jn5Eb6M5qkRfW3ccaO1Oe/z1mWvMKU151eDjtzR+XwKj6ERzdOzouejonKCtmD8D2e1+a9Bq96SHuu9PsaouAcpxcepKjKIlE2RCv6Qy/qOHOvbH6a4jCdFTpq2BWD/Jpnx1L1OzJkz7Y489Fp/5zGeSSVrWYTvr///6i/8kPvaXPplg3AU2ai21xaGeAzG2hEmlcekEzWCuy9w2M3aoAxnnJ3m91Rmzs/pwp7V2l0HaaSN+j7R3AWZiikP0sRMPpUPkIjb7b6EVuY70mOO/ppUerdkBmhNUfilBpBlGbp5Q80A65PVT0ZlXYjR/vvaejd5L0LHFrpFftyIW8ufN2wNYTZZ1mlWzg8R4q2Xm+dzJa9Yf+LWgNTLdqPlmuWWMj/cZTK8VjYdEj6YqEi61SdPBBQ552J1EwGRO1Trfq5XD+RgiNiOAYX6gPb3eAHKTtWisCfQq8bNZX8hSyWBumhj2OZzTUxDH1Mub3smMESRgVfIKQSFxMqcJZDL52pzo2yxHCRuJfiHIJQr1qZFRrG+LfSlj1Lyqxdssv9rrzqsm5qV5b9VXp/b5P6v3Mj0ySbbZHrUdalYbNW1EWOH8dz7Z59PI8+eRzt8uzUL0juF7InOVmUfCbDLmzTjnT1HKrOpPXhV02GdZyTfnujYuzBnr0Ca6ZKmL8aomZ319UjJCfLMcbs5zq1ey+QEjBMNSdD6nOZ/tUV0A0SwhyKiosWUe3WnpiXlRW8OeVl3CxxHBQQMCDBq4LjkmwCDAn8As6AgD+EAU2B8aWa+8ZsT3+vWQM0ZqeHxvyq+tZc4jyVyPOohoJ3OUGKP8BoRci5VjsbLQyRX27yJ9URqDOVW44Tzge/YTYxQp9DCZXwuaNrXeizBAK/gXOo4FCF1jFjmOJYQ5zWiG3Yv0vRS8YJa+nJyeSM/EMn4rK4cAjTuIP1I//YJfFkiA5ILoiL05NYd/vqFapTLauI5LfLdIsFg0MwtoyRdh8RsxaQQFranzrRSzaYUAsAp71G6q9ZoiWLmgGgpctOJcmjjO331AsU/HwSPnorltDMZnHr+zaeIuzSZNmP5OZRyw1C53N3envyPtA3Fh6t14a/xiXJm5Tv7tcRjNUTuB0TVRZKbTM/7dGKNcs/cvfuVfhMFYf+EXfiF+7ud+LkG7+929nKam0BTi6/SJT3wifvDnfiz2Pn44hkaHo7O9K82LUqkce2EyGxeaEkhJEuYButFQxEJl77PM98fpnlp64l7urd221ffALoNU3yO7n7/ne8DD9/XRcxCcS3GwZ38yOXp26mxcwNEWw611RIQHpkxOG0S3ZndKhqcXZ5Idsohxa4QRrZZIluhMDry8SuRuNZmPkk6Dvyp5NMBfE0RvrcnYrfLyHNZcqICfQKFBlK/bm9zdKr/tfLcdost71XZJkEo8igrUDFE3CQEgY3fjWIY5QUPUQj/iZZWImHmYDhmhBIiQ7rxxd6oDnWD/NSOJlVj2lkVN/pDi31xHmAQIn/Wme3Wt5vlba5hu3O/4GWvEs1BfJZm4elPDG3ff+p11VSOkmVQO/LEMwWeA2DzfPAf7UpMfibnauZh/v9lro/2uFglmYjvPbZbf3b8OySlDxNqQMdbXSqREYe5ltv2xHYnA5r5VOvu21fJ+TT4lIveUkfpDNJchhMtcv47/0Qx/kjcyNwnYwnl1m+T4lfABM75Y0mZSP/vZ9W3Fcm3PzXPyNhlv8jVZkjeBRFk/63zguL+FedRL3LKGmbFkFpsxC5tkdLvLlJOYCEy7kr9Pk1LyG2vQx9NcAlRA7cfKPPNrBr+MBYJ8Ns5Gsf1dNE9Da4KMvDj7PE+365NkGmeDa4tN2qM9mKcdonsVeAhbjX9Q4zjjptAkS7kQJoE/kIV904SGaAaAgjnM5XgMBpAYbAg2VHi1EQS3wPeCMSwmIQUmbrNTCba8AiBFg6Zz808B8Hcfz8o8i3oK82O0U7gAAEAASURBVAU8fa6JKbBuG2B2GoDyFra+tfcd4L4HQdakPLVmaJACDVIsGWQXUy0ZSeoB95dMdp3bMmYjIObpvymc+VIFZmzqUUzhVmLPgTOxTJ9ensFsGc2Ye10VpiVBdMMgdRRbifeENptr9nNXc2c8UnowjnQciqvTg/gd7SFgOkydKfXrjbHwks8twVC6vsbwPfsf/80/ij/5ta/E3/lv/04Khqvp8ZqQhXXnGpVJ9qeF/aXE/u2erbDH69ZPeHVNw9MY2tZbpLTm05pjwFP9HHjWEO9zhl/hhXm7lv3bcA7VzBezcZ7m9eTRVC8FYamMVALmhYzbs8+9FR//gcfix3/hp+OxLzyFJnEhhoC/R38YPa2d0Yrm0DbuwTRRs8zR2TEMz9lTyapB4cBu2tE9sMsg7ejh//A2/sLEu2mDFG3tUCfoP6AV7SVGxdAM8Qw8KVeTdujdODw/3Hs/phlCezbGa2NvJwbmxl3ZzfqgKM1Pvig8lw6APKPbvGomJHGfiCi22HkI3xYO1WbzSwREzQ6/SV5u+kobEzPHoTLnQfQBmdxtUqWbLjdYPyBxJW6V61pnCVL7cnR2fN39HliaJ+k0T48kwjI7/DbvC5+ZAT2onKInEXcEh+l0GNYPBlmUNBXix+83TspTNy+r9hmZIeOezCMlz5mODQ/q2oc2eW99Up0hjvK6ib7VBlMpAy6T5J9MUZofMg38bCvRrOR/A3MlI+pIfC8nTSXVkio40FxScymZQ/s4660b9ZcIu50/Xm1bJbQm0SK5zjohIBuElmc8F2CaqpRh3wgbri+PDLXlpkSRid1JGgpmkhoWftRKug+kucU9rWgCBFBYZMwkdhWwqA17T8xKTQOcoYJDCCOtVrt23vleTW2xbQ8ShwLM4FTqm9p7arK67dsCcYWWJeZ1QofQl/i/eaOj0cSJaQBBrqk8FMszB2IZ07cqfw08H83DadTSc5str9S3/Fv93vomBodLOSreWmW5tlQ5ikkc2iP3Xf8AaMDbEe1OvptneSWiGIq4kfnk7JmdY73CAFRhJoSUXwaRU1+dCiaEi83sSyyNsZnxqMBATU5Pxix+PTK4jSWenjuGadzR9Fxz58Voba3AmNE/DYwvZReJAdXYiICtKOAMxDJ7g8A6CaiG6iRpiu2zTxBqpSSmdl4/6uh8m+aMEkJ9bg6N9DSAGROPIxhojP6Db0Vzx2DygREp1PXhOeJ6Fk6mA+3hgc59ifmnkin7JEDgXTfz3D9Tfs1ya5PX9QfVxK6CmfFLw2/GtYXR+MjPPBU/0//X6LNqvDx0JlkAFIFw7+jqJJBuJ/tSxAlM9j6578l0Fr02+hbroRT7mvvDbrgwfTm+OfxcDNKv9qdjIgNF5deSa1pBYxkmViaxt9Sb9qsV9nfNGqdA4qyg3WnvbI+DXb0AYrTExCyocnRlEeAOIdFT/dH42XZES6w72BrWoOtYoCAFZF2lzsTgjM9MxkhlJJlWapHQUR2Pvw7WwjKCxt9eOQyAt1pRQF1asn5cZI8Ynhujz2ejB+2cwA0GBpdZG+EcE5DI+yl8rU27b3ZeD+wySDtvzO+JFitp9aA72X0kmvAzGJudiEf67o+vXXmGTRGJGZuyyY2wk03Ujf1Lz/9x/PQnfoI4EV0xhQSxPilJk7AqgqCkOY4IWRJ2W0m5f0VOuCglT0AG5NeCFFCNiAfJVpPSOw8diXY1G+8XMbbV8je6z+qXIRyNQ2KyZ2yvB6FE3Pg8ZikcgHkfKPHMNCgZkZNfTw9v8s8eMrgiHgMQrJlkcKPnvJaOLwmHTbrVy2q6EAxvKckkyRxtVN6WMqi5ScltlUmXz8P8oNWUTm2H2h8JGk05N0tKWSWczSMxE3Xzx2siJJpE6fteT85/pbWOm2OTxq+GAEntlOyFOKog491OUqI9ARSzjKg9sQRh2iJBxDyC1OdHPzohxUFnTGiQ9q1+Hsw0xkpCVjRLNVotEEuJ4Et1VGgh45U56jtHpoGLr8Ak+SpTkxqzncrW30tnWBeFK76679QzzIJHdFEHgzrnTuX12dz+MwVJzJu7MNStaIaax/joaGyQvI7Za7H9PLGUrqyCJ9CX7LeawNUM3U0P58R5xtBYBGUyHmk7Ndv0hDMAanaxB+3RAN9n2qME0IAvj/DY7qPL+oYwdySa04M8Mg8YQ4oXx3jqO5JpgMhOZtf8KchnR6ZGozLNOMFIud7MownQhgKBdZfn7kM700aso+HoHXgj+rrUGq/EGPDqy6DGpfVHZssIMGTGlpeYM8yVm5LNYDf03EnzhvKTJQJ1kEEZQWs1TR0WZljzlSc5W7rj4MEL0d8/FROLmgM2ZMy761mGIjVA1Lt20FgxA3cjlGupSWtMUc21+rfekzR2DNQbY2fincr5jLEnq5fH30abJQAG85c6anqpJtuy3bPv6zyemAbzbOX6ImhvM1gJlIm3dF8vGjDm0R+8840Ym57jGowd1z2PTems4m2RoMKOkxqocgOMP58XZrCMoA9x9UlrzthN+rbOk7fnSEMz84vynStLmlPCTJWa0dBRZy0Upg1mzhq0jFl8yCqlGUD8AWOaxgSWe/kC1MqG2FeYAryiJ16dZA9o74k22piCx7O+TLmQZBpz3AJgJm32M/3fiami2vkr+HvJJO2mnd0DuwzSzh7/D2nrG+JY5wDSpEWkbO3x2qUzcWHwUtx34GTsBepUCXA6Tvg3w0GnHfj4zFR87Y1vxl988kfSBrxRwyVK1HgsYPe+wGZZhfjUTCrLbKMnblyTiBKeWfjlnLixDppVLbGZt5JXIopvPHLLd565xnYpINXSzEzJpTb4ed63fPgufZmZDmoilREsFpPqQ2WVuEv8znFAedWk1FGCU43AdlJGzgqSsPlTEj+awimdVJOy2RgllCyIl632m2W/H0l/EgkDx7y2bN8nRgHtl6n2u9py7WPnzugMMW0gkLpbupMmo/Ye3+dMkpqQRKzX3/A99VkNDZoLCKVMm5AxH/p+YSyZCCSJJBkFoYmXed3OcNhfYwAaIPSPQzCi3WgCutBAEk0oZSNRpQRa7ZSMSDJn4n0aA4bdurUY4Fmmui45ozOtViHaIVzLaHpMmcY4vX1v/yggCQbY01xHVOrmxLXN5svNN292hUxgPJaniRUEsEChpNbXwm4x7xNAA4IDtElrqF4b1a+myKS5YA4nQh4CVKAEUwPmaCvklwUQVl+i9ugExLraED+RsaAQpVHqSZnMfU2jzS9Pzh2ZkTCw7ArPLbdDHOMvRr6FpiHaNMmt6J9gSvRFkrExREIBQIeimiP2jOXJU8SI2k+RhITovhY9bcJ/t8b1CgAIszxDDum+VKiCk7z027/aZpmazPdoIcamxoEuh8mZeTyaVvpiYOBSHNw/xj2BJgUtOWOuSd0izKgMeG5+1sK+1oTpn0mGYaWw2p98tj8S00g5vm6WPJfcJ88D7jCHsLClDPOv9p953wDaXQFmF5YioZQ2A8vt/PL87AAZL98Ly/TLwuxklFvL0dZqAPGl2NvYFz0NHVHBTLOvozem9BVL/Alra05Ta8xSG2GZXGvcP47Pl3YEKOPol2w/1lJDTaABdZcYu3a0aiYBNhZnEZLNA7feDNNGPduok4K5hupgDFfwTeM7smZ/pRzmSQk/IvMXfZFWxbFmzbKrMUwAdMNqlHnes2KashSE5m1To50YUhhQ54jTumUFbRKQ7HPTaJFSjXb/7dQeuPkk2Kk9sdvuD1UPlOaLcaB7L9qgnrhv74noQ0rUyiZ4uut4jE9NwBBNpE3zVOexaEXCNTI+AuHjVrj5YZJ3gPckkyvssyVA9Ue4XfIZ/U44unECviHN97qEshL+7TBIlufmrDRPoq0J2/x5zDjmMRlQW3Unybp4SEgSenBtNwnLXVmqJJ+jkqaD5MXpnLLxsOuFiJ9sMLAs2HgQCV3NXemgzWzWM8J0u2Xe6n61KxVMNTSBaoY5pXnrkv3nmKsREMI8EWvr7rh7H+xftZfGYNkoSYhslvxOEzyZI4N3akqiw7cmOI5hfcqYJJzF6fM1f4K6myRKLDKX8tZ9/YF8dKoIma8Wzb7JCEmYIwQBEnl52xwzNbgYM23Q2ltXdQaQkyv03RW4pIegxvbwegUZ9QpSYTtAxsi/lGqGQFJdrXRitm9ZhERqRuRpDqfDv1qpnEh1DNw78rbcMqu6L90nZLjKK5rZ3ZyydVtT6Ztvue2VBhgCHdBXqmV8bwAlAFigAUj0LaWkadpa+clESqKenxSsliCoGMVCLEtyoDWV8Oe9Or7l+fZUn2zHo+cwZSuUJnjV/I9EZyTtUfYpaWkKLexj8134Rw1Ew9K+KIA+h0SLsRlFQ3SJZy/zEL5pmI41KbQhD5ktwRbUnlWnTwDI0IIJITDcPWPRSdyjOczFkpmXeyO3bjelNcZDzgU1mjLUFUy/ZmcQbM09Go3Lx2LvwLtx4MAoc02GOyPIFcolHTvVdC6ZnD+ar6nhtN6uFZminPFMWhiuG2son3vpwZp/ClYUEOnfZgBk9+i2NhkfEF+Tv1Pm17SIn1azjIjjQk1S6TVaxRbO1WXgxsttLQTKRYOJHxU68Pj4wOOxZ6Y9ri0CTT6dnSmLBNM1aG2pjIXH6hmjVs1Au5MLk9lexvp3jRRaKBEkQAE2mlx7mH2KPLgIWIVB1dXqlggvYftsv3DqpSXCG1CGDGUzkN3G0UrBe1nrZQAXBPAoYk54tK0NDS+gF437aJGreyWtb/Op2N+8GiuqFeuOHixKZJTyme097cW2GC9O8txu2sk9sMsg7eTR/5C2Xe3Br33jN+PEgRPx9z/38/GNq2fj628/E9934uPx/MVX4z8++/spfsQoNs0n9x6Ov/UDPxuTE0oVt548oNzEJbiQBabD5XZPKzXT5CmTUGc+Cm66BmAVyvtOk0SGh29C3WMjn0K67rXtJJ+XQdOMIkfFygiS7eTCoc7holnCAgRuG4eIpiQm+0ubeDV6SgwX0KBYniZubcCpznOwzUFM2jfbrXtew5wAyQ/eNEYQIkLeSm9ZXj2xoFZAab+Hfwb3vX3GMC9/u6/JvKWopHd71Jb9NzI3npCvZB66WvQ3QOLPz2Z9532Oxww/mmR6yOfJPlHDJ3Mk4lftd/k9H8Sr4+UYSjBlxFhWat6m/FXJe5H25ATzVuvm8ysLVcxwVuJdpMT7mwARYZ4CjxYLhTZKz/uEV/qkUKIuaBT4YtvJPtVvQaf5ORzzMwsoTIgYO4N6rjFhNTlbP/tgw8Rln1G40l5tTVL8vD+83zGTgXLub5rHhhnXXYRBSqh01GWZoKaNAjCUBTjYpF7543RZAi7YrP75fauv9g/DmPp2eXEfcWUeRsNgSIUN1l8qevU69Sg0TScobadwtp7zccszN1vHbg7G6SJ783W07ZgfIjSrLhpLrBWdSB+gCfgloS1bS2S4gjZrYfo+GCsYKlJHz3V8jxBGQMCPTBNdDwY11X2L7VzLmzbIkOSPLaP+XigsJBPplYWDEO3Ho3//lRjYP8I+njFGjq9njOAhN80N6jo0MRqjnZNxDPezNUh0+tWU9Uv26tzIP6/VZ/WNc0XrgyJMUCfxmATNmc59FlfrLBNicn6Z/QSIjeOLU+w5XSlfBUwKD2RKZucyrZ4+S8e78P3taIzfvfDNpFVagHExiG0jJnGazuXJunlNocgMJnLAUXD/Cn5JXcnsTQHaEgASsFB4nmbAECX2CJmsQt5X3L8Ew9OMGWxrmbEG8KexlAlWjPGUeoX4RsLZd4Bo20v5mtwuANSRJ/s4gcLAmDexD+1v7Uvnlf5f/tQm26sv8NqA1n65+37H9MAug7RjhvreaahE1k9/6i/Hv/3Gb8XgJGYfCIQnK0SHZ5scnBiKRw4/GJ88/fF49eJr8S+/9v/FT370CxyaSiu3lzxc1FJo899ZBBp3CzlI3LVjFudzmsRhsMchiOyU8s1vK3lsVkvrn8M7S+ia31aSB1QZSZkEne+LHDoeyUq/t5ryuvu8hLpdYVvy6+Zj/RIjBhPW0oBpmfd4ePNj2fbNHNK9FOMm3X370mUumjB9aCI/mS3NOzQZyZkkc9Am3bY0IelUq1Xfx9ZXxCupWJk0CYEPIkn8GGcK446b6rRZ+Uqeha3Wqdt6d5U7kpZUs6/bMTYyq20NMKPMV8E9bKfPyDxJ5JgcC+dObf9tVpf3+7p1SbFdmAcbmbHl5cmEO6bWdatJ+n4ZSX11kHkwCWLXSkc8C1OkMU0JyXNRzUlNZq7M+TIIiXuRXHfeIOZqbrnlW9uSaZc1S8ok0tZX80FXwgyO+fZxWiMSiDJ8PHMr7a95zgIFXWmcgTjNiL+8Eo5lGreNGIz8pi28UgSmZvhdAEtdncf3BzO7hpZRai6DUttDq5mtrnPhsdPXiZ/M7+NaSvlnP+TX3CNwjF9AG7YasDaDCM+euPE/vz+/kn1ent2LxgACWVQ4RhGkF7QhvAplLZNnOTAgDYBJNMIENaC59nMrY2lsu3kACGbwm1F5lO5Nr2pyBqI6c5TJwqpsAdgDDdrgHEAJ9Lt6xVomJ3vyFkytN6wm90X7x91RhsfxmoZZXwa0obB8Ijq7JmJg3wimW5wBVGoem70Z1mnFcmuY3mRKxyAJZDAPoz04P0Sg4xsWA6l+lJlrkgR+sOy0r8NU1A5huk5eamJLaJrUtOQ3ZN2Smbpa5lwOhsP+qd/ri0P4ZBF8VuACzxyBMObR7KixkllTk9TMHN0X+zFNLMe709e4ZzHa8Wsroo1zfdUmNYBJ48MzS5gwemjrE7QwRzsxp1tmrCr8WFZbc2t0ETtKryaTYBKujQLltsP47C/1r5rgUgp957ricEj9KgLgkswUppXJ/9TvapKolH0InJphojvYE1sx25vl3qXEJGU35udHdxnzPMd1N+3YHthlkHbs0H+IG86e9cjBB2Lvj/yt2NMOPCzElMSve9nDRz4Sz51/Kb7y6p8C6QkxzIZZQWqFW+4dNdjjUThxfTzyw+V2GSUmIfnkaIPdkkzOtIN+P1JiGCC2MLbbRnYQaJgruNlnTA2aLupnu7R/3yx52GuSp5mfZh5K9T0u0jXaI9hAfpjU5uG1unOJK2p4DIoLk5RMBTPCoPa5G++N84MWAa1biTIbeS7VgdKrHKCOsw7aahLzlA4yK7dpymBrZaAEz0iAHKlWmz7wnr+QQF6if3NQi9tl6DwWjW0UdKUC5jedaI16IVJ02t8KQ2O/q51pK8igZ/GmfNXHxzlpUsPpexnKreR5uzpv53vrp5+N3a4QoZb4SIQhX+i7NcO61XewltjLy3Ee3TTMXsD8aPH6dBxb2htPP/lUdPfuWV2xsi2u4htPevsssMsvvvZivHLtHeJ7cgVCyTu2mszVurqGsiDGNivT9AoXvAxAx2yS1JM1RFkXYynxNwkKnVoiWSfzWJf4qEmVzLF+SJkEG1ISgnsSqX4FR3YJxfeWWM/4jRRAolvSxE7TN9DqAq3NZh2ghD4RqC48OVFjAsn0J61T1oaM+eE6qtzqktDUHZjw7cfX6SCS/27GByaU5+g1IMOzvWtl2TzQQGNatTaq3LM83w2j+7HEEMkARSOaIhi6QjP+eM1YArB/COAg9HhgHjivMAriXEMqTVozs0cQNNUGpXPBvQ/maBkTrAl8j4i1ZE1K7RhfFga5Pp/5KK2Ohxpck3uOQh333LTX0Pf6k9Yn15Nz2Z7wvPF519wyGpNCoQOerit62icg/FmDPD4BwMc1TMAF+aj1zxSZbQHmIZmM2ZXkd01IahgW94I0k6mDmulFwA9kWDRPS1p5mMYSZnJqSBSsWJnk44NZnT45/qwN3WoDFELkDJnnW4ovxXNqd8+Mno1jXQfj4Z7TKXaUjJiMUUtLSyq7EYakgfnsM5UKewn7XGdbe5zYOxDDmAVPzsKAJ6FENj/yuSVEewFTvSIMoAyV6zZZIQB5Xk0gGICt8DywGjG1DNACTIoWAN7ThC8SHR0d+D4JYrS0gG+TmnaYzYJjw2djbC3C/AwRTPdAK7GOCBo/vxoA2rPHuGLtmOLN0X+zMGb6yab1Ctxh/dICTmd1RtSP+O7nndIDuwzSThnpe6ydamjc+Bs5EDy8lKwp5Px33/xtEOom488/8lliXmBDrB32e2i7z2qvrPnLraTe9UVILHlKecgW2cz9nF2rv3O7n4VIRvqZiKybD+vNcqvf/CWk9W26lTZH5Cw1T7bBtEYE0N9VCG+dqVMrV7/frOz8uu2XmGjjwEuMEpqg+vLNr0z7ypg3KKFPREEqRYIhIyr1x/HSNM/7apwTATKcD7frY7VMrZiHzDVAWEFA1TJZeT3fr1frokZIRqSWGdgof+shASzErERUO1LUPUhRm5nf22VkLNfxbYVQkOmqnf/2fxafSSZJU7DNGeSN6vlerzmerqOMnMxykwEwKG9Ca4RgShC7DmxN8pPtcKolco917cr2D14y5iB29Eu8/8TpeOSxR7Mba57f6K1S+MvPD8UgcMPV9tasfPcS+uh2yT52XJIEO9U162WvuxdJnDak+eWcNyg1jt8QZxKZI9Njqe83K0OYZ5kkGSsZpWnMfCdAVtsQQW2zTG51HR+fRoKdVuf3geTWC2ZDF1rlHNWzdrbY69QfrdiK8NX0dlSdj/iFJP8hel9mKZmxsSfAgFTRSC1NHcfvCBO3JeItkQwA3UD+DUWgs9FWFVqvcw2tm0wUZn5V4jJVQZODU2U9QgTrmyOYwxJM1RLX4ZGWpe4FbeA5ocqDILKlrnOg613mOxhO+Okl6rhQyRgGqHMKlqhG44F5VzofZNiALJcha2qeirYuAq2WbQNm0aw5hQn+Ocfse825jIVF4yG+9WNbYSzwsalbM465DKR/zqk0HVK7+ScQBiaTnc3jzANAGWDGhgEsmCJ2V76u0/NoMBYBN9CHJz1vc2EmppanYxTzs72AOxToAzU5+Z/MkXWZmKvElblrCdCgg31Dk+ZWNOYtaklWWmN/eV882Hsq3po4lzQvVRgJ9xi1gjnDbb1FmXNVudCMWffs9Veir6k3uglG67wtob3JNVj6T1UXVmJ0kvhcMEMdbR1xCuaoE1+lefrLfd2YQ2uaJPJMa57p4l6oeZyWDA0uXoa5sIR5JO3Bio46MRb0wyR1UsjQBkPTDmhCywJ+r84N6813Keiv0OkLaqtok2NgKW3luA464CkYqk6g3StNCkuK0QuTmUN5Y/ENIiSx+9D0Fps1P85S6g/q78y3n33dTTu3B3YZpJ079h/elrNrvXn1XHz55f8cf/sz//Wa+UoVae65ofPxqQc+Hg8OnIwXMbFTspU2uUTE39l2t0K+Ei1lbJwl2reb3Lbfv8RJwyEg4o6SxFpCcztlWCM1E/rtaLJWn49ErMyRjExef4n4BQgIAQ/UjOjPJJNV60+ylTpYtuWat/bo5ldbvrRQOqi5Ly+7Nl/vlXhRsqtfjbGE1GptdG/tc773HtvW2gADxk+9uV79/e/1s8Q/JA0OyDe0bRsxS/breCKCuRfiukT/SLQoYd7o/q3Uy7ZuSOzTv/a/388gyc0Jta3k+V7vkbm1bIYwlZ+YI7RZMquOpWObIdoVIdIkfJzv2X/bkvUNhC99lDPuaT0IlVxEaMLYSuFWKpUYGwPCmsd7e4hhhHnRJIyQ/WkMmp6e7iRcaYQBMUkYq7VqLxmslfptIalBsu9q566P+dla59edp8YPcwsSzXKmNA8TSHtpX35PbXESaQa/lflSUj6DxuF9Q8tLBUEIl0ZgLi6iUbkfJukADvOgxsE4ZZo2b6KyMBKw2jBDaNcWAQGBocFbH6ETmociZnpNIHZSx5jbgzZqL476ByBygQ/nfgEWCo0wRcQzMu9i6yCEqAhzmsKpoWH2SRxrfgcjtYy5XxVmbXmxG7M8GCeYLc3gLF+0Ojsvv38ZJq1YpH8EW1AbpGaKajRA9ar8cScweKszqQqzilcM44SJqvWnzMbWa9HecyVa2xGgsY8aI8t2G5tLLbdMh3HehHb3s2NRpc7et9Faqb3me8cvEdrUeUkGkA1tvmEWhMVKDMIcTwG+4NxRiKEGRw2dDJhmdc5p9z8eYn6yQ/E3MjeK1nsAdDVALtC6LKElWYCTUBt7bX44Xrr+RlycvZpM21owL+w1ACrrTMCRB7pPxbG2gXik5wG0tm3x3NCrMQ5Do5Yr1dGhNtFlaq0ddpNr7fLktXh+6OX4gQOfwGwRoRz94zNJO5a0WAv4Sc7AHJWjr3t/7MF0rUq99xC4tqkKMNLKGMzbBOcUQgfAFMhyXXJdpPIoWx8pBYkFmBoZxSp1kbn1e8uo0HeaarbqowQCaNoTGXS1cKny5kzfeb2EbyEqXLsQ3y+FaO50CjRYV0CDl2CI4M1g9gAWVItEH9t+0xJjsAgD6XkizHh+Pft29/9O64FdBmmnjfg90F4Pod969vcIotcXfZ0EoENC2Ne5hw2vMX4A5uhbb78Qw/gmGTyuj3uUeometb97XyKOt9sFSqX0nXGTVfuhRPjPItluGROle2q0NiKuNqpXdjjkMrIbd/i85l/CI9efBB4mkOe0WHIDwoDH9W3R4deyMwbG/5wyd5CsU46+toQpSm5q4vksMVhqWEgM2GZZW3cZtDyZ33aSBEAyN2NuiDCopqe+D7aT32b3SuSm/JGiW8fEGK5CHufPSHRo6mi7PeDtizFMRypIOHtFAoRQ8/pWxzvP93avdzp2GQ0lSbn1Prfu+kElhpr1Y7+ovZqDgMnNPPP22VbNN5kVED2Z1lDTSFEiJVydN7VlJ6IIYnCF70yaH7388kvxzLPPQHQ1xROPP5YIsDfefCsGB4dw8m6Oz33usxDEzB/63mTZCkFkktQy3mC+0tc3/VsjhDfpA/OzXn6tHlTtgWtK5rydPWQWwm5Gtccmyf6RMN9uPKhNsrv5MtqYxna0SDAk1coAYwHB2HoVeG3BbKgsCG9qdlbQLlXn+zBLw0yOz5q5NXW/DmPBPoCJ3tLMwViBOaoSfNYZEVwvlkcypqgMU8SfoAsrqwFpU3fL8ORJzgbEuiIaoWLHeQhrmbE2yqReaF+SuR1apBXM9hr8LmmYmD/z/elP0zu1U3BxEOCa/a7uzU5SqiMog9okTbBWgDRvbLsUbd3Xo6PVOGvWgz2QuaMpnkSxYDqaTapD0CQy+RGyNhnMtBtyC1DVoiyi3WOe2FVzCREOUBr2owJoavOa2TF7S5h2lRrQWhGcdGRhDI2Fvk4gCPLj/FBAJKhNIz5yy6V8T8WfFu2hWqFmUNb0nRycG4kL4+8CwoJGGOZoftbYeMsxODsc5yqXYpJ9oqetmyCo+ge5tpYT0IJ72jTmqi17m+IY8QJPdh2zSwicOxEzmJiuS/aXf3niRhm385OX45MHYBgQKuRrJd3C966RMmfv6f6jtF2xBswNty1SZpEzpQvzwnm0e9MrMynrdWt2XWHkaMVIWZBYmBv2QJnHdJ21sADTUkV7N0cI3XwvTI/wXW2SEWtfnIwTHe0wojMx3LSfPUYUP0y6Ybxa+SkTE6uJflqhL2cdW9pgv6UzDgbKeErLiaGrmae1hey+3zE9sMsg7Zihvnca6gb5o49/Lk7sOx7DINYc2nsofrirO65PD8fnHv6+ONJ/JCaJe3Rs3+GY4iBoRWJUbi7Hz3zqpzzd2Cw98LbbHzq3uzkrBdbs7IPbPJXSarIwT+A6pZsST9uqPsSBBF198oAx1pLaitS2mly1T5dw9XuRueZFruOzh1xiLjisc9CH+ny3+tnyJRJEWDN+1FriCwlnpfsSLXct0YkyLDK8CxzoQmurxVgnWX3Pha/63ZBPIpr536RZaDr5s8x9LxOlRtAh8LOaFf+G6Hv9Ujoxz5JgW4GgRNaaEd/voW532kbHPvkMMEbOxY3mVX21bLeaI5kjTZckfhaYy8msjjnl97XJNdYMgVKAwJTYk5FL6FOJ+LV3nDmbp8nJqTh77lwcOniImxrijTfPJIbo/tMPxne+8+0YHBpMSFiaKNUm2zONmaNokWoONkvW13ZbN/uxvv5es4Z5q/RbSZpAM+QLhTVtxJlR0OEY1z+/Wbnv63XUFA0wJqWel2Nh8nQsTp2MhqkTKXBsA9oh/XVkVFbQGAmfXUVrk2C00RYtj3wUvpWVguYnmUhh8lYk4GwDTE4j5nPF1ku8h3FB66KfEt1Bu2+xjpPKZJWxIS+D1xZb0HBVz2WaV03wZNTmAJUAfU6tkT5NRRmezrMwdleYKzIoaJIxtUVfR+fTPsqVQdJpX6jragHfKxi4lhaFXNn42veeJ8bKS2aRPLPA/fovqdV1702GZzBQVRERYbZkBA93Hojuxi6eKRAgeyqZwQ2U+xPzBEh1XJ8ZjH0tBzlv0FZAZV2jVpenFcI4L4TEqMbhrgHu6YMRWY6Brn0xNDWW1ncF5vmVa28kJDiZN4Ogf2f2RdZOgXOtgjkpjDX1aMHn6ADPHeyGSaWeglM04yM0NDMcV6YHYfZn0RZNAlmNiV+5M/pbe+Nox8H0Ojg9srp2s1lqHzhMaYJmbxLTaOiGFrRH2SCmG7J/DKfa2mY0dT3Lao5kCo1Nx7rWPwqmcYZ2qKFrJEaRyf0rEy5mpseuH/tiXaJs65K0VcR9ck9U078CIiXDQjVYW2l9rVbShx1uXlyJxkw62TBKPMT+eG5sKK6x1jSjM8CyfaS5nkwq8Wq5nyfIZo4PjQIXUYAMaAFNmVrmAgGFqcpu2sE9sMsg7eDB/7A23U21rasjXh89g/RsJg60oSViY/zG1WeR2oFS07Mnuru7YxYCpICN+dnKRfT0bOitTdhhn4cIMrZMZlqzvT5QyoyEGaZBYu92hNr28t74brU307RR9K/8QLmTPXsBJ9TmFZDg6hgOCV4dVZfIv57YlYhdQbQs45CXnfwpErErZO+d1OTmdpaIiyEkbqbF8fvMGVoghUbKutv97MEto2a8K9sqHK2Eqwfx+53M136WCMhT0jIlLV5+5carfTKKX5L18nC3yzUxSdJqxm4rYyBD4k9tsk9FVNtqGy1HkyC1bkrO7Rk1fwbilLHYDJ3N5yRcfU7mSFM2GSPNg/I5VVuv/L1aIv0eEhFDHtkc2Np4FCBmmyDKNNBbxJxJgpIuT/0+hZldf//eODAwEBfPX8iLS6/WVaJyEhj9nmZM8GjvZsm6b9ZmRjjNZcfVpL+e7VYr4airRVIrqMBBv7P6dZce+oD+NeAb09z7YizBLC1N3Jc0RoU2GA+0Ocm/CMZmGdO0xYmT+O/sp1b0EtolTeyKzSMwQhV8fIaTX5FBZwVVSKPEv5VaTdFW25MeppfUFJnQPMkwNcIwrXTAnCdzPzRM+PUUmmDKEriE84PYQ/YwAA4Gls0EWFzHHHDJPBohxmHEZHyBfkl1dC2qkZRhbUwMkIIKtPOMrdoR1437nZpGtewLmFw5Zs5jGZsrQ9dTfJ/TB0/F3tY9UZmqxDMXXo6Pnng0TveeACCgPb5x7o/i0SMPxD4EHFMwlAuNCgSMd7SA9qgtzlx+K84PX4r/6uM/Fc+cexa/ncX42KnHorezm/YpGGAeUx8RUV0zM2hkMEqObgAIHuw/haXEeLx84fmYQCDYit/mRw6djqMIDKdhAnxGJuYKKH3npi6lPS2h1aGZ0dxulnWoX5MCiAb8MrUMcI07P527rrmDnfthbOqEBTTAoZ1CU3NldjDFbvJuDGUxBVyA8UeghsZ8SqgF/c/Iv4V29Lb00v9qfyMJM+2DpPFSU0RyjdQm90iZ1iq+rsnkGCbJ86h2zzJvf+1TBgsDvPl4tIzfHhDfr67soS58g1DJ817tVDOBcpto8zLIeP6kFek+vyozbUG73ABjZL1up0Wurevu+3uzB3YZpHtzXO/pVrlxv3DtVTY+t8eG5MBsgyVw3GovYTu9WfLgNDDcrRO5sImaF0VskDa8uMF97/2SNt2Lq8yL7bvT5OFnANdGDvuM2Mxyso0yBq2g7VUgDmVO8iQBkZnyZX3r/6Txgdh9L3XJ889fPZRT8NCaA1KiUa1VIxJgD+y7nWyPNvv+2W7N3RaBvrX9nMjr+uxO62Iutsuf3G/La5qazUMsbJZ8RgKthCTfpE+TRJNMR0IWvMW0kMibQTuXB5DNxy2TGG+9XTIs7RB0jSngqjMBLQ/Q68IHT2Pio4YzzztVkn8SXpoI6cvmtFqgP4WqltCzD+rvz5/LX62dKX/Nr9/utbOzM06cPBHPvvB8vPPWO3HsyOEoQxidOfMW6HVz8cgjDydgj43yUdszhXmTQoN6pL38fuuTmBrmRX0bJN4k/BzPnJBjK4FZg1myObz3ur5FfQS5du5PoYFwnplvfX55mXft1coJ2tB5BmWHIRMwO8SMTi1SNspUevpILAvI0qwpHH8tw8l0rqEJhqiReYtwI29chmz3PtfWvThnmNQwtaBhCnymrHuNZsp1q8ZhlrVRRRsgPHRVTQvxdFpb8KcEhMB57NwT8IKnIb41sdXEOGOg/d7goYlpcDQoQwjwsSnQ5PD7cYwWIfJ9RrCNr7/57TjUO4A1w7H4xhvPxG98+z9EW7kcn3/w++LiyJX42tt/Egf7e2KgY3/c1300aaWs8wLmyp0gOU6DsDqK5kimbJK4fQswSF0tHfFQ233JdG8ehqzIIWTsomsz1xP2RCuxfR7afzrGie33W9/+Iv4/+wBIOJpCXvzGd34n/ouP/4V4CKZteJZ8nVfuHzz/1tT5NDfd70/0HKX7AB7iB76C8lfiOszOHpgYzVtFq39n8mIGHAMi3B4EBmqzUuKBq9z7Nt/PIzBMvkR8IVPl3B8nIOwMPlctrLllgBwE++lu6ooyjFYDY+JMF7lcIJo+/KWmMGv1OU3icqFCVhD/qUfSKDEuCj40u0tria9cOzJeRcZQSmCOva538kz0l9vi1YmRGC/sy6awmZGP2q0lGLa9bf3UBeAOBUycLa5126CW0ZAemt0pJLNOu2ln98Ddpzx2dv/utv4u9UALTvpJrc/B4mGWiBHOcjfRG7vizYVrd74x05PdmxyBQU+aX8QPAWlfqaTpl3lmyQNUaZQH5UbJw0hfA59RAlWrKdjo/ttd83k38psOjts9WP89dVIbsZkDehOmKU0QH2qqaom0Gy03w6zNtd/XF7P9z9YLcz6I59pkuZr2FRpmorzShsmFh+D62tTe/36+9+BtAwFqCTMeGQvr5lxT3ph+0vjeWYkyNiIwNSAZzedQlh19e4vmJWdubpFYMgls4ZxXarwZ3LpEvCAUMiXOSwvIy0yZpCu3KDS/iVfnoKZ9tcn8nS/z9E/92PhZn6GWIshm+X1oJHMI5fr7a/N9r+81z3nooYfQIhEQknlz7OgxHLOb4vrwUPT09sbhw0c3LcLekBkdRwKtP4pmpPXJusu0O09qgVK8LoOlCa+MKR/5VYMmk3hzEGM1Fz0NmI4xJzSrcm4wQH8GKZsDhdJo4jlSBXKGRNQ6zOyK5StR6h1Guo7WqCkXpKzOHRkVG/tBpVuUZ18uElNnaY7+r5YxQ2sH2hkUtBb2UH5czzId1lftka/Oz3R+8IgaiwJMFfwgghL+MR7zmGfNkWeCEmc+aa0gE3Cs/1D88WtfR3sznhDPLo1dRWBQiqujV9N+cWH4PIxZZxzoPoDJV29cHxmNcyMXtPKOk/uP40O7LwkQ1PKoxU6aGjQ5/dw7zfp+5/IrcZ24fsYFenDgVJQ6DwK/fZ46FpIG6Pff/E/R3703fuqpHyP+kCbP5fitZ34fIcBs0oBeGrwSY9PjyQLhyaOPJvTKlwdfj2sTg2n+Pkq8wBN9R+O751+kjmhV+0AepMkvnn8lPnb8sWSd8crwmRjGH/LxvvvjaOeRpMW+VhmKb157ASZijhhIWZykZTQ7nq1TCEumgOnuhElx7WixYDDl6ix70TRQ8nSo2HZF4iENtMuMYTbI3PdQTtoyz4I0PusnkwAarYyjWjEFhrOg3OkWJRiFa8wxnIDZPAY6KeK2OI/f2lKz+xWdvbqmZHavYobf37InTnYOUK/2xChZboG1LjM5AyMpct4woRYujl9J82N9TXY/7aQe2GWQdtJo3zNtbYjTOJxOYZ5yqXIlEa4SKon5YbO8VUqxJiC8jShez7xIPs5M9MXc5EEcvdnYB95EwsT+yqFhciPOpPYJJym7uPpfUzjPUzdvfYXMW63IVhy+12VU90F6WOmWhK3l32nyjLCOmyWlcPoCaS51qyQhIQP4nswPPLNWne8lJA3emgAK6tpnayU2V4AHLkdbIiLqbrlVVd/Td/a3BLCEcMmAl7ZbAotDVGZDc5Db9VV9BRy/5PNEvmundv1Nm3y2PisQfw2Yd1IVJ2NKMi6bpYwxyfyE8rmTv272zGbXJd7NTwGBdcmTBKeS+/p8E2MPQeL3mtTJGCm5r78vz+e9vlqeTOSiDvPsBdMQY4NDQ3H06HFAGh5P2R88uD96unpTLBfHc8l7cchnMq8r3jqKHDc5n2kUNzK1c17ImC5jvpUEInSJ7cvMUVlnZGk/GSDWQJoyivUpE6QI3AETAjMp4W7dEytO/e5WX9XXI/9siTVDm11Wy9B+nj7SYNE/N0T7a32fceEuphvz7ZaFuEax/aouAC8Oml6p1Bk9HfPEyqPmaA7mMDvThE5WXx+TNGd8hj6v4nuyhHZDX0TPETWzjp07L/oUIPc7iV+E9kmKCfXKGAz03p6+ZJ53fXI0ekcvJ+CDT9z3FH4/EwAhjMcFTOcGevtjX3tfvHzx1fjdl74S+wANGodpeYnPf+/zP5/83QxT4HxynjErU/lffObL8cbVt+Mk/rTeO4wG6/P413biu7bIWhTN7vrEcDwJI6OGZrQyBsT2cvzwQ9+/ynQV4nde+IO4MHI1Th84EU8eeTS+e+6F+M7Z56K/sz/ODV+Mt6+djb8DCuzXznw7Dvbsjb/89I/Ht976Tvz77/5u3HcAk8r0sxKXpq7g1zQSp7qvxpH2A/Gypu1LU+kM1Rw1BQWfQYNM/dvw921ux4wRRs/zpKsJ5ogum0Yra1oowihhIrgP7WkHzOS7aOEqjIuIgb3NPVHhLBiu4B+VnkqPpHWgP6oAHPbVPIiV+goW0V7nW2EFpnB5ivXeXcLsEXCGRkwUHT3Hl33LV/dKmR+Zz360SCnOGNfNw7Vo3L12hCqsVhBr0TDBySqW2007twd2GaSdO/Yf2pbLNBxqwx6+nTgm09chKiDq2eU88G6X3AyNFK6vksRebVJ7NDO5L6ZGB2LvsWej3DYF0ZXl6X/9jkTiMo+1xOYr2bCESVYCUVglBP1+Scdh/lIsoToibO3527yRSMrNsW5z6y2/tv4S9Zpy1Psh5Q/qCN8MPGs97Hb+fXpd1/h132zhg34v+mdkRIp1kjFSw7E5MaiDtTJH7OaJ6dEEMfBBJo/PxIRQWc1RRJDNGA/M70BWqmUWNqtXGkPmm6YtEsr2/1aeM7+8fCXMMmyJMIW5lHhLiHja6MuZb5gyLeaGX93iovU1f5G9TH5Oayv7mK5JcKiRrNf8pS/5Zx8Zv8fnfJ/y4P/dSIn4wV+j2rwSl4evxLnzZ2Pf3n3x2e//TPJjskz76KOPPsE7/Agxs5uYGIt33j0b48v40OCzQEevSwZ/VRLejFlQJyZPtYyoY2J73At80PUi0TqrpgECzPqYvEdCT7OdGfrCmDq1e45949rWrHOlcQWivSkJBMwnaZNSLn/G/0SZM6Umrd8vsy/u5n8KBQSguizK3Kp/iiZ1etZLQKdX3lNHwSKW5vELBXGvYeYQGsOZ6Ou7HgPdApoUMB/Tt2wGIpt1swofXZ2HBUDzIeqh2SWQBojiRFCr55B5ZoxErGuH0G/rkEkirg6mYOMwQA17CrGvZ19cGUVIB5NVZm/65H1Pxh+8/McwR5fjCtqfT578GFmsxJde/Er0tnfHZz/yaUzn5uP/+c//Ot4ZvIDJHHVPe4qzKuvrWRj3K2PX4siegfj8R74vnjj+CFqqybT+U8BxynIfV2Difuj8FAb7uXdeSHU7ufd4PH74IWZfxKeoz48+9jnAHA7E1cnB+OxDn449HXti/5X++MOX/hhz0mmYp4fjK699NX7k0c/Fs+deiY8cOQ2oUUtMAHbSwFx2Hmua+vzVV+PV4utpH5MRUkA0i9nhNExpuQoIC0x+BxDfgkcoYGgjdpGxhARKEhFvsRGofQI77Gk1AHYb40EwWMwXDYLbQxuKCBxcE2PF8SQooPNTGwr0v/ufo65wanKKmGC8quH1fpFdxyvTsX9xJPbCZL1RmcQctI84cDBTmO/NAfHvw/oyyfBcnLqctGIJZCiVwNlIPWWM3RtmQLLzcw/aP/PfTTu3B3YZpJ079h/elrPZqVlQEiUhYVyIZIC11c2M+zbc+NhAy53XMCMB+Q5pWc4c2VFqgspIxCR+/ElOrGzS+vXkJmIrSNLd1POkNFjpeYrTA3Htc9tP1nXjp3JCzG83bE/dY9ZZdKYi7aip5tpdHkeaAyn1r5Xgrd3gm03qsu6eTT94mC0knxVvkeiUGLldsl728wLSeuAJ7rAfb1fK7b+/k/GzjTJGMjMSwqat5OM9ttvn9VfpQHKcTEGY6aZcu7U5c3TnQ2WZrZQnk5SnbA6uN9FT2r6R9ih/xlfnqO2420mzuvLBzrjwztUY+dqX4/jB43Hi8LHox2yorTULdDkLkTwxMRGXrl6M184ROwakr5UBhAKtOsJnazPr3azvRA8UoUyTWlHn6pPMjkIT18o0hLM+C7Vr0vv9LFy3TH43hGBCI1R7vdonjqP9vTbWrD/XxKz+M7zm99WXfW9/dizYGwA1qFYOJzjxBNIAM7mCyV8DIQCyoLGYdmIWHP6BurdcOZKeKbVfjJ7+K3Goq5zW3LUZ4/FUEtFbVMLBdFwmuKjoZStLlMVvS2tLdHYBYw6RnGkNsj1eBmA5MTEAA4FeWkQgIUM1OV0hps508j968dIrcXVqMB7Yf18yWesqd8Rrl9+ICQLC7uvqTyZ6w1OjMFUT8TvPfCkp4ZqMw0ZernOPDf0Kk8CBV03/PvfQp2BavhH/7jv/Mfq6+uJjxx5LzL7MgEyC05XdIeZhMDT9nYTRuQZD9t23notLA5eTT5Kxt7qB/x6H0Y+ZoTQHX7zwCswFvjZoXAQkkaF/+PD98evf/WK8dvWteHvoYvzVp/8S5nUVfKKmCNwqo8gejXbWuYx+jfojFBAGjnIX6As1qaX2pugAWrvcDNANDXLmqtURSnseczhgWWJiZTrFU9oHEyXTOsra6kDL18W6SAwUproJFIM1sYTvqVYKjYyH+6avnnHTszP8zRLDCrAYGV3qNDMPgAaMzalG/aEIkUBg2MOde2Octg2x7mR83afUMFv9SebCuYlLcaC1b21PNuaS7ROIY80ahdhMu2ln98CNE3Bn98Nu6z9kPeCG+/Lwm2yM+DUgIWoCeWYryQNJCb5EyU0J05HWrpH0lwhC9lNTMsmAyM2c9mGKYHwUObphm18yteJZ4Zv100hlsKFriiJh/16SpKU26usIJetF2clMhBINkGsQww0T9xpUU1tt05z1QaKt+YOEwvqUxQSRoN8oeKy3K7W7Y/M6DiCJAPvH9tQyRx721tP+0tzBn/VJn4GtjfH65+7CJzoiZ8jrCeK8NOeMhHXOGDnfbm5Tfvf617x/JMBlVHogIMpAT9tnOSPs+63ld9Mgry9sk0/2vuVvxChbrtrIzbRHm2R5Vy87Ds0d+NE9vA9acDpeBMTlFUyT+jFpOr7/KI7zbTE0dC3Grp9FAHA9prsL0XlfJ+hozDzAQExV1hQRUiCIM02Jfax2aAIzIrU7OYObNySNE8/o8D8PoXgrP0GZp5Gl8WTi1YvDu9qkfCw1rVpECq+wh+xSOQuYhNWuj7zM9+e1fm3lud7ZXMmffn9eqRtom8uzBJ8liO3i9ABaDPZUNEOCSRQAj5D4Rl3IfTJMMhnutfiRNAlb/lI0dVwBmroNrV0T+9g0YAVoHJLwiq2PfXKB82IJor2K9sg+L0AINxFDSC01uOaMtUwqTIDBW90v0aS6x6sVKS5jZs1PpTodEzAQh/FD+uqb34pBzMI+++D3RyfakRN9R+K3X/hPaJsbo7dM/CjOghY0Lqf3n4inTz3J9TJMQ3M8cuho/Oe3/4gxV7ORmYMV0YSpUe9v3xM//fRfjCnK+OILfxi/OfL78dc++ZMILZqiQqBXfRFlvs7D0AxPDZPXAxkTxVyaAOwhN9+0vWpBl5ifXyR24P0HTsUPP/JjSUOlf9McGpaTHUfjYO+B+P0XvgLTVoyj/QNxdvxCQuXLzjq0pTAQjXwnA5NMQMlXf6AGBRP4Bu3r7qM+fal+zmcZUsFOZmcRiAESM14FRhZN2gBQ483s8zMwLiiVAKRA6wfjItLk8jzgCKANClTRgs+g9bY+6AAdmWQ+O1khHz5noBtCuBPgGSa2hfxPsf5F74u2U6BE4kPKnXjMJXNu81GD5Ji7bt8eOx+P9T8Y3TV0g1qjPLlfL6HV3U07uwd2GaSdPf4fyta7wb01djZGMJNZIvib22cDav2M4r/9pqa9t6TA2p28ScQOVz2sUkp29qtv+VYTGYmwRDByfz+wrt04qLrdji9OJXOigda9xO7gsOUwKRr8j++mOEiFPjX/G8n3GTGSX88+3bgmcWayRCX5Hjr5IS9h1QqBtb+1n/Mcp3AQd64gIdS/ysesZ8a8pbMdtKzeONDUlySf04W5ODv1bmq82iIJstq6+FHTIZHVNOOoTSvcnEyvKCSvd+33t3vvM/7kbbtxfyYpFDVMwluidL3ZHcwRhIFl30m5N8p5f95Z/xQDBM3OLDbztcnvGjnYmzVXxActZ4y2U++UB4RIB2YneyCwZFhp+Lq21+aXj3dtPXzvPbnZTv13t/qcxcBSVpyNNy/rE3VJsPMQnTeP5fpbJfyci64b63k3k/kXgOdtR5PUPtCJU/gs2qKReOfNd6NxoRVirDGeOjQTD+4rxRSmdSM4n6t8kB1yT5hj7b4eXXGxCDG+KkCR0JxGA6RUX+jvzMxxtRX0i+ZSk4QNuJ0/mv1kH2i2J1G3Bx8M4y05Qq6zu8cM1fc4lYYIT2hzaVz9zD34GGVkaP39H+RnemOxK5amjsMcnYaYRevafhXUPKIIAfXd0IgmpNH4aCBvRmcUdMQnRtLSQgdtwAyr8zwWeUOJUR2CKRqCucjASVbbQFP13alwZiyqGYEwFyVUk7Al2r8CY6IQRjQzGdoFzSXZU7Xkq+J3JPbiMsS7wrEOQBHmAAQ4jLO/5l+trNH+jm72roU4CqLdDGZ4Rw+cToAORfxxHgBkQZ8hg5fDi8XV4Xfj9D7mWTpnEHKRawpWi4+NZf/281/GX2lPMq872X8w3rp6Ps2bRRg7taDj3RPxiVMfTff9KT5Ep/edhA8rxgXM/Y6AqqdfknuPwizPI+evcPuaIo7gz/Q6Gq4pGCkBSZzjHzvxePwfv/d/x08+9YUUFPba2HCyzHCKdLa2xQDQ+K2cF87VCnPe+e4c6gaA4aE99xFqA8AJ+qEZsB/7a7J5khhEI3G9MBxjlQksPhaSn1GrJtLUyVhJmuCldVcBxQ4Gyef03WrAXS+BL1B/r/Gb/iqYvs1yX2tnW2qfF2fJd5HXgYZJzuSuGJxnDyh1p73GPbidMpYBiLDeqT9ghtUmXUN7fHnqWnT0ZoiF7h3+GVpADWGjAC+7GiR6fmenXQZpZ4//h7L1Ehsnu47G6BimE6jlE8wnUr50GLLJedC4qZpuIuDY1LWr9pts2/U/xBuMxgrPeYDkvhc+b5KIyYk785PgO4qz6tjZkWRqcfLxk8mJdd9KT7z52lvx6U9+iuCUbybjpSx5AABAAElEQVTzhfsevT/eGTtHJj7J0aq5Au88uDyY1KhIdJmnBKmlqQ2SAPW6RLb3t+DQmuCAeUbJ/kGcTPuWuuP119+I+596IEbniI6OJNxclPZpEqjtu03txn7+6pmrcfXyu/GJH/tUXJuDmYJ9s5eML2FcD29cpG6aFXlolTEnmSM/peO235TVToACATFST6TrW/1nG0VdMyfNs9Yna15AuujBjrSvVitGO5IWjee/V5KHrShkSqA1SUzjl661ICHOiBPrmvfdpvWma+1d55etUwup1qkNYqYTG3jHIp979XkoedU0xwPf+5Ivy+pY+Yx10wQvm3n1T2/+2frI+JmvTHRte/KnbtsubnT+qqm0XvaR0Ln1jICf66/lZdzJa+qrVb5es6n9Jw9EnKBFBhed643xJpC94p3ohSDuam2EcLIlEJGaCaGImMUv5SpS9cXGNorPxkT/IrUFzk/9JVx/jrfSdeMYzeEzsp00AzTyChDM3Yyda8+1YJ9/IEl0OhgLgQxWhPRWE6MGo3wd0+LxD6QKGxfCOMAczQ89CYN0DEZ3IZq634ymnlepF4wRHeSacx8Q2vlAm+sM5LLF6/Q/aGPsEc7zZRAvNbleZP9Ic041RZ5YYGon5jEP06TL+w0s2kwg1NwvU0I+wYnA6OTrjiniAk17dkMJRkxmjH1qgflchHF6/PjDiZFqIxj5pcl3o6e9C1+kp+Ikgcxn2UMvTs3Gpx/8c/HV174Zf/Lq1zkKCnECWG6Z0l7uPdqHzxSE+UDvfuLzLIO41x5PnXgsvvrGt+NNgBSoZnzy9Me5P9AewYxDwL81eC4ew8/ohx77AczqXoizV88nBqkbP6en1FJxXhyBsTrQtZf+grkntMWPPvr5+KNXvxaXRi5jetcRp/afTEy6AYuPgmbX39ETTxx9GOS7MbRlBPql3BImcwdhjvqp5xx9JliETNVeNEEnOIMf6D6Jrw4mc/wIdLEAA+q6EAX0GGN0rOdQFIeL8c1LzyHkWhWWsCc1ss91cMbMMB6ax9lImZIeBAeLxsQjD3RUdnxiYg3qPIH2yP4WIU9tlmb2jvEKf8daMp+kShPMcm5pwJnbyx7qeTUBw5w6kjapTRIp743Rt+Nw6/5kPut6ljnyO/vX13qNMRnsph3WA7sM0g4b8Hulue3Ftnj40EPx/OWXZG/SzyIqeg8yA8K54aXEoZInr3l5DiageZUxSd95hnoKQnAmkRX+QrdKKWs236/8pz+Ob/3Jn8b/8kv/KI4cHojLb12K3/g3vxFPPvHRmBifxOETB1QC8vUVeiBKYCzY5Fs6hD3GlhupWYn4HI1t2D5jtrGMmYAR3xs8PNqasZ/WQRyYYUxHvLcJ6Vg/EsXBuZEkIVVSd+Xy9fit//c34394/H/C9IS2QRh2IJU+UN6LZBwTAQ6QFg4p49e8Tj+9/tqZ+KGf+hEOk4HUZ80c6NQgFsgfyoMyGmMQBKZpoKEl/ptwkFZKqt+SBIcEg0Frl3C2bTHo7LbN7TJCtL0Jp18OS7VEEseJROWzhIC0iNoywQw0Y8mTB7A/3vu9kkS6EtXQg9S6aet+Jxo2kc+UcEp4G7m+u5k4XfSFBHlOpNW3WeYnBVyVkGPOyOgaWFIi0mQvKeX1Puu23eQzSUsEwVZtrCZGJ8/bdSTjvgyBpz+DdawdG98bMyUhPkLQ+px9JCpW7fD5nG13HpjP+57oBIyCyBZmsUispmpbDBcPxRsEgyzNXsE3COm2ATVZy/3Lk/HxckO0EwMHgyRc9LMWWSd7T8HBCL4svnbhN6E56DQ+HCJpykimm7x5C0nhiEKZFCyXub5RumuzXO0RYQxWFkEXW+iJ6jyO6I2ApBAwVkapNq7QRvW69TVrnfV3dt9mrdhgPrLXLE48gB/RYWItEci7+40odr2FsAoNLZo9kz54OtarPUefDMogiGcwDO7HBpvOJlfS8af3luJczdeQ5lWLaI/c55OZNcxRCzGLWkqZplfNkUlACKbm6lxlHpCRa5Npkpj+vIkS2YOzI/Hn7n8K7UlTDLE3X5q6CuPQGH/hY38eIrsxLk5cjsuVa3G8+3D88BOfS0yEmpgOTPEsJDExffuY/4sEeX2AvXYJ37graGwOxH+55yfwFUKrBQOHcWC8OfgO2sppNCSNMcY+/dq1N+KBA/fHX+n7cRh74K1RrbVg7lbBL+kiPlGffvDTMC8Ep2UfHSZu0ZPHHo6PHDyd4jo1kaf+R5p7qtEUwOEU5neH9hyKV66/mZjMEpq17m72Is6GUc4ytWOiAApZ/mT/o3Gq51gCvbB/3cete97XmpvKXDWTx8f2PhqXh/DpLWW+wtjl4c9bgjFpA21yxC5PWrz+LjS0jMkVtTuT+ExRVhUfsSVelxcYVxmv9vYUPsA9TzATz8wSZpSnODNFsKxw9mnp4Ng3IcRz0Bq5R+j3Bs6dXAOsUPVq5TrasOlkxuxnk/OlpSUzR8/bkr7Y/bcje+DWlOCO7JLdRn+v94BE8iuXXounH3gqLlTeJf7BJBupvkHI/nC+9bURLYonWwPMh5ueh4fJZ7U1ni8ugnKzSpyoDWHTTvdz71aTDqgG6/vd3/xS/M2/+zd5HKYEJkjZpBG520vYRI9Oxbf+4BvJzGHw2vU4cvQIjFFLnH/rbPT198WP/eiPYm5xLb7xrW+yeTfCWE3EEx//aDzy+EMxPDQSz/7pd2N4ZCS69/TEkx9/AlSm/UCjZtDmgkIsYk/v4a32Sdv5452HY+rSZLzy7Mv4RSAZpLxPfv8nE9pRE31QnV2Od555Ow4dPBgPfeSBeObZZ+OVV1/Bh6sUjz35aBw+diAFCFSzJWErFOoihInEXM7QzCEBXwQwQROhMozMdpgW71VD5LO8zXyd6PKc+M77Xg1Yk5JECFLvWwA6vURcIpmn76Uk4Z8zSNbL9m2nPyQs9G3Q1KcJJte8PMRzxnGztkqUG59FpkNywP5pWs4Ytqx8iZbNCNTNcl1/3Xyth6iPMmsyPHnbZAbbGpDWw9gsI1lGXp8YBYvU96KjpMM7CHs8nz9jHmR5I/G+jD+GEL5CvTvW3n+nyfrmZeV55J/xFGIP0IwHX0K0Q/Od98XobH8MA19MLEu4SfySChPBbAfkl6CVXKqtqvnJxI4jiRYqWKdxTaGUdN90ozdvkCxG5khtsCZEieimxusSHzPgjYzpTJN/7Yb6Gq19sfU3rKmGMnFwWgcpiLXEmtKPp6GIkATm6c4SlYYQrVZb6V9GIQWZteZoP2HG7J+EQicDxr6RtaKm3VxYmjwai5PHIP4r+BG9DHN0lqrIsNxoc5rPTDA1B5dlTjF91MfG/V0AFwlj45VtRNhqXbAIs6HmqMh+1kgcnkaI8VaERBlCmhD2CGeY1wXasITtpRpax0ItquZgalXVJqopUdvunvj26AW0KZUUo0eGWVS54flR4Kqb8cGRgRuBIZmLN0fOwkyNxsGOfs6HcgxNDidUPbUtMgKTgA/IAFB0Ak9wnrQb48y5MofJM98JflDCPs8w0/buKL5xz19+lT26i4DaMlFNCBwaKNcgzp0wO4zrngXOBZhiun5wbjBZJwwR+HV0DIQ6ynhoz6kYHB+Oq+PX4kce/gx5tSQwiSZ8gNphRtrxgRyDCTUmnev6Yczpntj7cApynMzfVvcY81IDY997vqqByRmN0nIxnjrwWFxZvMq6QajCvNMfSEuJKvmWMVfsb+tEuEewcrRZncUOwgBPxBQaI/e5pO1jvTUxXh1txMTjXDJekYzdInnsXxzFvK4D8zz6sgtNMVOL0YshTPuGJrEyAVBDMAl9zYyH5qt7WRvMY5Wz3xh7ebLujkkKGUKbdtPO7oFdBmlnj/+HsvUSQkf2HUZtPpEOSDdEJU8S60KJqkmSaHPDToezJx+/bt7p0OO00HdAhkYtTQouu83N0HNBCdmnPvPnYnBwML76h1+PYydOUw6HNJvxM1//TiKAOnu649//29+In/yrP5U253/+y/88PvfDn48jh47EH3zpS3Fo/0A6QL/461+Mn/nrfzWGQdH5N//yV+N//of/IL765a/GSy++FJ/7oc/Gs8+ATnThYvyNv/fzoP+MpUPAwbMN9oevrWgR2gmO+Idf/3IyEzAo5q//2q/H0cNHkLohMZyej6//0Z/Gd7757Xjk5/9mnDt7Nn71X/9qfPxTT8fYyDjl/lr8d//wv+dgLiMxnCRPCU6IBn2g6F+ZFiX+wst6XdOgUgPSVyV1201koKxXAjbVf/V/TtDKCHmIiTblfcmUDQI6I2Ys/Xsr5fXeTq18xv7Ujt5RTPFXEgN4+/ZJXCuh9jA3JcJE4o2fvD8lst6PZD01j2vmx7xNviazPoiyFSNfknK/pAx+N2Py0he3+ae2qYh0V9MdmcXtpLW2QkDlDJhMlr5s65LrHyZgmfVRJY5KkX0Cco6gnZLxmJbSjrmGUvTxTuM6jVA3SvaFju1rX2+ji9Ot/EsCDdbrRnMmIU3S12uAD2p87O3cN3KjSm37mp3BQ+ZJnzTkzuhS59tOZGQwWeIOqf1paARAoOMCWnH6eaErVjBrTPVvGmeMMatFIx0wqitoaRpganAkSqaPSxP3MSaL0bH3deK7nqf965kjqyUzNA1hvLIykzGmq3V1T1dgk8/NG03IxxC/EzTqBrxtYk9pxDG/gNasEUAAAQNkvBLQhvsZbdHMl8UIbLh1QBOC75qamAb8WwaJNzQDw+NKc/yEtu7DHxUla9IiGd/NvnVfbEEQplBJTZOE/CSobQW+H4bREPlUxmga87JZQBck4JdBLhQhzvlhAvcuetu64sC++5PZ7ZGmQ/HW6FkI/0ngyVmLyzBts2WACSD0l9BILbbR712UgU9UN/GJGq+xh2IJwLq1PVWY47dnLsa7aJdsg+Woiepp7Y7PPfDJBP6gX1EJC4yVcisMhNYOxqnLhGMHuhC2DXwsMW7pLE21pLn0n4xkzlSo8Upnh4ckSdS5g+X+6G5viXfRpl1HW+vUWwQpj0pELyiTLZwtk6yrUdo2w/1FYk45njJDZUxlk3YMoAu1fcYLU6CS1go+WScYyxK+g2P4HmGYjlZoDjPBiXh3FBAKfZuog/WR0aKyMUBdTu05EffDHPbh45nPG+8R6VKo7zKaRT/vpp3dA7sM0s4e/w9l6z2YruBHMz0F5Geylc4PfCTwLdiTYydujBo3Q5223bjdxD24vKaE3s1V+N0lNvPWhvXxSbbeKWy2AwNx6sEH49d/9TfjB7+gfw2EoRClSKX8cY89fORIfOGnvhAzU9Px3HdfiM/++c/EgycfjLPnzsaZd87E8eMn4oFHPhI/8dN/Ka5fHYr/7R/843jlpZfjeZiin/grPx6f/sz3x8Ejh+L/+t//z5gcnYxmpIgSBXmiecm5WGmbUd4fevTBmKJv7AMZjSEYOLf6V196JS5dvBT/zd/7W3HfsdPxr371X9GHlTh27Fi0dwzHay+/GlNjk6BArUeLywg5g5yi1YGgKHKItmLSMk6wwEQQpNzz2mzlFYIGAjb57mTH16op1I1nbZ3gBJrUINPj0Ich2ISovPHUh+udc1JthHGh7AaZJE09nKq3S5nZGuaREGB5EnHLPPODPcN/cuTfe5IAkljKibc8x1oiP/nLQeDZmNrr+b2bvXqv46sfkPnLDG8niRaor5MMm0mAEZktGTbrnAggqlWEQCwAEV3FnEsS1H5yfUqszUNUVrg+wPdt2qpaB+bbpulOu5V6pL2INut156aUD3d1ifGEMJyfB3YcsyBTITExMAUyMjIUPPW+pztijKgFVaxCpFenD2Eed5KaEVgZs7iY70ZIBMGuj1PRwKtoOWlHFT+wlaX9PGen079NFb5DCzpzMDErHf2vRJl9aBqv+2WYWHugtrXub0k0w1xcS9bBMSbPFHzaATX52VFGY7iyiLZ6Hr8VfJwaYIoKK8NkDBHOWlMrs8w8cS+SUVLrqS5meZb9CXO8Ao5p7kPOrSK+R2qD5jBnS11GUV2ljmhDMPe7L3w5rhG7SIZEsIQSDMZTQHPf33+cYOZloKVhjtLaBuxBtDTq3bCEgC6h8LWk74zHZZ00Y1Mn2wEzcALfoA6CqH79jW+BUvcEvqeHYmka7dX8gVhZ6OMcgAlbQPg1i38W07+VYLEdPZfi0KFr0dVWxaenN54hQKyw5E9gYldCCNAFGE7S/NPeEbRd+/b0xTUQHv/l1/9d/O0f+hswhDB3MC6aAk4jSMw10Xuae9N5ks3f1Mvpn3GD9NtxT1Io6dmXfHiw4sjvFaiiB/+g83E1oQNW1RYzzp7P+i1NAYI0g2+YPmILK8ZWmsWcTmCVNqDDEZTRYe4Lag+FJ1+C2dFfqwS8/onucuqzseY9xLuaikGYI2Ml+X1i2pxFtFXBXgvCv08dejpO9x1Pe01ePxsixLfMkXtd7fUbLd19t9N6YJdB2mkjfo+0911svSV8cmJwrVkecmzUanc8hNJB5pe8z65jq4x00k3QJESo0Kmtmgd405ZTdq+meU9+4qPx4jPPxh/+zm8mtb9SQr+lKilpubIstCzS/nIrEj0OBaJQcELie8Qm7mZsfYQrlwkoIb1K5oKaXSHtVNJYxCxAs0HzwQZoXZK47CFAniZ3y5jQ/dEf/HF0dXbG8ZPHKEIiDGKBvCYrlRg4diiuXbmMbTuIQKB8Vbj2+suvJXnoU08/xaHUFlMro1nfcVVGMiMyMXHgBE7EJvWeh8DJ4XDXVWYLHzxw5/Bzys3D0iO1lFBNHmXMTOyfRMzajm2NUU1G30NvbYMSZKWgFRDQHBsJIwkxA1lupY3Sgd4rQ+H4mHyViJQ4SWmTPs2+3N7/lDcExq2QBG/Ue3Xib68I+gACG0JU05k0z7bwfNaXIlnSWH6tn/2ouWojJociImboj3yJtqIK8ZVMymBOLMt7lzFPrLIHVNwTML1tK8IIUocVNLJpIWyhHlu9xbnses58tEQFkzCXIYMwnsevaWoPiF4yGJirydA1D0Wx9TpEJ5oXG/i9kjSTWugHbe5kLM0MQOgSLwpAhUL5MvVmnrReTdVFbs9rvhHix4NmScCMpbl+mJZ95AHoRdNMdB54M1rbCPBpK5nT7Iy8V0tjNjXtpv9S4sWxX8bczWS/5mbUiUeCMYolTEL1tVpCcAUjUmzBX6mZOHdNagBZgyCNSpxbyNrcZS0uzYBghxWCMZIk9hUyaaI3AhCOgByCQGhmx62Y9qFdgYl44/KZONF/JD56/HH298Z4hqCt//47vxN/9wd/Lh7dc3+Mo5FXWyzAhMAgzoElCHLZdwEHmJTsr5lgaoI9QQahv2VPAkPQzO0QYAfdgCG0FfZGe3dLzBEk3RhIpSbqQUXOXeUM6CjE3j1DmFAOwwg0wgh1Jt8sgQ9kXmXc9E/tbupOfkiutzmYQ+MkjcJYqFUyFQFQ6MTiQBPxOfvHDiIHtWieobVpnhhEMkgL9Iv7+QJnq/Xt7uxBc5WlEmeYAAyILTCNI34hpoeLs1lw8MQgwSS7RtWGL8HACpKxp70T5q6d9dlE/fAfJH81RzJH+jo57ssc7gfxLdwLyt51xuw65nNTCJxcT2rvikD4p/OL/tFnSQbL9p6fvhwDXftoY3ttU5L2KIf69jxe20fX3bX7YSf1wC6DtJNG+x5qa/1GXds0D8uUOFdlOBJjxCYt9GkypeBgylN29K7en1/c0ivHNiexh3FLSzF+5Ce/EC88849jBqajgLlQOqQTb8IBmD6YqaVlzr7ZkQPhz+Ho4Tw6NBxn3z4X7176/9l7zyC9zutA83TOOQKNnEESIAhmkaKobGksh/WMNDVynPHM7MTdqt39s7+39t9u1fzYWk9w7VSNxh6PLclBlilRWSYpRhEMSETO6EbnnPd53tu38aHRDTSzRfTb4Qv33jecN5x8zgWkgaMwN1tj+84t8dorh/BV6ozXX30tNJmrb6yLARx1JQRtZBKJ16UzF5LWTBvxaRB2N8EbHn3isWhsxgGbPmhaoN31Y08+Fl/4lc/HH2FKt3Xj1rjnvrvj8LGj8cgnHk3OtH2916IC36mpYaXvmJEAxxkQilnLzSZfVETCTV4lW9RWZLBbFbAKbpIw0eTkRiL4Jka34In82iIRU3DtPXnLZCQmUFprwRzTwd1AmL0nDWWVOP6+8QFMbgj5DEHh+PQ9aiDikkTM4vq9ZZuuMaN6oXGBsLCvjkFTuPIkA3d5vLMZWq5Z69ZsLYuquNwd7/47Na4ZwyKplQkOVlOrfZPhdn1UExlLAlvGURNN4YJsGtgwycAjaZGAtf4aKTcYEvZRiKxRmNXJ6UHuwffC5yHTGO1qml/VPYVrV2JwdAoNLwSbxG0aK7VMF+P5VNODr0VDMpnSL6iogkwuJZxXi5KeVTX3Pt8E6zLdGNO9+xHItEVJ7UWCKrwRxZVqZoBz3lffqiXj1eJaLa9Aql9FePVGwjkT6CVm9VUjj12ZhHi246wizZfP3UiPU1eqNK11z7XCvSLRLCHueT+v5k2fM0z+ikvUvGVCBAOrzNE/q3EeUnf94B2uIwjwOX2yHANt65/izwjfmzg1WSYwoCLOiSIJ7wXmT4Z8G1Hrdm0gMhw5eDYQke7/+tYfxNDYcDJdO3zlrRQJ8cEt+2Nf59742dmfx9HLJ2Ga5ri3PT5HDqUBgoC8cu6NuJvodLuIKHfs4ltx+Fp3PLT5AEwzPkD4GQ1Odserl99kNPg3EVihCKHZJ3c/Ho/v30Efe+OVC8+hyboEnOZi36Z74okdjyQhnNHv3A/mVTp08vWUVFYW9J4Ne2Pn1q2Y/XUDt2wGqmCO6mCOKhEe1KLF6kOWpzBGIZz4NC/TCxqXfhjHa5h9D8wM4Rc1FFtbNsaeeaIM8uMJpMldWv8E26jHb/GKyxmQC+85gi/MlGewngelVdFeG/6Ltu2sXKO/mszpr6T5rfg79zszIEUzJnGkcY7zTO8wjFOWey6bPwMNaULJwsvmVnNmmMBD1w4n07oDbXeDR8VrmPeCR/1bK2sQKIQAq2etrEHgowUBkaYSIBGlBL9Rj5JMEoSm1D6dvAVDzuSUBV+s4q0htNd1daUEgwOYT1S31cZXf++r8cyPn8XMoCw6N6xLSLYSU4utu7aDbJFEYvq3bcdWTOQqEsLo2tgVTUjaJJL6CMTwnW/9TQxcG4KReTw2bdscn/7iZ+Ob//2b8Y3//g3w3Uz82pe/FNNlIIqRcWyk8TfCYbWxuTG++9dPJ8K6uqY6fukLn4uPY5L3o6e+H7VokZramtFI4WTcQALDnVtjzz174+OffTJefv3n8Q+//JV4A+3Rf/svfxINXF+/cV1svGsLEruBGMZ0MQeUZMukTFbRKMqrzEk2Yb7s3yqgdf0Wx2r4cJFjRg5Jh2BsBKL6sIrrZWYsC/CRHHYhfpQcFxEVLhFC7yGjkcZIfTp7J81Gog0yp+GUF2eBWLsdLCQ4hKEaoxyOPuNYkuR9gdjxWiJOblfhKq4rgYWkuaG9VTy2+lvoswySzL8mclli5swc6faV4FjPHrGPsjeO2bFbn0yoEf+cxjkI5xlM1bxHJqoO5/taCK1xzJ7KRzG5xb+lmiStldSDGzs/GfF8+/ZvfYf+YIsmdVRpxLQUNY1zxCuLBfpTDUBJUc/C9uNaznAs3vThvzH4whxwKm08EuWE49ZcLvXzFn2VEHWfK8iR0C7iTCxCe2RJeZmAQ8o/pLmbTL/387NYElHNGsT8UK1rYo5y+HFvCtMsE8b5m/xT0CakkqaQ85c97R6bZq4x5iJBMEIF8ETaH9bNGWfEzkoI+pT0G7Mwg9fQ6cTkjKMtkaNKAYCoWEJdS4WcZxiEGeobHiBv1kSc7z6fzpCayup45fRr8dQbP0K7dE90EKThJZijvzn0/bi784EUEe6ZI9/BrLM87lq3J54/8Uo0VHVFZ9WueO74n+CDVBd3te+OHx//ERHv2pJQ5Vuv/3k8iKZq1/qt8ZevfCdZP/zmIyR6feEpwoKfTgljrwxeiW+TYHZ367Y4fvlEHCNB8gOb76Pt1+I4ocN3E83uBN/91St/gxnfBgRfWSROmSTNmqc8nzRlg+kUfMKulu/ztSrcDBA0TiTBVweOxMnR8+wr752PC5euJIbpodb9UWcgF9Z6Hvygs7gVa8fJuDB2OQXWmGQvzqI1MhS5vq/VatHowxhauT4ESINYOnjGKVCz2C5TkBLFzphrkP4xcSR3zoQZBs4YRbM2NjROChDGQkS6Wsz0KqjX8zYxvKzBfjR6rhEZJOtUC5bqZh0ZXMLoeymVBZ/Xyp0LgTUG6c6d+4/syCUcRaAScx7MyYmck38S5KeZQ37Iv1MAiDBGZkbjgU89QAsgBBLOGf76rsf2xzYkedM4Gx944iAHvYdtRXzu738e8x0OYEx3Pv/lz6P6L+PwH4hHPvNoylH00s9ejp17dseX/j7hWnE6bd/QHmeGL0b9hqb43X/5u3H1Sk+0tGKyUF8VZwcvJMmzttjrNrTFv/hf/gUIX+krhTFWt1XHp3/9M7GH3EhGPKokEpEhaA3S0LCxkeSJfXH/k/fHOD5K4zi3/r2v/nJcPo/EkdK8vg3EdZHoSsbwEk9dRw6+09xiZn4IpEL4VuosQdou/li9piKTlmsisbRuPwvXD6NIcM2R/2aecGYi+VSgywybXVYDAVTBIN925yTgqEn4+K+gmPTW/ByTmH8lE58Ew4IbVvFWZK7/kQyB9UtIqoWSIchb9DvnJhGSq6jzVrdI+CRCB2m8wTreAUBuVf3iNceipsE8KrPk6Bljn7lvV1vS3qev2XrKzG1lhBSWJAaPs0GGyRD2ad0yR95bqRClvBnNyGA0zI9HA/M/5Ly87Xm/uafmVZMpSCZUzIfms8lMyHNqof6FpZI9LJPB3w3f3Vzth/gN660cYUnz6+QoIr+M5n+riIDn+nHsE8yvmmiJVs0cnQfFI5wuRLU0Ohl7EcDkazfNE9fVlE4ZiY6zHekAjAn9QDOeTKEAmaZq1TjyG8jFEOBLi9pP25vDT85tntrF3FlA53vEYD+l1eg+6JvrUM0QWw3zK85YXjUJS8Vn+HG9+TxdiUNnX4/BscHE/J3ru0gI7h2xuXlDvHLmjbgXTc1XHv51Pq+PP3n+m7Grc0c8ec/HopV8dtPz/fHSmdfikS33x4bGrrjEs1fqL8TASF88QQjxWvP+sLcTE8O66CKS6Zfu+3zspX4Tw04Ak8sDvUR2PRafvPuxeGDHfazb4vjZWy+lKHhqzWQeZTp9pqWuhXGpcZ5NpoEDBEag+6kIHxnHHhLajosvMW0TNvAWiTnrrMWUceFMEbeaduLSFBERVdSYYwtYqBl9tftwlM2UxP663SllhHMlg+K872jcAoxLyDeGHzFR/kzo2kbCWe8ZM1ADFhIDE1nkuRRshbaFtdedE7WENWiaehEU5lhDKw39yQwowU0IBWGS0U5pNigT5y43OEczQZO2N2IK2X53Wn/u/VEEI/ofOU6DM9QjWExrDm38WrmzIbDGIN3Z8/8LP3oPTosHXY5Q80F5zfwQIgdkgskh3vtuLlkdN3+//DcixTMjF0nmqX+MzBLJ+ziclX6atfzctctInzLJ5/xYdrBP9ELk0bRRj6YHcQqGGGivasVpFlOf2qrYuHlDtHW2kUfjSpwi2eAYSELkXIktfVH1XFye7I3JPrUOWVLSYdsEaZfX67OSjWoKKdubgycgJAgk24hPBf4Ws5g8JBCpOKOzRhSqoE37efbqJQgTtBeNmUarZ+Bk0hwlZLQCnCResATHB8lkiTrWA1kIZhHf7UtGyCM/ZvQLjAgPCX3Z2Q+9uDTy5UGn5mCYZmF2i2EuWVyr7p5wTpnmGZVMikhdAn2xUJXmLvXk07k208ddmcmiz+XE4OK9K7xxDSoBhQWibohNzEkMVCAzkO8JH833xPLrfoXKV/haBsPAB2p4VtvPFapa1dfCrYIxJW2A635xcm58XBgbnlkG0b9kHlUwXYWwFzaaOHqf9Vul609Ca4b9PI7JVwcM1Ga0iL1cmMgu3tjg2/gkUaffiVJ5pdVpbpJWy/NCU1NOAvarP6kjqS9vo4EP6daiMs4VLRXlIFfBHOXdFJwp2ALnyAT+n+UwHGX4emnCq4+J2h2vuxfSfsjnnHnSX1PHfreSwWiSlofXVLiu70+FkTY5B1O4bwCar5kUvhvCeRwCXD+ixNj4IM+5lv3zHu9Xe+l5RhKDhDemCNagD4zFPjlPKSk582aC8bTeuFaLNrKlpinhm3s23RXbOzcnH9Ip0iIY2n2Wub4y3BN9owOxBw3OeHRH/9wIVgQkAT9HSGt8t/Zv3hsvnnklXr44EfWEv97S2oUWm/OBNelaUZMi80YHYCKyKK5qRYz85lQ0EJWtZ6wPf6G6+ATJadfVdaQ5Eu5ycef6LsdzJ1+OKvEQzOr4grl5ZjonAyLj5PmldohgFP5QsaH+D3UfjS4SpDdU1SVmdXB0OI4OnyEZLqG50dKo9XFNC6Pp8ak42v1W7KzZCkOGFQNM0DD+rsJ5GiGLjBhqH/AZMGRO+tnDan4GEDQq/EsROJkbYZ0Xcaqa/Wr67pmXJXTNZljBkEIIFlPMY2UxV5EJR6fRME3RL7VdapPWVbfFfa13p3xz1q1w0ch1aa3RNzVHyieEdzJjzxtfe70jIbDGIN2R0/6LP2gPbo9GiR8PUw9Mznak6tdNcpLvDfdpdzxJXguR5nJFIeDbKQmJwgwZbSgvfjdo2NLbCJ1GidZj0X9kEClZdclwbN27LTq3dpGIcgBn02sgqEwiOT42HqdeP5YiHU2BPDv3bYhygjx4sGveMTKb1ZX3QZgoQRuxDfpRiF98nxegsdjPhH+mNSbKiuPw51bF6xIIkyIfWJ1ymIhKbM4lOhlYQt6Lz/OxsD7nyvDUhVok+5ARQzfgw8Uq3vc39hHEOw8BdmOBMMFR20SDRZjbrKY4B0o9x5gbJeYyLCa4rCYBaSFT4brVSXgMEyOlnC5BieTcPOx2bUnMVRdVp7asqxzC0Ffbz4tEiHOSpLD5l+/yNQkBYLArIGoL23qX1a74eGJ8CL28dAxplbKWHJ/EUWJ4cgZkxdqyCxLHkwRmsA6Zq0R4cWmqtBbNbk20EV55E2HAz7O/zyMA0J/j7RZh43zIHFXDDLvuC+Els2To/FnzMkGkJaI+teNZRs/4s5/uE/eGs7q6Fbh8T/O2C/fi8ne+zW+lJt9BcUxqhMb4CwQ5MjdsljRWB1u4V1L1fCdxXI52x2AMpfwpbBJWRoXLGE0ESDr5w2g53sKxygCYF04GTE4iCWnEB3R/MfodbficxPQE0QwbCRtdxtqaR91Uiind/ATMEGeBbRextzwTqvA3co0ynHhw+8F4bO9DMYTwSh+zU+Tom4O5SdpCDnWFS97bROjuS/3dsWc92pWiKrQ/3ZiBIWxDs3X3xl3xo+PPxg8OPxNP7n0s5WnyfFAAp6CAZtK6UBujhsc1Mk+fatF86OvTPdIT60k8a6qL58++HI9sfcBBAVrClkP0/+DNZ2Nrx4b4ewc+G5dhls52n2UHZNe9UZi5UtOZAlOXa5BkAk8Pn09JbPeUb0d7g9ar57U4OXEmaanW17TE5dE+ousRtIJodDOcpX34JI0Vj6b0Fmq/6urrUuTYcwgXByYHGRNCHuYqJfydG0zwYTqTVpAe0Qu0VQjhZJjzotYx8yXWbI+Ik8z3POunqLQhrQcqASZcc8vClLHN0AyTZwnhx/ratrineXesq2lPo7ROmaPch5MvEYhMxNUhhJGcD1vIKZhCvueNr73ecRBYY5DuuCn/aAxYwlMkmsw0QDqlIADzycyrFhdngxRmDfWthJHPKzFHooOEZMRwPrfKUoh880eW+y6/tvSVHiNFI0IPGp5ZIhEVV8zHCHmK6EVC+g5gfHA0ygbm4tOffCJ++MyPo79nINZtXZds5a1vKRFh+1XYcYtYxpFapnvS/5X/vY0h31RJNl4jMqGpgoGTSFcq7/fZtYVH8kYcnHBeUuxvksgu+f6D+pj8jqrIKQQRkKIEFnRx3pDDmGqUYm5HN29bXEsGDFBLIQzUuphYV8anEi1CYdG0pJ4wwUrSZQASASWhuIpi3TIF/uVFOBaWtD8wK5rBCX4pg1F439t573gmkRjb7tL1t1w9EsK2ncxjgEFaF4q6ebeaItyS2Q/7W9j6vGvM9mWMPAdyrdnS8ef1J+1M/oFX75Mp0RdJQrCCeVHzYIjn/rJm8s+MROvcQGwGdr0w/mNpzd4I24LqVnyrdjarl7Gu8LiEaynmfXj0ZHuDM03I+F+CWPPCSUIoS9xmQoTVwc1O2WSmt8yYLsnrt1uH9bwfJV8PEqcspMS4ONf5mkr9lFouKKXl7A2+EmYyR1VoF5PaRFhx1ss0pOhwvPp8XqzTawosFJq550yAbYTDZNInbBd+svUJ4cye1TIg8KEpRkOmQKsM7QJdZN1lGtQi2iinT6VI5hSCGInyInl+jpGraAStBbQ9RHk7TJEmzu4b/epmYKTui++/9ny8cupNEp9W4xN0Mh7cdh+m4MToICfQuvrWeOvSCYIdbEgEu5HbyjkXHHdiEln36byAC0gR8Oh7a31z7Nt4Vxy+eCwxm72DffgYncHPaXdiMmRAZcrb6xsJ7kAC8tOvxOkr52BY0DzJcLJS1HIpMkhrjz3r/QaBmETLVEXQBj7G8cFT+EtVxkvnXovDg2+Bt8qig2hzmnEXw6hNgsOcU/vb1NAQQ5hkj3n+IaA02t8xntfMO80O6LmpzGh35YmhxKAPv7aMSVvcy9enkf2veZ9BOFgv9C/3GUKtmBZ6NXMwhrBvCOZUU07nrJFIfp31LbGzcVtsrlvHvJPljK3mWaKJoIEZXCvy+T0EubjQ0xO99E84NFc2EsyhOcEjX0trr3cWBFaHje8smKyN9hcAAjU4Vhv9KTEanG6L9sf2nUN1VlMNpEmJsL3NeJQ+at6htHfxYL7NM9kJv3B6FyBykctt6+Aw1h/BA1zE3YepRCp8nxC0H3hfDIY1KtmVq+dAHUjLiG6VtZvdvtx/D/ZK8nIodZtkXFTzvpcMoSLRJPhC1t6NreZEjx3JCZfFcabeAbECRPi+d3hpA3S3hEiEKSADpoizExBYqvEcDb8pWpY+DwXzvLQKPzvvwn0qwf06DByzTJJmO6UQ4ouTSH3mTVEirWTbRJIS/RIA71WRuVDbI0Hg33tRZP5mMJMxp8qt1rrXJOT013NEMjWJIUiv14nhW/UpWxbZf7U9haaEC4vtFn2w/Ywwti+Fa87PzoswmSdwi2H0gXxMYPbYQw6flvlBzOwm4+J0ZZyhvwpY3NmrLbaVrZf07hZ9zNaNZCkP3FC9sDLSnj41mh8lbdKScdzwwMIHxyZzljRjac1lBL5MoWedS/vGlpar5f3/TiZJMyYZlwxKQDjtO0Gx/Dlqv41OlpgjxjmGVkgBjX5J2T7LfEkKe+/3Mva2YSJWzb1q0SjUldYQrGESjc8wVgYIKRYYpXQfW2UwRa2DOWAOKtEgNZbU0x7zABxdCRLsZTAY03Vzcd+2/dHZ2J6EHO4ylF2JwXD9byGpOR1IRPip/rOxo2s7/a2J104fjfGe83H/1vvi/m33ksPnWkxy3j+w9V7CXDdHW1MrDNe1qOc8P0D0u4bqehitirh7856UGF1j592d1AWjZNCXT9z1sZg/WhSHzhA4AybuCwc+HW0NrdHZ0pH8XtUwqTl6+s0fx5vnjsa6lnXx2O6HMY+rY42VxMPbH6R+fHewK1UUIVyrYN4NCORaEsee7DsXFy+T7HW0J0prMA/H56sBZvPqcH/0DA0A36Jkgtde18gYGhJuO9x7MplFDhLMyBDmMjZzaOady+SPSXS8pvIGBBGEAUe45Fmp5sq9mwC9MJlpv9IzBUma4WlFIcOar2ZOlGTmlwJCAI8u/Ls+0fUQAS/aCOqQRbSUeUvXedVELzFZPDeIoPLw2Al8hTFB93xi/ow02lIJg/R3YbMswGDt5YOFwBqD9MHCe6219wgChgEdJMrNKAdqsmcGWXmAWpQKp+g26XMmQ71VsyJXpVwpag2HpT9KA28qVC/xkf1qe84dnJ7XCWfYE56TONFXIz+4b6qH+pN0jgtZFcucwDB9NS3kJNrcEM+efiPqOhuisYOId6sgckvpQxWSsjmCLegw+0EWx3MDVvPTwrykS8v+Y/zLgGDZW9+vL+m4Dt9FIH0ZpRnySdHxKKmCqSHYxfU5zjrgmCTm0vcslWzVLKwdRK0SW4XFz+NIrGu45vq0eLfSZTVLI7OjzC2MWSJNNC95b4r9k0GyzSkZm0QgJ13CO27Afrq+C7VXy1bGIBx3SmDLiCTOHbMEv75FyXzF/cPPykU4Z1cdS2KyIOaWK/netD73iUTxuNo82r3VGpRImsTvRM1UMcRRP1LtXhgkYobFDuZnfB7TO6LfoUiEyL11bwv75d6bQmtQjK9FfrYUXl/Ne1tLJnqcKoMw0Mk/hweXg5jjl4mU2C1D2KN2PdO0Z2ttiu/HppG+sw7S+uX+1Y9mNb19B/cwEM3OnIOkTXJswhhCO/3wvrDIUOmDo1Yw+RMlq4HMXM+zNxG8S55ZfJ6q1JWME9GwobieM5jIbMUkIkXYNlgyFMOclxLeaR1xuIsD7Me0UQ9hqpoQUMlcqXXRjMvdqonxIM89vPsg383HuaGL9CHb+xLwl2BwNrZ3pbV+ZawnznB9GC3H5vb9saPh09SPUKnmMqadl+LaRH/0Q6gb6e5g04Gkabk8dBW/mQ4YsH0p6ls5+X3u3XZPWgsjBBfYvn4LZmaVcXXyWozRrwe23xsP77gfxoUAJ/j2HB54K5qamqKluQUTuQspjPZvPPIl9pRBXshMhFanCKZRQeKn932McwgfLf7Mqadv3BR5wcpgJmXOx/EP0i/p2vA1hDoEjUBLVAsDNTgxGpeH0boQpbWjviHaaxsTfhtBQFnEPjwzeDGtf60E8mMxm1VmmDeJUYYxq8LcsH4WMzwizF0YuxKGES+rUqCUrV9fc789X9XgZYU5ouJrMGCaADt/nnBsBTRItSmxeWK8aUvmyD+Le8A1pmbv2NAptGURndXNyaxyAi3U8Z5TBHTYwtm5/HmTtb32/6MMgTUG6aM8ux/hsXmwqoXxoCy0Uc6HnMI0Iwby8F1NUYo5NDnGcamEkfwPxSQ0XFrkiHTMBbl4NCc8fMPhqe02BOnCsytpcGSgSuj77YoapA13bYIo25SYscQc5TjhFg977EuEGghAn6fVMFW3qO5dX8oJnVv1IznMr6KlRLxwn3Valn5OXxZ8n3++/sT1b5Z753oprsZ3B4JBwrykfGENFcBdxGr+jtkJzTi4vwKydMGUUwJeLUeWL+XGFkTess+a1mUOwDzLOGowi1RDUYfpj8z+rYj5G2tc3SeZIwM4aAKZGDU0JolITqt4dXUsvSsR6hIYaRMsvXr9s3PuHOXz5RXNY2bmSP6ItLwK6XhuLnv9qaXvMuDL8CiRF8a2m+Zhof5kRsdt2SuaI+6VMcoYihvbv7n2jHmz7grgP44WqZs8P02E/N5FtLY6COBzmBVdhrjuJfodHjPsyWUEKEsqtn8p0SYmWpXMuQR8IRyW3H7TR+HmvpCBrkbb4ZgHJ4eSBH0pTN0N5tDSUV0tg6+2le8PXz0TcOGBKDactowAc7OwrpfWd1Nn3s8v6Hw6rz2r7c+CwCE1yec815DjcV6TSW8i8DPTOJ/J10IufFixuzQhY6CmopZIiYAgmaBpTuX+kEmSsXBZG/nTtekH25wmrLkR3FoIUuCqHhjHfAzN0+GeE+n7WQQmKT/cAmNlv88PXIyrI92pDdeXTNSl0e7oHngj6sea2Pskym0aJh3FdDQTYEE/qUuY6Q0SpGcYH1X9UC9du8LKk+kn4Ac+qPpL6ptTg/9TL7mT1teScJdr4rBTI+dS1NY6rk1gnjkCTtO/bWoKKwm12DA1jdUN+AhNkyR8DG2YSchLoqWhKYU3n4KpUZAjoyjScZ1EEP4evKfmxqAUMuFqvWVsJ6l7ABgYrbUZuMgwjcBEDXHGtBGESNO8WTRcycRdWZ3zCwxdmbPFhEkHDyqQ8utUvz5EkzBmRHOVYS4l2EIJfeaBNFdq72SCfUBhhcX/ahJnS4lCh7+R0UGLiaB3Feb0jb4Tsb9pdwrXbn3+pbUiDmcuPJ9ODZ2Pnom+2Fi/Lu23gfHB6EUbNj/lGUNbnNlr5c6EwBqDdGfO+0dg1GphOBqzM/KG8Yhsq7DtXiyevrcp3uJhKAJTWpYiNN30DAe7huUiQAjaYg/3hUM6J/6NylPEQV0JQSVSWq4k4o775iAI8ueXu08kkNe7iiHcVIW+FRKVY+Z++pCKUthyfDkci9L85Yr279qW58Tccvf4ncwnuj2r4g84898IejoQm8E9h5VLIo9AZPvFC9f16bhdsYUKCM1iNEciYs08RKR58TsR+NwYxDf+SalM0isSYBoSHEomynW8R/KqVsL68uL4xmFYp2cxDGUdJXIZAqzSKF7VBj7AZK2grfy59+I1EcDAT7M4ncsnijBjoX+u99sWbkl5ahLhKgzx+QAu/uAFxahWqIOhJ40PcwbEbmjGZzSlsZ7KYrRJCCUywuk6vPIHDJKmI7rF9ZzGQh/UhintZuYXhBZcKRhPfl/hHOR1LveaYMHz5ufpq2yP00Qva53rJwTxfHThCD4yNRin2NLH52CgiuvwYZJsvXVxvYxjOiRxrGmY2h21ScseXEuqst+uaZnZKhjwJoh410x/YpIy5sB7PEMUFlXy56umeY7dn6XFhJ8lMP+aYHlW2S+JRgn+Qtgtfe6mz+ypJLVJFwrb8f1KUFnp+6z2dBYW3GJ//FuMSsg1P5s/SrikEfI5LykoD3Pn97eac8fcT0CcMva4a8/AAk5JGU5AbRXNMURy2SmJbJasKSLy9pWPKfyQ+ZSJMJG261r4JXsB+2L/+Zz7U9lftTSlJp9N8y7Y0HSV4OPWRcJvrg3zJzhh/5NJWwemYf3lA3FsBAsAGAVHOM+4UqhuPkmuu188/yYmp6K8riKOXzoZW5s3xfaW+uid6GGtjmPaSlQ5hBCaDxrJLYGK/aapm5WWMv7i2Uq+zwI+6Gupz5tR/oShJcEbZspXx2kR5blH3C/DMGA1MEFd1SSRZW2fH+xJuYtkoFqrsj2v+aqhw2dN3mv0BPazwsNRmMAGhBFFMOzWx2GQ/J16R/uTGaOwnJuWQfIRri/wKTKe85joWa9zYpFxdU177ldytk5iAjwODF659kbKfXV35U6YJs4MtEdqkzSvk5nthjE63nc6KurQSrKmesljdW2oDxPM2ri7g2duEIBmba39v3MgsMYg3Tlz/ZEaaYaa0jmfcNJNgxNRrbJ4xkpUlCMxVFJ4uyIiL0FKq1RenJflV8qQgUyWkrBbaUQkusfIiwS5BMGK8ytn/60Q+u36c6vr2pDLGEhIvl9trNS+TI+h0JUSplw2y1r70SsAINJdqXhNQsaknlmaIhAkmFGHXjOz65A7RiCC7vGeVFc9Utla7OLLQG4lZG832tFEyWyy8V/ApzSVQWOBDFhsWmalg+hVEjHT1jkxALEE+WMnICj1T5qBOdJUZLHPTL0IOy9J6s/aSE7hEFBLi1ocJaF5MT9LNf1NpqL5l+/Tq4SP7RgBTyJOpjVnLFdqUsJqZroKrRiZ6auGMUXMCFTHZ6jllYoQti2J9uXWn9clVkcJdYwHYPIrWU6blOnZJAcznyaf0VdLCbJrO4W+p66lJZvhpd8u/1kC0NPEH4muKebjdMn2ODlJAOLRszBKY9GFVP5ufLzbYFBeIijAuWJMXlnjtyvWnZk3GvGxPDEywuWWwpGFSp0bYSchriapsRI/RMY6QB8yUzlDxiu9b+AsYs2qNYPgvVXJNIpEIYT4t161A9kZhhRes9FbPew1qfk5wkrMwtQaWYCPsHJQsbQr8CSEhaevwDO7vnDNz7drgVsctwyPRfip5cjqydZMusBl75Pg9Z4Ez1tW78WM2J5kD+pv4vr1THFICmCMsNnM/h/BnHHK6JLUXYyGw3NBBlRC3kAQI1zzXJABTmbVPGv77gn7kjMTeZ9vHLLtzEZ1zVT8lGSuL55+IeoI6V0B42qC1s1tm+LTdz0WmxrWxRU842SG9D+qJkz1PGeSTK5GYmpqnCv9cH9E1LvYE3Gg7i6ELwavUNtFMmKYkGR2xtBl0OyjOErtj2bqpZUy+frujBFYAhNcmHEB7RgsN6xRp9UfLslolBFd0jpbyOmmtu1s31VCj+NvSKe8PoGJnOahfuF94lhXpuu5l7QVQ5gIzhGSuxqhTTE5iqZg5EaIBDuM6XwqtOP+Lja6KMeMTFJqnzmxlDAv5d7Dt7VojloINT5KBMIBmEYFCZpOGgDnmUsvIWABrpXrWZKeGTCEaAmvwRwd7T8d4+TxMmhHN+HRh2BKG4H1/SS53VK/IfU5Nbb2746EwO1P9zsSLGuD/rsOAU0ANIXIjmyPdFHFysWDNbsnO1x9wuIntQwyEpoBiJRNFqh0LK/xBiSx8FQyYcNuWhOE5EyavvcfSBJyT6K3itDOM/hqaBZi+9eLpguYbHgfxKYhsldLMF2vY3XvNOmqgkkRKUhYfmAF4GV+JmY4z8LGLts2BJX5nlaaP5GtZljrqltjons0eq5eAzEWR9v6jljX2R7nzpBU8eLF2PfYQYgWw5UXxbrK1ui/QC6QlpYYGR6NI8eOxcNPPgTiHE6MlVORayJEus5v+qEts7mXTpXGySMnYuf+nUS8qsKERMpA8xmQNBJNJcgIhBNjlmaV5zQToapsQfHifEoMj6O9W25shd8lfzXoEk3sbl5ry0LtXX8pkayGUYJ2DK3WAj20bL3cirYM34trm2O8YjzqWs8TvYsw5hCZktj5Xlr2Yb68ce3ffJcwnABOSnTdNykimI1ms5IIV/vrnEkQywSomTLohczoe7Wuc6Iw9RCAaJLUD9E4VNQYx8yKMzYSe4pG4l4iHj5YDmMJ33wBJinTJBXu76znS0fqmWIYfolniV5NLR3XrUq+TiTGHb9CmQac6ssZ/zDEpIxXTXkNBGJtWjsKeNTMOTe3KvmcuP4r2U95HrNJNGXZ2cd6XrHQZ4jj+elmBAZNEJ9o62GUiiHK54lWVgzBWVQCcEowWS4mMTcJqYOAF0Ho7NWW5DPihpIYpiv6vSnsSHpj4Jhdz2pL+3eBCPebHGY3tAUHZHBvyekiGDehLvzU2prXx/26WGivthRfGLSWnuWJOYIJ9SwS3ka4mwD32AetFSypzdRV2pFJ9L194k8GamnhMjdMxzXSOrTXbohffeBXoqmxJM71no7/+syfRWttUzy644FYX78+MQ6u9/qqeoQT86ybihggB9EIJqCz4I+mijqYZzXp2VnaUNxA2PDa5G/0Zu9bJGTtTsxwvtZkOubEWwry6L8wKKH+MQIoaEJn3/K9oClfYqycBIZRhD8d7xJj6BAsozCLJnYdAi5lMF5Jw0Mtaqhh1/EBkl3hcQRWY4TFMBT5BJtHPGtOJNmZMRLTDo2PwDzJdC7gXsGo5hjmSEbUfmSNC97US/aBa4NnmL9qxjFN/0cmDPTAekNoJU53D393+CfxsXX3xabqLtJxjJJv8EKcH8LPCaa+vr42jcO1tr6uNe5p3QtztJ5eZUx5dnHt/50IgYJT4U4c/tqYf1Eh4BHaUdOKFG0UqdH4IkHg8e3hmR3j10fnQevBXaSJEZK1/IhNAQ0ggjXzGkSaXomnZhtaHZEillOJ+ZHBWVo0kNIJ16SCIhwRQCq0UVZEZDKkfLU4rU5jbqXEcRpHUO/LEU/Wv8zMyDDMNfgYgIlXQgAAQABJREFUvB+5ZUQjmvXowzCCc7AE5gdR1E7o0GzJ50NiTIn10uK9+bwtvWa+EpmjvtO98c0//XrKuSEiM5v6b/32V+PiyXPxzLPPxL2P3BfNOF5XYAtfAbH281d+Hvfs2RO91/rjO996Kh771GNEM4KYnYSoxym5COQsEVnGfFOd3A59IGoY+UiuXe6JH3/vR7Fu0/poXU+SQ/xOipFg63w9U8HfFOaVtDE8PhqDEM2WRERIQS2UxIBA7K82xLZw8UdYfFBFotOEiNBVtykQZdVIomuGY+DqdvytkLy3n2H9y7BI+Cz/uGtdZkYGZul+XPqE170vme7RL8Px5uDMmVifcS3JLEjQOneaP0mE5vtqab3LfqbPwtpxJ9INIss2UuFLNZpe1zRVnxRvLJK4IwT467NVJMHsjYer5uNhmKSS6ZK4UtTO3dkzkpcyjYLUdzcVvtLsSb+MtEYwE1ptET7j85xRSOXrKmpJTFoLQQgDAgFuXcJQP5ppmBQ1Gast7ki1J1UQ2cJRbZKvK86ZKpeyEQjcMfzvejA5hUmacb4EKM7z/skMYWYanrUQwTImQmRVhfUkYT6PhmqWen1svhimD2ZLLVVik5yzBcYjEc63qtj1OYOQaGRzFFX00efe1Mc59nz/JKZ2nFP6IwlDx61/oXB1DZRjKWBAAou+c/qUySTlUdRcewDq+l96C+TYFMnnbIXNISSKYJCK0STVVFUjmFnHF+Nx75Z98ZOjz0Lkj3JmV8Trp9+MI5dPYko3nnyOfmnfp2N7+6b4k0N/GRcGu8FbRfEPHvxSmj+1T8MTY/FjnleraIQ6GXG1b47FvSJznpg6+py0dKzDGfx+7KvmbNOY4oEoE/Mnfqsggl1pxXUBFuBJI8wZQ9d4L1FY0z5kTryeon5Sbz+BToSZTL2JZI3gOUCS3IHRoXR+l6E1Mt8UurgUztxgGAJSPZGFbtCPDF/IjM7B2KqpTz98NnHwLFpQr8GqQgdMxgUCSKg1UkPvWe8B5Zwa4OS5S6/GhfpuYDQKM6j2kDDgBJVorq1PgjHncltNV2yq60ynsOwxPeDPCV4rdyIE1hikO3HWf8HH7EH28fX3x6baLtTivXF04FRcGr7KITgCGkZi5RErss4L55uIwXCoZcXtIFtkVuUc6vxUojEwh8MwTFYdBNduTFh2giznKupjGCK8H3OAc6jiJRq836MY1Jwkb5q4mJj2+vGZ+XjIXGX3oUmAUZKYn52H4VLyiGRLZJUX61QyLCLRbOj9KPZYM7fquSxoQ96396OtrM4sSESahwUE45xJS6SPBQ1LmGa5PAq+zN9yv34bFTOl8a2v/2U0NjXGb/3z34mRweH44z/8Wjz/sxejuaklhgeH4rUXX4/+vv649957iPjXGVu3bYnWtra41t2btAw1IOkrV6fi1OlTIPOIbTu2x9YNG+L8BTRQhK3VaVmCYP+B/TCrSIthKkX6Ez0QyVcH4i6YrRHMUN449gbOzaPR3t4aHV0d9B6fEGz6dZxOC6Fg2UnEy/SuRsPhOpA0+KCKfZogmW2StKaO36pl+gYTX1l/OWpxfq6sHmAu81XvWhaNFAx8oSrXmX5Yrm9Ht5riM0lTxB7JmUWJd4nXvEjYJUdywiU4Dgmgt1NkX/QLSZoo9lz5PAQgGsCsjxmz5fhs0/lV/2spdp8yn8dmcGiHSbofTdLjMNtvQUd1F7cSZSxjCGWAdOifRLJtdK1lS6ry7fXb/gmb5ITOe03u/ONtgoGwEzbes2JhXPnRuPQcUJNbUcrpxD6w317PYLJSbRDdpWMwSgsmUd5m5WlYzvfCnC9+9tLt6lxoi0eLSmQi8fUa3pgI7+LKAZgbGJzyITgotFP5QBYeWfmFMcFsTQ9towO7o7T+eJTWnmPZjiRGp3+8P5mtmbPK6KeamY3NgkuAowECXH/CVd+caTQfmmsVSaADJxkLr+clMQ6Ol+V6a9hxD4xmEQzfCGa8V8BhDZzP53svRB9MxMMknR3Fv+dM9/m4Z8Mukss2xX/96Z/G86dfik3NXXHyyplALBhfuOfJaG9osbIYGBuMpw49Hd2D1wjx/dmUsNaoeDnMZZpTn+zf9S6ntTMJU2EpAVfJcCRh3jivwENGJr/fbWhKhHKi5FUbgAEYKEAUp6khUsBhgBoT1RJWL0aZp8aauqhAaCg8K6ZJkF1cm0zr9B10/9qnMvIplWGRMYOJ3BQmcvPg6rSQ6Gti1p0DVfh+6/rEv3eeM7u8mh0KE2oOxAsjmO3BIDpX+iQVwdilo4HHyhmTflmHe45FHSbY1RVV0drYHM11DWitM38uNUZGBHRZKfIsSuazBYBKra/9u5MgsMYg3Umz/REZqwfqfW33pNEYfWhLXVecJZTo81cPxeUxpGogNRmXLAINt3HgKZGcIsN3EcxQ8fiuKOp4DsIc0zokbB68uJjGvYRx3QQBlLKk80xreRO5UCRbi+IskkYPXuu0fTGG5gB58RBPvicQ10kSaaMFxbDeJdg5+61mV9cLyIFrmha936VCfySOfm3A3y5R+bb6BnjMQH8DHBh4Brcba/I7/U6WEmveJZSF/cjQCKZ0Z+N//F//FWFn0R40lMVXfusfxeTQWFw8fzHOnrsQh984HJfPX4hjh47Ev/2f/1U89Rd/E09+6lMwp1leIfNi/eh7P4zBEQgGtImvvPjz+J3f+c14/sfPx7M/ezb2H7w3Lpw5H71Xe+LRRx5NksfzZ8/H0SNHor66LrZ2bYmnn/5uHDl8NLpgrF752cvx4OMPxb6H7o2xy5h64j+wtEhkK9G3z2o9lhv/0mc+iM9qzsZhjjJ/u9UTAOWVY9HQfiKZ+WDTkqKlZU7M2Vp3f/hnkbXQXCsngG43LmGTM0H6LPm8JRF3iVHxmwUfBL6ViLXV1fc+VZf+yRiZ90wTo2n8UCZYf1WsE/egzEEZZ4WEr2Gg1Sbx5WJDxezzKYioE7Pt0YRJ0B6ij20r7UEAUxUjpZ2YPGWhzIuAT//MYPTM97LjMvjkPXCsyTzQ+vlZbu3n9y599X5NERG1JHglocoN1d/wYfFxYZuZJUo0Qvh6EjCupAWkhxZhqblVUTkEZ2IgV8l8GkUjL8s3nyCQGImF6znRnj+WvS55WA1L9TlghfnlWCe30EM0QVGqCZ/m1csxgnkdBSuD/ikQK286ElN9+2L6GiG5J0jgWn+MsaJRIA9SEZqJxjJ8D9mzU7IeEPMG5PHVNawZtfnN5jlHNBlzvTiGxDzzTF6S4OD6x+yc5bPztlzRT/N07+F46s1voL2uIMAB+bdIELu/655oqW+KJ/Y8GleGeqJ/hDDarMlBfGTU+lbCTDy4+UAc3HZ3+l4B20+PPIvZ+Xj8/id+M7paO+NQz5EUCS9ZTiDs8ZxNgR7QxGjG5u6yX2nP+jH1kzXJdCbtC+tExidjULLeo2MnuMN8NMBgdNG/WXBnH4LJoQWfLOvTdM6VLeyqwTkdJMvFIBbt1BSMUmWsb6rFJ3QqaXW0rkjrf6F9tVU+r3ZIDZ8MWoLpAvBkTqfQDNn/epjYdbV1+DBOxwXuG5wfTWNKZoHAxz1WDo53j+ge18fZ77pmApNZXRN5mgzIpEapihxRmsTPIyyZmlEASj8QGCw/awudWXv5yENgjUH6yE/xR3OAOYGfbJNxvNxWtxEfjpp4se911OyXk8ancOTJBEp/hdnLWIHsw+oDp1jMpSTw1oGkdmFz3oqvy7wZw7HnLxYBKoXi4N5MIrt+kNIMCAPxVSLdJGumkAAW85eZKhEeHA2Uh/FyBI/nvxhIcwOdypPfkgQ0besjlGy3efL9LCKvatpSMp8Trzkc38t2NYuTMbgOByWSOvYvHR9EMUi/EAHe3A+k8kgLxecivCHs5Kcxgdm9eVtUEA3uAszR1m3b4nf/2W/HW8dOxH/8v/89oXLR7CHBnIMILknSwYT7Y9vOrVGNvfmVi1fiZz96Ji5dupwSQO6/b3/87u//bnz/u9+LI68ejrmHZjHN642n/uqpaG1tjq9+9R/h+9Qdh159Pb78W1+JvXv3xPeeejpe/OnP4sDD90V1YzW5VTRNubn3EqZqkTJztIwQXXqX8yLx+EEg40QcQ0xpJpRBZWlvbv25tAySEGJLBti1bq+dZ+tVo5qYbz47p36fM0wr1grMvDdpQ4ATHxIjVLgmbEPiLgGoAMa5AiGtM4k7+pXeFzSW3c5/fo065jrMzaOszzVpTpuRySzpNLEEYZQ038tNHQsaXKgXpVGMldTGIfyyiqYHYgdalHYCTQyzBkZL8TnExIwwIUlgolO4ZGZenOMUjhuzLTWMS/ub33fr18wcUe2c66vQf0aGbulK8h5D/uf5sLyuNF/CfwKz4mnNjwXQQlHb7L5Uy5Z8n9h8hdfz+5yQ1axZn9Vn03pz7ZSaB1u8/jzM75ww51smNgV9WJjg4qpuokp2Z9fyJ1J3rz+d9YkvMYeVbblJuwRTUFp/EqZnPCZlkoa2xNx4axTVsd9LjkdPUX+MV+JDU642UWYSzRFrQ58cGdKkVYFJynPvVEBAF/Nn/jzP8hvHQjd8lj9LgtLSrmYdpqez+Bltjsd2fDYa6mDUcYdpg/Goq66Jt7pPx9df+jamlDAjLeuZJ6j8BZi4S5x3czKVYKZmeHBNzExy2o8GKqUUSIyrMHHNscfAbfrbjqXgEwtMP/1yfSxG66NfMiZqcFKX0xD8xydw5vzkBszuuqMT5qIeM1j9g6oxUT8HEzfA/ndWZVD4h4IMOLLO3bvpHCTIhMgzhZtHWGh0U00cR8k5lK8v4ezel0nyT+PGZLK3AMuFXqV9u6N0MNqrN8ah4UH2XSNhXjJtryCqgTGrKa/Al6yKeYy42I/f0wS5ziqok1DpCs66h3tgeg0nPhdVM+4PgnLUM1JM492jdGOt3OEQWGOQ7vAF8Is+/JzANmdQV+W6qOBQ/MHMc5gb4JDPj9dT0SYcm+NppIXFpVc5vGs5EEeDdIFxL5KjGg7mOaKkldW2gCAXTsaEHCLq0Qo1EkWtF6m7B71m5ZNIsQznLPZRyuYprDRwuTIPkWQyPu+VyK8GsSjx0++pGCSnj1COIJZ7/r38TuRjQIoy+m6gCB1plfS9l+2XQ+gmpEutFgmFZGol4ZKh3WxIYDJhlmsGsi+v/8/6BDGO2YdhY8fGx9HqkfMD198zp89AnGriUhL1Ddi3Q3xJAJQiObRkyM15VEIKbkci+dbRk4S7NfKTmggIV6eNdVNXC0PMvBrFUKLH/mquJ8G/dfvWJEkeG+U5qutYh5YAv4Hm1hYQa2a6abjZFOc3tXzjP+Ets6gvkhHjbhj/wq2OE9r+AykZ45ExIUqWb8vALOmVzJEET56/KF83EtvjaGPUzhSW5cZbeB2AJIJIwk5/CUNPL1fst3Ok9iuvU6bS+ZMlUGOciDP2u7RUuo++uv/98deFUILvWDlnhP22Ts2OMgJXwQeEHcRSERJk++WYkrnaMnMzjXbsCg7zp3h+HT42ZZgSFZPst4LwwGUQ+hJpyb+LZ/WVkjCVOXCvGWDBP9vP4eeYPRsUoOgXqYZL88dEZC/TvmeJxF0xRKjzkc0rwwRGMkJJO8R+s36/Sz+8Wq4zR5oZLr/31Xibn0spuueEDE1hcWcvahcE1gqFIab175ljcBPXnMy5RHoGd3cicJjBvG18ffI7Kka7ICNThKYoOKNTwAfGkU3iCg1Rx9wMplsTLRDBPQB97KYbXRclNRdhIjj3iu+NmZENUdR/fxRXdsZc5WHMwRCeEUZALUUxGkDno4i9bSADtTdGYdMcuJzzyDx2FXx2345iupXvI+fLv9wcLDELK4OH+2aipbY1drXtx8etN0aLL8ab5O7ZEVvi9QtH0CiNxC8f/GxsaF4XRy6+tcAfUSG/zq2pJCrKgB+fv3Tf55iviOfeeimaCPKwvrE9BTIyMa5MTBXrYhSGbhotmJYQZQtaMOtxDfnn2nDPzJK2YGocCwmDJHB9bg7rg6H9rKWy6KgihxR7aJx5VNgwDg5xPhPTyx7zR5SYscCZUEJTc4WUpTA9nsfznMfVMEjF5H4y4EXCQcBNU3iZM+Hp2a55nzC0TmGa+VPB7JHj6P5mcj3x7PmyTs5+8LnPOy7O8A6iOlbxqundud6rcakfTS7Xqpi3WvyhZjCDTcFx6ItChXEYzQqS0lYRqVIaQuSgxqsMnLJW7lwILE/R3bnwWBv5LyAEylGPW0RMmtw9ALI5gfRtEkRQvpiJGyQAkc2RToK6qxAtEiLjxKaCoOCQ1FgD4wmknGAY6skLeIc7imIDB/AwttESYtNJ/Z8RDF5XI5MKWMo+ZMSKSIWDd5RDfLI6qqtGOGzRWEFM5QRSwnIZOsme/4D+OzqRfTUEkIEUJkAi5v0QubzbIjFmGNqMYID0gSCSGdSUISdsC9uwHysWOiqSrW6ojU3bN8UrL7wcGzd1xejQaHzjT74eWzdvjc5OGCaRMnBPiDnNHbB3kAvTKBl6tbs7jh09Fr/zT387hkdG8Du6yjMZcbhw2yJC9/OmzRvjvsfuj6NvHkumefv37Y/aupo4/uaR2LlrZ5w/ezYam5FaIhWdG8lrWH4kjjsRSi6yFYoErQg7mVq6qN7HouZHYkgmQs2WjKDvV1Mci1G0DBOc4M1D1iHzZz3LzfFq6tWuxxDTK5WcGC+8bvS25vIGdh/mbNNDEPJEdENDahmeGU37tkF/A0ziNIsqMwgBxJdaY4lcGe5SNAb2e4z1D9mcBB+upSm0QfrhOJ4kAClsOL3nCn0eZMuMMndVRYMw4ZVoliDoeN41P0pABRmDjsqW1K8RBCx9SMxdmDJB7hHrTyZQvDbh/9hR2oLwojSGSc55cbwbrQC+Npwr/iw0m50xfLZfCS7UJwPkfHj2aEpnHi6JTZ9LzCtmYzTJ3sQXBybWsM6J+ctqXfa/dVVxPphfxjm+XhQ6EBqcc8NxCq+lxW8co1oj/QhlNiz2J+X7grkchbi1Hu8tMqAD45we3Il/D8wjeYBKa65ESe15rt7IdFvPjYWRTzbHdP8+6Fog0YqPXFbrjbfxSQa/uOpaVLT8nEAtozE/0QzhTYj0qf34wRCoofg8+XqG0xk/hSYaOjoxJSyZRLCXQ7DXlxD1TiEav0YiFAZqcByLJmGWBBOnLN3mm+VLNW3O4Z8zRk61t0YuYiZ2gq0wh1laS3Q1dQK3ovjB0WeYh0r8kc5E69Z7k+lnPaqmxMiAuRQSNBC1rpkEsA9uP5CSnD5/8qX41fu/GJ11LXGexLOes0I6C/kt04ygDuJfAYGaQqcQUUHWX+a9vBJhBcFo0gmMVm524C7ge1e0bjyC1r0Ev8tRfDInYA7ZNWrsYZIYPi0sWQusOc8W7Qk0W7OdOfyM0jzAfBqxUk2Ya1UGa2oUH13Wmmu+ojZbM3md4m/hqihjb+VwrKtvj6NGv2N/WW8KVc/arp6vgjEimiN9O9+PCSXnvTi3tLI4ampgpJizORg//ctS4lv3DIKJznoYLfarLShIM5Fuc7PRC1eev+Vnde3bjwoE1hikj8pMro0jHbITE9jmj4MKpjT5IYneAoMk8lULIVETxVd43QLuKo4hiOSLRM9ZD5mVR8wpBKUHrwRMM9KuDTgMn5kboN5c0Q+6B4EtapzEhqkgyZrB1KG/MXoub4jRkeqorBmL+rrBqKkbjioiglVUYP5FiNYPs4jKSpAI1kIsTkDAjJAzQ+TwbkoKZUzOmCKIPH04imGWltUe2YjIUgCvWMhgD+KdrpqNz//yL8U3/vjr8Rdf/4uEuEVsT376E3HmFDlq2pqpCjMetEftaHgk3jvWtSeGpgRk2A4T1dLSFB0d7fH0X38PRAzhi8mNGqP6JnSIk5kTcm0tBDehwStxQN6wdWMcvP9grOtYF8/99NnYt++eeOjhR+LZnz4XJ986FcPDQ/H4Zz6OM75+LFJRKw4iXbiRwLz53kTE4ptWjC+TGof3s0ikSpSkJK9oNieRqI8S+lYC73ZFBlhpsAxdRrjwPIzdu/GxUsOm9mipliLvi0RRFqkq0zb4vTRLCwxF2WBJjA6MROf6tqhqJBDHycvs76K4e+uOmBgjWWb3MNJlBCM6dNeVx7mzl5Ikuq2tNU6eOBV7du2CSGIfQsSt29QRvcVENWN8EyR3VQskga+WM2kTqDeNm+8lTl2501DQAxwpm8tg5BF+XCke5XyAYOZ5BQ6bqtZHy3R9zPRORUdzM8mESwjt3JcIOsds/YkAo7JGkmZeO9kdgz1DsWnfpmgk/LTjzOaFdQEhnJgI1m9K8st0yRgtpd/smwThogbMfvKMPpMl7BHnf/VFjSHrxbaXFH049elQ2+X85MXxuPcriQAnM1QYxCC/x7w5wkdCNgEDJ5HSulNo9w2fzagMxEDCVoOD3K541syOE0lwshGG6gJ1FPp4LvM0uKCosh9NwUtw92oLNMvjVc0hZ0epDDWmpPrBuMY1T0uRAnl1oxstjt5HKe1mGjuYJGFACOwE2gVQeA6tRFw7B0ZAPUDUuiKStVZUsrYh6GVkvHZpuDv2tu2MXzn4uTh8/kTUVtfG33/kVwl4QKhvzupHdz5IMnQiB8KoqZ18bO/D0VHXTt9m4rMHPhGHLxxPeeLwOoLhzJhnNXeJIWU/lbMO1NpOEBJ7Ek1RCi7BFOfmmo63DH8gc8jNYo44OYDPL7475VUDMQRzbT1G9PNcy3CGsFkYOPXnzDnHbDpvfdbLMpoGwGGSadORgpNpC640CS+YGubPOUBLBzPq3k9Mp997n4xd8UgcaKhKQr2zJW2ME5Nx9pzhxl1T5vUy1P3IKL5rmFrXasKOELWCRN7CboZ+p/UKrMUPDQg/W6uaY3fjFvY+2ltoiBFyNBndb63c2RBYY5Du7Pn/hR99kihBrI0jDTYjuoTQBH9iKs7KdMAuIikQt+ZQc4RTLYIo9J5R5MbPQxzeV9IQbURwwgQ8Fe2SPdAXtRNInDqJRDeKadpFJZrpIEd27SG/SKFIyGG7P1kZfd2tcflKF0gb7RZE6NhQQ4wPkTUcpqgKE4Xmtu5o67iCyYHEmcjlwyoZmZscuCF4phakzu+8N0QIS8ErsqAEEhDOkahwaRGd3o4hU2N3cfxabN61IX7vX/yTOH7kGFHUKmPX3p1RA3OzsWRDNK5rImv6RNTi/PtrX/lSlMEUf+HXv4j0D6drEPDfa/5liOOq+Ae/+eU4c+Y0TFFDNDY0RkdTa2yc2xRDBO8YImP95t1opLrWRX1bQzz5hU9GXQueJM210dSOpojnH3/ysWjuwB+tbyBptBo6m5HOXob4XGI6uGSgQlgY3K5IxCrZN8R1Tqjc7pl3cz3NPNMiQyCRlRM1t6rTecz9jLzPOmQa3k6xDpksBQ/CRU2DPwYQWVq8Vz8Nfwph6L7U4+HqhUvx+vOvx6Of+Fhs3LIhnv7WdxMD9Nv/8rej5+K1ePlvX4o9O3cl3zMl2edOn4W4y/p88uhb0UYURHNaGWJ4U8Vm+kUwFwikShl8/BrdmiUzEm88w5lQXCFRhakuJrb2bbqqHUaqJ2mntsywTuaIVknyy8uTPdEz2puY9YsnL8ZbLx+Lux/dF9XbG4AYPhIktuyAKKucwT8NQlzn9Eby3Jy6+lZcOH0uNu7eiIlUJ8FjYAIRYAjj6QnPNQpKsmtTAzFICHI1AQp60lxmV1O/ymA6y2AufM5+0uvEeAtng2CUzaIVYK8vV7zfUlhn4fv8GeewBpMpTjx+lPxnazzliMNMSZ/MharyRxZf7YcMlGZ2Eu7pjKDZ4poLqeX0YKou68vig8u8mYcKL2k4gTb3KpMFjFZgqq6PgRFaN8INTfHUcpsE1r5Oo2FMyXI5C/NQ1qlJu5ENLzFDE0RzdOz22/H6N8e55zNGS0044RZdl7HQV3Z9A8EiYM6uEG1zck5zwqyR3vGBONp3MjY1rovPtj2R1ix6XmAccXr0fDQiyHHc14jiOkikus629tTvN3uPJcuALV3kLCNgw8WBK9Q7CZ6hX8yPRL9w0HJgij6Ms9anOfsqaklbzpphWhZLMYIFDaBnh9cBGEwkYY6KyxGigVhdI1XMn/mX8kAHKTw8dRsQZxafPkcygpWGgoAqz0j+MN8giuxChEp5bszP3XP2SZiUV6BRgjESpQrbtEapKL3nur5SO2d6o7OxIU4QdKG/sg0hBeNAuCTTJsh9HcbfyHHJHLlCy0mIq8ZoTq0nmrFZIu2VKCBrrI1tDZtiR91mtHD1aY9PYraY4ET7a+XOhsAag3Rnz/8v/OjVGMkcTZG120M0SZkgnFIEOw84z7gcUfEq4tI4pYyIXCY3lAIaBJE8D3G6f7466ngVv84m84IFlFpQx3qSefaZtwGCLfme5BDknsmpyhgdrI1r1zpisL+ZusE2yfeIdkEKlnmosdHhOiR3lRA3M9GxHqT+d6Ao5VWnAPp4173JCSwrElndqgjhBSgvfxv9msCJ98zQhWhqaIi7PnFvmtsBQuBe7euLTnIktdQ1R994X5Kat29qjwEc56s6agjRTnQq5rysndDMhNGtbK2MHZ33YOJRBHEDcocRMZLZIFLk1y72R0cbuTEai+PiVHcUNZcmEydNmGraqjClGqGN4Wje0xHtRV0w4eNxbvhSypVTON7lB+EShEhdYBZXvgchNtooTe0+CAbJfrhnNCWTUF3NOGQyUvLGgkGs5rn8du/VR6YK807NaISvxQhhK9ZDH93PrhPvsc9qHgaZj7rmBqTNZdHb05tyYPXxqnDDQBw9RCQUjp1oFfWjMadNOh94PvkvQTB5HpQTYtikucpMTr9xIk6dPJWk2vsO7IvNGzfG62++QaTEszBOk0jVK6KpqSn6eq5BTM/GwYcPYvZ0X7x5+Ei8cfQQmqcSGO1tsXFbZ9IsJs0X7Wk2lMITM85S2uyqbov53rl48403Ut8713fGgw89gG8HBB3jmRmfjnOvnYZoLYt77rk7zlw4Q5CQV5Pp1469O6JzR0didJTiJ5gAm8KSNBuMqZTzRnNKPys99yikOwkuSbNQsD/dK6UwNfod6aMhcXrLvUldwrEauFIrY8/MzCSc1WDdqlivhLFRzoAORPYCs5aERfby7RQGxFlaVNWXPbRMHY7fkmp2oBbGbuAOzb3mYWyq9f+iHv1q8iiJau28Z6kQgCfT2VZsW9QD1Aja4/usai0Lssayzzf85x7Hf4WEqVfH8JdKIcg34h8lg2UFWf+ujfYlbWPed59x7dtkFZo5zcE0c8xC9VOnE7tQt/tl2nDbCAurKqvSOadG0Xv00VEjqAma+bisTx/OQubI/rp3ZsqZF/zB7FVZNSHWCUJiMwYmmpZph/maQXg4Q3tJyAKzjxorw7PWi6DBHGIGXJAfHcQHWEZPs0vzy2lil+/JzOyN0fOc/cwFNmrwLHNcKCGp9T7dgthPF8rWEUyzPEYx9yvM+yWjNTU2ldJ3KPwRnDP6q6LhNcBPCkEOjm/E53h/857Y2biV/Z/57c3A3GmJINx8v1bubAisMUh39vz/wo5ewkbmaHiYsKcgV5GI343rtDl6iSOYgw47ar/LiwgGyofDFyYoSRkVYXl+FmE2MB6nxgawk65GZlsa9djqQ1qAMziUPbD5meDg7dPRnsNeP4PCMoNJXfeFdfi6rEPaLLKxrRvvye4HeYCr57z/yka0SZNoNPpTLwrr+6DfCwMly+D997wks0bgleBfULtzlpJ98t1ykFq81bmGwDUjfCykXHFaq4mEVAqSvXDyfJL4JV8NJquFyHOz1UVxlVw1ImeRbZIukq9ofLwabV57bGsqJofWyRgbJeTr+l3Ivy9E7+QQhFDGyFi/U6y2YYDnFgs5UwpL4foq/L7wvffoQ1CK836ys4cBWtH/g3vzn6XwKqzzvXwv4WSx3dW06X3vtDjnMiO5Bin331ux3TQPXHUyLLzIzOk3MUDyx8bGrqiprYp+og6aP6UdM0rLhbMXYoh8WUqIJcBfePal2LFreyLoc7NO52VifDJOvnk4avFzUwtwFEanGj+Fi+d4vn8wyj75RBx64efRN9gfO+/aFS/89Pkkib7/Yw/EuWMn49Bzr0QFWuMf/+0hCMQZ6qmLo28cjQPNB6OhoX6h3wsaVNqz7xKe5fjZHDlMaPqLl2mvOp5/5vmkcakk1PMkZk8vPPdCDKGpfOyxx2H2Lsf3n/o+5pdAC2LxJ0//KD5Z/Klo3dsVV0dJ1JrDJo184R9wkzgsZFSEsVB03DJemr8Z6t1vZaK8V6JbrZREpmaGah+ypworL3zPVSjsxIRJYbt+PeBWUaxXYp3wATyDLwuMiSVvL19nfs7f37JaKf1likEWJIA1X8t6lmncpiCA5/SdAX6+VxPmujRoTi7YqcS0OpmQLjDy2SqUYcr2iyZu8wb+oF30UMnkUCFTwkcr7BPHkwdxyHtUVI5Jp7GoC8vCcPK+eMl6y2HsPU80FdanKJ1teVs8I6zUnJcRvIGmKJlPnMx6MsmDOeKYS/BOgQ80n1xoy7sXC9+p3Z2GKTK5ejFmiTP46sngGOjBM8y27Us7vk5wSWhtuI/gdkW0rdZ3I0lXi4k2Wl9H9FDyM02TG6lnEs0qJm+alyoomUD7b9RRTenKKzOzOus1kmRHTRvzgQcTAJ9j7M2zPbGZKH8jgKqhZgdaKRI6T51jDjJm3q0gAyRDW4qvVG7+PqtlCfeo2ZIxN8n8/s67YlfTtrQfvV8ha84UySQl7dUiMNbe3IkQWGOQ7sRZ/wiMWQnPKHbCyYQEpKwUXB+aI4Mn482B4zj5ghRR1d9QFFZz6HN7hjd4VYPA6QpyzELfXoUYHkCC2wihUI80VSapMiHM+biIRqIfRK7IbSnCVjpVUTOOlBpbf212lmAcmqJk6DW9g3maGCMx4LnNsbV8CiJP04XsrnTrB/zPnpnHSSJRIu7dF4kw65MwwW4fZD7HH2hVcAMJyAkQn9qE61BZudUE70Lw8N6oWFNDU/Ef/90foiVox7erBga3OB56/OG494F9IHDkvCDLYsyXJvS2hkConMYpe6YrijBNeeOlQxC+s/EPfn83iSMNxU3YXwhQpcLmO6EySKbpZMq0VIK8ck9vvpLIFfpaqlSdeR9FgzXKWl0sEpULHySYJF7fTllKUN7u2fz+dB8NZ34i+Omg3VBynmt1blmPc8izSQaQd/6WD7jvsnDerrG8D/nrco96bRYTy2k0E86le8q+acJpL9XiFdXORx3mNucxSytBe7Rx2ybmsDjO4Zsm0btv792YBlVxNxoyvr+p0Hcl2A6hGT+17Xt2kQNmKvp7SA4NMTfUPxxNbS2x88DueOSJjyVttUTqFzHh/MnTP46rZ67w3VQ0tTQTVXE0JSCuwGyvnrqGpy446Bub5LMaCUNJb96xBSEO0mpMes6cOJ2EPZoYHXvzeIyMjcQXfuULcf+j98Mc/QATrCtx78EDyS+kr38AhnAgOos23Vj3Mp9Wgq9jJs1sIrhlkPUDU5ovw+ozMnEyFRKMOQO9TPVcy/yIMkKdcTE+98o8MPL9akoFhLKEuPmokj+T8OFZn5ZQXrDcS/26vlNWqjk/Ta63bSJQkz+7fhybZ34WmCYz7fM7Cewp9iUrjU+usnnMIKsyLR3rIS/q4JJ/ziJTwWeaKkpMi0xmaQwVjSV8lD+z9NUx5Ay/hL89LUZLAyex9NYbPsvg6TdZxVh8bgyG0n2xEkw8ywxsYBCHHE+m8wWm1HmVyVGzqVZULY2Qy/uVtDp+dh4SgyTjUY7pGloozOaEpcX56YIJ2lDcEWePnyGyH7iPuWxra4oNmzab9C9+8PSP4snPfyIGywlUxPqawzqjpML25mLI5O6s/xL8v6oZl/jC/S6T01bfEXsbt8f54+dVGHH3TLTiZzWzbjv7B83R4dOxdcdmmpuPSwgK1GI5jnHyIY2BwysrKqO1uimt8TGsEGYJDuEpsq1+Y+xp2opJXQPnVxbJUnrCP+EkY/RuzvsEmLV/HwkIrDFIH4lpvPMGIXM0RmhOD/ohIlb1YmJ1YvhcXJokZ4a20wZkACwSMyn8KMexh39CTnwvMhA5jCMRy82LPBS1l66DaIE6RqtQRNBXtEYkLFSKOEK+iZWQkYd0e2c3NPV0XL7UFZOjSK4T9UhVqTX+z2XR9vzGvol8xkfqkBCvjy07TqaD3msfVlEKXEk481GCLEg0vJOi9FgHbUN9K/lLzu2MFgOGhMCmtQGHmTWfSBUaIOfnnbZlF6eIHjWCFvFL//r3o2sTBCNzWlNNvfgIjJ4bjp4rV6IOX6XNO7ZialIRJ9AMVGAaNzgMcU0fSvE7q4A4mrxExvd6/NCaW+P4ibei+9o1kgnWxXr8WkrxO+kZQ3OU0QTvBCzpGcfpGkxhnyFaXB4ZQSmpAKECvGohyozEpj+ShPTtiutRhkqCTonyrYq1yazqj5LahaCQwCqlXfPcTqHhGtGETknzbQbr85UQIZpj2W6W8HHl1vN+yhCvrjie2RQ8QsbNvguvFEWSPa+CVqYbAx8YmOZ46dkXE6H6wGMPcmNxvEoiYJmrxsc/zkeYkgVCNLW9ANdU50JnfH/6xJl44W9fSImAdSR3beZwUNIu4ZScx5m7VAXEld81Y3J38OC+OHLo1XjmR89FfXtrfOxzT0ZFXSX9hbimcutXH91QUZsIQWjAeBXN1JXLV2L7rh2cG1yFsEzJMemr4erHcTIfRIulv4TasHMwgUZO3LxlS2zYsok+SO69s+K4ZIKSJg+zLufTUrgX0/WF+bX/S4vfeXbqQ5QT6q5vfVFkeJJ2cJV7JpnbEVWtDOGSRLdnkX3M65dJWymIR+qX3LrBFrTj4i8j991f4AIYguR/43qR+EZT4dqy2Ib9lHCvwse0GJOwCaINThOkQY2aYJGpUFCmSVjSlKE1Klswz0yVLP5jb6Hl06xM0zXHka+fxVt8Q53Ot2tHc9CSEu4zrLl9X6FovqZZmn+at42g+VOYcVNJay1bF/YhL/n8+tkTwKh7KfgB9RopL63nhbny+yqic3oquceiRH9dBH8DJFgv648S8klp0mhNrpcaIvFdOHYu/ug/fC327NuLAGomrdt/9k//aTJ7/d5ffzee+MTj0VrZFEWNPAbV2Ui0WSNIjuI7lDD1BPNA30try+Ns/8W4MkGk2Qby3vUOxR/9wddi266trNW5+FsEFp/EF/SRJz4Vr7/8emxcvyG6ajA3hbGaQNtZW4Q2sp7gPgjENAXuLGsjgmxlXJ0gmTNzXjxbEtsqNqZQ3xVoscbGCTjBflN75KvrN/8zQulaubMhsMYg3dnz/ws5eg+w073no3eiPy4jOepGGzA0P5JyVuigbxGpVSJt08xkDGQioaLzrEjLYiSbceoxRKn3igxE6vVIcEXtlWqPQLql3COxOg6xZbvLIrxUo//mINauwaANRHePkdVAfJjdKPmanqqIqcEdaCaquC8jNzIZGqGCB1qIdHcBcyBsvbV9+BBLRfIJIKgEpoSOd7VFxkiTCR2zS5Hu5dGYRKD+iEwlgspgikTwQlL/hezaaltZ5j4JGOpR4jiNuZRR4JR8v/jiy/HNP/2z6MKH5Bq+SnfdtTueeOzj8ad/9Efk95iJ+w4S1hdCZ3ZmJF77+Qvxs58+E7/0xS9Ef3d/fO2//NdoXYfzL3Xe/8iDcfDJgyQ0JIwzCPTdFtePmqQGIpYpMZU4M0T2MBLONpz220qa03jGYMavTvSu2JwQFZ6NRGCqKa5mhc3GwMxQynty/aHC1YqZH/NTz/2lmAQlhoFgAyPY9JuoUXMZc5FItFlumBfgK3Oy+B0w119jU/X6VNcUku9zoxeTeSvD4/fmNSyBVsEzEpiL9Vzv6E3vXHr6YvlnfdYoEa6vUm6eKNFsGGyDauSyiHY0ia5F14T0YVtHC3udMfEZOjC9Jk0S92iuJlMi8elav3atB0K1JLYS2e7MiWOcK5mWT02oTBZVpJ7IOKkpyH05Ll68FONEHdu5Y1u0EKnu5ddei16c7pta21Ji43G0RROTE9F3pQ8tVXM0l5GvB/+PUZielvYWmJ0ucnQdz2BPGwcePBAdXR1x8uiJeOmZF6O1hTw5u3bHrrt2xKZtm5NQoLm1ES0ajIAScGBikaF522VhTMs+x7WMUcnOx6X3cBnCVDM+NbQAe2GNyCApaCpkMJc+u/Sz69lZVtuTFb/J6jcss4zxKBpD16frJ1sR2Z3Zf3ozXQdRzPlahklsKba4MBxs8eTflBgj1stSzYA2AnXzNQTlQJgDY8MBHCX40MgYaMqW8vC4S9kzhl8vxq/UPpjXbIZ8aKkIiIUiLslgln+z/Kv74TrTwvzldTGypUXNvn5danplGMfYszJ5NxcgA9hmCfwhQ8OyTuuWLi0W25RRUKDiOew9qJgEfipecx1VEWQjmV8yrUUySPrQkih2qvc+znmi7aXw6/lZQeJk8sTVYab6a1/9H8jB1BD/5//+f8Sbb74ZB+4/kDSTmuGdJ5F3Y1tjPLr5/rhwimiDQ0Wxb9e9ce7ihThx7DjR9KYxY90Ze5u3x+AQ5y2aJsPtKwj41X/0a7FnXX18989/FN/+zo/j4CMfj517d2IlUh5HXz8eW+5GAEY+vKOHjsT69euiubGJ9g/H8WtvxLrm9thHP64OkOrh+LH4GSb4B/bvj03rN6bATprqLy2eC1UwVtfnaOkda5/vBAi8gxP1TgDL2hj/LkNABPmdsz+BuBtJpjYVMDUpnLcUDKUM7ZF+DkYmSkia71MYVrDHDNLYRFCDCCR6KkA8SaoOI9VAKFUdmc2ZglAP6XSmYRqBAFF9v4iUM2y+CKKEsEVM9GsSiVhUTkZLF3l2uMMISSKiiSnMqsBDIz17QcJuO69mZRap1sR4XTQ0qrm5GUHm930Qr44xOdDTjXFCpUqU3qoojRSBV6IZUDsgvIWHJX8tfD7Binveq1Faz/DwaHz329+NpuYWotPVxqc+8+n44dM/RJp5V/zmP/6t+PlLr8R//n//c+zduyclk/3kpz8Vjzx8IP76W38ebxw6hMbvYjzxqSdiD0zUD7//g+RQ/JnPfyYGkN5LOzD59NdxKZl+dz13/GrVmiuQbBJe/Oqlq7Fpa1f0VwxGLczzuTfOJmJl98N7o39qkLUp0Sar7TwIV4n57FMdDv1tZS3Re74b807y7bQSOXGuhzlQO2q31UJl86dTdzv5QuYGp+PCmQvJ9LCpsyWFtu5jn2jq4jo1sph9TLoTiAS1rJqqqQ3NcpZkDI65YMoniuPIq0di78G90UzCx575zEleh+mlcy/hWGhax0BuWWRYCk27hLvCDUP45sU2hjFVbEHzd+Ch+yDkaAOtjYzPgQcOJBOiGiIRDg0OxbqN66KhuSk542ue1ERwhw2bNyTTOEMCV1RXECK+Iy5dwt/n238DmOejC0KrHp8iAyiU1StRh+HqbMsIZ9ZCB3WUAZvtGzvwJ+qOH/7wb5PT+OZde2MjYeJHSSbrvmggYmIN5p9HDr0ZZ0+diTp8nB556OHYc/fe+MlPfhqXz+EzSZ8aGuv5a0SD1RV7gKl+Ub2XemPX3btYm7vipRdfYi0fiq3bt0TtY7VRWVWNQKIYxpjQ2MAm+eQl88zrZ0sOq3fyKszVMHlOpuW3TCWaNBkRTW1nrpVxi/Dr4bfME7f+aum6cc3bjxRljvfEKk1R026qRQIepmhuZGPMkkuppPIKvjCXCTKAXyH5qOjesqUCxqhmHlNDzuQZhBIKzvRTKR4j8DfMWh2pHbQeSEl/F+oomUbbpyALM7EZTKuXlpxZLzwrfPQGaPBB4jsP4pGLigqfsV7vMQiGzJFM2xhMYjILX9ooOGt+uoa+439JyHPDpRfVnWHudNq8vmfEfelMACDCxMTYuZ9OXmUNpmkKBaZYW2x8zkOj67HGYD5np2pj8tpBYINZXNXlxbpdI2PkMDp38kz0VWDSynpubG9aOLuy0X3zj78Rj3/u8XhiyyfjlRcPRfHEbGwm2t5ffu2bmJrC1AG4n7/wUvzOv/n9aKslyJHt8+epOz40ECM15CRCGFNLeHNzG/3p1/4smv+nfx5/+effii+UfJHIptvjG//t6/F7v/Pbcey1w/H8cy/F7p274ylwwz9M5nVz8Z/+nz+M+w4cQOCwMw3XfqZ5uGGBAHMErcmQJAfK2usdCYE1BumOnPZf7EGLbEaKRkn8BuJAY6CNtcXDX4ZHZCoxJlrQgVmCVDW+4UfBDoreuZLZmIuQkpRI/Ip0mxM5MUgjSK6GyUA+5QGasFuGUCTc0p+IW2RjK3wnMZeycy+aPSygOhCMxCH0V5R3nAHB1MdY/6bUDk0lBARVhQQaz9Z1N6BQLn5YRfMpTBXot9LKnMhe2pskSQdxV5Zgqw+8JW78+UCLBERVRTzwsQcT8WoyUBMS9pAY9rEnH3U68U9an3IbjQwRQhuH/g4kkVp6mSj0LaSaImeJ4FI0jlt37ogT5Dn67l9/JxqbSDpMvUw0Q3pvxuWq0OeiDlOQF595IZ761lPx+//6n+DjsoucWd1os15LEaYOfvwBwkC3BvY+ivEzAQCmbyY/LmH9Goq4Co1MGX4T586cJRR5S9yz8W6IJLSVSGJLTIBaOouWdTCt12bs7Sd7xuJb3/irGCc/UAXS0dGhkXgc05dHP/Wx6I5rMYlkWEKwlD00g4ZjBhVMMUTgMCaXamBNylpEQkuJlhoCCwydG4iXf/ZSbNm5JTo3wPBhQoqVXnQTHGMYf5yFHZCWg+tCBsc1s5qydC3lDFOuAbYO6x8lmuFo5UTc/9mHGSdhv6eJCkbZ/8mD6Xrv7GAUVc/H/scPJJ+Ehtk2VjV7Eclz06ZW9mVFNG9Hy8SzCll+6cu/GmMjE1FeixkV4bU9T2o36RQ+RhCP/th6cBcaO+6dOBOP74VY3NuJ2VFZrFt/f9x1/+6YZF7r0BKNYJw7QK4stQ2N6xviU1/+LL5KSKoBn35yDY1oC/d0RvOO9jQ/BpTRVEnTrfptTTENIdh19+bo2rUJ5/iK2Nu+L7r2bEJwg9awtSGmmFuj+GmiNImZsGeRc+RZlxa9QHgPSuaXiAkn5+Bye9s5UHPs/k9noPfxtxotytvpnrsv85XjTCJAR0p4So8W15g3wBSUNrwVsz33x/TAXmBVA2N7DMu7giArhY3yjAHKJ0jUSu/TWW70Us3xhGcaD+d5Grn1F5QifGZkxE2dlMrC0S0+MBdRYeCMhF9uIMALK1KYkRHpiRFdggLcLwor9M1SYLUscySCUrvTdyBmRsAtmALq01TMfi6uP8NYskAbwgpsxfxkmh/NRW9MUwEIWT+afnufwTpSwI6SEeB6ivrvBn+SGHuc/dJ3XxS3sZ7L2G+MrYQzagBNvWH1Z/ApMr9SdV21y532rY1HGSegpRc8wr4wkt6xI0fj5PFT8Ru/9xV8SCvjj//91+IaZqdVjeQ5glkVp0+MDsdzP3gufsp59Nqrr5Hs+x9HDcKBKc6o+tr6FHzlKAm8Z2mnAs1XF5qh//Qf/r+4/8D98eDB+6P76tV45ZWXY9fu3Um48G//zb8hBURzjI2B2+iHZ0thqSQkeHUVZvbJ5DGNoPDy2vs7CAJrDNIdNNkflaF6wJokz5M2P9y06VaNb9Z3EYrHGrLkxNwMQORPGqHGEKQLRYmtqCeFJvXg5sdzUl+DfiIbTaA1SkgOwkkzPBGT/gEyV0rcMnJBW/bs3SLTlI7/vJWCV+ouLZuOps5j1EMEogmja9lLC0iAPBMI3pPQLPvuw/4PIQ887dDYNI60wOF6gShCUl0pgQ5xVKg1un7PB/NOuOtkvHMP5hadVcwzzAEaOU2tTp86F/swpTh39mwieGprMW1yDhmL0u4KCM/Hnng8DJv8nb96KvkfmVx0L5on/Uq+/53vx9Pffjp+f9c/ScwzK+jdD4o1q+/VzOhMHIU4KIUIP4Qt/f779id4m0dFiXwtUu0zF4bjrcPH8YEqi32Eem6GqH7tzddB8lsxHY04e+JE7N69K9Z1rsPPivw6o3Nx6uen4gpakGYi+ekP0FGPhml8MMqJmvjCKy9hzjkU/+p/+9dImIvjuR8+G2+8+kYcPHBvnDz0FlrMiejsbI9dOzriuUMvRB9R1DrXd8TufbtYByVx7sTZFEyguqYKE5V7MUetgzCCkEAIMHF5NPov9cXOe3bEbNU8USExeV26FyDk/O76ul8enF7XjM45SnVQv9owzayWMkgm2zw9dD6ull1L+1UJu0UHe581qqWEp8xkioDo4UExQIhmRMX4PiRimHUxS2isoqlmzoRKAjX0wECrVWOP8owEuWeADFMzRFvRNCHmGeNAWVNcJRfSHBq00sbq1ObgRHciZjUJ68V37WIRBB/RurDhSm37/9TAxXROlSNgoAO0B6E2yR7jovrCCXxE7Jc+JzPDaL35aasjpD2M7iXywJgTaRrNhiaSluz84Yyiv2rEs5bSpXf1z72dAqmwZ5KvJnX7nUS9c+RcCWf76n0EDktnqd+9H8VzZx446vd2k08S6yTKRqK89VXyz+GcXwpsUkCBJT1JMKYO5tN1NVdGcmB+GBDCMbRm4gX25RxmBCPkJlK7lLEpWT2e+HMwsFNonBKzAe5JMOC/fkH2LV/jmqupjTGMeW4auqQ36aPwlBldWtwDozCECUNxz7LFcRvmHAahuKKXPHBDMPskwq0ZRmNKYlS1YwtMkcxrKjxiQBA1w9lcuWKcM/Yye2oeQYhjThouWMeSuteinDQWU0O7gSnClxEEAyX3RlHrs4wV/gzmZcPmjfEVGJ0WcjT9wb/7g/jZj16IL3zxs9yfcZEpXHdanwsWBPRtqHcwhoeG4xWERRUwSCboriXi3SCaQrsjs1rFXBy8Z29cRNN/vL42dnDm2W9xkvvywccfRHP0DUxke2M3VgBGwhvk7Dpy9DB1D6XIenft3gszyNmKEEJBqcyRpnXCPS+OowLrk1qYI45HrtGFm6ckv33t9Q6AwBqDdAdM8kd1iNIuImtNf6r4MzjABAhK/5d6CKLtRUhkkQK9gSleH3kQ5mF+ROQiLyVYlTBT9ZgpDRJmVEdwpeeDSGQlhCQ4ppHI6h8yPojtu8QawR/KMTkBfS4iwEJCoPD9SjCvqB6J9s2vEtYUcwUSUCpRMzdSRZkSdhB0QlIrPf3Bf6/Utmi+NjnAKqGXfDOYQBaqWbMzv/H/h1OUgraiPZG77R3pj36iEJaT4POJzzwR3/6Lv4lvf+vbcfnCpXjwYw9FR3sbIdXrkl+BRHM9YZjvOXAPTNJj8Y3//mfx/M+ej3Xc88wPfhrbdm9PDtdbNq+HPJB2em/GqE9cTVFlXCN4xAzani/9+q/ES8+/GNfwWanFN0VQSihdwuzqz//0zwkUQXJhyKNjrx+N3/jyb8Sbr76OOdeR9P2Vi1djQ+eG+OH3fhg70Hz1wNz82X/7szB/z7mz55Km6Ilf/iR+MGiAEBD8/+y9eXCk53nY+QJodAONG5j74vASSZESJZESLcm2LEuy7DiKZNlOxUnFTu3GqWSTVJyqbJXzV1ypVP5KKpuKnTip2q14y4njsndjO7HlTaLDlm35kCzxkHiTQw7nAGYGg6PR6APH/n7P11+j0WhgMORQMTl4MdPH19/3Hs97PPfzzKKhuotgFaWJUroKrD5EVLYHYbw0K/tPv/BLmHHdn6ZGxtPvfunL6Q/+6I/SHUSE+9YT34RxaOLLdSr911/9jXTi9AmYpOV0/oXz6ZOf/L5YrSZffeHZ5/GhG09n331n+EF17wUJPAlafNhvXIBBJrDIYM6TEXXMhJS9iiHgDfvt3SEcgXgyD0rn9xXMrCxxDcJrBIalDhMqSbhVNvAFhJikvoGheWtJYREAAEAASURBVHwUITCDfpKIlMjDxAvisblWTJVLSKsXyKkyhtbmDiLplTgzqovtqoLJoR6DwEiIL6Ppyks2KuuEAOM88r8hjSVJ9SfyHMj6hfYO00duoL/lSIY8DzGsVN29WOWs0ifL4h50jXpueX820vjpDb+oHRrQb4o/59XzVW3VitrlFuFtI/k50D33b7gDVKBGSrgIV4e4awE+fZjVFUrXuY85i3u3z7LPRr8FFX/he6eWg7W5WeadBsb6SNaMJgYKnCqAOUIxq4p1CTOihm/dQAVRR9YbGScDVuQaKPf6EEx4RLYjV4/GC7uVYHBFBvShG36dpqY+n8G56y5M4Ioz3wi/ytKQ5rCZz+cGgSdqdHPVoAzMlc+2nwQs+ecM8zB2GQ/Wqz6oMkix5wQJGtG+SczimiRTXT1BLzDBWz6LpvXpGBKGehH5c3Wlmq5SrzhUH8/YkcBTrf4E0SavzM6lS+dnEeJcTicPH0uHTxzmbDmZPvx9340FwJG0BJNzCFPXlzE9ZqHHXJRHxtJj738Xjo8Pp28883L6fc6n7/3IR6N/S7VKuuPus3G2PPW1J9LHP/mxRFTxdOzs8fTgfQ+lj3/P96YKGqgjJNJ9/Mkng+txHZkSoFt7VICBGjFhLkySDG0dgcUIdcV2ilEevNxuEDhgkG63GX+bjFdc4/FrokEdWI0GVMEEQVOEQ0Nj6Wz/cLqbk1IEMN5HZiMQ+jlMY6qGe44nOeIhRMd4VgnfEpLmVQjWPk3lqMMoP2Y2b4JUmiDCQcy4Sqrdo8bAi3sjau7crQyWCHc61G32YSjsMZzfh1sIcLenv/3XdbjWQTnD70AUjJFp6fbA+G96NzMJ4tDoUPqhH/ssJhmjaQFGQELjSn0+vePd96Wh8nA48L4fM7l3f+A9hHldT9/1iY+kacI2r0PgPPi+B2FSQYLTo+kHPvuDaRlflXvvvgffhVJ6+flz6b34tdyD0/B1NDAN1k1OTLz+oWUZ7E3B9TQMj4lLjx85Hmv3qT95iiAS3wkhRvRE1t5zLzwX+W8+8QOfwFzwSvrK736FQB+N9F3f/ZH0L/+Pf4mUdST95N/8G/i2jAajJdI3oqNmgfc/dF9IS4dIEOm+sAThzAyqaZWhqGICdwyNxOTEVHr+m88G4/OXf/wvQxT2p3/1r34Wv6gz6aF3vyuSo379Tx9P1+avI3VdBSbvQ3N1Lj2B1uvKtavp+rXr6XNo306fOp3+4l/7gXR5fT5dWbm6E1YslawP+4NeEMLuBMZVhzGS8MwIw53Px7xwGHgeWHp97yRyNO3JNc3ZE/krJCFErVqqyJUGsa1wPq9Z0tLzZmOeZK8bhP5+8EPplUv4XMDcjh0aiXYNb21HDKGsKVhoOWi83Tc+uHtkMiJoCdpCtURqvxXSXIfJkqlqP8F8+NsMGiqTyFrsn1L+Gvd1FrUh1qGDefv5zht2/ZyfpvZya08D+vgu3HPiOgYSc0kLGXB21Grbu83Vjpv3cSHTwhhdTkaYs5n1u0N71FlP9G9vTtyz3z56lrWLHyHKV/uAK1oqDe+KRJR0z3ArPkotrRXM1Aa+Rw7fR7ZqyOqLuYUhEC/JJG3IfO2juNYDplsV7nhKgWDeZ1l2mbtsnsBnRczOWUuD+oKybtSA+HuDM0BmIDflU/tip9trhAAUGyvHUQwhRIC53EQzpqY9C/7R6oyqlIHrJNL+GjwjwTAahKPTnhYGzHoM0GAy2M9/7oswFggVl1bSd/+FT4c26PjJEwilCun9RJj8Ar6hSzBRswh37r7z7vTAg++M8+oP/vuX0yjRRhViTiDw0i9whPO7jIDuDEKZBjnPquXJ9PE//33pT37nD1P9Q3WCm5wiMBMiRdTpav0Zapo8PpWuoN39yA98NH35t38HM9fr6dq1BTRZ3w8OH0wz+F02NZ1jLQlrYRlw532kbKh7IvwRAGNlBfwPvoA3Oyi3MQQOGKTbePLfykP32Nah3JwQ2iqvgjQlovTvuIOoXndD0K9zTdQ0BLJ4D07l09iaf7V5DckxpgggsDLEiVK/Eod/CenRElGr1EYZ5jUnPpRcFsqD2DyP4JiaMQmi/yqqfUMb58jqZmAZ+Y66iAtQFge3Sf9AOJ1I+2YqfpPutW9GBuvE27eSAHpd3QZ+EpJXN66nY/edSPNrOPEaIINiwIFXNi+mQ3cfSd/zjpMwnuvpfPUSCJS5nimR7HchrVU3cIIn0SzEwivLhP4eK4ZfyOX61XTk3uPp6D2nQMr1dHkBJoDocAMmHdS8chsU9tdzEXAQY7xi1Z8Wryykr3/tTwmlW06//3u/T66dpfTkE4+n97//UUw70CIQPW9xYTFdJa/PnxDFTNOcu+66M42iTTIE7+joGBEZCRKAxHUNHyUJZv1l3oHpybnzr5AUlWcY8yMfeJR5o4/8l2jWv6WyXIlQ7lOlyXRt9mqaQ6s0THhl86sUIHAMnz8LQ6bkuIEZl/N+F9HZjPA2e3k2/TEJTc1Kf98DmLLgx1PBj8koeHfSvyqR2jbwjTGP1Dpw7VwvQkrp+35K9lz2qmmQOWtC4r+fh/dxj3vaYCzdRUJTIlLpdx9nCVPVLs6fhG8ZzVM/DoXNhdU0O/sS+bQuYcZIrqRVJOoDIxDREJtEcqw20Do3lxEswA3zbJCjTIaaIn12hqhnaJAzBV8/61WjKRzDzEqVJcWnNLecROAzUoQB43nXkrBoQOD5OS+uS6/rU+P4Iulz/uOe7zKgRAtsEIFSzXCJ/lJtmDjSdwlsNRjW7TqzD/5Xu9A5n7Yv8a7PCj+zznlnTD4bAXJiNHt2pONHoE0fHJ2w8b+RRJfqK3HW2483VOif/e0OTmCdjq2EL5qCisJIEV+UEdYz5z3CCZkG29YMO5iM7IF2V6xzGAZajVG/WjfqktHf99CzJd+ur9eHIfCTzL1Ado9uuDfkDCjKQlZhymXOXWPOWT3Mw2HmOtaKpmaeB3SXBY/GFL+l2twHGHMdn62Xs+ALAybZJjBDvo/BoWlDDTcpFJDw5Br1PoJcLGOKehaNzad//EdgjtBkcS6cOnMqDRnYZL0v/fBP/Aj+kBvpfd/9aCpODKXllUp6/8fej//QZFrGl/gH/+pfSM899Xxa4Ww6c89Zcg0uofXGEmC4kM5O96Wf/CufTJXCWvrmlXPpNH55Y9MIEqfL6VN/5TOYtRbTc9fOpYc+9O50//sfTAvkQHrp3FMRtfQvHPmhCEjz4Ifek86IB/DNHDk+Ac6Yj3V0uDCNRQgMJWt5BLPhErkT1bQvV1n3CM5cCwfl9obAAYN0e8//W3b0OpMqodMvoYKtf25LPIW09QFkfyUQguRySNA550oQkGdxaL9Imu8XsXA2h4vMlMI0DQ9miZKzTrAETdHNoSACCmIACZW+NqO0NVIAWVJnFcK8osmMSOcWHaIexRIBEhOGqZYgOyh7Q0DieXalIxS2c8YjQm6J6GYSVFnRbISIZ5evpzqEbYHEsWMnp9MCmiJt7LuLBNAaCWjXGyDJmGMjROFUTI4O6L59I07n0HVpFCz9RdQYHMZn5dy5c0Gg/OAP/yABFwrY3Z+KYAcvvPxiJq2mmVOYtN1DfpzvRRJaJtGp2psxnJ5/54tfhhkaIErisfSlz/9u+s4PfBCpMWGQQeyvnb+Q9A/6wc/8uYjiJzPz3g+/zy7D4BWIWHcy/dHv/WG68Px5cpAMRmjzK5eupk9+/ycCBJoGGRntHffdm46fPB6R/SowTK7HF55+Lr02dzEkuBK+fYRCHoa4OEmdj3z4kfTsU0+n3/2tL6aP/TDETBkzG/KSZRRYBl1hISGXE9nZ1d6vzkiunfD+TfbFLSssEM3T1EBoqpbvX/tn9D2lxi1Lp21NurL0sSnD0AwfHUrXCAbx0qvPpgfHK+nhI6QUaDxLqGsieXGG1NBeX6OSSRgPsmq6CjhjCOwA0UwIGQQyBj0g0SUEbY2gDrbtOrQ/0adWy55x+nmNFfH1gkkIRpv1GH4zqge6in2UIanDPEkAyyjdqAjfxcomDDkREScMa73UrsOzCEOyqCLbWcKOvronKO1r9N9cXMPARm2PTDU3xbNDXF/ms5qtGxX3SsaYeSbjd4VmQ5+QVYjVSOwKM6Cm9E0tLIlBo6KCGzZZ500iEbpvi+RCWyN6XbY4YHwEi1PQdf4rRhpA6+GcAoQw0exkJPfqe6d2qNd94iNDy2uuplCwp+CAZj0Xw9RPjqkFLp/N5y2/pgRgvXoaZv+d9hqgk39tkUTJmM4NEAEwFV9Nffg0RUzLxpHUXLkzogRurhPhRsTJP5+7UJlFw95IQ6fQuWHWrmjkheYrRNdcSMdHjqTTh46lc9ULIVDsPwNDwrm6BFwrA3Pp1SsXQ9tVOgMzivneS6vn06Urs/iF9aPRfw1wL6UJND9fmC+lV8DzCwgd1FZ9o/JcWh+hnoXldHUFIdnoDAzOEH6T80T/rKTHL38rHZ88nk6+/45IpzDXIK8SQqDiVH86X5/FxHghHS7Op0OkVrhj5GQqoz1ah7msYo/o+S+8RvRzPii3NQQOGKTbevrfuoMvm+UcxFWD8FRSFsgaxHwMgqMMUSJBkiNwR6njps6ZZzFhe20dTZES8yA6IKbJpXINFf7xoSMBEJ8LIhApooi/jERMvxtxwhJ295rBaKYkYdqztJBSq7Ket/S6KLFSB3EMYvvuAX1QbgyBbjhJ/Cq0D2JAYkoagXelh4vPXEn3n743zV2/CoGL/867zoKAdxKaOhObK0f5LxRrdGK9Rr0QnmoT+4eUku9jfni8wXyuYM5mGSZJ6CBmKVVMTB754HvTg489hNZgFXO2U6mKJsaktkePZFHN7sWn6A7M3H4dvx/N5qZJEKp0+uLlS+nTf/Ez5OgYTl/50h/y/Eo6cfIEYaunQgP0BHb45185D3PXTO/DRFDiTFMvib6H3vdQunjhQvov1Kn5ofvh45jwTRJa+uiJYzh0w/SMlzGF+UD6nf/2RYgNkkIy/g986DvSOx9+Z3rq2W+mX/9P/xmzk9F05tSZ9Ogjj0aobMOjy1B98b99KS3ChB47fijNry4Avc6NYD4azKOIqCWjYdkThi3wxh4OgrulVokn38CLcwITscGel2EJYp7q7KlEJ/wRX7YzFo5DBsUzR2GJJldH7jqO7xE5qMj/dGV9KZUJC05w4zTcb7LKtXQMKXthkNxq+GEMkMRyU4m961Fzq/UKgV9W0zk0Ri9T3/rgBL/hzwSDJpMWY6Ybo2iYpmCQJIpz4laYyfh4Prm2u4t9NXdU/7qmeVmgiu57Or/XG4W0NH+M9cKcTF3mPCWgjVoHNpH9yPvS+Uz3Nb/LzJmQVc2RTI7BMYzqaX9y4VVnHd2ffcZ1GgmSOc9ltJTo61NqmHnXzrer2N8a+1bGdgP/S6MOGkxDkMf5giYpK/n63n4WOGb/4FTi3fDz+yrbq9nxiHNvYIImPrPin05mMdZH63nv08ROTZElzOs6zrkwwXQw+NLBiaTB0XMseU0zgfEAwUiu30++o4cwXbs7DZZfYQwECqmc4PwzaA8Vtk0GZRQJP87cvLYEQxXFG4RL9n5+4xJ9pgY0Xyu1pXR5+SoMeSUENmqaTIy9gkletYI/mybu7JMSfkBGy1x/pZqeQ6O5WLyWXjl2Jz6hpQh6co2zxeOXXQAOL+A3OUY0QYMpLXHOIQiC6VEAUqkbfAMteDDuBJ8w4iPXXd8lnlvBjK+2eiWdGD8csOwT19N2vdaIPS6DtOcZlQ344PVtDAEEpJ7aB+UAAm8dCEjU/p/f+mWxVRxyEpkiJJH0J0heeQcMhlqhkN5DKEZhlZuZvoZ06MtpKY0en0lnRg/xvZFeXbwC07Oc7hg/zaGL5AqplSewR/wopi1qm2SUTEppQk/D9Wo+YXSxDBFkTeSvQXTTN2uIpJT5D/t490AeHiiH38HB4bwPgHkLc2t0pg20ROYwMdS1Et72ycbvjVVMJ16cSx9636Pp1csX0quNq+nso3dDKO+kMpXmN7FBX1+hEhdBR5HYKeC5WygjW7rRyUkHaoSKX0ai6VpQ+3Dn6MkschrmeisF+oQpyalhwpCvI7FGejkII6+56BSholeItHSBhIoie83cXN9zV+ewoz8Cc9NMlYUKubtGYJIwhcFnokzo7dnLc2nuwuWIYncU2/2rhKaeJ8mtpOuxkUMQ7+V04dz5VCeIwUls+CfI5dOo1dMS0Z6K5BCqbKymCRzyq1dX0mXC7c7Qj6mTM2HStU6C3ddeQvuENvbM3XeglS3imzQfTBUUWaou4sgNfFaLjfTy4qtBGHWBj14gjdenjf00ABEsG9q9zkVJdcLsV4CbBLPjazLezNynu8aOybkFH9fJo9OHeW7fyKswxxmT4DSX0UwfKc/AJGV+QNEUTJPapk20I+tEtKtXMd1BOj2Ihnkcc9kjzPEJmOJDw1OYHWGah3+DfmKNlUVIzkaShfxm/6m0WD4NEdtE63YtLUBEuv40rTs8MkMQmR5OELRZM3gMBJ6MRXfxLJQJHYHBkoAMYr37Jr6vw0RdvTaZ5i7PYFZ1OU0dfZV+bvm09Hik5yU1HzJjOUNWp1/mqMsjX7r29yrCd5U5rvKcc29k0fAR4nMECdjr4TfxN/swzvkfCYHpUxPCOuDtpFNct5pq50KUvCsZc4SIjvtC0AKTvEiQBtdyZ1FTIY4KEgwQGXCmey903h+MDbCMZ/LDh64oBNF8uM34dD7E7665nMyzDafDdgAvcPazdYgx/QkNZfVkql/8CMmMXXutuVM6mLeZ1w8TVjr81VSYfoI6dp6j3iYspoem0ijro8YeWSJy3GKVIBr4JKnRsXoFRuucfZ4dQ0SyM9n7lccvpEdGHyTH2N3pv/7hb6byI4fS2PhYMFpDCCjU8JVCgKlPJf5+4PFVwn5nc4a5HL8XmbMcZprNaiZZR3vFVdriDEcTP10eS48eflcqoBE3Ot8wGvTOstd8dN538PntCYEDDdLbc17f9qOSCdEcRYYmJwBGMQWahhTMvwsEj3ePdpGRuWOKPHNyaCRVkQgu4KsyizboOtqjYQ9r7lzDed+wrj7nf5G8bZmQcgWpqCG/JaoHsY9uIw8+bSu55NAKOKRvpojIVvGBsqgxuBFxcTN1vx3v1al3nUSuG/jtbKjlyfG0sM8Lcx4axLG+9IWv/l7qZ+4O3X8ikgZLXIS/hFRCXpgyTd8M5BCLJ7/Oe7QHMh8oIr+E8NmruO46ncn1mXoFn5UxCFfNYFZJrGgi0dkGEeyUco7oOA7RiwZiFsfiQYjkiXtngmCeXbuCZgyCa6Ivnaucj36V8ZGYQ0rfKDYxJ0Srea2ZxpF6Tj1wmN/Jj0Qo6QWIEbUkmxAdFytzRFsbTWNnp9M4+2YRbehr18hjAnHTj6Pz6rJE6iqEbjkdnTiUjs2cCtOoc8sXIMhraYJnZ+4/GpLYF6qvxNiGkALXlq+ExsEgAo53CV8C902vtavJlrm1JFKCUcLcLELF811iJJ4BrHmyWTU3EjvuiyAE2cP5Xw777na27/+95yivY+vdfQ3xxL5V6yORax8MG15iP24rng1ofIz4tej5wI/rg2gAlZvQ3zHW0CkiFp6skDSzsMya4t6+cUyNjqXj6QpzcC2ViT0+j1bNKHtVmATPGsejxkKfoIyQdSV1FIZUUvPEvTqzd443vyuD5N5jX633BRPaP46ZU5k8WPS5H9M/9wNd6FmirVZ3bEOmVQZJwtTv9t+AJmo3/N6rRB3s04wk58yFcVAjkhPxPqsA4KYL/cp9g3Zr+2bqtJ+x5uiPzI1j44UqHJdMLCZlzLGBfLYxqsH4eJ8MEvd2ni27dCACQfQGV/sJGaPuYp/EbcIu1xi176ELBhwyvYWMTz+CDbvumpJxUDjhHrQOA8PYX3s9UJojGMNzCImOt6vKPlBLnXQCmOJ5bxRwpWdNgCSuds07t1UQAvUhRNBsNvpLfzZl1CgynRvknipgUldEqz2ASaU1lzHZGyYQBqcSMEYoBTPkfyPPjmFKN4yAxXEs4vNkrrfr4HLxu+h2oY65HueqYfyH0LYStBtNEeckEQntq3nvSpx39uU4IfpLfWi3MMceiiBM0a14Eaa2cVBuXwhkq/T2Hf/ByN+iENB5uAhx5QEmAdPHQVjClMWDXyLWQ1b/ozjGOePWcGrPkUg/kqN5JLV1JE76MMloGVFsrY9DnAN2mAPTenVersEUSYiEPT5I0nwlVtqHtGnXwkFuNDxO+11v2esH+2nyR4kktQYHpRcEJKL4j6Zng3CsTFGGpLfhM74wn5rM9cNMnHzfnWhLCP+MtiPBDy82FsNcqQxDoKQ9LxJXJkgdaGAutLpTiySjYkLJG2mRrEdTIU2iRMbO6xJaER2Qg0EAiYekHFrQMNXbiuOAWVGjsFvRz8rbNtkL5sOxvfkN6nY/oB2oXFxIq5eJbIXZycjp8TR+ZDLqMyqfhJ++UUaq0kQmFnWrIYnVVdoWLjmhKZO1QEhdzVmXMRFbZ9+4t6Dt22UxNGXZ1/y59o8dH/xNUkzivs5fwTD37F3N18IPh3vbJl7sQ30NdUyPiJLuwVbbITu3E/zPSLusEfeuxJ8Lgo+8Am0+OAcyprsXCVoJM4IowAwCodBcFSAiR4uYWnk4tIp1qelzLisQVxL59iPMsPjgnI9gHtdXmiGASAk2CG0ZjJMBWtYg/ooQpKP911LJ8wXtXQ3zRgzJonb7rN+La8M6exXHKLxCS462LS/enkVCc/zb4RIXWi/236hl5allCFT9jswpw7kFw6P2SY1jgLDjITVbmi57ZlqzcwLZGmfUQGv/OA/dmpKOKtofDZduxFEAEkx15/y5T15PcW269ltT/3qq2PaMsF1jzIOcF65ZI6aZCs3+CV1zYpUQYqj52mgJxbIK6H+suxhem9lvV87PMnKdY476o9b2XTf+EM1k8xyMmPXyF227zjRNhCmwb+Y80gTSDaHmVoGgWhif0Cqisy/akg9OPQGTRAhvqussa4vvTLWrD3FdgSIFEz3vj+c77g1G1f5wLoewwW5x33r4kWVnss8oZDJptQIn507YircfvYPAIa98PX3u1W+k+qmpNMU97rcKfZ2vEX0WYYx74Do5lDz/DNFddH7EA8xRE5O7fgSZhjcfaMJgYTYrbVAkwMogjJPPFDl3JgbHCO3v+EEJCHvy4tz732cOyu0LgS2q4PaFwcHI34IQCL8KHM2VvE0MjUao3EEOwQjKwCGbIbeWxI3TTzvsIDw4RFeRcC4QeQcLmDhkR0keN1HClA6kEY7NPF/hMJYQEP0YVtYiolknstcgfigdtFL8lr8EopMAh3TwAH+9RUJEG36lX9uQ1+ut8E18LiNo8l46dktGlGaf35xXTb7WV5ljwbwN1HyRTpIYwLm6j/84rEHsIE0tSfRgPhfOJkFipwZEsSZf+QjsraYxA2RUV1uo+UpnCSSuFulGvkh0w3oN06w5VBClHZ2VCd4AUcscKMkNmW7nmtk2ps4eZJ/zn833Yg4l115GIBIsgEhR1dcW07tPPxA2/k+/8BLhc6cCJjJHVcxFdZy3Tz7XBcAQCKxhYpbDReLYPxkXJAbxTN5+3rOd37MrzoMMi+IK28tL1m7mm6Tmyb7rF2SCVfuW/+79wWjCMACpgJmaHffIBkRxfKZe6w89BveFdpn6ZI7VMjufmulFlC+ZmZ5FQUmdudCk1v1bjMAsJnk1H5jFEclkLdaXkFovhd8S1Fb2QwcAIoQ3Y+nnLMBlHhNPGMqV1jrizJJhahKwYQwmrIiP2iCaJZl0x+RdMq1GydQUqaNau9AuMlAG0JAQljnwwYLCAOrx3Mj9q9oPdHyI8xFGzfuLrM91tFdrwhAzpDUSpBotTdMymS3nXehGbhiERsFk0laT9kc4N2WOhLf3OWcmc63RH7/vVmIPOXft9bfbnTdxneaiD517aD+P+xzEe+d6yx8zN15E7uE1fmcdbQJvAyVoCijMNAPcNlaYW6DTEqyBRzx3nJ9WkcEPjVsLZnF5t0nOH+r1zjPuLddNrH7WYTDHjEeGfc1cP5xzRUzBQ+PtMcicDZeyQCEMKLSWmp/tKJrM4U+3veBTN/mtNFifTM2lOwCaml0ZCOZehgLBkX+G+x7wOvtvGByt1sd7muJPwEkX+Iln6Gf4mo2CT9mjnoUNBJmFtZX04NQw5r8baW6lnJYxURXHVzizFvFXIkB3+KttUt8a+HgUv+LDU0SkA3+7tak61rSa8VWFF2rI0UKVSNVhYmv7yrRFuO/z8xfSTGEyHSLlQSczFKaw7IUbmT1uh8/Bt7cbBA4YpLfbjN4G4+FcDbvlEUxeNL+ZQdorMg9JuFJ/NUMQUHECt+BhZnSwCYIvQh2D5E0UuwmzZOjjIQgECVSJGhH3Kr/LFG3DWfEFPyek8f2YA3jgby+o7kGYBYiD6AeSMe/oRLoiM0mN/UhY7btINbQd3U1tb/jb/i2IAfrnPKjJ24CIWEPqB/qLvtjdjNjFnjyQ4813MZyhN4CeeFZIdsGAZiFUWsxR3mrrXhSLzBFkMU7e60gSmxCCTSSJOSFjfVGnz0XVXZW3uuvz/TBXO3yRXFrcI9Ng6O/40nqm+004DIHAbUitTDeDEIQMWF2GoEwy0E5NVnddvb5rjqRJk6Y0MveaqynVjxGx3prBbNTChMXnXd868asRdQbbcOiqXJMh+7tmvheekXiReA/JKu83KpppSVw4HolBmT+ZK7VT64w3Wz1ZLdEH2tCMr0kQC9+7+5Xf77gCRtKgFjQvzkXAlfHmM2l7ecmfjdDHUEaaHDmmzuI9EvllGOgSjKHjlIoK0x/GYPERoaAWcB4tXAQOsMG80bjLr2qJhF8tfCYK5GMzLHsQZtQxgOncJou0AoE50ncdv7BRonpNxvmjwZzP++z86nXOANcF5pfso84xtZoKBlafRbK4xZ7TtGiAM8iN09Wt/JF4zxlp2zJYjdox97FQ8fySYVX4JLEZ4wYWMmGdcDO/ziY+Jc6H/117nnGaBjbwwdpmdtbRuuPwXjX0kfKg47c38tH+BvOBoGw3hiev3/nOV0usDwfeA2DWtzZA0lOY3ez37CbNvVwvq8yPFgadBVBinUCIbRhyz59OmAngvF3nwFOzkzDvrGffn+lS59rwTJExEgUODoHXYFI0v3NeymhPxHPOU52+G+QoM4fs0Zow2VYY2EAV7RLJo2GSNmpT/ErjDL+9/2Co4TXDRFn87LrtYy25ntbQZskYlTClizD7PKoW0iTILrIqWkXPiKnGQpom7cIspruNwaOBn6dIiVDkHKnAILmuoj3W38wg+cHA/zJQavvMOWW3hXljlfpot98OcZZvwPgbFj1M/bh3jTQO36y8kI6Mz6T7htkHTTTZ0AEKQuv4ZYbQYdv4D77cbhA4YJButxl/m4zXTNgirxnMWDhtkTojieUA3eCAVgrVXUowRpuo8Q3ncJ2DUQmR4ZJ1vrYorVX1ruRTVf6O4qE/CKKR0RLzbCuaUlGXCAFEql+JzJhFyVhW/I7pHISPBEggyeyW+DlHmjkx50WJZp3V1TCIh/5nF5kWJaa+y+QpXZXYlUDo7HfWTyIuQVj09xGimPnZdwGxGWxhDYl7HwgQgMKkgNCpQ8JDxG7xzYhytqENPp0AKXMP/kUDMLASSKv4hjSCIM/6J4xzOLf705rKnf3P7oj2umGf96Fdyd4frENzKItmZSL37vbya/av+7fdag8igPWhNkiiwWeL+JDoLD9I2NrhU+Ppay8+nYqEMz9y74l2NSJ+CbMdsGjfkX1w/fm/sz83esYnY7zm+WEfZGR6BkDI6Phbwccui0q2tY9sI8xYW0x2V1e2fe3sT/5DEPz5F953u0ftRhMGSOK8cyx+LsC06NitLnEDs5wNFtzmoAEjIPZZY673MPMhxL9w4ZFdi/OpeaSR8SZJAD1IEA6JQMsaZp7L+G5cgxi7EwZ7lBwx68yj/o95sf8GhZGhNN+bwWJGgKn979QMCWu1WzI4MqKePz67jSjPK+18p+85UZ0xsTCwCCTy4noKLevWpfynrXfWWr1RTlfxI2mOLqYp8jWpeQqtAOeqQiYZ6+658PsgDIZMx4YEOt8FZmdT3rP9ylazu35yTMxfPAse2FZh/hBNOTfWHWZgXHc/KFzoxVQppDLqoWZioQflDLINmVxNPp3f7uJoGp6NtsP8bJuL6Nb2vnlPz752V3yj71RjEf4FtN+2K0Ni9QoAxXVqkOyf86v5uLmdWo/Fszd80VRt+FIqTcMkkT9pYOQ12kCQwK6JMwzcKJyM/BfaXHC06NK1ZG4pcSjfom/uWc3IZehWwb/69zbB3Uc3l/EdmkkXESwMwPiMoqUU+p5aeV+dv/HyRJqCQZJRrbM/+8ABjk1griMQWyNAkwLGOtEkl0keq7VBCQGMyXsLvNu++2YeH+TH555NsyPzpGGYRmCh6STwIgBOzE3UefByO0LggEG6HWf9bTDmkIxx2I/jPF2DWFnAH4PTHgKeJHIcxI2eZgNI/OocxkiWlPwrxTTMaCBBDuhFEJpEkAd6fhB3gyqQtmLVdsmYI6VlInyJlRISu4rOp0EQZUd2MBf0adWIeyAExOu0YT1onTjgZSKaEhMdzJfSY3LWca8CME18cgSgRN96s+eyevj6JhcZuyoh0m26k6C32V59kLAYZkyguXbP9+qiMFonmtCGEeQI85phO5gf/IAKzFcfSL8dHIE50MTNBK5qkgRbv/dwXaKsCvI3rGsGpd79sy9CVMJc+EpgdhZN6zbxb2pX0vGjSBkM2+pjxw+7fBTRqqnUZK0BcW6bth3EFsRZEDUQ6PkMb6smH8S2i8wBf2rFcubIn82BI2FkW4fOHkkzdxC6nu9K1/XNM/xzCcJWGMVS61zKtL4BY8ksbGup19xuu6Hji/caQGAIpt7Pdr0TSO65ESLp1UhCKRxcR53FMb1ZRdgq+S+iucn2D20FkRQkXRoCLkP44cCvADK0IOy7JXwe6oQL1pRPKXjP+dmlw85DFQ2eAuxJjOkkIjNYWEuR9AJou2Hqx4hmuIHUvKFkX8K+o0i8r8CQGTZ7CaJNRklNY4l1lK9X11Zob4B3Nzw7qtrxMYhnEnmGGaKS/iBmM+Yhbt7elfbzzqvPKplfawynRnUizePH1BhbTjNEUjRYxzBrwPPQ9RgaDcbRCTuZswJrQTNmTweJVfeUs+85oNlk/md7+y3Wk8PA57uf9Voe1EC4hfaGRjf0WQmzsJ0tKTyzb8Mw/LEVJfQZv+ehfe0utqnPSx+RJT2+u4uwaxc+2o/ufrZ/fz0fWtXH+ICHflLZ2aPGivEDW9eT4dOz/XmTjTC2gbEX+P8ynd9iEIU908oEsu8VWjFOmXmO5dDEgxHhHPmdN8ebCTQzP6GwlqA3Jmg+peYfPDw/dAxcilCAFWK49xrMqIIy7fRsa3JkHF8qgutzTrs/Y254ldFtwpA1+mACB1bTMlonBar+lyEM/0ACPWjtUcI3a4g5XEUTOr+ygF9gKZ0aP5EePHYvpojb8cFNQung9rcBBA4YpLfBJN5uQ/D8H8Z0YAYJ0iCSKjkINTgVmI8GiC4S9SGJap3VW+DhIJ0n2lkdgnp4ZAjmqszzmOZByMuMVJAkheQIu/79lZ3MkVJzJYsSR5vxDr4AIYm0VyGW1pRchzQyQ7JKhJWmSnyJsDqLSEQNjVG/NPOgkkBwvlqfSKKMeY3EkYj/TS8SRIwpR+b5+y1pF3ht1Kl/CQJfmsNJbiF6v9dqfEGxVxptIh1FkyfWbQ25DyIzAsr5nf91tIkyR5ZWFfF5txdNzgZI8Fnu65AYWj3wjozxu1Syy+Xdmgm4BSOk5FwqnCIMcwKpew5zk6ww5ZOYY5ydJSMykYTC9OTPWp/aDSW2EtfDrGV9UjQZ876hGj5REP8j/fid+BRjtDgWP5qnaGlgOa69npd+iPzQHLE28z511uM1YVCGSbJNTcm+nUX4KMTwvHDkmWaAqxB1xSZMxxowZi0C7dS3lsFSc7HXWxxvtQ/zN2ocT6MQzhmTtEn7K020LOSRGe2r4Fsl3TgRMNnWVmuRxfmBn5Bre7lQSZPDE2mCEOBBlLYe6AXvbXV1fBEOMgS++7dlZpeth45b42Net/fKmIWPEkKeJtH5VjZgeJfuIpT1AgzTVbjBGqZcauMM545fFRu4AZOhNtw1mddV5Nxb4/zV3GqIM8xz0d/0F5VxUnvG15srwCvXjPV6MEwn+SH2HHsq/75XO/ZZ3zWf8byOtcPnbtO6rfbQkLFX+xF4rCMo6y7Wk8NAE7T8c/d9b/Q7zUQo/nKcARlzZLAiTdkyzdfNArejR/ooyel0FdejDKA5w8YxfZOxlOdXQ7TBfMqsNdhXob3jN+GaM7RiljJBZk7BtCwjFKgNkhKBPy4jAFWb2oq0R7eHYHAyoSHzrTk7a0gN06bWIzJomNOtbCJYoM0mmiTN7eyu+H24hIaIgAyGBq+T98u2SqzV6WGsHfBVrQ1U8EFeQPOruaqCSTpwUG5LCBwwSLfltL/5g15eXk5f+cpXdjT00Y9+FNM2iQTOK4i2J598Mn3jG99IR48eTf5W4vDaTynCiIxjeiIxo++PpgMrHPx1Dm5N7zwU1cpIVIrUPYRNFrqkVgG/BfswiXme2qeQ0nKQijREXsMcoj5zoyKiHGmZLcho6Q9Vp22jMymlVLIlo6S02nDADXLiiDzM/6CfgM6r1iERbqhg7+1V7F+Vg3wntZD1sq+fg11s+GYW+ibR6N+bgdBFoiYKbDNHrbEgW06VVUIjN40ipjZqFikjyG7MiIUdY26BTlhpEmUf9zOHOcgkxjSxapszUp9zVcBkb70GUadEtPf05FXc1HsnYeuDbZjSjGvVSHki+w3yduj8rKasbyzz8cgbcq3aX5mtTHOkfDgrQVCz1n1XehxmVAA59kQZQg9GxrC4Sse105c56sfEqqgp2OssSmbDXwaiuD2eXepy/EZL01cnM7fb5cZ9XHae4w94MJJd95FV2S/3ygBz3QH12Pc+u8ZvMg6yT+xOGBe0IIi9bzSevbrprFT6stD9owT2VpNEAkIk3CMEaxhOR/rm0wRM1IWNkTDr61jV26vlB+tS+i+TZyLZ0LpQl2ep6yHXKm1/cOc37wVo/Gfi+ef6UJvSx/7pLt7rvhc+MpKl8Ns0cSragRJwmmFPcqZWr96dlggNvbH2XJqZJOQ8rncyoLH2MGcuwpgbKCNnlHzeADm2H/2xO/yp5fM89dxssNddm7vCpLuzft/jZuGTEeetNqlbDVcuKOhVndfiDIZBlb/NYN6haet6iG4HPuKNofU+i/Lxuq4c85tRTBOgT5pwFreEb62mZ4z3zSqhHXP8rJHM72mA/a22Gs2N+LLffFngYtZZDYFhmCG2OqNma6Z5PU0Vx9MLK8upicm7c2+ew2Bm6LvacifYwAzBqDIu4e38hUCS3/SlWyTSZkXtLfD1eom6xoeG0+TYBIzQSJj2zRFkZXZpPszGD49NEvIbfyY0tKfJS3e4SHqFEGa8OXPzZsH/oN5bC4EDBunWwvOgthYEHn/88fRP/+k/TYcOHdoGkw9+8IPBnFy9ejX99b/+14Mhevjhh9Ov/uqvpl/4hV9I//bf/ts0Pj6+7ZleX9TEVCFqJ1CxNzkhK0iB1og4dh2CcIJErjrIGkK0gMnMIH5DTUzrqjApc+QbUfuQR61bXFkJSaWIW5ohl6n2arPzmqFSyzBo2jBvSihAcKmZ0vE1GB2Ia2gDCGsqhXhRS7XJtSFNBpBKaSIjMvHA11ZfInWvIkEVHey6SV+Kfogrk5DmSLfrltf5Ve2JJoeBfUQzgVhF5n7eT8lQyz4RjM0Av20FYqxSm0yXr76DsMuVdHTyZWCGZqQOYAfREJKwtbMr9kuCSgLgZomOICBAqJrwSdBZZK79L3OyVoGRhlGi4jet2IdwriZCXhY9j6YENW2uY+rXx5gHhsOyv90HiZ8IUw5BqX9TEHvOGUV46IcFxDAPIsfI5lAQh5qXOkSNPDfRKtlmmDrhpMyEt+ve7wdhLfGj71Mu1d3Ps8GQyiSxL/e7pnar12hualI1OWzqz9OD0M+fzaGTf/fd9rWwMvJV9nt2EoSWhYPhjfbPWpdhkhqYJGEkh1mPwp1h/HeK6XB5IN052EyXCDt/jYhaNyKZ830ePlus9SZBOiTgXQsync5Bfk/nGLs/e7+sD5MewgY1e01ycMlUO6f+qeHQkd6iltvzSqI1g0d8CG3JyMRlrhMlkBDQi689kprVl1LzECZLaHxL+qN0MEqDEJ76vxiMI+rp2FP53MiQeb5KWHcGV4mOvJEX2toGG747bvcIncn2B+PuVYSxVgCxTFpM47b72Hex9bjP4BP0PMYnHLeV1tfAE7bZCiO+7Z5b8KUo00s/xS3CugaDEW3egrp3qwJ9dvgfKXyRsWmyJ2WsXTM5FIS3kQ8jRxOCp3xvGTzlGLis0D+e5vonEVYMIPjJUm1oleHzsSZhvtBPpvoK2mfgjESDOW2diwjRrmPuaf4394fn0ii+RKfGjqRJGCR9aI3aZ2TBQQUh7AHTCBzGf06m/ETpOHrcCZI+M3uFOrTI/vbSbvA4uP7WhkB28r21x3DQ+z+DEHj++efTgw8+mH7u536uZ+9kiE6cOJH+9b/+1/H76upq+uxnP5t++Zd/Of3kT/5kz2c6L44OkOyVA3UGyVAdIpBwQekYDpaHCodA2BAMi9c4lCHqNTVCEi/iushh++rGKkzZUDgUZ+Zr5nxBIxElk156COeHdmeb+WcPak1HRDZ1CBSyt4S9swSERQSMTDck/6HRoF1V/pMDRNtDqqekdggixj4tkkdFJLBXCaRm3RI0gSV82SoiPw96NQW3pkCo094K4VZzaaN92AsmO9sFliCtsPHnyRsVx9WPWY4hdMOuH8TXJE/FwvIx8lOspGNTzyEFVCPSsgvXNygLDteuWimi5nL2cwdR0r5r9w9GUJLBEoF3lmCSyki0YeC6Q3533vdGP1v/hoyYWd1jnqmxNdWa2xnWPJJBYvXROT7X2xAJSQsIAjRlqjEGbfgt3tf29QF0A8C0fxWGZoSK+adPVB9BLSSW12w/nur9Yl05cRmfrYBiyGNDmev8fOOZ7qjb9hEsZL4oRo3M6uu4Y8dH7+leh36XcMfzKUyK6jh3CwPNZiX291s2YY4wRER71CpQwjJN+drfans/Pc0r2Xq3n3h+BJNE4PA0wnlwYW0sjUF0nxlcTu9cW05fXS+lVc42Wt16sOuTeyXTEGb5a3J42CvXsAmOZZQkDvcqMiEB8lhu7Ffu9xzJYIY2kbNK4lHCMSJ/AZ02LLiv3UP2qlr84ujlWHe12Q+lFRilRvUyeZbOpbHxxTQCY19Cay8Z67kX68hxsGdl06IfHZ11TBGSmnW1jvb8Zuaxo5rsI+31CsDQvo/mbwSr/N5gEtmLauxCE0U/HU+8eJ3vWg80WUue63F25w/znu8fz6oILsM15+FWM0muBc9eBXMKEhUAOmH5WslAzsBvccmSuSo4zKw2wkySNjpbij5wwaBGMm+5PybRS9IxcIBCufn+EQIraFKa4UYZvRAAYN0xgYZpiBD8jarm2NbGGjIiLczYMgLQ66v4DHIehM8lzNRxQnhPD5eJOLhO2PAlhEYwVsyRpnWePadGJhACkFupMJFGNkZTzYSy9G+Iawfl9obAdkrg9obFwehvIQRkkO67775dayyXy+nHf/zH278PDw+n+++/P128eLF9bbcPHv4fPfTBVES6I2JewQnz3qF7w+Z5jIg366jOF157HAkTSeQkmmGSFpHcPrdZkSJMQ2TSHgL5X1/Ffh7b5pzcQaEDqrrxoSg+lOisYfo0FP5KmQ9R9FckxKFv2GslZJBDIeGaRkI1XRjlFkx8NLLh4L5KjgaRa2Zm0IlCtkbu7xGSnDqNFgQmyJikrVuoI5MQDsJ0Kal9oyUfn2ZbOWyssxPZ54h+t7YkOMoFc6R0EFK73JwhbYgsJOlq99SWrKN5qywQoajYSMcnXkUqjg17PjeAKkOL2xmhJsyR0fU6+7xLkz0v+5wETq9iv8zobpQlbntzClWvq8HZZQploJoVoi2qOUPT1TkHwkMTN52WZfCq7UhxdlcpMj4d/IXpC74vxRWkuC5HSmYqSiQoTF+qSH27i89bpxGnbMPvOYGrBiJ0LRAwvSHXXdv279anuZh7JVsH23/v/GZLOSErI9C5HmWGZI77YRSzBMsySVkgiJzJ76yr1+esfRkqYcsb/ggMFV8kt7ChqTOJvCZDGQP6+haCghv01pgDN9N1mNo6wRo0t717aD1dXV1Kz5F8c13GtVcnueYZFealLfM45yMvoeWASHQs4ecVA8l/3f7uc8I0tCf8pEDDtaDZ4yCfR9TK0Q/7618+775nsNqqT2K8hBnd2sjltDnzeFoLU7uhtLJ4FEYBv7bmLDlxeJLzwPaMCuifhKmMtRp511Qns+R6KnJO6jNn3rvO+d5q+cafoq9M655MyBYI96zQ/hnwJC+Ain6xFl02ARWEZnw3oMBOGLl3su2NPC98rXLTSGF6K4vzEWHGAxdle6UNP5qK9m5tk9H98GULxnz30yDvh3tf/Kmgkm4CR3MTCUVwAFqgOhpp16c+Rgok9f+aGZlhrxQRenIXoblDKBnPsqcQlF6tXeWsUyCaCflGSkTThKm6Bo1QRXjknMR5xboqo8EdwcSzzO8e65ODEyHUdB1q6p+7AtzKeTmo660FgQMG6a01X2+Z3sogecj89E//dHrmmWfSAw88kP7O3/k76eTJkzGGTubIC/Pz8+nrX/96+tt/+2/vGOMf//Efp7m5ufb10dHR9K6H3pVmyF9gWR9WWu7JilTOU7Z4KG0ce0eqzj2DFqSR5pBEPcMBuYBkdZDwumbdFlHP12GYthVNhTIJaifxue2W1peQaNJkECtc87ttr6tl4IBugiTxiIKQIZEtwSCOc/jeVZymlxzsPFeFQLialvk9c2TuJuxFYEGYgDzCWV9JGQ9Co/cs4csBkVjA+b4bMe98gA7sKFsIzV91tpdgknnLEBoSYpCKJEzkPRKj9Sj2W2frUYJHSKjeqC9KBvX1AKUF4ZRHpqsRTGCQnFZnjl2AKOc3QooNwDwIE+E3gEanc46Efw0fL9sL5N+jbze6ZH1qNHy+s99+lmnTpyyKa4z/fusFyRu10/N3K2Nura/Vys7b+EGfJKXC5IXNwp8LjK4iMaGmCHax3T/HpFnJ6oA5kdAUwLf3Ad9+iFaL+6EEE1iLec9Mjpx3CRTnccgojeG309UYXzthtfPX3a/4nDB3/kODxZ7Zbe4yYipjfuyXAgoZopz5cV0oida8zHv9r+mhfZZRMnDFXlqIiB6nVB9wAIaQRkdgFLpvXSU0KRND49RHMBjCby+TC0n/rTdS0PXw+Ea6iPnjN2uV9GE0og+hBF5AcHO5f0rotOevsx16GUTgIIxU9/T7hH/Cc8ePnZXwOfZPRwUyXQWjDzYAAD5FeQJYYdtZes23bQr7zSJrZvKFtDb2EkODkWhpfFm1CKO6zgya0bxyoJ91yplhMIEIY05deXH9CXs1DcLbnmz9mt91g/e8+6/r4e1120874RoMLRLMclY4IziD6vyP6HbR0+3Peo5HIApg3nmMOw/+3cqiRjWznMgG7ZzZ59jTEdjoVraW1ZW14ecc4DdqA/+1WH+MnTO+H/Pzl6p96eHpQjqWltKcAgnWxBB4R1hHAmT2n1rHdc1yacb1odxMM3XzhnkmcCMLK2O21SotmgYhlh7tMXZOtMAjgwiZDBpxjaTxxwqHCfwEQ+Y5KHOEJuugHEDggEE6WAO3HAIGaLh8+XI6duxY+rEf+7H0nd/5neFjJPPzi7/4i9ilt0TXrZYbZKz+mZ/5mXTHHXekz3zmMzv68+/+3b9LX/7yl9vXz549m37pl34pCB6RSz8HaX4oi3i8Nn7oDBqiq+lPrz2dXtxYSaskCzVZo7480rkSU4YG7URMoiivG3dIqVMQGXzetVBPDamVegfObJC4RJhkjYQ85zaH8SQarSmo2ROD2DjTQEb0YBKF3fQIJkEVNCMScUbgiZCoMFT6wIRvkiYaEm3WjX9VCTOCIHr43l1EfCZExcio+6f47tiUvo+EVC6DlteiKl5Ebga5iPwujMBoP/0ksJTpsNinI+VpIqGhaaCdS9UrQaQFkcXv9h1yGwRUIHjGaJokwpawsE6RViec8+4jGMREcpweg7DQjl1D81djzI5xgKh9M4eXyW0k84lpDoSjmjIltkFOZMCMvtl7503b8s52Wj/u+Rb9b43fMdr/bYXf1NysV5lbQ48LNIpzoglHH8xGBsTs+ut+bdUrvg+6ebeKuM92mxVys3CP+U66SxC0wD7rWF6xdwEnJNsN/F36WEt9K7FbIEyyGlyb+puMMneN8OOReEUrpf8ShIlrZK8Sv+cgYg53KxI7obXgXusPwgoCKZiUroecT81gDBsd/k1U65yp0TK3UGiJWF+u/zCR5LPmhvk8hdYLib8MlWtEIlbKyj81GO4v2zB6XZ/ia9aX2gwJqw32KAaAaUrnbQIimI/IUsLsy6Szi+Q5qqHZkNG52XW3NUwBVkyv9E2kyfp8et/QWnoYJqPeXErX+0cRirC+KJ3QdH71ySgxFvfcth+5Vzg5biXlMSdRw84XhRNG74oQ5mws4TqAiVFfnah0rDFzwo0MA69+tDeOUY3VHsX6jJroWlkhQMgajKlPRN/1FdmlZFoAtJc2RWJmGWaqimL/YffjPJYZjnt3qWe3y44r19RY3+ufK1vIEhrXUQFFnQxQrYnDM03D3r5vQBGYRuG5fO11z192wxt7dYzCMBgyqopl73a3XWGQA/iNNbPtaeddQdd+i3dmyYgVBrJuyVV4cZXAJfVaugNt9osINANzoL3VOmCc8PbRBudxdgDzBjwNrjS7PEviZUzN0cgaLClwTsyJ0WkzTaQYSssOHuJxmVW0tzBWBYRJJ0eOBI5Twz4gnqVUMflDvxSfD15uTwjsxK63JxwORn0LISAD9Cu/8itpenqaQy+jvt75znemn/iJn0if//zn06c//el2a0tLS+kf/sN/mHz/F//iX/RUa8tkfeQjH2k/YxAH1d+aEUgYxanf/pVvXDPJ43OELH5qdT5MZDb0RSJKWvhwQBh5qEIedTzlmQtBr4kRB2s4J1PHjYoHrcRA9IPn8iKBNRb5QIbTBFqdUcwDOlvT2GIc6dUc0tpBmBFOa4gxyR1/EWFwgPNA0GwwGRJ1ErXbKskb492mRb4SEDvN7Gy5Px0uTaZxCKAraOOsW9ApbJORmz46kxYKK+mK8HLctD9UHCXk6rHQio1iqlDAd+WZbz2bHvrAu/GdqoQtt4RqSJppwfDqBp84M3oi9ePk6phGys10HuSV4+OwJacvImmJTBPzvfLsK+nY6eMkzOxLSxCdw0Wca0nuZz/60PjJ1ErMxvdcsOeQOorEU9wTkNj6oZMYyogjJIh0RsJcxtQ1JDMqYDV9VL7ofXnx8wbBGTqZI3/TF2kDXyGGe8uKQTs0J9F8pD0M+hqwgwITClnX+Ez7mzDNcMQ7inAIBmTHLxJxaJE20WzKIEEslJZYe2PA2SUYzcp8ABt8AHKNi4KCTpj0qDaIRRl091AwMDCbEjPdhJh1GsVMxrsPdU0wpKxB12J3cS4MvqA/jessL3lfBllvQWCxSSIBL2tfRsh5zRld70WfhFkOogPutx2v+a6/mYxgH0lhC2jT1Pxu4Dsiwz5MEAVz2QyWWH9o2XS6z84aGah+gryMByOyWF9Em2TiWLVfr68oYKlj7/gsGpKJZiXdU2LeQ4FIAABAAElEQVR9bi6mJ/G/mB2AWSVxZTdZr0niKvMyTETMPFy3Heg0hczhtFuv3E9GA7WscoZB3qNdJKgC0fXqi6fT1esk1i5XMH29joBiIRVLKxCP+mf0mKx2IzBd7GsJ0ViHzPfWYm7f1PXB+jIzUH1OBhA6xL5tA5Q5ZE127uWuCm741blrM+Dtem/42I4bPF81DzTRuGs7TNmCR72JShluHpgkzPVu4tEdHepxQU2gppFGEJTx8LzTr8cz0jWeK8J7PPq6LrnOXHf6qwWzSC03MyRhKNPiW519VVm/lsYRTtTBBVVwgsliZfiNeKgFRVMmh/24wXhWa6tpvnY9LZMKo1BCkIJP8iF8iuaWrvM8GmaEZmsAIWAiPhFP8LjMfhtPct7OVa9HCP4pwueLdE0m/fXFp9PHxz4cjNPrAszBQ295CGxhnbf8UA4G8GcFAiIOtUed5a677kqHDx9Oly5dal82kt1P/dRPpZGRkfSzP/uzaWKCw6lH+djHPrbjarWahc3t/iEQIe3rAFshko2MEVRhROqKUxuEIZLTJG23Yh1KAiX2b0Rk5HW0tU20rWlaFtHLZJkpHd4RPCEjCMYhJIYg5qoc0CUP/Ogb/eJDMEhoa8ybMkhfoNmykj2aN7vt3TFpz62ZzPZ+S1qgHSCK2ZVLc+nzn/sfqUpivFdeeiXdfe9daRSG8+M/8PF0jKSifcBG2A2AbAwhPVwfTM89+0K665H3phdffjH96i/+Snr3+x5OJ8aOhmbF/EEipmUczU2KGYwHhOUX/r8vpGkiGD76fY+1GaQhGMVxNGpgOBAUz2HG0CDwwK//P7+RPvmpz6RDdz2Qys1ymp5YCoRuFKZN78UUooKZZKVJMmDH36MUZM4g8Ix4Zd2aQvGBf1uoOggaiG6Jh5x43yK6tkMsmqAto8ltEAFxRwHJqpHcxIyos40d993EBRmkPiSYOM3xFP1mCHkUPdfkZt11DaEHkdAPTPpJqGivt8aQNRaEKWum+3relSaEeJ3K12sQUNRXYo31hUaO2lrEb9Tbgp2f9ypK0ldxpFcaG9orWpbJKrJ+ZIJzWFuHNUmoSSDaPzVa3Uyp9/mMzJHaq93hmzE/+t41jL7G/AOaYA/VO+Qzn/c/jG5aF4MZZc/1QwyZDFgGSLZSuKt5MTpDkWAPXEwNfUziF14ozoXFXC86pTsDMvbdApe4aZ8vtr44MJm+7nmVqulezHwO9VfSt2C+nk/T5KaCYc16FjVqZmRADjsWvlGsHZlAzx2FM8I2H/dWF7jC/V7399gPzLEMqMy3PpWo0tLI9AUWGE7s106n6ipE6RoxwxrcM3o1DZUXWJP2ca8i48u+4PxqMyW73W4UDJjSGAivhugvsKdkZu3jLSlUE0T4LaksqyTXMvRamzl892wuW0Ls5ZiJPW+92R9dB2UYBQU/JkmVQTLP1BBrQyGaJrqek+7bffV1Hx2wDbW8ezPPOyty74cW1BWIwGSYnGNllsQymtl1zoBcSCNOXagtxhqXOfKYMj/gArm3FjCRMzeeZnGHRyeJbFtOl9fmOdsMJc56Qiu+hjnqIGeEYHfOBjhbigiJuMrZVUvfWn4+vbYym+4ZO5OOjx9JF9eupJeXzr+hPb1ztAdX3moQOGCQ3moz9hbo77lz59I/+kf/KP2Tf/JP0unTp6PHMkZXrlxp+yDNzs6mv/t3/266++67w7xuv/mP8uGL8HJCJb+mVM//Jhr08L9n9Gx6YuO5LDSrVCXFA1Iirs593tOriLIk3DZE0hymuxVJKRGDfyHJ5qgfpJ1+CXAIRFs7AmEzBqHYLnTA9pVoTYBQziCpfxGioOZ1TPTqMAKbRjFrFQkMpdpBfMG4GCrcdnsV4VHHzKCA1qWzOIYGUvJLlaF0ePqu9IM/+ql05eKV9HNf/1fp43/uE2nmyAzavkOpsQTCeXGekOjNdPqO0+nwkan0+S99Pv36L/9GGvvfCbjAmAwJPaJPVeNwOnf+lWSY9MNHD6VTJ46m8+limP5o9nD+ldeYB8YpfBjOEITuidIholtVaHsuFYeL6e4774JygUmCCVlrkJcKrWCtxhopnIlw2y+9+HJauLYAozWTTp4+nC4wFfp+CIHtJSMACuSDamAOFKZyahy4bee92TUJA0v+vr2+7Ju/yWBDT0Rd2+/xN+6AqFTD0Kpu+y37+ZZPtX1lbgeGWNeYfEjJDmA+p8mR1y0bJeZfaShrbABR6oaAzZ9vteUakKjo3hutn+MtJOAmsERrsma0LSNFoaTsQ5NYGNu+djqf6/XZPWRACLUxW8FGMmm1jFCDschoh7aHftvlIFZbNLbz0z0HMkdliBylxr3mr7MfDl+fK/ORlVmfUzy3yvhXWIPu7gxynU9kn6NNbjD30zp7rLNwiQfRJrOXKoytH/O7zGSN/nefB8AbiN8SQsq6rw7MpN8nYe0s+WAeHB5KjyBPGMO34quswaWC6Q9aE04fhbdRwiIvEntnlCAw+vBYumHqNQVDmh65PlxDsY6AtTCWydzA7yiYXEybRiYvkpT5Cr+wDonAGYU2ZeRuXDLp/I3mrg9Byub6cDBtqKeBbXZuZwlB1dSphbSftAic30jJ99AbqaP9bMDBTrUKXdsB746f89vyd4UDFtNQ3OriGjLxuLNUbWD+2WpLxkhGWI2jEScjtxDre69zYq++7RgvN3ute0SuASPaaRJq2bF/uBZWHRxH9mUIIZtmmq8hwGvA1Ol3a836T1YQFhD3FfymttckswjlaisBxyLM0aHyeDqCn+Ai19WwdralZlmLiH7aKGC5USbRrFov+yV+pQlyIl2jjQq+yssI/Qrp9PhxMTxtHpTbFQI3hw1vVygdjPumIHD27FkixQ2ln//5n0//4B/8A4jeWoTznpqaSrk26J//838ejMyP/uiPRhCHvAHN5+688878667vvSSCTYg+w4XLJHnYzuDofGbkeHpm9SUxe6tAzkC4mTRvL5QbUbJ4QgTtwz7uq++2LZOilLwAQRLaEK6MwfD4i7JsGRq1GMch2CxhEsV7MG8wDgU1ANRzpL+c1jEnO7e2mK5j87xKGHKznfeDBJTCSiSsc4BrBpeV9kBa37fe/MV8NslofXnhoqZjAxCBF2BmLlwrp/vOzqRjJ8haPjqSjhw7nArTSId57n/8ty+iLXqGnEND6Yv/44vpL/2lv5iefuLpdAVm9qlvPJEeeteD9AMPAaS+j3/tG+n3vvQHaP+G07Vr8+nH/9efSEdOH0qvLc3ScothzAkAKJwZENfG8nr6L7/6a0CmPy1jAnHfPe9Mn/30D8HQoFTauJb+6Cu/lV7+1gvpzp/8X9Kzzz6bfu3//c9panI6LS4upU999lPp5IN3pOfm0SL1KM6lc6VjvqUXAo8fbvBbfo/vatI267uvEpmjtVVMumAA9kPsBDHC3Aet16rWaz4buYlcVZgXDWLyZok6va91bxASrRM7NDW7dM2x7zV+zUvWIIJlRKA0EAZITtEP1zofs+v2YO+SM0cS1baX7Y7tz4S2CCKkAAOlJFeCQ01nr3t90usyuPrR7HZPZwsusSFM0KYJgnIcxn0UIvAyTtkvNRbYSy1NXOcDnZ9ja7trtorMjqZmBliZx8ztKian/eTdGiuNphH8kNRsaJqT981IYVl+Gfq+vaqtSvf9yTmAsCUX0uObI+nyyrX02PA6JneEuyeIw5OY/TUZq0xLXvJ5dh0J6yqmcpnGYCibz9aNEsh1fIIMcRzaaUdAY85HzojEd9ZA/I4GabBoFEtWRhcDmbe927u9sw8huWeuY41HTduf2JQhWocxI+JdIufMwPAV3itxhhkIxpNLJ/rYL3zLtJPb6/if+o2BtoURfI79ba9bPiz2LZ+ffL3E1LXudZ91EvG3YiwhkAL2DYQeaonyInO8CkPk+jJyXPQHYYv92TO6X15B693xuPo1W82LuM5224U6o2LWUmgC2S/LMPmutSLm5B13xiPW5dyucZ6OYRY/ODCRFjdYF/p3crcwXkVbqmDH9g2AFHiUZwr4LcnwTAyPpkOYxy02Vtg3Cy3GsLXGad81ZD0DwXQZ1MEQNkQbxP9Z5mkNK4ECeKpEhNs1zOuKCHZMpn1Qbm8IHDBIt/f8v2mj//t//++nf/yP/3H6oR/6oWhDEzvN6AzvbSjvr3zlK3H97/29v7etD4899lj6Z//sn2271utLQVOkrmLd+jzJJBn4QcnvQ4fuTeeWL6SmUnIOW5GYwqwbRaDywPbgHsdhPc57nwYJiBzC/lkmRz8O/7ikn9E9xQns9wcI4CuRpZSWVD2Y0IWTP4e7h7rPijzWMOvp1wwFgvQohJdmT1fW57KgT5hOeWBvQEAUB2kHEzbb9i8ao2854u0CAeNDqqzP0rbSgNBopLFppM2VlTQ7fyzdgVJLWBgNaB0NzqBmLWh1vud7vycQ/L//N/8+zV+/nn70hz+bLp6/kL7/U38uzV2U+cna7oNJ+o7v+o40MzWd/sP//R/St576Vvrw3d+9rdXOLxID6zCwZ86cSu/AH+1bT34zfeULf5A+/ak/D2HXTL/3pS+lpcXl9Df/t79BNKEhmKNfQ4N1NH3f939f+txv/Gb64m9/If2N9/wtiDm0HhCCAYtWAwELJ0nQ3qIibDaJumUkqN3rBX7hsoYZRxnEL6e3RwmGimAP4GUY0pY7s/MKlT84gg0lcxKzHCJzKsoXXmedva51/s5nNXjCpBNGnbe4BNcJgrFG4tkS2gpXdRY2myYlmvZTuK2Bz5EhnAP+ez7DeoeoiVwsrft27Ru1hfaVPuYEZy8i0j0H25+mYYiOoTmZQiquDEGN6yhChTL7jjSVe/Yq9hTEE9Bo3+fo7auMhoaIijpk6ObxUVgeqMAkDeMLMQqRGVFDsvvQytifW1XU0vTBJM4Wj6THG3NEz2um+9AkzhEC/LXCzM6ZdT45R7K54ANDYvmG1iv6xOfw+0IA07kuhC8697a5o+u8bRLXYoqEx+spzq8CC9/3Wh/9Q9fYC8XUvP5QWlu+MxVGX039w5dYm2iKOf+q9b323+vp2a17RoI7hCgCm+J60pKgvV65HIEYuJ6brmb+jlkf2vdlX2/Jq0I1/Y0UANq/zuJ8mxIj/GzZ5/rnhA+U3b+J9SveKrP+s/6DT4WDawmtjVFbY99ybRiBhcF+9G9bqWvqpnYrw2V5v1wbRfYrFUQ9U0Q0HOBcWZZRp1PuTpmjpkJP/iy2q0awXwsFNEejQ2UEGCP4zyJkxNxO83hxbmwCajC4iuHkFbyUENLUG7W0hJWE57EWEfbXdarmjZiyqb6MeKSPpNv0YPN01mY0fPBy20FgJ5V524HgYMBvBgTMafQf/+N/TPoZGVCh07/IBLGdUeleT/u9kIsHnYzT2NhYMCOr+CndOXAm3Tl5Oj09+wIEVMYgqc3Zywcp+sO5KDILDVEH9vCQFinmxe8yRXfgXDpusAWeI45TPOHRSpdCI8SpHjbSvKUmhLdarDWCRpho1hwfmkMYMQujpFDvbyA11jQhIvSBLJSUSziqWdIZfq9oSR723SVyYiAVHhpbD1O2zZX8Ht/5T1sb9OdrX/0qDAp2PQykwfdiCYk5MNUEUgdfi/Vr3vPk159ME2j8mjWQjQPtKo7VPpcx69CcYQ0b8Lm5q2l27itppYK5hDcwJ9Xlanry8SfTI489GqZ91epqOvf8yzC5zfTbv/W5tLK6ko4eIViETAVzIjLOvG+cI5EzTB7X1NhlGj3H9MaKCNbgDODIAM/utbGWVr2JeYPJ2VOTZLeQ5EYiWDG/hX67Hs2XFSGO0Sy6ht5I6TX/3fVJsK0XYZDSWERxqqxX6BrXSJI4QB/2HAeV+Xy0cxN93U+/BDaQz4h9+uO68T+Xs/Zsm/+asp7AfPUUZjND/O61bAlCcLEOyly7jg/Mrt3jhzC7yoTUYfoXjVBP7C0YhEyzorlS5rtg+Gb/L6OhGg3NMGsXs59ea59q3mBxjWMW2zeenkMb9l6i272juJGuE8RhZaDD1K7ViiIZE5OGdkvzI3IhyRTlMFeo0Kvkv8dvwCQnQnvdezPXrNd5U7OwpwZKOI9eAP4kNb36aKrNfQch7F9Ng4e+hl/cUj4lN9P0t+deYBUm2q5Lxhhw7Dp2AldwPoVZLOdc4Cz2un9bwhRXaNeDb2AEshR18In+NzuKffa89GzjPe9zL1y649mOC/oDhRaKbrv2NfEUvxADNY50z0xHNISPnvtFk0lxr8xbd7HtiP6KIGoNoeYEZp5KCSt9mF5ys/1shIZ768mAK9fUig7ThgmNrxEspQYT5ka2bZ/1A83SV8wK1RxxwaAkGwXOOc9huqNW3jGIe2XoNLl1H4nj1zl/+HGr4YNPtx0EDhik227Kv70DPoSj/rejeMh52ObEiuZrozBKQySg/cDJ96RXly+GqR/nJ6REJmHfs1/cV0U9sAIxVMa5tY1EuK4Jn5IyC02mKfxrlGTnZ6mIR2MAi8jRT4MkqNXvyHsMpb1MKNMFJGuXkXpdIR/TKolpCmiOQupK383XoAbLd0jESPDpwe/hvRaO3Na+/2KfzCVSxZl+vbRIx9CMibypQsZifm4eTc3n0l/6az+Wjp88kZ5+6mkQhEQVhAvjrVYgoFvwra5U02//2m+mRz/0WHrsOx5LFy5cDGZPnwb7aAnESabzDcJRTxM5r7xWTH/4xJ9S77Ppb/3UT6cXn381XTh3jvsg0sul9Jkf+XSam72Sfus3fit9/8c/mU6cPpXuuf+u9MHv/lBawTdqfGqUsdci+7k24/0QVs6jCTtlmESkEmQ6KIsEw9Sk3ZusT/t9NfjC+gohoc3bkg9oz4dhkmpK/THTGNs9rF1GkMMZIRnfVmhDaaY+TViWvaHiOpWwl7jOVt7u1QlDWYgSktU1NKAGWiDAHUlKYZJGDbW8++B9Mg+LromK3/db9rrXPqsJ8X/MKZogCRwDPmSmrdnT8pcyQSX+y57WJbDiU7bHCgQPKaIVxTPKJbx7sdv+ZyNIXOZ981LRACn8NUjoml+3Iv06Fta+HcQ7xCEmuC9yThxjfdwBYXeZQCXPbuBsz7g7Ie5+06SqiWZQibxwVBNm6ex7XPg2vex7DzJPMkkGJk9X30d0yDEWIaQJ2vNscr5NHb7JZhT+tPcIkyHMO2Gdf+5jfBtrklpbM+Za43h3lqjDFbz12012o3277bk2Jf532/u53633hhXGPpvNZyLMyoPRoQVwm8zPChqZzvYCPzK+GkK/dQN68HCZPGpZHr2dDdpbzcr7YOzG0aLXFBoSSbEXTFznMi9hEqcQEV9M2w/rjFbVmaWGPZZB6kvTaJdGaH8J7VkEMaL/AzBVapztm0zRKIIWzf+yp+jDCnYgCOoOyu0NgQMG6fae/7f06D3s2wc+B6HISiIqLzmzdHbqVHrg+L3pycvPhNO9TFL7JMxv7n7nsG0ihVuFQZJp0cHV+m1PxCBys4hoRpBOKanysvUqgeYYD2bI0OINzOXqOsFzmFcxx3lt+Xp6FZOdRYidJvUNEEGshC21GiOrsE4juA1zqIt4Mo2Jjq5K1mHOuM+7JCBfTwk/JXb+5PRUMG2GPC8ND6bjp0+kb33jmzAvL6aVZSIDYY5QHiPZJrklvv6n30h33nE2TWNSZ7SgkwRxePnllwilWk2XL1xK73rvu8I3yTHoyzIyWk7nXjqXfve//05ILI8fP5GOHz1OGOEivka/ky69+gpaKfI/gfCMePiBD39HmPb90v/1i+m97304ffITH0+f/+IX0xSh4ufn8Vd64N40fAwmCR8ttUZ5EVYW35UorkDkG8p6uJ8IYxKRAav87hu/h+RwFQYJE8hW1Td+yDuYuJiPbAJ7P0NX+zHDQ7HRu8QC6v3TzVwNRpVx5+u/17NhSmVHyOfSB2M+jC6pDyLckLhG7VsnmtnA8O7ws25hbkRA4d69Fv3NtRvz47glCCky/Wqn4npnx4BbrHXal9XJn5UBrko8AbcSTFxeGtx3HSZqmsiMfYzhahX/GjW+LaqnydhKdSJ5kWdsrdRbe2Jd0RdgJZGWF6fHtSMD2EBwoa+CY3QpRfJk9iFX8ttv4j1vwxb2V2Rz5/HJeAbp+IeHm+md5Eiary+QSHanqZ2hxhWgGN7Zvx0w3l+Tt+Qu50+BkGtRkdSNilqmgdHzwSRtNMaZ7z/jxClT6NnSeb4I79hz7A3P/7CXXsOaoXqSaJxGaN2a903gsm7SZhLq9hX1Gd3r4NgJPeHavedsdS/LApuXqZOBCA2xY+jo085Wtq6Ic1xXBniQkRC5iYvMFWS7eYnPfJUZMmWB38XJpQ68nN/b+W5uN6vZUPBIG4o9Ak/Tx7xO340quoaWuwQeGcS6IaKWOgb+WWI+qErY+NkTKNsP5u8jwbbiRhhWXDA5lNgj9lW/PtZfnGlc8128nc1tq+Ko/eDldoPAwM9QbrdBH4z37QEBmRV9jTzwPYS7/ZL8XWmW+Fln35dXXwucpW5GgktkYfF473UMakakk6lJT7MzGAmd9fGACfhUz3uIzsDITCLhth4JbBPlVtGeNCBqmpiJSbQsgEjOVxfScyRYfW1tgah1+Ehpk41maRC/qXDAD4Sr78AgySnHIS4wNSCqTg0zhSAx6aQ5hyRKaWkbo8CFG5YYI20MwewdHT0UDNKhU0fSpfoszqnD6f577k3zV+bTDFHpPvCdj6UTaJIOHTqcRqfIiwIB+gBMyuThmXTq7Ol0+p4zaXmxEj5lH0LLc+zUsVQaH04L9eU0Sd6KyclJYFQg1DphzKuYOJTH0iOPvjeNToym5co8ocIfSg+864F08tQJtENEHzp+NB09eTQdOnIIhrGYHn7PBwhYUEiXLr6GRut4uu/h+9NsYz4tUr9IPf/rNegIDAAydLxmX88QXa87t18TMW7IHFV3J6i3P5F/oyX+FUogXk3kdimhTYTxCvv4HfdATLomfT4mascN2y5YlyagQQgIDea1XViI/qYGQTjtViSyhjeLmMJgRkls3QKRBEuREAkzHdZsP2uz29QuFxBoFuiCl4nOnM0lyIW32k+IEP6bhNTob0axU8BQwhcg8hq1vvvb9v/4CrC29VOQOVETZp2ud7WCETyiNRj3GtNFUAbMNzHPWoWJGseU9xCR33wfholvsP9XEUisG4WtFxi45jg2wuRVoQbwJP+KBNMo5nsl9nVhiLMCAQa/BNNkrheLzMjNFcg7TIdkEbOEq46gV6d21mqy2Aq3l5jPs2hVXKdz2AetAd/uGoSJ51oW5n5nXd+uK647BS/6erLi+dbd0149YQ8Ul5N+SX34ouzrkV7VfJuuCefAO8yPq3+T9eafecw2mjDn1RNpfendaKPvTZu1wzBJUyyccbTFk6w7cMoGa7pMpECYwf2vhmxw7jPbdi10FxmJ3eAd5wRT4fM3iuyX98l71eKOYFYaIeVhJjxjV8BpCg62FR6yT2XMtPU/shhl0v7s7ClTzLmlH2wFc3gD/k/019L9E+PpCoEWZglWwjEXG1286l4V15cJIjQ9MekPPRnCNfyL9C2y7kGEcBPgI4Wdy/UqWmUEOppOI0AZIbDDAMKVTJNuuH73DmODAWvW8K1kHA+ffCfXtoSu3HJQbiMIkIOxxw67jQBwMNS3JgRctv43Qp4HYR4m3M8edM0W45Qv7yVs9//Ti78ZuXRELBYJebUpK4QF7UYoIhmL/ksfO/7h9GrltfRadZa8PRniNtFmgSg7StbuLU2n0wRaEFWsrmCW18rRJMMmTXQNX4BzzWtpGabIwA72qQ7TI0LNmuGdHjAQTOlgjorj+DgMpYswUzJH9s1x6SCuI2lEzpLw6NCk2Nf9FMel/fiJ8hEQzTD5WyrpQmUuGMg7xk8iIdTMQIKQ8YPoLaMgEshVtGcZ0V0j2IKIpEziPscisjSYwdwyY1xbSdPlKcwaplKlQiSuq9PUsEYwh/k0OrKKyaOSeaSYPBPEPRgQ+pZIYJhVQcyO9E2mpcowztmbaWpmAa2SZnQb6VplMc0CDwmQfRdhBqFbBm75fO72rONYr+EXhmkddOg+iTMpDW6F0R3QPNKw3GgJexX9ezZWqJ/1Q1M9i3mNihNIM1VH7lGEWw1zQ03bJMzKxREIYm3sWxXzZiLWChGdWgusZ23msJpcnwwBQP8o/cMtbH2F+US8ulpC5WnQCGCYF2EU/gutdetv4a9EHxQm+Lsl9pLLufWXP+97u4+dFzs+W0M8H+8ygS3iulVfx63RtzPslcNku6/iBzcCUzSBJtRuqAm7QECS882lVB9kQreGEVVkPWW8PCfzbwRM75FBGyNcvDm7GsBgtVRDSp6Z/Nl3NWBBHHJmmCpgL/h29jVGvj6CCSOahAJnVnGR5nLisqtz2x+Mb0LhKLlZvouADaMssT+oDaQX+2Ywe5XhovaORWXIc0PxR7lx1T1ae+OXnDfDMsskva0KCydfw+49rQvcEwbZMTnuJgR4ahzCf/EdCFvOIuzBt9TAE873ALBgbxXwsxlAQ2s+qfVUgdlmr1Gytb8PaHkj8y2zEoEEOuY+8F/H933UtuOWrfFlTFhZwQaCCHGdTXt2L5NQvTNKXl6J61AL4qmxCQQKmbBIrZNafYNCdBf7a7LXWVKArHP/yeJC+rFDQ2m2cj399uYJMoIRza6lXVKwMArjVSYog/uwAq6papoRvcrmZR3td20V81zwkRHuhrFkOD4+TRuECa8up4nCBLm1DaijCf5oqoKv3T/i3YA/Z2+DOtciF11Kf/X9PxJw7u73wffbAwIHJna3xzy/LUfp4SoTIsOjJskTzizsa9g+r0D0GNHOe/xdSVcVZ3/Dn5aIOKYJzQx5ExYxEatw2HtI5sVDXh+jaQIv3D9xVzo2NpMmsWPWF+d87RJEKagxHpCUM0eDknyaB1Eq5RpCG1OkHwUk2bNQnedXl1MTafwYOY8k8JVkRXQ021ELRV8s9kltlclUK5j2WW9OLEoUr8JENJB4iZhyJJb3eb/v1qfd+Eskwct6H2iBQBFr6elrLwTB7RWLksMSPj3lleH4DHkcMEaAGO/+brEv1YVKqlxG+guzUD/SSHPDdczojjI2kNLUAtLSZUIVc/OqrQo1AeZrJu1c07G8WkrL1yFKCSAxcex8unSdqH4ClpKbQPnsfovzqLnWfkpoEtAe7Y85og8MXQ2LTI05M3KTFYfVXUTwainWDGbR4oW778kWIPXuY3hqh/TRkVB3DvQ7EMG3C3XIMJl7qAEjtRvMZGqQd0PxMAtMqvmc+vW7Yi4G0IZFfpB2pdkH12toO/1qX51G6rGNbE9k9+WvMc/5lxu8s3SiHvdXgf3l/Nl7574XWDQ9XYK4HIF9ZydFf+yHUyAxFXJrxpJPSazWVhuuvSaS4gZh2kMrzI8DwGyYiHglSKhGAYIKE6gajJDaIolhe+F41ByoEdPXo5dJU+eY7U+UeIP5XCWBNuZWA5hW9Q/Nsm5yAq/XCLcAZt+vkkj2mfp8+iCmdg8w3fM4pl/ZIHx+lTls7ROfqOALtz7YRHKvNrI1foCghnMwoi0GJLYqfxM+yRjlOXjehOr/p1aZa1EbEOHrjJPlwSyz2jam8KO5G+fV+zhHmOMigqfDT6TS2KVgiiJtg5pR7u5jbqxnhf2WRw5EWt1eq7GGdxslS0U/VJO/iiHyp9R0GLCAamJdej60K9ytrtZ113SE+eeAyoUSg+BWo9XJ6OivKp/iAVZBYNCLObIq8dQwOYasz+Kz4SPasT7jh44Xz177WUCDvjg4nS6SsPUMvsMzCBrXC+BdOK4C59wwmqMwOwduDfZ9E/jnJc56vsscaa7nWGJMMDzL+Cg1FMBxbhJOAs0RgkZw7RqAEoUZ0GIdYVH0UwGWnWHf7L0j85YP3t/OEDhgkN7Os3sbjM0IeXXU4QtLC0FQFTHLigg1Rrnh4NPUx7CkVRihOpIhw30XuGdsBDMaDv9lggHnByHHIgd1Jpk7NXIiPXbi4XTn2Cnq0VRP52fV8PgMoQUa1GeIJxu0MUdG7xlNgHCyX0cyNQii0tRqHhOElxvXQGIwTSAzmaNVzO7W6EcdbYWhnodGeY77PczHkfpOIB0z8s9ifSWQTX5M+x5mUxDD+bXXO73ZePPXfPTZe8CgVbHt1QhUIcGaRS3inuxfvItI5BO1C5979mI6PnAIU71iev7Jl9PZx96Xjp2cTcMwSoGEIMDVmInIJDRVkvis0atq9WK6fm2CfEpHuLeWpo49mwZGrgN3bmiV1zNmn9aHRfMoCdw9i3yBlMUNCz3RFG4ETZjR3mIgPOSjPR6P8bIW1yrk3RKf79ENaKcbliBUGFNo36jM+jWlc211wkhztBJrbg0tU05AdVdud5sEZNBUJsHDAiSAwD/MzEzMmJmW0OH4R+0xYVktPhtD4cU+vN5igIhh1r5axSILxQh0RqUb5rrr5SXygy0xhl7F9lf4bYlgCpoKakZTC6LJXCmOgXlnTEPUr2+cO3aQ+dK/z6AYV5oLRKSzbjVDhTSKYziGQURbJIhKfyVViQQXvkfCuasD+lhs0OYKEbw6x5/tCdY369r+ydzF3MiADqxiUnURs6tyWlu6E18IfBf53gcjFoDPINrVUv6VejB/fBlvsaMIau7F1O5eAqcsXmTCVsbo91bY5ZgbGMT+cP7Pnlf7W8NsrXGilEaOjYUEPca09RI3xhqKieUrMHRq6Xr0rBcDnPeu813CXBPN/e2nzif/bH1WsCY8PAeFQw4Wz2rPFa0B+lmrm6ybjdpp5uEdCEGOcCNpE8bOpcHJb8KQYkLHPay8WBO5majrI8JXs2YVckTd7i+K7UWDu4GDvrguFZP5rGeBC9R+qT30wBWHVBTEBQuV93yXCn2WZ0a1CGDPmGfISS+BW9XUxPkBg2NAnWUCHdTQ9MvUdZ4HOXA0AR9GMGkJ0zrqNShR9HGX5hUuRZJq4L2GQO4lBBf3jk+lk5jZrQyCf4kcI+OnabjmeFp9KCwMOFGn+09c36yxl2W2KAWEVwWsFRRkHCY/Uh0/xAbr0vtA5GkMTVSBc6PG3Jgoe4M9FQKV8pBHYERQ1Q/poNzeENgHSr69AXQw+j+7EPCwU/q7XFsOaeUGRIFSYYlIEVEgEX4XlYR5FgdpESmUEnAP/wqSpWXMQIIoYJiikTJhQ++buis9dvQ9aWZ4CoRhnc10GfOuP5p7Ik2g4Zkg6ekQyLGOWY6hQKt9jfRCbZ6oV2qzIMBAhlgUpCuNxYhUNyQxBZoxl4MS6QZ9XMdOWgSDMicVMc0aJ8GpdcuMGTlPAnULJW/NQd7XrStv3ifbEvlU17PkrG0mqatJEajakTPvIAgDZk7PXH4R22/CVhOWGHwbSMuw6k39QULcqoYA4mITU7rFqXTt6tG0sIBZ0+h8mj75ZCqOLAOHTALZ1dRNfw0izT7cSGjO79InGXrdrRkgAnM0OAqxgzQ+6Bkf2PshGCOZQ+7bg05xLWi2GQzXHvUp3ZX4yRkke+o+MHStUtYgZrxIW2qRFBDsFmVOzc/KQDVVIdzbpQWnviZMIIIF2EAIL175n2sMvVdioghBI7O76pzeRHF4koTjMHDHB8cQLuiUTZepT6FDzAM3SZjXIDabm0vhS9QLgDJCKxB0/Ther62yVmHWnQ/3mxLi45gfDiPMUGgxBPEmgyQxWIf4WV+pp8W+Fe4cCOaoTGCPBht3cWCJdjHTYfHutt9CyyXhK1EnU9aaW2EkYagfoWeBGia1KQpt7NNAeRZTTHL/NCbQKo7CqMGshL/NHpPegq26tCrmf99EW87OSQPXC+me/uPp4Y98lAAoaKZiQfaeCE3AvvnUk+lPzj2RVkqVNHx4NEyX8vVi6w7B8ToG2TqjXkbAGeCoP0nkq2mN01Z8NjS8XBMeVmA9mh720qz5zF7FPdDJbO517637LYd7x8BalbtOLBssxBxOcAZxbQDCe2Mdc9j6ESJ13pvWqsdR25gSgcTR4y+SfPtJNuBi0OvmmTOMvwyX6z6SbbsGW/tYoNmW0+d6MpWDwWvEX71KEPkK7WAU2trc1o32zj3k/MVk9KrAa9zo/reo4V6jXZpE62zcRjWyWcnH3cc5UsNkV+sDzYVlAl0rzplnlgyTDJr+QdZR4rO+g/raZhqpVoU93tSsuVdYeAGDCyRJXmFsZ4jIeB5taAOGqwGurZGbSJg5bvsXfeOD1himzIicRlyV2SrC6KilG8ea4xCm9KbTmCWPmO0oLDlSPpxOjhxL10hge7XGfmRM4iR9FmucAf34Yy5WlBrlkOjR8YNLb3sIHDBIb/spfnsOUN8jSxCHHPAcrXwDKbSQbNg8c4hrqnYF5uVCbTaNjGC7jPZIwmsVoqXSvBoEexFmyXNQIuDRw+9Kjxx9F5InfHHAGHXM9SSUXlg8FyYtZfIBFT3Mub8G47SG9GkTE6s5DmCJ4EFM6/ow68kKkkQdqT3E+dHDV2QU4aPphP4Dm2sjMEclDnLDbm+mCqYDaqUgU4IAjXxNPJ8jKuvt4znIVa6B2JQ2WrgnSt506+uteMuZJBF4Hs0vr9dmRepjJ6bS7z3xR2HWOHHmUBACCvOaSJLrMHtrIkrgmI/D8dVXiunahVOpsTyehicvwRw9BWKrwFDcGubIPtp3E+7CkuVd7vkeSB6pI8Dv+bvUn/coldT8LEoO812e8LKETz/IV3cu192uhSo12durSDDV0PY0IRKy9Z7drZQ4D1/b+XymRdIUTBNQFmeP4nzkc7LtZ/or0WGIazU6JRy0I08TY1DTMwVTM00I6lUImPMEzqiybmWW9hqi9QsyGTmZolOFsTSFf0MnGP0soWZx3xxBcOC6eRVfohqMUHcLEpwj7OkjEGZ9mMlsjUWjO4n6zFxPQi46F3UzjxChR8KUtUFSzZRG9DlirIt9tIPZmyu1u62sV1uvMhJK2IW/1dqGzuwmphyEGbM9158EYx2zJCXfEmIbMkTDV2CUrnJkMfE3AtpWk9HG3MB0+t0azNfCcvr/2Xvz30jT+8Dv4c0qFm+ySTb7vmZ6bo00o8v2yt7N2oljrx1sjARIgPwpi/wBCfJDggUCJEiQzS4WcQJsvNp1bFmWLcmSZqTR3DN93zdvslgsXvl8vm+9ZLGaZLNnWlrPkE8363jrfZ/7+d7Hq0ePJZNwy8wKpywS4n62bful70hzc4n7zqSL966mK1P3sfJjroAzMR3ck805DBxjklH1WfeN7xb3TzPjMs+YCyORvKzQAzgqYavvYjPzLzxyrPlz8fAeX3Z7xrVwmlyXz162eRZNTmYiWv9btiAKBRS2ZTCWudShFCHY+grMUbUfxuhEWl44DHAnDQTz1Azj2Tt4LRUGr8BwoK0jtLdazby4Jq6QJpuNe0v84NBkLGU0LKGp4rvFlYxn3FPgEJclzvQ2QMV79feJcW3ze15fdKZWdzBd9GEnXbt5+2RO3GfrnHk1/7Eg9MM97fHStM4gJrKBRrrTRNx+ZLNpq48X11xc0IblgXPQzDOTBGe4V36QjpgAlnO/3DESwsU5fYXrl4nPMkWayBlYwVkSRnfCHOkLKiPUi1VGnH0nDEFVHwKZ830n08neE+GbOtTWE1FoJ2GezDFWzrXVLMFcE2kPHu/ywZV9NAO7Uw37aCIOhvrFmoHZ2Vl8fQCEIHMZkpxYCYhWc1h/SNSzC/NX093qI4ggTL0wiQo5LlDP5HbCTKVXJYEon4/3Hk1vjrwaUncBtwhNxCHC0VG7GxMENRLT1TnMgsirsDwXwJnI05nkDSmb8ruoOJ4Sh+D/BNFQpf0qzNYKmeE1dwGS895LPSOpF/W/hFwFYgNFQEiyusnLoB31soQVhKFmK21IxiLXt5JwtA0yUhXM+0Rckg6BCHZFR599jZ2PBZxiRUId5oXKq6K/EkgjZ8dS9wjRmbivqxeTE5Ejfz4jgZETBPm7c9raOZ96hj9O1eJgKg1dy5gjiKxnV9D2QNBJxD6xMCCJ7U1yxie46ED9zUAMaPpaCnuoq66x0BwwfqdpxwIiDwZNJ5wdivO5iLmjvkfOXX2RUFIg0I7JV/Q3/5HqjCBnFDaZqtzUpfH5/PbH3umXkuCTnYNpqAMGPmYILSvnq6emPaFVZrc5XccfxhD2EoCPj8L+ZitvfUPkDTO4gnmMto4k6wFbKCtU1EYfhmGSzGt/h7D4KxKSteJtfdQhE9UHQVZPC1qHfhpKl5cg4GINOU/hQ8UWcw76kC6f5szOoPGYXa8QTIWIkcHoSbTtXnxe2KMmOiPa0U5jBlRAs+A5jDmujUPNi4KTKo75BiPxPGTELW0gxHm64lia0yy+GlX9TajbmZ2fn0t37twNgnR0dCRg0EMc39WUtUEsjqBhMiom4vWARybnjMVqaDyYAeFTQ1Fr6bgK7CWfMzpdaECAkc6DMM/6vS+I/YbnP+9X/alc3zWYzL2V2uRvuZk6qGQdJqdpDa0+UeSIAc90osZv0w+Vs0UQBVcvNgyv6ipirZnztEKwFyLRrS1iRocfWdM6jHDhAVOqKTe+N6Wp1NWPhpBgDG2En1egoKmhGg+1GSbadm6ECbuVXHOUwXPuzIdS25TZfmPV7dM2JXpMG8LibQuXgyHix2ztsu/2bTvo5v4ypHemOQI/secsoYGiLtsrgBPyCI9uB4UBWQjuuHXXF8+kCckrmJ5b2xqa3MuYzZ/u7kuHlkiHsc580wcsfzemwjZzgYBmd3GM2J/tRLGMSKA80YU1SBdwQR+kO7MTaYAADa+WnkerfCgEJPMEcVGkMto5QsLnKrn+JgmqlFmfmN7DPb7ZIh8Pyr6bgQMGad8t+ZdjwAJHtUhGr8sRgUAzL4+qU+kXcx8DzdeI+lRILSuA/trPFZgOI6YJ+CXiJQq6kZArWdIkKa8vB8DWG0Q+jICfNctbWCeCDsEdwFIQBhDWINZlpMGa0YWJBBItmRoJW5kq5LH8TluYogXyxf55rXos9Q4hnW8lDwbPdtM2rFIgau+1tCq5D4IKSTSYp4Bmq9eQ4iDLRyFRYwyrsyA8CAdM+X6VxXlx7tpoP/NPqW8NSX4fTB2XsnlzbjNiyXluLF6RkOgevJPW+++FtFTCBbTXeOtn/04jMgiZydDm3tiuQvvTpPavjfaZ+pC+st4ibxmMiNaGed0G0bJdJdtdk3aU6pCW2aULJjyUSdruHvdQGS7cRLk7VaEkXxMUx+uedDwW+5slz0VCSz0yWDJKmZ+Dze1UY+xSGPi2dKxzIA1FlMZsT/qEtJcrJXl+SBO5jqZ0szqdZqJufuT/Ksk+l5c1Q4MZbl9ORRhAtUbj1BWSaCtqKEqjZWycixbmnsVjzxPdqqk7ztEkc6CQA7cuBAkkgWxByoyGJnZNXX32zzpkbC2OU3rSOn2HXmVu1DyhZYIpekTC5vLiYtQdI7cupCabMxnVbHmxZjXNOcGoxDqe3XJX9kUYoU+YhL6MRRXiyzPumYq+bazYNg8/dol+QcwGIU8/JcDfe/fd9Nbbb6PxJlfSi+fTyPChdOXq1XT7zj0Iz4X0O//gO+nEsZMbNTmu3dZ+48a6D+4xiWj7nBPxdltmr6IvF/PlvD/rIqxpAbbpKxLLsm0D9Q3TqYAldo6FXjMSGudilbxyy5gW+lclTDTa+7UVov3h96jpY1vvhdTUMck42OesV+5H5Zq1sM7NCMWa2skP1o3fWPN17nHcZd4lxiHM2WtqVti57AnXm9DYCN+qwEyZGnvoGMoI54JB3nYctb3q+jiZ/A9Tuti0NkXtbl5BPe3Wl5gB18bzwZrsVgKO8YD1aTZskmqZIMPuN9ZrX2V8N/ZLrd3QhnIQfT7nXrxHs3OwH81Hj3brRvwmzM/91WzLebyZujGzW05H0OpeRnix1ihkouoIrOM4mZuWTs468xIBcxiAU9dN9FKDMN2eepQmiYJaba+m+S58e3toDy1cheh5MohFYMjRrnH8bVfS3QrR9OhPBYYp5v+JvT+44cs8A79aiurLPHMHY/sPOgMSWErBIjxvQ08eVabS27MfEMlpJY0j/b658AjERHhcwlqHk2ctpK+IIEwoqOdQ73A6jE1yDtMl8jfrzoj9kKDRlhJAo+EBkgOXaJ8togmmjfDKAlbNk5bxM1oH8eSIxXsyqZuarCGQZ0/q750Gt0A4gVi5FTMiidAMA2XoJWOMOjHV64f4HVRazmeTxkJzpqtokOIRxXa/hiLiq8Jc6q+RjytvNoIw1L4EUt2Qxtcwan7jlnecb9GG6bMR4cvV9NXGv+W2z/DFeiSSG/u5bVUQRJq4tZVg0qQtWMNmGaacKXII2YJs+/hOF6MPMD8xpB2eD2JFyfw2RcJhkT21hGmdSH+nYqCGBXwEVlpXgiHSvC5n5hy//ZCQ90/iViZpifXxc0acbFc5zBUMkn+aU21XfErGYAjn8PY0kK4RVMHgJIbZnp1Byzo9FEPv7Z9JPRAmh/AHMHHjtmOhsjwgig+tYWqZB8Io0O8Tbb0wY13hI2DSRzVXAxBBwaw3dJ8uBTMkQ7QKEefZ1P8gHMJrA3FOIPnTJD52cyuLYRbXIVPFw+5f/Rb0Bdl+ZTZnI/P92vy+3ae8e65Lgf1giOaliErJiZL4i3ae1NLjNbvGwqlbaI+OnzxBOP2B9OmFS+nUydPpT/7zP0lvv/1WunzlShoaHvks23dLgxL5O2lw4ozlg9zy1Of/4p4Nv5Md10KCGNM/mKH1VTSJMkIwPzJAqzBD+nutr+hzhWBJRkktdW4i5tlgf6/L6CDJYPnjtLhBPRfCpSLMTxZwwDOQnwODN8AMKBCDQHfPaPgceYLATUKdwCGsbYYnNF6DoUbjGH48AWQ25yY/o9ajCbX3yuQEI8q8hsAm34nubfOlNRb6U6U9292dPfJsZM+7f7TAWCdYS4UADB3MtZrQHHbYhCaBwov6Yn8iiEGMG8EgOHQV2KPfnzKJLFdf/RPbf/YMGg1whT3sGegEx3lGp5p7022i2Z0oFlIRPyECfG+pwPlynIbjFi+3d+LzJ6yuzZEwQUb0NprVRQQfjmkC2PSTiXfCBM80F4GnWT/nWGb2XO/x8AO9MXMrta4g8ENDmOPiLY0ffNk3M3DAIO2bpf5yDbS7uzui0hneW0CXF6V+b0+8n+bbyulsaRzmA2IHAqkXZ22dMO+Up0LLYyS7TXzTlE6URkGGmmBkGh7tmvN6NV9agoAKZAXwz5LF0mYgM9+4WCsBovneXkCyDBLTpM7EdWs4oQDSuQt0iRlOy9pwGh6aIBw4CBRTj2WA/BSEWkaIilIz8yIl+GqMDiGJ7BF5cF84mMOA9eJI34GjzwpBIrKkmrRun3j2mZq5xPRm43WqDbawBvKoH3dt+BtvzlVmf745Nxs/xgcJdohFEFMgZHpdxbb9WRbnW8nnnpE1iFlJ9ZYSY+dK/r7lxz1+YTGViq7qlLXddECrhLP1Nm0oOdU8TmItR/6NrWbX3V8wU8GcZEySxF0QZ3X702eVQEt0thFFLfa25p+cm8frR2NI+49W5gmm0BP+KU5EYzf97rB6MGc5AWETexmNV3fPIk7bD9PifA/MUildLSOkgIg92kPuJnLARCjv2rPWkWmPNBXlMxfcQ+vkwwqilYueCTNy9XImNvy1bLixQ1yqL2rnWiCIMyKz/hcJShLAQtqe6BgksAj+ShBWagwWkSY/rM6mB/glLMJIcuxijPVP55+f0Hx+W7znsycsauVMt0N8lg1DDAEqvHl8DbY8vs0X5oc+d3V1pZnZGaJj3ksLC/NZ8BoSVt+6fSv1dPeko0ePpslHE9s8//f7kvMR+4J9mM9dY4/XyiPksxpBK0Tgi2W0QsskYZVJWtVfyruBuxsMERe0xwqbLJiW1nJq7b2UaY9IUpvB/HgoGB/NxmSOohb3QN1iB9PGxtDfxfOk75lPhlUC+8docFvXU1NX8UqmT4qxcb8CBpkiiXrbCiaLJxewUNA81OBDOS5yDjy/MRdZN6NvNmx9nploo8Yi5c/lv8fNdc9FH2qDUjihdURXUyG0nTJ+ljDh1mSh7qCZ0sKASG0wJuIB29VEXNM68yblMqGoYJcXBRFlI9LB7JhIurtIgAZzLBEq4jIht8+Rw2hgZSpdRcvjCDcK6xA52eiHY1Qg2QHs9g6DYDj8ORgkTfdKRUL3c20ei4sJfJr+5u7P0tf7X00jCE8do/jcOgw0caJ9NN1bIpUHuLWbYBHOz0HZvzPQQA3s34k4GPkXawYK5DLQB2meULcySZmTKXgRIL/SvprO9x9Pg+QxWkES9BxSqPHesfTuw4/TLMniCkidlT6JaAR/2oqHPA3iUmmUltgGpgqgyQ1KCecA4v4WTrcga3VHAToFxhTJN2jgQCGB/gC4mcofopvKl3H+X6MvgG9u7k+9XZVULMF0rZLlG+JI51CZI+uNnA/0aRAtzSH62gWhK4VWhdGqggiWlkgCSl8fEclqGvOQNsL/KnmMxHwA+RWZvDpEHh38HC/B2NF+U0hGM4miGot22nWO/D03vZFRE60GMUqf/H37omaMUNT6jvB8SCAZ/zMtNB3M3Bp5nKSy91J26u5ent3hHglYw79DPWx/h236Zxfr2o+ZhYCQiNgOUesMrd+HyYMlUjR/9F5NOxfWZLbbIQyQfsMCNDKzOaEVUerYk66TzzWWafx+3pu/k1aKK+lwRx932mamOa2/1/rsfgmztRH8EeYxhStidtfftZ66hxbSxYXJdHcOE5bqWOqc70+HSpjcoTnMJPbZsGMPsBe8Zn+rmOjNL0LAQOw0Y6bXAVNVQErdhqRYQjKS8tbNV31/HvtsndHDzV98VD+oo+3krPFXB1ArjmccDe81fCAuLt6P85YtUH7Hs3l3HGooCHL2mZgkj5f53l586cX007d+lt5///0wr+tBgHTx0iWYpXJ67ty51FELvZz1um6gz2YYv7JagviWOdoGjrhGiT1enX6RsOnH6QOriCYEFgVYRdQ4ko4mzJc15V3FlG4dxmldPyK0TZD0/D6Z2gY+SS2lazyH/0swAZtzk5+ZaBomQoZIGUfAQ87ZEsyOQS0MzCFzo/mq+Ef4by2N+81Jso7sd/ACz8b5hbAXFgq/vZYVhF9tWgogSKg953CjUHlj3T5bbFdo5fO1YEDCU/ubz13WqVol8RPwIgscQqcoGX4ro0law9TYcQnXI+ADv23UQ51L5A+TcZUxjMHytPDHe6popNoRvoTJsLVyvxq1LQeM6+LgMnhM31wFRN0EZVArF8mFuf3GWhEf1uV0lLV8H3iyCD7Mz6jPhvmsY+JetcTRP25Q0Gki2CLJ1rW8KDCPBg4xKboa3AcEbfrh3Z+nb4+8nsZLMNdqv2p/5pOTqWpdRqtIGwdlf8/AAYO0v9f/Czt6gWEwOQBDGaUAcADzfiRa3ym9gW9BD46YOH4uIsnDP6gFoF1A67GKRqdKXgV/Cx8FEIqI7QpE4LHieKpWAJb6JwFoJWxFRHfLj9JUeSbyXihpLwB010MKKczPsE47jFIB8zfRo0hQh/oA2iJE+qo2CVUJCBHgu9YZ0vVV+jRPrpUVsO56rR4R5REi7YxQVxFiUyJAE5pKGb8p3tUmzIIAb5OBfYZoW5oGmOdFUC5AV9qt+Z29ehYlkA5In8naqE4JqPMgGbBKdDr777uIsBVmrkOGk77rD7O4iunKNr3JnkXLVEPAmntlTr3Pqud219WjvmdZ5cYsPMUHps7oiav6NmxTwpafOZbhqS8bRBDzWl+8LmHSQfRDoyS6Z9CppJm0gAaJfSdByT8j3mlr3xza0+1BvfepYTM64XYMku3OYsb5wfw98hEtp0F84jo4c0Zp64DYsM8KBrKZ5pV90kufRtpKqZ/+DUDUaMbW0jxBUI5ZghWgPSpAYBoKJwAAQABJREFUBGGQp0+L2ypMiehzGUGE56eDIBCG5J6qNKdLj3rwDSJpc5Ew8gMVpPQ1R276tXW26mfo6T67PSRa/V9fjN53BKZQZu8qY7efv4qtVM8kKSzZTVtY37/sc9bpw2OH08svvQT8qqTxw+Opv78vfXrpQuod6E/HT5zaeKyZeW4D/vmufiNbuY2fmYLNSdjYf5s/P/ap/v78R5/b7nr+e/17fRuNz/ibDP+W63aPbufajfVlzOZWzP2DZgVtZQtBE5rb5/EbnKkxSKRxkGnintWlAfIVjabVRcw+yT3V1vcJeajuZxR8zEV9zyC6bZv2ZIgk2s29E0EsalOkpqeI2bbnR8uFfCw77RH39oYgiY2vxqkDgryVvW5xnJuzz3iApS0wbs6BvrFRtqlc1GEKhnbOjYIz+5kxC9nqhr+hINwbfd5G+IuIqjBgdCoEWiY2V6vrjC/CUBh9VIuF3FcuYAmMjI+rvQkzP9CaeFIGTf9bSwU81YpVQye4Tl+5Zf4cd3vAKoMWMRP8mUOsjB+Qnw1K5BjnSKpuYBVbmW7uweJjIh0lZ1EfgtAKmq2NwuE38AWDQusPPCS9xKYW3gTnmKQD97qYl1nM4Q3SUCYIRBtwuLtQYnzV9EHlYhrsGyDkd0+s3cLCQvzeVSohOMG/mMV3yg7K/p2B7bHm/p2Pg5F/QWZAhkgGKRABfdamuhOJkdLlARkhgPSczFCE/1SmCBIQ4HGvSSLX0LKsAeybSRqnTfjFiRvkXRhHa4O9uvchxhahGL718sNraWFxIRWJerWCJFbJtUBd3yOL2ptOGJrMlMs2YHyWMHPBPjqYJPrZXsTPCGRYIIJXp9JNYHsFbZBmGIXWErJP6yGsMaYEJ5Foi8E0OzAzeHkRnw6QzypMGUY06WYz2gEeGIR4k7iqwOAtYD5QgYjzmWcF0xk6ZipgVj5o311fbFPG0nnI0brjtp/ouRirUlWYTEyqvKexSEIpLTSaoDbuInGff5ZFxF2EoFcqm/fxWda/l7ps13lUDKxZmIQFl7YWLq2xT9cjt9LWOVCbKCPkXLsv1XqqFdJ8TibUuyWoKzAhBmNwzEpLM0Jb4oTVgOEPSe/WVje/UYnESxVJu9EWG9ch9jN+UB8v3IYxkpnCnIh91017Rf5KfDYRchcMcQnCpJv+nuVapqFVo6kU3H3QlO5V52G0iAjJc9Be7GZ9ABAq+M8zBWlU5PkCPk3NaIz6Rh6lQYjbEcKrDxb01YMpw1wqJNKN87g5oi2fYv658rTEjju7C+L3COdxCibxEdErMwpzS/XP5EvOJJXRJLl29jnfs43rEQ0yGPtXwTxvGcJPIlTTunPnnkvnn3+e89eaTp4glHERQQvadoUai2ieS2tz6flW8/MgSUdCX2EPrQWB7sw7R7QWbWft24dt249OsB9hkt2LYarEOfYsxzVgnddcW/eUe1RNvQIU10EhkkyFe9p/7j8jijruFfarOZi8rpBF81Sjz2mKZt3uK/fzOgKHmWoBuIfmhLDa7YPvEkDhenz2/lir2CN8JkpdS/sNEjzfSm2raJN4tgkBE01k98V4Gl7ojHtXgl2mox6O2QdNySKcO5XsPEdZnfZmI6+U46rtcefCcTYW61sDnufwNRPENd7Fdx4V76ltUizi/DunG4X64+yzuF6P+vydw6dZHBshbmVWY93zdrxXHGtx/Apx3CAKRJxa8aY4N6wdxLt8niFwkYETHKvaJB6K+cvHPUA6DBFfFt0Uv0r2o/Wq3SwQbMlQ4iZS10/YnHBraKIvIuA821tIJwnDvcAYy/RF6wWZylXgQ3sH+4x7I7gSG1dLSnFTDxFn+4D9+mSZ68ggIvZLaxM1baVCMU0uz6QL5atpuGeQtUSQA83gnjGvmcxgrgHj4kHZpzNwwCDt04X/og97ZmYmTEskCC0hxZKIRxNRhUiXWKhU/Q1UAxZ6QDK4y3M3UqmrG4kTQB4EIDC1CHAn56bTjxffTl8ffzUNtg8gjcNZFVW7jMfteaSMAH5N3IqdULPUp6Q8RyadMD0SODmiqwLkK/OQrFUZAxAG/dL0TCTWCeEgUowQ3fS1tQkCwAsULLfTYSJ8iakE0oswRuWFLLLWEuFHJyECJglF20n+liGQEqxaMIK6q+vouoXJYHz2Me9TNPAUL6JNM6dLWGXdy/qYV5HZ0Wff6omDQOyQbhU0GRIzuxURNORxIK76OnZ7Zq+/uTYGkpDw+qxzsNe2drrPPVZB+6Btfg/+Jq0kmF2dy5jmLc+4baVF3C5C5IxmiVua2TdF5lFptT5M+ms5r86X48pvjdXhpYP91EpwCYlP/6ysUTMVFTe8eH4KMC0seDBUjeuRfzfkvME0Znn+QZqLtZO4UhJ+iETHXykeYc4hniCE8uKzbRt7gVxfEDBz/NWOX35bjKnd51i7GULo65vQ3DQFAd6KHxTJlBeK6VhhII0TCS8CPWw8ucsHJkh/QveDCSSftjivwbDBGP6qS2Ym1Yl0m3MdxLFbgk2RL3JdB2I8PS3p6uSN9N7H70WEupfOv4Q2PXMs9/dzZ85lZkzlhTQ5OZk++OQTJPar6atjwwS3KKdra7PpynopTeDZtYaQBhVMwCkFG55NmYJMU/w4A6BQqAst4UChJ/W2kOQZgn+CKIYPFyfTaGEoFUllKxGuUOABEUU1dR3G56PVaKKU9Zb1dBvTxcnKTMC/4z2HU6GJaIis/wPSM9yffxhE7/HucaJ4olEUdnKWNWEbLPWn6UmeKzSnK6TDw2g6NEZNHSb2VHCWaf6jofzFOYxwkry3mk+HC8FE5Tds/66wQSbPRciXQYGLe0LYEgdg+0cbrmaCAhkCGUcZCuvcqQK1VmpknqRNDCaFOdPXVo1P+M5Sb35eoxMBHDxW4CH+5TAGw76NLnQhkDAvFvrngPl5531GRmllCZNq/Gpz0+lWGHADThQIpa0ww/56xmEj41H3z0IAtawmuzCLuW7rqkyzpnz2lX7C/Jqc3XWfRVi2BLOv6Vz849oUnV1GoHmG/BczrPtNBJVzmMq5dI59vT1j0v1u0AiZJULKOkpiceDXuzCHoLQc2qUV8LJ+UzPr82moLzNffP/hhTReGEune45FR+crC/hLznJOEIYAx9wmB2X/zsABg7R/1/4LPXKlPQJvw3zLCKg6bwIJN8lcEA5u2VDBXBeS6mT60fTF0OKMtgyC+NEuocoXwEaBODWKzqWF6xFO+c3h19JY11BaJgre/ZVJkkfOpw7yK+gwX6mQE71Tx//s6CjJitCoURHtwkStLIC1w99IZIH6P6KhKflXqqpZmo60+FJggiBysQiH1/hNuam+TuUyzFHZMOLkbII5uo+0s4p5Ul9rT5hSmH2mBCHQ01QiIMVa5Ka5X5mOhJ0itPB/AsCHz5TY6SmLiFyEaQe2INs91uMz9RLXnR77DF3bqaqG65mJZMPFX+tXHe8nFqdDS+Y4e0kG3NQDUVLWH429wfQG2cU2bcX88jGOodbb2OcQj+sgfOfVZ+K5bUbjdf0azEsSzCHnITfh2eb2jUvWGwSf25p+ScBsVxxH436QiNdcZopf5juraGElmDaLz2S6ruya5Ot2RcavFUZLjZfmpHEfFYUwgfMyh56sipS5rUjeLfIyyfhZ005zYRv+5nniaIXWdrt2n3RNzWxFrQ43bt/zJ9Wwt9+dV+GKpkurhKZWy6L0XZMkCU7nWabb+9wT7UOFdL86k/7sne+lo1fG0nNHz6Sjo+Opt7c/hDHmlZmYnkzXbl5Ln974JN0jjVln15nUNruczjffT2e6y+nk+lR6uPIoTQBb5mF4qjCf6zBKandnlmbTNOHPZZKES/m6SzT2wRid6jqS2sot6faF27RHhM1Tg6mnD/g0k9Ll9y8lhVgjY6Pp3GvPpUJXZ7r+6fV06cKnaNZX05nzZ9LZ48fSR6uXY2EOdw6nT//uo2TwnRPnxyN/2hAM1fBqb3r/J++mV198OfX0l9JHH32Ujn/1cPreX/xFOnLucGrreZ0APGifesupo7uDoCIkL2YvKsDZcbVicz55Jb0t2zvem40+sxbQNA5G9MlVbCy8+9D19D20M6xrG+eZr1F3Y132XusC732s+Bjn2iKMjRxVfI68VLX9ET/u9ELleT/CTN1z5FjiOitt3bVmQxAGU6olwdoyN8AT+lMX1hTdwDOZ6dAuMYBMY5yNcbum3cPiJtsO7RRwz+Syof3ityUDLgEXV5FcthMwRfQ9golhG5YTK82cd+CD2qVg8pg7mUcFO9E+n5dh4troTxZoR59MEj/LHHGPQptlzP68d0mrjGI5tEYybT+59w4BkLQAaU3X5u6E9YcsVosh4g/Kvp6Bln9G2dczcDD4L9wMiDTmiNAkc+SfEqdWJJJSduY2WUBKulT1O1Cf/9cqt9K91Yc4hvemSTRLU1NT3IkNNSZNUQIhgACpxyg+98oP0/TKXLo4dz19OnMF4i8DsiGxArjrq9GMVNu8RJ2o5ltwJl8xUAQSrAqMjbhZYKukbL3ZdpCAotZXyip60blXYK8TqYSOxVelcH7qQ5ekPTTVp7XOlnSvFbkcDGCJ5/XP6MUWewjmqod2lUT2MQdDEDdFJJpTJriDoOlGY2EfRJp5G7azXQlcyEutK/SDAsISKUoQaOv9xTM3yCS1mv/stYi4cyJwr8/sdJ+mObMVCEyITIkQiZ1OCM8OHakhRltgmjVT0XSxFfOxFtb5Seu0U1s7XVdS/SQt3pZn2YQSOXoW5XPh88G4sN/t37YEW60Snx3A1NTQ29npyxh+NUa30C7oy7PT/Lr/21grhRBLSM49DfY/DgbffM5/ZXzdKpw/73dvZmPMfuPS4wUBSRBl7m8l0/kmf/zOx65kZzKlhxBRt2FEHo9K9tgjz+SCo1FL4d7VVC5M2AAG9SbFNtTM2W/rA6b0t6YHSyTFvnE5XbpyJU08fJQePnqQ3vnk3fTjD3+WPpm+msqDhDI+AfNT6kv3KifTlekj6eEs+5G1Hik0pcOY7fbCKLWv4bPDDlhj3duAT0YEi+AZ7OF8Tzgvh7tHU3GhPf38b95K/+7/+W6ampxOZ144m0aHhtN3/9W/Tffu3k+lvu70d3/9w3R87EjqIbz7v/zf/hVa/7Y0Ozef3vnpLwgecT6tojC33hIf/s9//n+k9975IL361VdTZ3eBNkbSe3/7y/S//o//Szo8Mp4OjR9Kd+7dS0cPj6e/+Pd/nop9XUTnezkNdrPv2u+TzLg1DXX3BxNdCaZOk017+xkKj0Xeqpj/TIPrOigMM3jB0+wjW3eMmalZ5qejxiRQFvNvF6OfDV3VFE3tVT7v+SjiDAaQzq7IeGhiab40792x8JMMledhFQFihMgGxuu75JhWEMQZpptDHvVEniG0PMvgtVbN2GDcFbwZLW60NBBaH7VcngsFF/ppZYzpZg+ir/n4vMznqB3c2I4GSkZLM0Wjby6Uy9Enj30bTG8Rc9DvdOJny97/uHUsXUfoWAaWFOirwX1kfByuuFzf4mXM6DwTmuzp3yXjqNmuppvCiSom7/o9yiSJmw301EQdkwgWFVrOgzvL6NAGu/rZe4fSscHxNFwafOq13hz9wacv+gwoLzwoBzPwhZoBkZOBGUS2Ct4zhAGkRMquq/tqBAaQwCIKFo7rN5bvBXOkZHFqDi8efI4K2ObLQAA/Q2LWDIFqRCQJNDVMn8xdYU4yjBUhgqnZdoCrPMNDzRASSCuhLdJieT4QTg78teYPMwyI4TJStxbMTILWo9/6F5hMsADxQVW1FrLpBxelCYjIEaRZBUxlqhB0D1swB0Fsh4EWrySThTEaghFqhgEUqNMblWSYLqChwLxK0xGZtr7Onkh+6e/xnzdpw3qzu7z9LMysmi0ZtKxEsj+QaAdEPIPJL39h3h2b8yN58SQiSYQt8SnxICMoixDF+dqyQnsbvkRCGUZ7CgZJZKxEVuJhjrDRrnsgdnnlKLW27PCvoDi2py0SgZqEqrFwL+er7/wYBEJ/qMbimZRIkhHqZYw9JtVk3GperuJofW9Jc7y8psannWfOLe0pZbfIlBVhtjwvapRsOwrDUWsyCdPS39pFZL1uTGJLqRtflXb63NiC488e5Xnz32iGu+cp4bxC/M1xJqtGhvw1F/vunHk+CwhHnGOTU2cmXwxDYpbShgCm7Uh/WhtD8zy3mH754JO0+hBJezeE5FnSA6ANlxCMFAYdl2HIb6flhaPAuBPp6qPDaaz8UXph4Ho63V1NzzUR6gMzuftNvelh+zBMUj+BDAbSZBlNKIFn4ozQJ4nPFhj7r/7mG9nenpkLeLpSIVLh7bvpD/7pH6TX3vxKmuf6jevklWFPGUnya998E+K3Lf2L//lfpPnZudTcna/YWurr7U1XLl1Ot6/cSq/9xmupabk5ffrBx/SBQCRq1SDG/VtRoAXRW8DH5FBpJb3/yx+lS5feY16W0utvvp5OnRgPIdEc/m75HD7N0jnPMkPhY4TflHVY8p7uefvUNeo6StRnTAzoI2rjKmsY9dJmffF3Aw2oyV0nmE99CUaZPuUWENbNzuY72lfuz8zy6p/gM53WP9SUEyEwAN7J7HQRVruXv1aYiiX8Zr3R+qL4RsUdBROTo4mWQYQ5OlwaCsHcI/yC1K7KJG0X4MX9aVthbmtd/DmXebCHjsgvhdkxZ6xiHTBi3qTWTsx2enUiHYJZ+Rhh4VV8hmR6NQXU3Ng+hgCBM7+8wLMxTzzEdYWGc8CHqAem0fkQF5A7OGCv8HkZgeYCFho9pSLaqbb04eTFNNwxkL4z/kYa7RhG8IpmK6xTanNh1Qdl383AAYO075b8yzHgnp5eGCBNEACq+gfADAkc1wGIIgJtpAuYxU1BlPYA/EU0t6aJZENmbSVXfeRGGMBEwAg9AnlzJMg4qdlpR7O0hnp9pQJxBiDVGiorYBkJaDQBEo/zZKhXY9SFDbyR7ZTfrUDQ6TwvgxSPqSEAYCN/o3fQaFzUoVQAr2QM/RN+ONjRax7Iuwkw760spCOYsEyvl3FCJpcMgRuUOJZoYxgGqRnXEqWLgVNFfJisrMDM3Gesi0jYh4pDQWCGsze1ruOfJLG6Tr8iN5OmHjxXwJypF0K2E0Rs3+8tTUMQipoysniVepfpYzvajqwxfvqshfYCSzcQAp+1uic9F3MNIpRBeZL2S4KjzJzr4BwaCaW77ANN03RwDk1GQ4M+gxx2gzDISBReadi9NolpUhD7fA8CRgqGsYucZdxz4rah2r8XX12qmAf2Zk4c2jHnhG0cJfdNyb5lrzLYd0jSrNT2HIkYe/Bpuk5I3SvVCc4Ce5B/OxZ+ypkj75FJk0BUq9RCwlh92nIG3nrU0N3HyXoCXyWJpjECKRzv7MMEtbilFbebfzL8EkxaNe2l2IbM9TSS7QmIrSyAxC7930uln/Meo0MuG7KaM07XNkrsJb47zkIfwhX+8vMawhx+2wxZzE2kBmjvuZjaum5iNlVMd9ByTzV1p1v4X5zDz3G8vSmdxtdxdPkCUvsR7PJOEtxgME3A6C6wDu7hR+STa+9uDe1Qb38vjBAhlDk3mhibT6Yd2GtwhlIvZnvA0dHRkVSAGP3RD36I6XA59WIuNzA8kO40TcQeo0qEVp3pzNkz6fLHF9NXvvZaun7pSoxzFM1RBwKxR/cm0s9/9HZ6BXM7V8IIcp9+8E766+99F2bslXT31t30l9/9y/RP/us/Sj34cpo4Wbhmyffxrnsw7oQhYJ4VZAhz8+eyOmo3fMY3AxqUCB4g7G0Cfq8DW8MMfKM+WvM3/in0isTGStYyTLJxVwye+RK2KcuRUeiC2fCreEEhX2ORsY2gQWiMbEELiA5z9XUCixSA2R5tZW3XmCSaDthHvVG4ZwyGpY8x3Jh/BG6aDz+i2q9b3tyTwki7LvPUggYq94WUsdMkU02QWuBF/We5J84qtTgH7Zy5F7tawb9L6VrzIEISTW0JxAHutuTr4tj1f1zGBB02CZid+Wcu8VzO6nmObb0JmmBJAA3D6XmYR7ApjaBGTFy5uM65MDccfkqtSBwdg8zyQdm/M3DAIO3ftf9CjzyXnkWkBQhOi7BMiZUSetXnpVJXOokZWgdBGb5//a10H3t8kXdXVykd6x1O3WhaoDbCafzKDH4PYqUaPJSoFi8Y8S4Hkl5rI3BDeyeIBUAsAlMzMNOEJLSFUKFIqJdgdGSNNL+T2Qjfbu5TcG3dAl2BdREEdZzkm30wKOZA+hRib8FnafQeyEFn2TDFkkCU2YrOUC/ap8z5XiRB0QQC5CLBOMFT3UjUeyEOlLQOYooHOYXPKuYDElW0bzQxI5t1QQCcKxxKxzv6MbHAuRaE8UvGf2MJgiXa4gU8u4xE2GAVIuLPU0KT82tGOEoNJaplT3OE2jgGCQdDjEcyRO7ymUzLByMMgdQFwd0JAW7/XTt/l5E2UlJZbYpMNZVmTJjkRaaJq3Ld+c6LDFTGNLv+X4zSOGd+l2E04pNnIo+sVz8aCdL7MNoVGXUc/+9gYiiB5LzsVjY0RNzUyqEx7LjEo3Olv4e/q72qL5JzrssMEeZm0W4scn7Od42kfgQKed/tZzMMfvAUrJ97+0k0TxCJ3DgDc3Rp8SEmdlkC0SeNob5vn+9zAIot+8f6HIvzj15rY3yN7QTRHBcDOjT+XPsuo85H/DuaOxfZmWrKWtLDjiOpCfgxQWLOQ8v30xEc44/zubJUwBTuGI4ng/jPTYbJ8QIw6uoMAWNYJ028otBtiWL/ZKIyhpZZ4/oS5k0KihQoSairjXBNhUe2D2BGg7GcXv/Ka+mDjz9K92/cT+/+7JcEmjiDVgzTzBg74aQhZv0cj/D+0XvvAuvUYqymbkKb37l5N1UWiMTYF6cyuiWR737w/D6peK8+MYbOf/LdT6rt8d9jDzHWJteRYdQXGQC7qGanBVisH97G3NbfWPvseGQ68mS24gFLQ7WBKEKTA5NiuoG8GNBA/GUOJ80JZVhM9BrCt9pNthHzzXfhl4zNAqZsml1Gc7XG6u9zrqPfbAs/26GcmVPI0k4fhCEyjO4Vo8hm/kTATtrx7xgm8UeKaI/m59IsQT8UZHpP7ntV6x5VZ5q5CvNZJZw7qDb6WcDE3B1A7wNOZf6YwPZ2GCHgiGPSJN48ir09pARxPWCcNCk1XLhCVgNGSEcclP07A5unZf/OwcHIv5AzIPoS8QV63RiBAFfVuOFtjcLWAfN0rPtYOtl9L31y51KE2h4lO7fMkfcKvKfRBBmtToRlrQJdEWUrgHy9U8DMNSg1gWgXAFPTAM0vDLCgFK1s9B00PwZjaEfSKRNmAr5moui1GrqZPor0LDSBxK8lHYN4HCNPg3berWiFjsHUXIZwMIdESGG5sUdHe/ovk2PkMIM6rCGVtw55uSgiWz4s4shKylykez2JGF+pDyKxuUBGefq+grH7J+U76e7yfJhItMI4nS0MwyANRz1UAYJsSWfRPD1YIYIPWqtgCKg3mnFSPm8R80tIMa9ZpZ+3wsbnQW7WzYDtrn8yfjlyb7zb794pMxSEPiN23f0XhTd/z4gxCcos99Pk0gzzg7appoXLbs5ebbP2dN2H7DcZq4wQyPZc/XP/IT/nRONu89TYPzWkRfamY5VZt45s1rNhOw9TzNEUZobO4sacNla0zXfvVSosIZXXKRHo2fNM1jNS+eNCALfXPdamCy1rgZD6HdyfFwnAdfwrJNJcx61S+/yu7D3rK0ITcgXJHN2F2ZPQf5oxbK1x798cX2jpeEQCExk8f5slm2X2z7MstVCesprNjBOnuDRDPriZ5T6iaF5OzyF2Obr+IM1X0Up1jKS1Qm8wvBWEClvnhN6yCO3hE4q/xyLwCpumRRLVDnYPpI/f/yAtkcvtn/43f5L6BnrTf/ff/vfp9rXbqXR+YAM2SsSPHBtLD6Ym0o/wXbp792769m9/O124eClGvAHz3BlOjPvOcwkxOzeNTypmya9/46upf7AvTa7NhwAL76GA+WoqFIKEKVb9pDbMpTjAcTXekl1rvNrw8B6/xrxtAIrNh5aAKZ4n97t7VkYlP5+bd8EAgEuMvBrnLiRn/mqtYpqMwYgrDMZ7nFeWl1scHH9OXkP7jkyz2gJnb0EGl3/iR/dkFO73HMySRNa5FPfSxcCN0Q/qjDkCmUSfadI6bMfzptCyBcZDYUcRBtQxWmQKQ3vkF+6zlg5M5F/tAA+Ck6839YUJnJ+jXu9rKAG75Iyo0nGofdbMTn+qCrjZCK8tbSSZBnd2F9GkgWO1uBAeqM3s6iqGea7TsoxVivhdLZx+wJryPw1sbOjawdcv+AxsYpEv+EAOur//ZiAH/koV/azUx3eZI4G4AG8dabQ5Zno1vQFJFIuFNFjEWVliiSlrC98FnMqDeEK6LzEFrLWecKQnhHcgCoB7iXCkY0hRi5jsSYAp1TKhns7fSu/0U+jCLj6LVgcBCU1hH5SOBuHDZ224D0FcjsAgreKfZISuJhDRCMzSXOtyujx7PxikVdoQiYh0JK4NRKHvgVJY6zPcbSBE+qX2YhaCdI13TfYOt3SR6wME24R0ENt9EdQYGq4JEE83bR+FiTqKOZJdy14CtUFKcC8MmzbiYj6vPssScxGMSA3pPqPKHYc5VoowrCLZMDFx/UD2OgBnK/14Y665pmK7aTikK9wL/s0jNZ8mLHE2Z/zQMD0NX7c0KGFvLo4lQidLyG3UseWuX98X97QmKYZfNtyvGpvG8ezWmwgygg+QmgAJMAk2iXrH6Xxv7p3dZuXxFkIwwVr6bj3+8xx4fiQMbWuz7s3nbcWcJzfxgSqxD4539rub4wbpOaXC4f8Rm37zucZPtleGab60+CjdINx0aIGfZmIaK9zjd9t1jAUEN4azNry0fhQySfUlO0PZ9nm6ma2v5fHPTkvk/GEO29gba8DLiTaYFUyMRxC9HKneT1dIcN2Cn6Oh5JeICJaXptraSOwa+KYPBuXCRx8HnLp780566R+9EMKj9ffW0/Ur1zGFA7bRoMImIFmcLWGYVgHtEM9vvPFm+uf/w/+Unn/leZLeHsbXVCKV6nhxHUOziPbDa2fPnyWU80w699LZVMQyoIrUvxPTsY5Fzc6AhsDzLIpjNr/z7NFMs5X3/vF3mS73cRDxtUl273lAJOZdq6ct8UztMccRH2Mxa7uZdoLx4IfsLNUa3q4hfgomqYbv4hYrjEnKHrANtWArnk3gufdr8ZDdy83gE+c7zE4ZqVtcwZ4aoiXmqDGKpf0Xz+pnqPVEq1I1HnKuIk8S3/NErUboVNNjH2JdvZ/1Ej63o6WyF4DewGvlmvbIWbB7WNOm0+uT6XjPcLqJtnKm40TgvYj6qnaHU72l0L4wVaijGZ/tiY/tXZUztIB22WJeJgVo5gQTTs1Mm6hAJhC4Thj8wZ4+TDKXItpt30gvzFQmZI2HD1727QwcMEj7dum/2AOXYDXUt4SegH5xEXMnkSMSnwD8MTyIIiRFJnmVGTFT+FBvH+Zt+NxACLTDHJ3sOZlOwsjchzGZwhG5SJQnmZ0ciQpwlX6JbAaKvSSrJF+IiA3ALHNjzqMq/SC+A8xRJlXXTEEJlkk0ZYj0fwisQJ90JB/kPok3Cbpm6moCsJsMcWSxPd1ZJjwp162zFbMXzRA0wcuQG4AfxKNmqxmtkADf7xWI00erC2kArdGR9h4iU4HIeKYJ08JAamimeiFmR5HGnegYTKN8FoFslkxa+ICgAnNE8snQKK91fIyyyUxyuPmU94k487na/GXrp6wt7nQamDOw9cZ8bL3zs30TmWWJenNwtmmnHoTJDtXqRyYxsl0RYcs0RCCP2myFRJe1FPF/lqKEXSL0aYr9ty/PqnhuwkwQE0GDH8gctsJIu8fb0VDuNl+NfXAeOmvhx51LiSrNV6zz8xSn135IyNhXx5/Pw25z4SzNYxZ3Db8nE9YeakODypMbhTO2QSRuXNz8YN0SWvry3cSXSjiwW3ubTz6bT84nkADhC8wqR2Suibjcdd23lTC/CuaxxljQw2dSaMcgNvNomd3zMgeL5IO7tbaQutknQwTGuHb3KhrzobTahp9RNyvSAdxgPx06PByJPtdbSWRN5LFv/cPfSG/99U/TX/3ZX6ax8bF0+OyRVOrvTmfv3krvvvVOWka79MbX3yBM9/H06eLV2DetRKB77sXnUglzp8NHxtI3f/tb6fwL5wkiUEqnz55KQ2OHMIXqJTy4jFAhnT53OnWhiTp/5hg57CbTT37wk9CSvPzaS6l66jAgBtNq9oD7Jts7NQYk5stJ3X7eFEKVIaY7GJeaTO9yD6j5kIGtoMnQjFpmIuAAN3imouTv2bfsUv6ZWwJs8GJ/XGeFXj6iQKdWQ373E99t2zNrBbYvIy18Fk7DZoQwYEVhV40hFDdpiueAoi0ZCf7F3NgxLka/GKO5+sIfkHo9g2HWyL0dMO6Bc7hTJtX7FVjE+J2ohuIaOEaDKsgc6U9YawgYsRzzbNhui3WtAFtbmftXumC2kGZeSYNpBYGjPrTekUUPjNs3XlwvzZz93eAf4v7oE9MQ5xcNqf6P/Ex7FfZFc+oFx5cQAMxgXjcLc204fCNndjE/V2ZvpNO9J9Kp7qMEBzFn4TYD22j94MOXfQZyiuLLPs6D8X3JZkBmSEAokqiQUHUBYKdWRUAowPa6DNQi5mIT81Pp1uKDVOoupVEkRYEIQFAjxdF0pDSeyvPldAag+M7yx2iJiuGATBXBfCkV868TQN2D345Rh0JGDiJZMbpVGXU9ts9tSL1L3CMw1gTJiEUGP1AHVF7D7h5GrRmGZRV4Ow2SPdSJlgcEso6dvyVCqsJsHSZct2GM9SGyrmaYJDVVIqpuEE2GZSWUMsAtgTILUvHbOWy1+yDqV2tRJQwGYTI+NUIl2nqhcxQNEkgy7q61y/POWwUm6iHaEZ1XRX7eYpJH+K9gaNpg4mRELPEkCAweEUYMEwnn/Ukl7mHmw05G7ZeI/HMWkJdzXEQblyPuvdboHgltB+8SCvXF7yJzfY8kioIQYF6UnmZzV3/33j+La61vL8X+Gd3JdyOQSVBZPg/CzogQkijDTEsA+d2xyoRoahh5kPbSubp7rMMiQS1D6Xed4/Prdbc+8aM1uSYyoprUGTVN88d8ffZSpys5AYNzXY0idXSzhlS3ARMUeNS6vG1/XOMp2jX63q+zOH9qOoRbJvwsrz1uUuQ8dLIvGVporncywfpM/WZaJChnCdQgIVwiMqCwZqZjPN3EN6j50eW09AizYMI7P5okWAOJNDtP9HEmltPxl09pyEYy7kfp8sS1dPzkkfQfH/0DgjMspSLhuu8vT6W7cxPpW7/37fSN8jcZJ759hAB/uDhBJDvSEkC4lgkK8fX/9Fvs9Za00LaU/ui/+s+CEbm+cj+d/+1XwqRZreLr//iNtFxcT6/+o6/JBqSHa9Pp6//Jt9NXZl4HTkPclzrTrYWHaNQJr+9Cc37ijfEpuFLj8aQzrLbCudXcTTiuKTXhWgLGC6+bUHNYj+e5lcXQ37CqkxswItqq22Ce107whnXYf79bryaqzvMaAHbK/HXMQZgu1BbPve56P77nabRWv2dFRk0YYfFer63BUIQPDe92Sb9ZhWoFglpQZfRBzYljiDNXq886ok72onggcrVxXhR+iN9knCy2Z0Q5Lkd5rJ+0IXMUJnUwGTF/NYbKZ8UZWl44zxavqYUyOMIRsqmd7h9Mt2Fc7rc/z/yyplhTuNYKKbcUOh8+UwooOTeGxGeS41qB7zKFLtISmnvHJQ513ONdh9K5sRMknF1IP776drpLUmKDOnSzV012WyHUfUt7xnBuae/gy76bgQMGad8t+ZdjwEaXy4qmdWhcmgCw+A3M4tS5Ng8wBOgalWamPEsC2Jtpcn0W5qgfHwWIOID/UGEkneg5EUBeZmsUf5yB0h0Q40okaQWiBgIxelIRE48uGAvN2wSwy7QlyVpAY9PX1RN2yxKxfZjJdXFtmaAIkakdbKSEa3VpLYCxxIJSvol1CTBsnUEiQfAC6CVORJCDMFkzAPJ7ZLmvwAB2gpN8ZgkNmPJQOsVtOckYjzDWtXS6M2OO+DmILF4C4fjdIpPXwxhEov6TuQwESJsSy9OYIjzEn0qEEs+A5NpoXHpSfqkD7YLar3iW1xWYsAqS1BzJZa3s8VVmCWbx85QgPDB/lNDIzbGetj6RroizsYjcDTEtwRrjhYHQvE7pMdPz1MU6XLF2GFal2o8RFNvUqGa0DKHufpSpkmGQSJGA9l9eYie4Rvx7YmEvGJBCTY/358/4pJo0CaH82hPr2uEGtVBGWqvskvNoh0dpOx+H+zxjJu3Pdmu0Ux1ed0XvoPHQ1O40Jrat+tlQeQgVaudhu+dtX23sgiY77IvPOxfbtbHdNfeHJlCusW265sH8OAkNxd/zHDD6tCk9l8DM91jD7Xv+6vMWowXOLGXJr2V414B5jzpG0S5NYcLblcZHhpncScwAEzlixvCPLATMVXIvwd0G0f/hw4vALWEHEcEmCG9PiPcC5m6egh6CQDjP92YJ/gCRrEZM/8qPpi9ljBkR0s6uH+PeIk731XSBPHSLnDtWjz81C+yHqeybh9HzaMQ6tQsufHVK4ruSwV3ObVVCn/fQ2Esg5wCR2nYrzqmwTbjs+Qs4zQP6t/QRXKcLM8Op1TnODRoM7hPOZxocOsFU+rzvJoce6xolKwQCFhhGo/sVuovkqetKNy/fjEh+zZ0Q9fi7qWlZWVd7k4fq1q8yYwo8m9YZZ99xMx3rhHZb1W7cGeVaMHYws1X+bFzz184iDB44rJ2zII4aINpjkXWlhTSBplVtWQiXqFumSn/aMtYY5gsKU0aEZP4zUlyYtzEm99yiUeJCelabRa7bx6x/gvcseIRaK/csP4N3wckwVmoq8zPtvlPLVV3ESoK+fLW4zFq2pA+WMW3HVL6ftS0wL5q6eiaiUJlz4T6S+RH/KQyMC1y0bqff380NqGbT/jq+4e7B9K2R10mD0YeibS11rnWk71/9cZpZxWeNST3eN5qOloZTq6HVG/ixrPGD1/00AwcM0n5a7S/RWHWuFHkB33Aqhbgn7OyDhUeozGfTfGUxzIeWkeqtYOzeUexI4wDGYUzkAKeE5C4StOFkSLZkjgScQ8XhdKjan65N3E0rAGuLSLGJREcSJAJ8gfIMBMQ8QLkXCetyGf8NiICeUk9oUZrw+ymRP8GQ3TIPEgz6EthX7aSbyCnUXmyFeDS3ShUiQwK8VoD9nUFEYEqANLW5im8H4xPId8DcrCwT5pvBVokqF8lFQSIqY8yRYnLODggNkYIVatJnRvKc6OGWkK6K0NRUmTBvkRwQIpY2nKqnIGYvle+nWTRdYBcQlrmbJNiQePLOp5AGen9mnoW/lZojkJbIb++Fe72dej9PkWjohDEygtZnZY5s3/mNCasbg0Rqkf2hxNh58J/5VCYXCV8NU1l3656G4Bo4R+30VaScR2Tb7WERfIW10EzS4jxrDifxISHtX16suxNTTvu9W7EfEt7W01jcNmoZ1yAkcoKs8Z69fnc91L5tFwZ8tzoch+PSvEwiNBjgmtTdcNFx1pmXvRS3mAIIQ4wbtOFwW2+ck5zI3a4On3Ee5mhrQW3Ar7k4785dnCc784Si9tmgMJ5RA7vI4GZE4x4ebqjbNoM5A1BI6Hu2/ZNBUtCzhE9j9cgL6eGlO+nGL76fThVm07deOgGD05XevUi455nJMG/qHehLJ4+OERlPLTkEJ2S4+67UUUrD+ISZKFviX+2xDIsEvdoX/a7UFKAnByYXUoXoeD//u7fIhfSVgLMy2wtLZfpWI5Dpv2tVQLOgIEOGqIxpsOdVGLcGYIzkpRD59c80DHtPX4WpOvpLnOdnzFXSfPphdQqTTlIxoHl3j+q/EzCJmiX6SzBBx3uOprsf3UofvfNhmjVXFGG1v/0b306D555L3/2/v5ve/M0308grJMEl19Q6WgsZrunqXKSQcF5cA6GlASbEZwpJ/NPncoVABgsEQinCVJqAulytEJgH7TfhsSMSn3kC1VJxtlcQ6vV0wOCS4+fh9UdpbGQIXNSGyeQc5w7LBqK1zi4jlMPioh8GsF0/LuZ3jeAmjwh+IoMk8FP7tcB8u64WNbIyPvHVN+bfebI/ao5iN3JdGLbIHFUQbObP+rzzu0TUwSrtH8H36Ln+/nRzfibdbT9KXqISzC8JbAOxbe7rYMzYOzwSaTiMZBuwESZ9Q+hIKzJyYWmC9cYSc6NFyVwbEWdJ4REN0/fjPWPpt468kX4x+RH9RkBZ6Eu9HTBPrC/VZ/23owdlX87A7lh1X07JwaD/vs+AUsCf3H+XSEvTaY78B+bp0V78xtx94F7GGIAmwyHzcKkfzVA32pdWotWVQWCF9MrQmfCdcJwCUOHvACZvaoQWiNIToFjmSM4i+xJSzuvTDyLEaQng31ohRCqMRhFpoETFItnh20jOOjw8nE6AGAN4gxAuPCCz/QoSV3w1WrSvy4sELe2K1NXGaArXQixw5daaigRiC/IcWI2ZHXwVdZC0kPGB9yNEaUjUqFLCEhSe9ZXv1iX3FN3ne/hRQYAtwfhVKhDeIAr7PE9Fd5bupYfrRPGDkVtZhCEDSbSSeFKkqQ9T1AOTaYABmYWQ1tGehIDrECRrbc75NeYylw7mQ81uoh/2hX4oyfxsRdM3fbswT2S9LfXI1vpjUpnDwKl+3aHYR5F2PRKU6JQ5SuRBFaFKVMyTEHgW6aLMRbYXdqhwm8v2TWJKU70hCKASBEo0uM29+SWJXAk+iUKfl3j1n8XvmsL5V18cSwl/GyXYOxXv0WRNgjGvr/5e19YxKomtn9P6e/b0mS5ESF1MkZCrQwhna21o+dysr7Ee+yPR18W5qWfQvC6BaH0RbRDtl3W4bk8qzoTCjE8wrW3mLByGOd15dqxNn0DM6yC0PQu/zuKY2zjbnuNsz2Bux15sRuDiuuxUMiZSP7k29kumTYqz56beY7HNHoQ9mtSpIXd+LTIz+T5wT3b0EKDmK2dS29zt9BLzdOJQKf1/711PP/7rd9KpU8dT35Hx9NYPfpoGhgbSH/4Xf0xC7sl0+/ZdfEI70uHxsVQioubszHT4bM5MTBOSuzd1Et2uDyJ4fWE1Td2bDKHM6eETaQbt0qVPL6aB0UHuIeLm0PFU7V9JNxfuhClaaNfok9HJ1gk8I/GuVcASYZtlsjRb2724E550T1aDVQmv0LnX1qYJgVyFxLkzwM95ovsRXp7z6ryvLQEzyJ+jNktzsKN9h9P9T+6kP/83f45P1bfTmRfPpAvvfpp+8L2/Tf3gJcORm0ZijHQLVy9fTdeu3oixPP/q86lnvCfdvHor3bhyAxxVScfOnEzPP/daunbparp16w7tAauIvjY6fjQdGhpOFz64kA5196ZXjz2frl+4moYGh4LZ/PCDD9PDByRcPTSUzr5+Pv3y7ffSv/7f/zV5o15Nf/wnf5x6Uim9//a7aXp2Nh07fSx946XfSR99+DFM1H002AvpK9/6arrYei00TTKzCzVGNJ9fmXrTSBgiO0zeEebJGOlzFNo+5kXmrsIcGRp8awF/sIYK9NqATd/sJvIhObk+WC2lwYEjqR94KcNoWPH6sytcEDIuu+epO/ZpDaWIX9rog4yc9S6C4yoIKDU7F1/dnL6drk3fTKfWjkUtiwhTD2Ga/p1DX0/l1nkSD5McGQGNzJSCU8N87yZY2Tqeg29fthk4YJC+bCu6D8YjQPzFww8idO/gQH96vvc0QFlJIgk6kebp+FkiO/g4uY560coorbxH1m8dMV878goAcThMCJoJiCAQ1JG0U2kbdwbDBKEpQA6gzIvvSjsXkCQaUpZU9DA2msUo9UbTAPDtbe1OJ7rH0ygJMtX4JCThJqIjgGgQ62p6msmTpNmWdKx/wOvMHIJ30bXtKBUurMHOoTGqwujAygTy1Uyonfa8Ly8SuwJ+AlVTF2YGIYGGJKdyzSaUAFqnWiOd543wZN4LNU+PQHRK2Emdi2aLvnG/CK0ZW/VIDAuxlPVIzQPmDTAL9tei1LoDRpPuBNJxPTLTFT4xL2o/thLxSnY1i6FvjgFi5rMwSY7LpLntNVt4HaQcH9XRN4i7KkhzBck6REob+S6y/tvjx4uEZ710WSK1A6lh8wpybxhJ/b7mWpDkwqhIdH2W4i6S4egnNHIXvm1bFq+hwkD6En1oeJaYPwmubBduvbHxmt+zf1vva/zmesgANT6f3ycRnDGM9Tss//Xp3t1LasoybzdWiCrbiWIC6xGaicbanPtOpOX1zFH9Pa67WiV/rxI9Teaxfu3q763/7N6YxjTyRssUDGRH6ufc7jY6mX99kDS93Gme6ut/Fp+dK8cWWjNajcKb14Mw263D3Gw/1b4UMflyfkLbsQcGMtqhbs+8SVE1+YpC8JedmhTeNRGkpkpyWaQn3L6Senq708uvv5pe5W9ycjLdunYzlR/Mpg9+/m5agDCdncOv8ZXX0ksvv5x++O//NjRIwop5BEq//09+H+17X/qrH3w/fEgXMUGrPiino4ePpsX5RZLAfswccJ6Bz7/9+7+TVksj6X4ZKwF83ILZdr34079TQZPFfSxwrc1kXHvsZQXtAGagTYR0fmKhIn2mJLid7diHsv3CQGB8lcS6VRkoYKz7Zl34Sl9WYJI0UbtA0tvevt505Lmjqdy1lJ5/84U0ODSIPyyBcjCPK4Kfbn16M739k7eSGribd6+n1cpq+ta3v5GufHApzBDVPN26ciudHT2RPnz7w3Tx4sX02suvpZtc631wHxO6r6W/+H+/l8YOj6Tf/aPfS2/97VvpW9/8ZrpHaodb12+CU9oJm/4jNNgkRl8gJYXmZprhYfr91vd/nB7NTGFl0Zn+5rs/SK+cfiG996N30p17t9MLL7/IGAzO0IZ1AekswCEK1upL7FEuyBxZwqwPvOP+1bRxEaaqDIMXu6puUVynWDOXC3PM8ZU76VTvAHga/8XuF2Gcuzjn4nOZUIMrZHOeVyFbFBHwYLCy3E7gPNanxF62h/PQAa5RD3SA4HuVuuyT+30Kzd/6OppOvrtd7IdWIkOlo0EHhE8ugkRpgYM8SLGs+/blgEHat0v/xR24QNJkrQY9ON9/Kr02cA7E1QWRUEofP7iYPpm/AlLqxt66K2yeFwDSSpZeGTqXzuJ3FMgBwLgEQlZSZOI6behLzSAQvpu8MIqIlj+L9yRNr1ohYDF1KAKIJfo00+ptKaWT/eOo5/shVmSIMHeBwK5W0LoAfKMGXpR06pirOYaQuQXTiDaDMCDFapLYj4g/LWmIehdhkohUG7bidqdf0yMQVaazoV/c2wpTN4tW7AZOvitI6Fsg7u05XhdomxgP/epCMt2EiUU4qtIXieC7mGXcBEnMNJHTgnpEPg6zqQsiK5i7zXHH4H0RkdW+6BhLTvJwPjbXkL5JEirxj3cRktEDJTizAuPl05oFymzRHxPpPl1hvLTVwniqS86D6wehg5R9aQkzjBUJxCpzSjSirnn8Tuhv3uHHGgJdixkpklL+M/xsG/b/q2jRpAGUii40QYjvgdjciaSUYO0mgITSedvYrnjdNZUJVctiUAKJkJ3uf6wOqlWbFsg+ZuWxO2KsOQO0U72OQabD+/I9/3hN21/JxpDNZ36H/dko9FFDzWJTF+PKTAezfewaZRq2dtb1SUWtiv2M6HsQ5zuNpb4ee/UAH5gS56cDkyIDN8TSb7McMvASVduNp77OZ/HZNhyPBLeEtu3WF/eOQo697D+fc77DiZ4zp19Jtofqa9z+s/eZA06TVdMTuB5OTX4+6p+KPURfK5yTJSYxiM2JyfT2T99Ot2/cSteuXEsnjh1jZQwAspaGDxGq+eat9NZPf56OoGH69KNP07nz59IrRJr703/5f6UHtx6kubm5dBOm6mu/9QZmv+U08WgyjfTj50Q/RohmNzI8kv7tn/4bot59NRVOZMKRdpJ/u1dzIUJozewoHX/y3kXTsTScmtsngUf6XLpDttkMtfoMAqN1glHXbMd2Zf7V2mmGbEAemQId/tWSuF7CwWUEVwrkZBLNqyPOeIAp4pm+E+n1NwkogTWzrQr3f/qjn6Sbt25GxD9n/92fvwMD9HLq7kErjD+YOOnDdz5I09PTaR5m6cixo5Ef6hM0Pb9495dhxbBIzp4bV6+lKxcvp9mp6dTXjdk3eKhIsvROUls8evAoXb9+I33tG2+k48ePxfsc4a1/RNsnz59Oh4gI+P3v/hV1XE9zk3Pp1HNn0le+8zr+sjOYF5MbD+HgbsF4TLpqMAjNHtX4ihcz5oiceuwxcUw+zbGPmMdgXJiEDoIcvdyFPxCM0oP1Q+QxG05z4Gy1dNPgKudcQZP+m7Es7A1N15eZX9ckc2fNmJwwo4cZml6YDr+jIj7C/UQ/LLJObeBwhQnd+GR1Foz1qr8XAU/wuQpmjTPUbN+5qI+zwtODsr9n4IBB2t/r/4UcvUjkt05+A2fiyfTqwFkYIXIYLK6m461jKXWvpsuT15CKtqdJgOtMeS6NdY+mc/0nCcpwBISGFBpkJfATCKp5aQPRyUAVm7GFh0gKbiCH5n6TaOR6u0yJwBmAjVcRTFoHkeWK6Ryhwoc7+iEKlEZpKicjANHCu0yNxRCkXTidqn2BBk+zEBHHMLtqL+i8i0QUKdk6QSY0p4CbIfcIJi6YFxFsmJwjhgbHRC+IqECrQQjY9zmQ5/VV/GMwQ5CWb4UJa4fJacOcrw3E1k9S2LF1TNIYgSZ1d9dmCCU+lxaRfLa2wwqCFIKoQDoswZORR9HlHV+UAEukDkDwDqM5K8FcROQtGKdFri/SX5P0LiBxjLmjy+v0ieox/0PuXEXqx1g0Jdx7yTQcC8xNeWY4Lcz0EZ4VKaw8WAt2+MUKUYiIOlUog6gzaeFOjIuYWoJSRO44zJVUQCPGVDOHVLiV1n9iF0Nbt575a+jbG75eVKJZp+ZLsW7b1JkzJTJGBk7I8p9oArf34r50T+9WrC9b2d1rjjxB9Ns69zoJjiEIVRY3mGCe3m7ebV+GIPwS6IZCAp8IBoF9zpco9fuvvh6vS3gGoeom2mOxWpM431pCi0Q7xwoDrIrnlPOpCnSjcG4ZQ0eNMdGHpb4vG7c9gw/WG1ES0VhKaG9H1HvNAAZNEJr187Bb89arJNwjoSYpF1DsOA6GL2Fo1EGjoZk3KAQFrJN7Ku+XZ9gSK8tZWcK8axmNCUco4NbUxFS6f/deJIV94fd+F2GS/htorZHCK4FfJFLdMkSnCTmff+l8ev3119MP/+qHEP7VdBlTurFjY+nsy2fJi4R2aprIhdPka4PAP//i+XTy9Anu/ZsQqjQDWy0y00sEcFivN1muX8q4a4cX/E/WljC3bGXMaDR32+fuZ82thIuOXubHICcS0J04Wsk4FfUTYs41OX44jz4ek7vYzDJePFYoEBUV02z7PNp9CA11U/rlW79MJ8aPcR++pZjYPXrwMLox8WiCcRMpcHhUIJIe3H2gtIs8UAjHwGccNHALuGBkkEh+a2mU8OmVn/5devvHb6fnXj7P/XfTL3/yDoxVT+rr7U8XLl9K05gzjsAQ2I8V1lo8JCPTXSqlWczqlvSvAofMzcynl994JZiyVjiOscOHMTlbThemrwaj4dnLS+zHGjyLz/wkTtDvqRNNrWdHfyg1VZFTj31Sv4eDGeEIe4oLKwvp+abp9ALpN+bBfTOdJzFzXYIpm2Nfggt50hKmtZz7fC9bh3W6NRUuRHRUPpvwfA08ZMhwNXk+3g7j5RqZC3EM5utIaRSrD6xHMOdrh6HT7NyS7fNsrePCwcu+n4EDBmnfb4Ev3gSIuL8x9hoM0nQawnRpdaMmdZ8AAEAASURBVI3ABzrxgrjU0rQC9Aq8r2PSdpx8Bi8NP0942kPBDMgYKZHLJURBiFBftYI/ESStktQyEtWcdhJoanajBExCWKKlkx+XaAtdSDqGnfkRHD1FBNYr0yJWazI4BAijCIFcBDkVMGEogJiWMEUInyMN+uh7G3W2AriXIVIWF+chJjBDMtqRSJG2piCeDT2q/5HF6gOQ88FIfQsglXkkYExCEDTQLkQ2IkQypjJQAvjPlEEEy0kvrMtLOFTD2LWQc8RklEGASeUwfmkAkY//HIP5ekwG6nVN96gNpJNLbUXtKY0ztnEYJH08ViEkDI28hK9VGfOVa5iPiKSMimWJ0OFUEpoDtUswjzKQUXHc8eQXCfElAnIsIdWsrPRg6gOhUpokKtRDCItZfMA0vNAcUqJm9wAOEutGwGuFYIp8HY4RtVNLB6YhziUmjWoSNbjaqYig2RGpSALN7vXMB8i1CTMU5w3G2xC/241RqWjOGPmeI3zn/6mLVMJuhUXMtBUQLzCEGSGw/QOOac+FW3PfIGSzIeUNwtoxuKeoqHE8niMyskR/JMplFDyD/vNEaaK5xt6xvvy6fZI4NfBDRQ0bxFpjvbv12X4YfOEGJqWG/R7ivDEJ0bv8Ob8F08zZMYnpr6o4PwbsUBrumtSX+jGxK4E3zsHu61X/vJ8dg5ogN10EUpGQZKz+q69/4zkmx3M9uzSLQANtBwybPnMSlDJLCniEe66nc7ZOn1dCQwAgQorf39eT3vzGm7H2P/vJTzCVK6dbN2+nyxevYib2rTSDNuMhvjaWvP1NU0/2JcRrxYAxnGVie6K9mOJM1syQ2Qv1z8UXXtRyt66RAJz9IOGe15v/vuO7GwGN/TrBJRJasK074PGnJPrVeKMqijbica45r8KiFU2hYVjQPRMAgaA9CKCq4avJHmbe9dk5fvZYuoyZ3Z3Lt9LJ506lT9//OH367idp6A/+kLqJ+obQ7RA+WrfRII2fOBZ+qId6htLU9FT64N0P0m/8R78JnETgxL3ClTXwh5ocAxINEg5bxunTDy+k3/7d7wADu9K/+9M/S//4938vIpD+HLO9vmHy3o2N0E9NtrO9ZO6+RzBjR48cSX1oVwaG+tKZF86GueTICLiMMa6BJ40yaPhx905eHLfmhHGtdtngNTIaHQT8MaBCBcaoAnOjsDDbN0y3nznvMYdsHbFkH4K9V1rL6dWizOda+nh1IN1huqcIuKQgxPPvrsnbyvdx9EUERJ1aUsTO4k1YbUTEWZjUFU0d+Wc48VYYtgIM7UDzYDrSeZRorvi9MZfLzKPrlLUTtca6BmPH9UatbnbHwet+moGtEHo/jfxgrF/oGWhBVN/f2otkSaI9G4rIStK9n6hyx0uHkRj1p27M5kpoOpZBCoaslTGKyDY8Z1FKWF1C4oUk6w75MywBl+NTgN4IS+o18wAFMAXQDxR60qmeY+kYfkciqfCLsC8AVruzRHsC2n4St748+lyEGhXZlJcnUxO+T32YAzZ5L8SgxPI64ZEJQYQ2qxuJHhIt2pvjegXzA82D1GzJABqAQUTBozwHSkCjsk675uNoIUqeUvGQ5NNhc0MYHvUWuUIk9m/ij2GkvGEQmYRp6Aq4L/uXjdXea29vFDxzH3WGhDtzFtch2SLi8b55iE4ZMj+vIQltxdxNhg+2L5U1UYNRWqEuXh1ORpM6OfyFSQYarC2TbeVPKjB7hb67SEEJsVtFets1gzQYSSUNEOAvyjJzBk6E0Kut1w51yiB2wNBF57hH/6gmoky1YC5CM1wWC+9cnDfNGbvWiagHweW4ovBugAsZ0Xrkm9ck8pf4UHsVBAcPbq5Cftfe3l0J5/9JJQtdToQwpO5qbySCPm+xbRkuTYskzA0qoCmMTKP//C+j4/w6DxL9fg5hA9fdE/beM4MOLbS6wSTRN+/JmS77GcyRvllu/M9YZvBdmsEZvB9iyTPiFHiu8+K1Dk15YAyWyMkShFmcj/yOz/7u+soQRdCJ0Eps7i3bUSjhOso0WpwvP9V1L67v9uIT1qXGssC+DtNXYIQMkDBGIjTGvE0l2RmGwCdpsAIi11ENqykOSuRmkymJPYqgpoLwoRICBCLUYcLVN9hP4tZTmIndSBcuXkB7QeoDhEX37z8I0y4DvEiQqrHOTRg1T5Pvevn1l9MPfvA36WcEeCjPLSJM6kwvPvdCao/cPcA0Vsr8Nu6HfDLydYpQ1LX52mZIj19yyxtQgDEy2ZQnz67CsWZgWK5RCy07ayOTJyPfjK/oMvVpnuscquFZR+DhPN+df5DOksj2xVfPp8sfXkr3rt1Nk5gknj5zOvURzGIEn6EiTM03f/Mb6a+/BwN/+ZoigtT5Ykc6MnYkHTk6nq5dvBam5MXerhC4DBFmvYcAF5riLgOkTsB0LSPcGzsynvoGBtP7v3gvnSCgQ3OhOZ0iqe7tGzfT+z9/n1rRlgD3FdaNjo+mjz76OD135rn0jd/4Zrpx+2a68OEnmGIbGrw5DY+OkLC3u3ZO0XLZK/aOjBlvfHYiZUwN660wgz4j0GvBAmKZZOtrwM9Wb+QO9DnABj7yTDzmc3zohRl+rXOF3H3N6T4w6dNqV7pFtMlZhIT2VdgtTOELYzWCX4ZDqClK4EDqcZ9GVDuuykDOwpjpmyTj7Z5fQHjYy/59rv94OlIYQyiG1QHtOQJLMF1Zx+gtsBHGat4+QFR0dcFIH5R9PQMt/4yyr2fgYPBfyBnQFE2AvQZlLJEp4u0EuTa3mWuDXBo9xyFcSzAQSJ5B0DJGIm3NCdQQSEiY5NAwp3fmHqZPpq6kDycuYEuOXTqAMv4D2TswozM/hQS4bYiwR7uG0qtDL4Q/UzdaFEsQedStL5P3hakcUNgQrEoE+wkdqt9SRKSDQBtq609F/ahABsvkOAqpnZweSGFN5EvfplsxWcMMoIAkuRdiZRlGTjMoJXOaHMiAPUTuOtW8hOlE1q5tC9wDJ3GvWGkJp+TJmTHyZgylQ13tabCnPZLoKcWOP5ggEaPMlU8aEUvGTROSnMkQqcX1mJ1M4rcAklZarfN7IEGYgkz7kvlsTUOQrovkqDXMfRhe+CDBfAVDBUO3W7AGEVYgSSd4o3gVIrudMXfOI0HMzS6CfOO3bD8wS+Gz1Cil36im9iEjRK0xK/GdLq+iRlgkX5WIebsShCirV4Q56k761tSQrgQbe7ClAHnPn/XlRWSsxsVocu49923e6/yep32PuYDwlkHebOnxWmwnzCl5D1O+aHvrff7enhMmW3/a9tuGyRFMuEUSX2Jc4jE3F9Sc1TGHBghmSqIliEuILq95n8KFIPggLDNCPiPo6+uQmcwIs2278sSL+dz0k2esHyJJLVEwxHXr4z1qOtWYuu/8rJY2+xcg4YntbHeDc69AwhDWmhQ27mnno+Ke0MySz3lAjWydsrndrt76axnDW2O0Za74k6kQdhmdUQJf4j7Gwpi2LUyAc+CvEpuazYbWAXOx0CrTN+tR8KL2tattIPX2DKb+0b5U6O+OfDuGd37xpReBzUSAJHl3P4EHTpw8ns6cJQIeBPr4scMRmU7zOhmE42eOA1hJSIuZnufhRQIDHD48Gv6Vh72XFA3WdeQ4gRvw/5xHkOVYhXMR+p1+2t98fTfH9fiV+A14mpYRTrVWCA5gxNKMkN98busn21KbnpnAZkymZtLiAds1EIH9Vvg1j0m362dxzdV2tmDSduL4iczZH9xw/NzxdOq106kdf88e/H76RwZS11Ap9Q7CVDKWbuZx8DiBfgYLqWcYn1YYybHjh4mAdxYm6HAqDXanbjQ+s03zYcI8OjSSTp45lToGEBaVOuKe/iMDaWJ1Ng2ODUe4bZPynub5wyTwLfQRYW6oJwIb9B/uS0NHD4Uwxz4fO3sydQ/3xj2DhAFfaCbJOlYa7gU1fObiK63NpdPNM+kIqSiOYtp8tGkhHWlZ5PNiGiV333jCR4prR3n2GIKrk6zZSX47wWe/nwJen8R073wHa4q2/iq86s/Q6N1qGSA5cibukSE2ouWGJpQ5df9tKUy+2rT8DLsfFOhlVhHgDfa9uN5E8UMdA+kbo1+JPevu9t68CFO0KvFdLZjM1tTidAi+9AGTATso+3cGoHvYGQflYAa+YDOwgFOqRWDnn4yJwCwIKYiNtSp5HRYMkpARGLHNwZkmgZxbmSXnwzz5KxbS1Mp0msbeeRpHbiO9BWFEvQJefWQM491tBDKICyWX2lj/g7FvoD06GkSI9fonEp+ZmQmTi05svr3WhhTLvgXRrRQOAqgM0C4TvAFMmvqRCrbAiCwRXAGeLYqmARUi+cwu3E83W2axBMGpFOboZFN3aIsMXboMsycinkdTcpHcEZoPIY+Fa2hC26V/lVolpWtUiUnJ7PSptDh1Ko2OPEjHRsgNU1Aai6MzSCcj/qiTvi1AqJpQz3wVVqddfRfjLdD+ID469yqzaZLQtlXGKh9g9Sc6h9MbzEUUIMkSahyJhiZCll8nTOwt5lpJr5HttHdXs7bMujifHSQx1I/LthqLxKkO0hLt9jOIadZSYmSvxciGXRDET10Yh4ThPTSK85g+bts/LmIEmQbXyG1UM9cRkJqjqoUEu63FTR+OaN+5weRRZsC5dt4loj5vsR6Tc0qwSnxbp9csef0yLjLNkHfstUxz5Zw2tq4vVolEnpp2ZWRyVLPji0zNAlrJ3dYk74uVRH9o1PfQMPHZc+LzO81Hft0RNfZ3x47t+ENTOkuUyec7DxFghXNZEwo03q7WtYwAYnaNpKloU+4DG6bZy5oPPU0fYpwwFAZm0Vwt10LUt6dgRYZZ2PNZivNj0BPhnsUzoyN6tgM2a/Q+iX0DrLhuClj8nu+RzTu3fpK5MsqdSY6FiQaUMNHoAMDlFPM3hObvLmrku609ELQYKWPW3EkuOAVS5n9rhSnSCkpTU/feoloGdBIc6GDgTKrdxvNL+CkBqtAII2zhnyZeq+TgEXZiMwwcbUp3Kw8xq57b6OAcDIm5brJxbFxmU6H1WDwMTuBeNM0ab27sHgjgtfIoY4Eyb5+m/rrf6qrY6aNMpkEaTIAqbJJJC5jM/Gve5V7emFMWwdDpw8XBiCDndaHXNHmFjHo6RG4omeD5ShnmUvNXLAaAkbOMS61sb2eJ9TTBayaQEv+4rgpXJsqTYQnRT+LXLiK1zXO//VEIZ0LrKaK4qfnrxfRPCwefM7rrEvusA78p19XcfO5119dnhRAVtD8ltIa2dW9xIt2bmwB+A7fI+Vdcnknf7lpIz4E/WoBhjmcdRik7FbRAHYbl5lDTGjuOfmturvbQTzLW62g2xXUrzOFNmK6PVnvSTEuP6CCK70b8LPC7uHuOcYXpeowgu8dX4cYKWt6omGfC1BF8q8+ndSwQ+Gh6DtxDKo5jw+Ppv3z+Dwl4YR8RVnBfwBU+u7+0KDFQg3i7iJ/wo/IEzNVaGh8YYQ8dMEibs77/Ph2s/v5b8y/NiGU+BHYyRwK6YEoA7VUQahnTMxGCJWeijHo3sXwvfTJ7Cb2LxB1JX0FGASw7CHeL+ZmgXQDfLPHEn3UKhbXNFxEf6sSOmczoeXsyRhI5Qej5zp+VCLDtV1YdSBlE2gwyVDotQgqCSEYCJNIM0uZT3GuQhc5iKT1cIdM8/S/ChkjYMjwkXCA1AL7RiexzR6cBGPrSOMBc4mulbT29v3gzVUFmgYk1FwPRrC5pZ34/jY8+Sl2d+jOZ4wRkTbvWtCRjBNFUhjkSQctoKjm3SDSPkzhwHAJoCNvteyD3+zCX00hy1RYwnECmkrgOoZXM68to7ZSwHgY5m59phmhwEjkrmIJ0rhgMA4Rec3ZWMqivk5OWtSgOgxGF0CtAVPoZ2j5M9WzPe7KZsne7Fc1gNHVhLQP557Xv9kztNxoQMSrBXKB9tVASRvazmfo00TDsegfRBtsh7qAJ8aliJnmOLZmakIwanri+yKRIxMp4SVj471kU63GcBv5wrgwjb9XOpvsytDrsI/eMWjWvyWx+3vadV+vZjTlyfI+1wzLYNyOd8RbFex67L/tp4/qzmC3bVSsiUdjBPFnndvspIjNyfvs4J8vs/UEiZF5cfJgewOx7Lp7UlxgNa2EABk3qsv2zKbWuDY221SjKsGTMTX59r+8xj8AfI4ypdZLt1ESviTOYEbybe94+GYTCSHcRaAazME2XgjmNMT0+Ks+NfpRqknk0zpJ7WHPNaRicB9M3UiLB9GTxcJokOmhrS0akowjkXjRICEWqc/iAAEc115PgXfTcc+Yl0J19++2eVWugo/3y7EPOkftYoVF23tWEud8a52mzx42rCMyYQ2hTeIAGx0h19TPq/MxyQRbgySUYnjjY2V4WB8joWYowSdZhv0yAax+d543CR8d6H0HLfXyGLK5ZFOQ2YcnAV89kxahtBBKRsRGWepYn0WTYS/1sbDcvCo8iQuo9007MpyV8L7vJE9WMFcE9hEJgg7h/Hr/cOSwkOlnDOKc8RycxCzRAhe3aG5KfV7O5iL7RzAxmgzKpEbnO8wI876CeNzrn0uvdHenWaluahKlpZl/I1AUuYb2XgDOLvIe/EfWb1oJwOZ70aJfJIF0Emh0ZWIIkzBIVdgnBm5H84hZqci8o6LE4J1p/bFdiXZijjfn0ptoU6QM1MzMbTLoXl2DKJxYmI0LpOsmwm4hmN941EhqjEIhSTx6oQXpisDSQHsAkaT2goe9B2b8zcLD6+3ftv9AjzxkjmR+LyEkUlmVnhxiQwIXpyU3ecoZlqBmp3TxMDIJDfSJ0CBaw6sRaQgqvOYWAWcRmERArsZNYltjsbUfCDoBX6mTbSreUUgWqoQ/zSOgmFmbSWA+OsVpncy0YNRCJwigT6oVWy+s8JbFiCeRa+2y9i+TyoSsUkAmStlWyrMu4tJGzqNW2AfKdRIgaXAMhhhSUvBAQLxeraIzQnsELwrxgLsRf/8A0YVznCW9KEArMwbTsF6lFn0Ffy4xR87lF7Le5PSIzmWtEs7phzJEOQySa+FAtUi8E3whSv/s4dd8j8/o0TOaDlblgnuytyFymz0ktMWdniDD4EOfvuyL+tY40jJ15oYPgEz6HGcgiSDXYI/og4ZVNgflGZEqUavrPNQjyPhC77Ty5ZES4Zi5hJvgUT1q3IzA8tyYbEV6c9yDUQPJr5CnBd56VgRAhGMYyOZdWWa+8iYhkyB5prQXW2OhrDYFvfH+GHyQ0y8xzaCnsSOyvjBlyD7u//CcB57/PW2JVIOzyOp+2vmfRh6dqk7k3j4/MihoW95mEqbazLR6WupItE6/8N0DKKPljPC0rRMp8hHBgtyJhaRsyFWr2cgJs22eiCeFM1uK29zzh4obJIusLZAmNivWpsXLfutTOtetk8bNhqYUxzoPnPvPjrNN81NqUifEvN83z2QweQrhOw5Tdraa7Cx1poQchR0uVgCn4eEISq9VRSzKLubJMtOfGOfH5bA04Oa4B/5wfWMQQ0OSz4O7MWJBaRzJQHPfXrmw8m3/f8o5WKpFAvAnt/MahzG+gkSZ8I7PpsMXNs5AT3fbLIgPjHlFQFr5htVvrmSSjpcp0LgDHrLTxPFiXzI6CsxAi0WQnGhqjOYqjon7WwneDOoh3XBthqNeC/WCPWoclTJbJ37RynyALK0fSufFz6f1LP0/nu2ZTHy4z19if15v6UhW4bcJaNTHWZRJdIaL7UnbIeW8xkM/G+PMdQhtaKcAcKMxRk9JCnW90zqY3+juB5evpnUTEudZB5kXIrYbffEdEYIVJXJXZcdv9/+y913OlaXrY9wAHOMBBDt0AOqeJOzthZ7hpdpa7y6UoSitRcilQKkuyy9k3rrKrfO8/wXcuV/nCVaJklYqiSqZEmVkbuGGWk2NP54hu5HQAHET/fs+HrxuDQYdJy51pvGj0OfjCm98nB+qXgaTx1FqKl4sWhOnOCoxafrMPRfGq2jk1jnmVz5w79vb2krO8xdzldW4nfOPaMlq8eoNAR2gwmcBktuexNvnxhb9Mzf2qOfLAg9899kIcaR/JhjIog/POHAtHtS5RiyXja3/s1155MGdgj0F6MNf9Mz9qGaQPFkAvREE7WhJLiXxKDZPXjlQOxEP1o/Hm5JlYwo/JiHEi64GO3jhEZndN10bnMbvbMuUQQGsSZVhZpb063s51YroB8pR4FomuaDaHRmWUJIY3GmOYvi3HC61fjlPVY2nfrMlbK+YiqhjUQqwDeFMiqGSSIkIw4StYOBk6BkFwhy6QLuZLMAZK/xcxTQO3wYzhrEq7nfpbiVgh2FdAUCKNZpDXUFtPTBLeW0Qq04dLAMkYCfeNdqxm+ATaX01iudBKYRIetfVKzKLZ0RSoA5OYKohvSjM+JNE1pOCiVBGQxff3YbbWB7O0b60r3l64Hm8sjMYz3WQ+51rKImnbgBItRIWTSWpaaYdYW4t+pXOac1DVAP1hePFO/VqGnV1f6YcYw6+BqHQS+SVRJsGwhCnITulxduYe/7n+y/yIsxPRbREZd3utQIbFWE1Ia5Sp0nHe9zZYx02YVDG45Mt6K340TKJLaTsWfUnM99PB/CkRLUmPTxvRltqpEp+Xa1a2W34WvXyw/vcc7ycAyhHORw3ClG2VgofUFLN4JQG6c1byXLGrBzE9HETyPrXlA7PzufJvGYEOzsdu5nTlM9s/fV5Nk2tX7pPt9+/23fVUaKIm03Pi30m8A6fWVhCoACdaOcslc5LEJq0IdfKMwRgKj0y+m9okCcq87xMJrvJz+3+2ocZy7iZRI9eHYv+Bg+QuuhKbMwvR1oNmHCHLJFHIFklEXUQxA7ah5fLX9v31bCsMsX/p70UfZZe8/uGKvdmtQNS3zcEI7a59CBPEbn+RcyujmbXJK3tv6ywns+KdHX0rmSQ1dQb16EB7b96f0gep7JVMl0wzFVBnUWkngrhWYIt1ujY+o6+Mpoe25+O2L/wSN5VFzVo7GqPjlQX4enEDPq/U2QTzU+P7UdZzBJPsfvyGzgGDVlqHk0HwfXGXeMzcQa3012AkwupixWUEhWesPrjEdVMcJeOwQt2H1ifjywMtpJRYiZ9v9MZUFeaIfltk/Nw7K+Av+1euiAxYGwySvn4ZERU8U4yehnYp7jvnovA7KmpRsKU5dwnX8nw4L+BcfaJyrlwrp9exMBdLmOSp5ZV5sz8WtUPvLJ7L8flsb29vXJkn71Qn6SJg4kfnx6KHVBguz7nZy/HO9Ln4ytBT0d/ey9tFHVnR3n8P3AzsMUgP3JJ/vgespmgnMpNQ1BFTQKm09HDLSLzROB0LhNRWWlbrrcVwF8nkIObHGgSbBcimDw/IRmBrMAjzHmm3f3Hlavx49WUDFUOcEOAVAmMDLHAVn6FrizewmSZUbq0KAL4exzoPoWESkBdMkES09uorMDkSA9nPAmsAnHHSRvNToQ+O4UDHAWzH21D1Y3KCdM78GYtkQRdZdGGClyGyJfJA7GpYRA4mwjtQ640z8zfSFlwiqKutFn0gZM3aMLhLJKUvTBP96HIMq0QggjmagJaokr18H9JyGawGZnrV7ioSwzr+Bh3RS5Q9u+pcboAMjZQ11Eq2c3w6TjPu9zAjeRzTwx6YLM3sJNBEaDSTbcmg9SGVS6Qs0UCyxy7mzzWoMhebcyP4KcGQ1K4Rta8wsfD9Jf2WQP4fpojS7KtIM83P/A6CLqSBhVZqe30+l311HkH4kHMweBqB8bnFfDJsSv4H4oUoSdcpGNSUUlN/cetWtUoiZWzT5I2rtuHPp1lu1b/Vl1t/fwqN5mjUFDKvn4XSg8T+RG0fGtEiaa/r7N5U0LGBhqCilOKOBYKLPdqGwEGtIS77d11L99JOGFRWvX1NymcM3mD5KExSRqxD6GBxBMIB4VSa7rEHM6kzGhO1STJTpVapeN7gEUAFzrLEqdrW0jfJ++V+L77f/t9p28REbwWfxMV5QjsDnxzLHJL7GczCFjHtStkPHSrnws/84WXPiv0rmcgWYJvBQSSOyzm53dpH+cb8V9CAK/2h1bsWbjtmH5NZ3n5EbxHgd6jAudbaQEZPYYqlDrz3+vaSTBIMg5XbhlodmSb3goytZnCzaOSBGKnt8V0ZNvskvPU5oWmF9Xw0puJZrAnmhivxo0uj8ZOLC7FI/reXga1jjY14nHtPta/HEFr9tzFpHqv0xwa+SLZjXWqG1tEKrQHzHZ99s24lBp4Hn7Fh188gB2qQusF9HTBVb87Nx+W2k+BG4DF7pZgs8KPc1Y7iOso81REO6oPq2t+tOMY28J6MVVk8o1zewhngEv+mGiOgGr21mWSv3My9W8wRI+ER/YQ7YNbFjHBTVEdfHD994h/aofbE148sTSMkbcRNzGd7wamji2Pxs5k34ipCP8Pbf+vQV21+rzzAM7DHID3Ai/95HXoB5N8/OoGr1418093UEUfbD8SVSQAhGpPhnoHowXRskvCel2ZuptlcDwBTowBzbQjclb6JSBpLjfjL+uvpk6QUUMQOjYFTN0wVn70wGXJEC0ibtVUvzEsAs/wTeJs8UX8kgxOkxFSEAHGWUjuIcnGAfdVZ9GD1QHRSfwO7/CaQo/5SJqFtwdY8w32D0dZhtlYZk2Z89neMMViXpm7thMrtwdSijah5hVldUXfbEhHqwB01+tGM+YYopMdnQBydONGOrU7TJVA4iH+ZZ0wwqNkE1edvMn3Ycmt+o39SS62JkOTkMGEOujArc1wtWyGuzfnk4JUYW2QujOQnopIxAnMXyGulB2ZDCaDIWGkuTBbIrUH74myevK8icZJz4WRbeBEdIMEuCqK1CGRQIGHXVQJBJshftXVKO3Wcdq/kbw7aOt7fAwkII/1t3S7a2va/BJDSedsoiwRqxUSVZd/KG5/BT+fDMf7SF6Zf4v8gUSSHCbkvM+B+0um/QkCNTbSumdcFtebONd4+Nu+p58gze3tJtz+S343ap9mujPF2Yr/cB5KjCYvYF6nF4ZxZ70dlkrJfnqOtIs/qGKsEDhEurOAQtGbOti1G/pY5IRvYt/RLcp8aVMWxGSJfpiqJ3q1x2vftc+Pl7gH63LgSq0T/bB0cirWuQ5jUzd5ijjzn5f4QlniC1FlUgJmF1sFQ88X5Ef544guN0m2NCZfvXm4P+/3PYd7aXJ3Ps6fo414lTYILMHV7nHeqe0dlaowM2W8QimRCdtwv/yzPvGZvCr5yb9CGPp/TS7Op+bj1rLgKGF7CIGGafjpHNybimU6088zjlRqpK052ENAHzQuRUmfACfOs2zRE/2PIlx5uXSO4z3K8u3wtzqySDqOZaKvsCwGWfVlx7h2zxSnaOd68JgMlVqEwTuKGJq7I3FBe3e09n7VQnwGD1KaXe7+4cef/PQluZcetSZ44NSPM8UoyjMkzKgCQCeUiw/Fs25ZrmO1wXWa1g4ALCtZcH+vNKK1ULtRy7vUxeunGW3Gi4zCCOgIzLE/Ha9PvkEQdgSRVG9W2H43z1w49l7jwzr3eu/N5noGCavk8j3BvbJ/bGRB4bjefu9tANclTM5PmHhAMX2p5Mq4u3Yw6kaqGO3vTx+U6mdDN2dFDRvcuGJ1JEP524sCEqEYpU7xmMtpumCvrlPAdbCqIr3mkp9NEx0P+hunBIj5LfUmorMIomDV9BX8libMq2qkKmidJj0A7s45Da0mGlFowCYZ+3p8xUh2mABJXZmRXgyOSS9tvzAQl7DVFuIrd/xmcgY0kVKN/vZgTKQlLDML/Av52iKFuTIA2YKySiEHbY/bxEWzpVzDRMA+EeaG6aoSTxYyvj2e7qEOi0iITY03amNt1TWSGkcoPgYCThZQwAhGbpyqZvhXJH9/YqiBfh9Fknnkdoox6eHYT/6QgbKztSECJKPWByuayhnv9B6MnEgchZzjyJDC0K4dYYh4l/krH9Vbn2x8ZI5lLfkSkkA5F+44ve+cQ7eUdytaQdt71HRljf8oiUtaUqgNtnAE6bPuzXFKL5tzyc2tt7zEg58V5KInFezz+idx2iXoQMgzhO9i+xRxZsQSVgQE0a0rpsn4eche7FOvQBMwcX37etfBw6cTv3su6c5/4XzF295tEYBnEwU/nUIbpkyjlPFeBVUaIWzMv2Fb9zr8wQR+LbmCcOrG55Xn8LhZjAJOihA08K5O0hJ+g56IH88IuNMAmTzap8RTPL3cR3vloR5xkDie6T8RNzK7GIfQ1hZW4H+7an5oSqmLegL3ASDW465gK02Rcrl9HIGVAgoJKtx0ZDIOf5OG/10QkfOChnNv3P5wzTWjpXKnd/JC2P85DeU6d+nss7fbXtn+XmF/HAiC1+SWg3P5A+Z2OyQgb+MZ1ENhoEpZzxkBcN+euCN5QDExmWkgxQi67L3XhW8Z7r5C24TLmc8sywlXgP1pQ6wI5xWjTvphD6z+1NhtPEEr72bbN6Cf63JvgpRtNvZgEm1oid0iuQ/Zjl3HbD5/KQEOcDSf6A8zmLu+VQ03Tc+HpbgtUPrTj0+rcD8Jwo6kKIz0nCaMzxQX7g/1mXwx/Loy1/wah0K/OdfDs2SqdhZGiHvCM+KgVwZTMlIyS672I2fYbU++RYL4Rtc32uDJ7Na4s34wqYeXFz+79F0dfiy+TkN4cYHvlwZyBPQbpwVz3z/yoRRwGSCgA5r2HIyD1V4C/gfbjYHUonj/xHPbGp2EaWom+Y7btWuba6OsgpDbI2pDUAksRugDX901AZ2kjlHMv5myajimxVcpneNZpGJn5RRBU20zM9s9kkrqlJWzTYeYE9Bb70ApjIkJIkzuAumZ8EvI1Ai/4m/2E8THk9zIhSAXkFtGmOYRSush36xAxjGKmcW5pAo0PWisAei8MjkEnsg3e8kdith1CpZu+61OVSJAxNYNsqpijWM8CPgSGq611kIcDCZo5Y6r0qyz2Wil0zkuBw9N/yr87yPmRReEkCFZ/qQ8iSIgv1s3f1DQxF5BQ9AX5MutiSdOI/JaTXiD//PvO/0l0q33KpJRb45XglAjWQdk11+xNjYHJMO2XRJnvlX2UILCUn3dszXEXj+7+CPdkbpNApvay+LdI2k+1VPdsp3zxl/KTfSCpxf5xL961cFsixUTLahLrmKGWWpS7vvcJ3HQdhmDg+wiXvLOXMkSGYdb/z7OQ5/wObbrcmtO2Ol6+32353VOa6ZYlmYBtjZf7TQLQ+avqp8YcynyU98p3P86n+4vq0zG/rEeYMNSxL6pr1Zi7SgJpnBT3kei1i4iT7evVmL0yHRM3xqN/sC+OHhvJfD1Ls4tx870bGbZ7+PCBOESy0mv0fQkNRTMmtuvT+G9w9o6MjHCecIJnnQ8374urF67HyaNHOb9I7K+PxcmHjsVPXnsxRo4fiN7OHvYB/iJJiBuEBU24fovA17tZOzom51N46jvOm3NYlhIWQ1aXl+79efv1ez+7yxPiCuH3PQv9XMUkT0sANUnCAQlx1zxhAXskNSXbKtKzrJv8Ql9qayDEao53GpUYrQ4TmQ24ZjoL8ODt4lxg5keEubeAp1MI+L5YXYmHkD0NELTiNfxnzxFgZ6mCmSmTrPUA1Rdt364kvyV+4Z4gfYg5rrCmpnO+5+bfquej7OPMN0XEPBkkBQsWtVWr4E99jthGaZlQRcBVYS4MctFNSPl9HQSl4J2JxTn2X76Vc1pGYnVO/W3G96yJCKQyqJ73BjD49Nz5qBDFb3p5JoeGTUjOh+uhH/JHGUd2fO+/z8UM7DFIn4tlfPAGYZSakuFw9AJ0kYXIsvzdbVZ8JtX2ANLHBh5CA6LkFuYEKdKx2vG4sjRK/pP5NL9bwZyu1gVhJRIX82wTJNUxlRtHqreKJKqm9Ip6R+sEd1ggFDDSrhuVaRDUDNm7h2EU6OstRKb2CIkWfIFIdQkmYhEEIAFpHgaZI32aLuPDdH3uRjQW5qMDLYyma0l0byGAVK3YL96rA+jPwxwtIL2VUamh+envIgwrxGGaZ3B/mfecoz4MXUQ+MktQuKABGAUYnmWYh2Wi4M2SE0rcJPNidKYepM2MPJFHOZ8Z1SmvwghZL//lvFKlDKt/yxxJKDptKZkXuzGuBnbx5t+waAKxqWmPEnQkfJmbxHXMMUKQQkz7PpfuUYjSZJhymEi1SDKXzqfmjmlyR7CIQpOGVJH7MicWu8Q/fv3/wxQHzfN27g5FOeXO4nxogvXLqj1SK5j74n2rvXMUxd/lvN3X3OU06YRNslQYFRYaZrxIIOuc+PtpFJdI7dEwGpA29tJuw8pExZz/+9ljSqw9U/eivSWqksAsNskHdlc5Z45bibemZxLZ6QvzaUzEtjr7CEZTXajE6VfejFdfei2OkID1he99M4Z798V7L52ON195K6XzF06fj6eWn46nnn4y3nj5tbh44WJqga6cuxJfev7Z2H8I09qV0VgmauaPfvRGvHfxavytf/S9OHwE5gfN9bmfvRf/7l/+bvyj//wfx/DhYRLBzsb6sc146cc/j2ebn4uRZ46gpcY3BsJXP6g5YOSNhak8n2mSt8vRcj2dI80G1XQr0Nk+ua5Pmdhagjg165x14dFdC7eTWd2qLNeH9rczXnd9/75vbhLogBxH7H39ZIwMqg+Te8WSxDhfb/8NMY/p8hPNM/FIrSOu4HdzoTISSzhAylg5vt2KRtPrCPuuwEjMrcySNHYJ36Sm+HoPUUkXZ+NtGNOx9d5owPArMNoCZkVV9oV/TQrB2OonYyK+0NsTU5hCjxEBVoZNPU+5h/Olcq2s6mOUFU3MOQe3mBLqVXiRzBH4s6VNKxBTP+A3zPwJ3wcRBHbiXzi6OMOcYOae/Qer8W4xj7c7lXCGKVODaxHH0SKaOAL58B3eHuEjjJQJzPkRh5RD+xjD2nv1MzwDewzSZ3jxHuSuyyAJwMqSAA7gKPOTgA2AJ6G8E8kJNAsGCSCLVOyh3iNUAYG2hukaZm5H+keIZHMhrt68wd8iYCSWaH6spwCYBchUijmLU/JsfS4q0tswPeYRWoU5EiHX0fooES3y4dwGszIwbfjnSBMuLGLGwvNe6+zEVwiTPdMovnrz7Tg7czFGp/CHgkkbwMl2GPMXpeBdmsbAzElUCb71n5gA4c1CaFENfkTkbwGhdeBPpDRX8406WiHErdGOX8IIIU7XkB7ChiQSaIKhwUeamGsrmGYs8qyJ/8AUzBNyOsKCS+jfRodplgeB65UkBEFczqkIyTaU78qA8UgyOFzgO3PHA+a0kDlKhgokN46fFmQMPknOB4bzSPgKdAYyZO1auG61dy9FvQt18oFQt2vOf5ncV+Q5iUavE4Ii9wr9zPXEjGeDXB8tbS7cbQR6t3bsR/lkfrLGhUXU7j10f9xC9FkxswpBI0G8nRi7W5u/yHvuJs2gbq/03Vt3zSU0HOf9FBnVJXwKnBW1aK2YGhrEQt8+w+jLuL5/vu6n1rs8wyKpTdhPQs4+2uL4uqU/ULwuYyiD7+92mOLDxerCgEOUz3LO9N3YfcU/UPU959K5di8scO7cXJ/o+D/YnbySgRH41o6G2EiTU1P4G3Iemji75949g29ka3z7N74dP/5PfxEXTl+AEK2hCboSx04cRwN0Iv74D/4kLr53Ib594FB04yvovpmanIw3X38zHn/m8fjGiW9i1leNV37+cpw9cz7q80b8HNoKgKCJMXAbmDJCst6zZ87EdRirFrTwJx97LCr414w2rqewSeYhF23bOBR+LAHP1HCn6aKTtjXLrlsHplbpY5gLhL8M69lkkBfWTuL4TnvbeReO0jFgaIFTduKNbd34WF/tt+G81XgIrz0XZdnJyBlR7sTmRHypsz1mgOFvbg7EPNqfjJa3ZY1QvvvBT8bLWGZbBuKVjcWYwJzxi5jcPdlFcB2EVy+RaHasweoBh4mjh1al2H1NzFkLfWohiE4HeOJLuC61Aeh+stiM0G9f1plmalzz7JTzb3Q8bCQ+2I0PceV9giPnhr6sgR+z0FgLQYjEleLAfR090Y/vlb5+CzCL04vzGZVSzZgzuonwUaHD7dndvSOus1pLmbAMzIO1QQUc6l65037Zvaa9q5/HGdhjkD6Pq/oAjEmfop3EjMSxzE9pereb+V3JHDlFRtepaTIHIJ3H5GuZiD2DA33xaPcxzOMW4u2WczGHLXu+A8AVgbUAPG8V3lvGB2gd5GqUOaMDSYWhKEFjAaPS0g9hIOHv5UILZehtzb5WIE6WjMQDYu/qwrwF7ZFRjN6ZOBM/HX0VM4wFou7hq4IEzeSKM9i49xKRrgoj0YF5jPW3o3WpwHhcM8cQqMAcI9pQ9/CciE50NQODsAhhV13F/0VmhzY3amiFZFokKroGYW42Y4A6sWiPFSIgiShqMGsyZibUFKmrrduOzJ0DkY++TJrT5d9ifPrrfBoeO0Mog4BEQvZvneAQ+k/JTGkec5M8SE3ad+t/JYO0VURMbWjMpFh4tChJSPDXrQtcTqZrGa3dAnO5hOmfiXFB7DCHI5hdFAyyhLI+HhTNYBjz+moVDRfSSEIBv79CH9ql0Pa6RCRd1S+qqIy6IC12K8k8KLnmZtldv8tMiPR/GRGvhHMmaCw7vNvAtl1zDI7Hsd5vMUqbjJCBTTpxjM48QexJze70y9IE8pMq9qobgcJ+TMfUHt2tm2wJt2zuY+nyYn1du0IIUKffV1am4/LSZObrub2qn0xvf5EMs/5GHT1D8fTzz8TE2ERMjE+mZnpxATNeUh4cPnY4jmEKd/69czAv1+PKpSs5dwcOj8Sxh4/Hvv37YgMt8zChwTuRtI+Sobi9pzO6e7rj5vWb0ZhejgkC3czOz8Xg4AARPdtj8uZUvPv6O/GFU48mA6L/0+jZG/HaT16J3oHeuHbpeizNL8RT36JPwPA6/jJNmP7hMbJjqiFmlUrwT+GPprgKHdQ4qTmqIvBSK1AWmax1rhsxzyS0dyqucwpWeCC13Xd68JO6nl25rSnfWa1naoNxHCC89nNdPAx8fn2tLWbb9qH9LtJOePbuDUfAOczRGglZzwNPZwlE8AXW7NG2jfgmJtVzwPkKSVQNJdNCmE+fTbEbc4uNA+fGua7Gz5eb4lzLEGC6yFHUZRj7PCiuA0wv5xZWZucwPvrfDFlcu7aMtl18Acw0aqu4VzauG8ZoH+daDm2GvTI6P4HlA36/TpXr72GmFCxf0Y0SSnH3A0VGsgVbQvMNroHPqu08LUzgZ6882DOwO4Z/sOdkb/SfgRmQodhZBI4JILlRIrztz5RS4lvXhKWgWXM9NLALX1uDccFMq2kdJNJ7MgZ6B+MHEy/iTAwTBPDcBNE2p+mBRD3vAj91RjWEdNqgyyjQh00Yhf3tA+T8GeDvwnRucdEABCAgEEuTjBymZv7tOPwVMc9iQ/3q+NtIlBeSkOjCrKK1BsHPfZPu6YzaBKKrQ0yOr5ApHElkama0DQeJoj7CadcElYWGR8bF0KZtEA4GnThc6cP3wNDXaxlSt7W9K2qdgyBCzNE2+mOofSn6NrrTdKUTRmuwi+dFgDBZc3M3E1mJhG4Vx8/9kkiW4arRV6P7yXSls7GMEkjd8Rl9TyngKpqkKQJYyPQVgRMIIU6Ib6suiR21DCKolO5jSpOMCXN/myiAUICpnYOwWmLtWnTURTMnc3Sgsx9msgMNn/VL8dJPkKyLtoGmcHm5m3nCidv1Zwx3LTChy4s9jJ26e8d5lBe2EPDd3lN6LRFX5kGy3/nj/rhno3er+ZO/J1HkmiVBep/VuzY6OytxT9OV+3xPqe4qWrQVGG/3pXumFc3mJmaQMs86um/fYvdZ7Qcec227qL8HJkmYcLc53w43XF6La2VfZ9inl4gMdpXcMouYR7phvPdJlk+6vjv1zTWbxVcx89LU9BdyLBZgAsFj0rwIgYXnVkm9RLB54oQjzqf7pA2BUjvCEtf+Jut1k/OxBkw6cvxIClEuoDW6cvFKHD58OGbGZ5JhsY7ZmbmMPuZct1D3Sz99Ma5evhYjh0YEkZj2vRaPPfcYvp2E/udHhU4FGLJ9bjQxVitocZ94ppO55IxnXh87ua24lOZ0W8UEepm1uz3ebQ/5lddKvLHjzqf3p2Bkx/jco869aKQrZgmwsBz70a69urQaVzGta9GnFGbkPsDPjn6rTWqJydb98ZcEcJgmgMMJ4LDRQteAu+5zz6Pzs2aKBdpvRptMevSYArVcgjFrRgtfEW9wX5NIZ9pzr1BjGe3W3WCAQkE1dLZzP8XHVhHkrcB8K5xzgVoJOpRrxBorbFtjkuaxQLg2P0kAI8wNZerYu/mzxbzViCwoc2Xf3At+GgHPc2ApPosdlgwY/VzDB0omqRVzvt1oiHxx778HZgb2GKQHZqk/XwPdDaGVDJCAbTfglggVAOm7Oni2YhtnElAugZikfchrgUmbgFztk0zO5jhgVEQM0PR+IWEqtEISlZWOThgsmSeQDIS/ki+1O6cw3TNqkwjPkN22ubgIIqEhzfCWt0wHJBD9FVhLbHbjUF5rmeOzHUkZiVOpo4eksb1IzHrQ6LQixdMZ9fWZs2hgxjN6nYJWrNGiDelgLyYx6Na4hCQWoqCLXEVGThqu9cdxzFoCZqe+MJ0Ss3ZM0Ay728x4K+Yvwh9oo70fZgCfJ0xwOmCgRJrLIOglGDr7XpIgxefWX3wUpikgQd5th8gxma1IMVHT1mNVmJiO2kaMI5E/35hIhGVCvya0W3CVuUFrMDi91c50iJcIaqZ9HXVlsEpiyT5JZC8sLMIcoR2jvQqMYTtjGIGpG6Tf4kD70E7yWlAk86R/Egh9FdPDBpq4rmkfuVVngSzff0b0i6rPDkV98ijPj0dX/xhzQNVSMHR3a1jvf2nrL83HZEQ1WytLgeD5q8DP5eW/0k/ntBUC8sNoj+ywY5GJbWefGpDgbgTS9gE6Z0ZZ1GfM6G3JwHKxDUm10v9FEmbqp1Wu9fZ3P/R36i2m+u4TnnuL/VU+bduSUZqAnlkai5urMBWsZbFbfO6TKY5dJiTbo36J/bv39OO1m+0w966X/oYyexZH5NlU+6pW1jX1PLrP20hHkCZVMLGcaihXkpOy96cIAnApgBWtvcC49Thw6ECa7b31xtsxiVbqN/76r8fFcxcTZibRCmxjeXOswoSpifGE0fOz89FD4s6+nj7MjDsgwBejRpQ2teG7lXJf6J/oGfTcOgpFJ7sVn3dvq+VIM7rdHvoruJYMOx3fxNygHJPdyESuWAx8sTobDwGDL8MonGveH834dakRW8Nc0HED0j5kKZhhAzS8w9rdAH52wRA0AGgZDpt15x9MEAwQMNi9uQnTpAZOZtV0FzKohtB2ptXcae5oUJw7nX3XpQXcZmLcBoFx1rd8T+/WcVdzDYHlCtojNmA+msI1GJbcQOxZTSwnCaCg2eACQjCZqMTp9FkBpkyxWul2Ntwa0svCp43v7NOFDSPMFnulEM4VY3ENZAo3m2GQ2OOtpMjQzLt89m593rv3+Z2B29j78zvGvZE9ADOQzAsmAzJBmt/tLOV9mRGZJ5OqCiYF4vrtgBMwAWtggYbZG3eUjJ2euYxZwjzMEYSLxIT/YHgsIosutBTwKwmwlwHazUTD0RxvX7U/Htp3EoYDhIb2Q9+ikkmq1+tRX9Rsr2DUsl4qlhjpwOPn+ZEvRd8M9SJdHCB3SzcMTzc+FO1IwiubSPHIITSAQ3UrBM1L629mMAlDb1cZcz+MQTcSR0ZDmG+YDOSQveR+kbnqJSJdB3WtcX8d4kgCpAXGS9M5TfksqyAmmaDU/jhMEIwM3gqOvCILCVsJOs3nQCfFp8/wO4OpxiZMQQ2cspqJH1uSuTPTe1lEYjIzU/WluLYyUyB6atpYZxJ5TETYiaasi36uQixqhleY73FTgsjC12UQ7TwmPMtEGWyFMao09yBZrZDsrxXTC77Ttwbj2lylPQg7pYuq+epQACv1AdZfE0CSfTKXPFxUu62fxRWa4vn1FfKbQLC1oHFKLZ1UREp+pVLuXGTiJCI2ya9TlnIPlX//VX+6iu1oWSSIKxBDH7bIFJtja4P5zKhtDnVrPu9Wl4/oe9RoJn8MbUsUydDvxyR1pYmEjSvmIuGHOXTPlD8lE26QDZnnuxXfXU7/Jhkbtc2312G399x727uvkGQMTe6NVTQftHUnAny3uu73moypwgsJTOdPAu4XU5xR9zcCDJl9znq3fovkfpsYHYtL5y7F2LWxFNwcPX4sbo6Nx/VLV4EtEdM3rkXP8UNRbx8E7nVEdQkfRvrd292dfkr/4ff+PRHwBuPw8aMpNBGuScAKR2gu4YtrOjQyFI3r1+LoyaNbviX4DXZiDtmYTmbZ9S9Lrnt2s4C95XU/i72x/coHv7cCu6r41BiIxrkuRv/B537RV4S9kPLvY5IUCJ2MyXimqxaz3H9nszdWmWvNUS0ft+9AW85rW9Rb+9GsEVESWLoG7vJ8eAb072mBCXInKvQzoIS+naucAYP2gACBzQgy1AIrENy2TvavLHl2qU8hocxsBtQob97h07pMAmtwJBaqqJn5aAVnqNEsizhKBqnwly0YzIQT7CvPlLDMEN9GwxOHVBUAgbfSr5UxGI3SmVQ0oSG6yWJluhx/ngulYLRuQlmq3CsP8Ax8eKz4AE/W3tB/eWdgu3Zot14KsP2VebqlXcI0REAJr0EuhCYIbrUkGzENUXRm9nKcXbuSEenUili0gdaBU9QtEvGL0rcMSwqo1cxLydOj+x6Okf4hakZqBcPkr20WBAkSuxUJP2h+mDX4tCQa1C5ZDuET1FV9PCVznW29aEUE+lXMX0BKSNUMqtCNGdvj1Ydjk8zpy/PLcWXuGsiLcL3t5GKClOtAa3S46zDEF1Hx1ChtMReJtIhs1ALDhWqGzyp9WUGzpRROYkkipiBKpZtEnAsLdXFVdHTvJ+LRAsiHGaPf0MYQQIyJn3XquohW6yZmf234E1XWMXmhzUPkcDpc7c35ci58to7m4OwquZqIHGagibxJeGFkl0mEiuicX80n6jhYy5T5rtcthgWoY2++iNlOKyZ1Lcz3Wv1INDf6SV55A8YVh3pMfxYWQXqsp5Ul8SvjttIF8h2I3v0XWQ/ZKJg+kO2dJKBNaBg7esZY19Wo1uaYmw+HLfV9sG6lsX5msmE+fxmKc6oGp539kVqcj9gpGYd2kgvrEQI5kox+Roa7R31q9ZZNrsx+s7i85toZQmuLpxImUSYS3SJ+3Bnuu609sAqDL0Ph/N6tmGR4ifNZbLK7PekjaiWVMKNVZlsaAdm/mzG31dTLn0+yOBYl2JpgZvj5X/C+sP0Bwnu3AgM8hpX2lnjkiYfjjZdejz/5gz9Gy70STz/7dDzyhYdjbGKMwAxnY+zSuQz/f/jRh2MZgU0LBHwHvkJDw0PRCUF/4uETcerRh+L48RPRjy/nwUMHo6evF+FFcxw4MoL2uIZJ3UHMejvj+V99Pv78z38Ql85eZCdEnDx5nP1TnEU1TJ4096gaWIVDzpEBTj7KOuRehynIsOCEef5lKgrQ0gxXoQs4ooP0C8+0IcDjDPwc4cxs+35gmgGE1KIX2saPOwI1tYarXwG+qhkqIDO4EXyo35FMmsUcTYvgB+0AeDyZJBkjb9tv4arHojzD2+dVXFKFqbPHS8B882rdsVgNlYpnV7BWUNOXddqQOBLtkWtYrv0a19UI2idxaMLYLcGdWjbbErZYn3tJRrTB3Do28wi2Ibg0PVbWB0zfQIhlMnS1xIkrQHhNnMc+BIjuwr3y4M7AHoP04K7952bkAlP9UXYD1LcGCcBTa6TpXMm0JMHF9YIZgJEBWVyrj8VbU2cIs30tNjBZ06ROdKGWSUlWFVtoAavSNX2Blo36ZgUyDNie9MIQPD54CnM3TBMAzLZVfuqHJKBPu3kI9h6iE2nPXUejYnSnHoiMZiB3D2YQ7faLSGuG/DZ5Nuj6AABAAElEQVT2g01oh10GntBnYLgySJLbQfo6GkM9vWhfIHaYiz60KPvJ0dScWgGTVTqCvAXRh4kM2iUZHa+W/SufyQf5zxxQGyCaBu1UGUsn4YE3sV9v4Oi7znUJYxGRUsQamrR+GLT3YLQkfKF0aLsJJgcmBiJwuLUnq9X34fTCzbhen8r7RVulBsl+8javS8jMESFQ6aXjSUScD8twQobTJ5nVRJzUv7ncF+uLx2C4pngHTdGyWjHeRWptVCMSPSEFhRms78eMCK1FxzL9IlksdSeSLDrygf9Fja21hWjBNytLMY0feO5OF9KRnDHLgKj10HTM9twDf9XFfihR/TjMEVUUe4s1M3y3PkwyL67zvUqeA4i+JfzQclpZi5ubk5CF5lyBQMTU505rozO+RJHt7Ny3t9tFC8x9c51sbf/bt3Z8y/VgSRZgqOc47+ZYyXrxO+uJbs5BQWi5t1eJtLjajCDFff4xilqRUmunxtZd8Ysqzp1n7MQTp5IYXWpdQ+gwEYceORxt+B6Oj96MPpinYfIV1dtW44vPPRIH+yA85+sxcBTT4UMj+EBidsj5r0BEPv2Vp4yzEq09bfHN3/xV4FhPhu9//rvfiANDCFYgQr/R9zw+fJ3xzb/2AoKMvmjrqcbXf/1raKauJ5E7cvIg/l5zmcDTmXB+NI1LzTnnJ88Q7aUfi/sL+PJhjmMVOLuyDqMBTHHtfpFncOc+tm1xj7+pYZMgV2ADAd9GWO8BcvtM4/c2Vh2Jdfa6ghW1dIa2dl40bU1h1kfcMFo/yHAaNKU8P/ZJZsLDot+nzEJGC+RqFZwpE2dxbex3WmDwhyZ2K5yxnbvXcYn3ltASb6Sp9Y7zwgvi0PQxYn/4vEEZ9IMr+yRzpImn/kHb51DmyOANZUk8Tn2KvIwOuAbcT6uBrQd8V5y1CC7uamOjImwsOky7DNncgJtYGixwLmS43Ncb9EkBxs5xlW3ufT4YM7DHID0Y6/y5HqUAUsAmYPXX72WRsVhGYwPKhZAXKRlqlpw5EPNZxAn8aEp3euZCvDd9PsYIgapteNsGwBmmR4KpNZmEGhodZHtUWiefhYBfCCqBAx6hFpLqoTUZrhHpSUqfom2/iEIGTol4fWMJU68FTL+QYoEM2lc70GxsENxAMwKk6kjQjKa3kj5P9Bpk1qKvFGPqNIEsfy8RQnyxvpjEwvxKnXwitdjf2WdHYJI68J2COcJW3TCxqJzy13kpckcR7puADZp/ybD5W/Y1ETbPJcJhNErQZQg1D5RJ2sScTeSxtIgGCERkficwdnQS9WeopSf2VTpjfI3IdCAWqiGbez3eXrwZLZ0tJCqsxRg5nd6YuJSR/0TyYF36xi+OwpbNZqWMSgcx66AdkTZD4hlNIiz0ibnUxE0EnevspEtg4oS1BuJbQP+wimZNk4xmmDZYKdprQ+MgQ7WEn8MUhAaR7HhtDcnmLWRs9bsW94xtcpPOuH9Sk+Sa36PICDcgeESzEhzJGGdF93jxF3Rb7Vlhv3/7vHyopnNt3KOcEZiaFoiMNn70L3INCyLu7vO0ff7r7Bc1UR0kJ06/gTt0xn2h9tJ9KrHv3x8oXFKLqV/arve3vZBbKOtimdk33Uis3b91/CYwyGHXKcGWhSnWcQ4/hoa5U/j5qEVC11+LxKemjgKRXBPa+qTL7Z4qoNmICYJO9JkrjXEvrM0AjxSCtMfwQyPRfaw3iXDP9hymTJ1tC/HcYzCtm/1xEcHCtXUDoxjkpIkUA7zbJ/MBc1m/Gq3dEO8t9ZgDrnQe7oq5JuaJ4bQeqMXo+gTMVReE6BJa7xvRNtgSB/cdZagIUzgnU+Sycd+oNWrDdjk1EMA7i8y32vDZeXxQ8FlsaZtHWGSobFfmzsV7ts9jxXr5mUDlzu98knc8G0beE/a714UBwjF7Uxbn0R9xlSbc9leUtclcqyVtgK98po3w6ZqKGbDHGkw6K5a5XVNZ490/Xf9Cc24tt4tmkJ4/TnO2K46wXYMdqMUq2inesb/CjkUYpLJ9x+fz5ZmWsUvcyAPltXLoMkQZAZU6RJWOOyOcevCoowVfogrWHgbtcITi6LKIg8q/c+7Yp3ZCWLAJfnAedysygLYBEqVfQGVgltFeZdQ0BTQn1SptFzO6GYvih90q2rv2wMzAHoP0wCz153ugZdhvAbFIaQkM8/bl9Th7naAAs5A4SOgO7WuKRw9txDAJ8yoASTUR2laPNcbi7akLcWH+MmYFJG7ExCGJPrK5aqZmZDR9YwxPaxSlGfMfNeaSwCltyAX4gNsYaUNiCsOz2lIkh51E46IUVNX+NIllx9cmIf5AdiB5JV1D1KtxmbmRVvH1UfGxBuMlk7EAwTizhGkXPzIUnWu1RDj1eXyY6PcyAHyGRIAjvQPZv2aYroNktu+mvymZox2JVKVpheZlJf2hDMywipZFpk0EIxO0vWTwCaR2vmuEvcKnS1ShJsT8SjjdMgfOUUcNwo46KtgkHcJ/ZGKT0NkFvkqkOIGk+Z3N0RghH805wv9OzJuxHETVimYFJIiTDpqegjgkVjp1c9c1tO982r+yiOAcl860IrcseVsk20Ri3sXo7xC5Et4XhA6PiX05jBNIv9q+HN0d+EgRSW8Dhsws9BIK90fk0sh2TGm3wbO3+Layg7t8rsgYY8LhmPy9v/Z2qehTuCQB5Bxok0/vPlIL7gG2bxbXKh3y+V9znUaTvgsKBiTj7q+kKRXmMZ4ZGYjd+uW1JIbcJ1uNb3/OeW7h3X2YmnbBIGkGKyG0G0/r9sotxPBbEIrwDx8Ygntw9iebFtFCQeRtjU//v6ZVycetC/c3pF2fUiNSji/PINoS++KZLglTX/T79rHtWtk9LjpXDB/Yxe6jEX8U8NTJv+Sc7EcL3QE8qt8gZxG5iGab6+kP2VKHiER7sFGZJ7bLaYQN7THVStqBDqNzFgTpDCkGzG8lc+dFph4CvgO4aRh3GUrWih+FBO4VPxVyTONrZL8cs0VtrodMH5IOhCmafwoDyyKhbXLhhWU07hPH0ebPR1vflajCvBlEIn+ozFrKIoxMsykuKDARDro3flFF35dukhS3ayJNu2qRDbNubrpyTRO+bc2BsA3oBJNOcAQYIYVhRkf1upCqAEJ+Fi84kq1XP9SQ0h/sfTNVvG4r4qQKIcA1G89HWILsA4yrpVglYIbaYp7PXIHF6zmmkvlMrT+8oDjEve54EwbKvfCb/q7sg1wOx0gdzoWRTmWMDLbg+HNP5V3b9ik+eSnhKIPP+Ssu5z0ZHZ9zjxVrv32GhBdFSXNF9wt7xz1Ycdz8OFZ2SrbRgGEqRrz10t7HAzcDewzSA7fkn88BJ3AFmQs8p5Ay/v7PVuMHb5kTiVDaZBEXQf3gzYgD/RH/7LuVePSAIYYraI4m46fTb6A1msTvAL8YTLdkgkTmvZ09RI7rIGgADBJMhbK/Be2yYaI2CAe6icZHn6RmAgRsEP0GuBrTEAzXZ2/GMD47o0TA+udv/G48d+jJeO7AM0TDGkuCqw2fm3WI/P09+4lQh+kaSMT21DQZScrcQONklb8wdyWuL4/FMjlHJKZa5yA4YJ5S+ockTKktLrZxvAs7f6Si/bU+fDj2A/BhgAD0aoAE8BsQiJrSiazKABZK/GWMNNlzzryXiAdCYr3KcxCWSnFLkz7vGWBCprKCBqpLRNa0BFHZnIyWOVREmhKiG/RVpJNmFkzKNZjC8ZiJeSLO6Q8lgWB7Ij9/Nm7lQFJ7pKYFZpN6ReTbi3bjRlFqqyIlhGDyx/Dfangkfhaov7sTp2C0SyJHpbDtRM3rYP3bYZqM1CdDMC9zBPGUSHZ7A/f9XaRr3xKt3/UtiQ5NWdyfH729uzbxkW/aN+dBYvSTLO7ljFDHudDkrsGv6+EesjgPErR8SOGw/reZAJ9b3iyi4kns+NzOeXPdk7jmddczQ6pvXbMJo1cNo4UacfsjYJj3XGk6x7NbjfJZlMzXRX+zK+5fNCkrBGWpavLE+01Gc3PjWbb6X4yiuPRR/vcsFwySrRbF/aHGRKYgiUpgk/Pl3lnFNNMxOu4PW3wnTWGpR01VOqpzBhVAMLCsU8HP1JmpuHzmUpx65uHoPNQZzcub8e5L75BXrRbPf+VQVHtOQbh3ogneDzztAr4gXacOmZZFEnWq8ZMh0Bm/Da15O5pEmR2J6HmEJG0wvB0EpHANGjIqQNPpxmyaSRZzXzA3rnUL8Gs7c+SYl2hjiqhlZu1ZbRA5dGEkGkvdmPWdj3YiTLYhcBFWGewjmSng3TLR4JYXOzAN7gKuY/6LRpDbt9ax2Asfdkbv73nXswfmqB9tfmrLbZYf29R8Thj+gX3Nerey6RQL6CplHe6BfIv//PTMyrwoSPioJesEfu5s3/oUJlUQAmjSp6LNra/Q0GeLvhR4wjVel9nhuj3zPBYdLfqdzB1wOf2JCOHvOXZd/E1LBsxZfdsiM1VFIGEuoioCQ+G3gsuEGeVTNOOZsR9pHUB94nThl3PiLInT1DLKUK6RHHfn+BKWgFupINvMtnnK3mlKby5Dx6thSKbIKDuYvdz770GcgT0G6UFc9c/xmNXA/NufrMS/+RG288eb45tPVGOoT4fUzThznahAVwCnQH6RqRnCa5qWQCAcSikfkjMk/vqKtAKwj3QOIEmGSSAHREbiASEsA0CbYy4B8zqaoh6YjB7CZbdBDGhyN7M2H5fq13Dsr8Sluevxhxe/j11/ezwx/AW0F23R19RDriX8hGBmBpHEak4i4pE5kmgQWYzOjceZ8QskvyNZLEh9LvDHQRrPAxT+E4CLkPjXjrZIglRCcz9hvNvxL5L3WFxaRMtTBH4ol7uWJnq8DoGiBs0i42T7EmX2wbouLl8nel5nPNJ/Mp/xnmZ9/nq/jXqqhPddXbpJEAckyOSJWib60LWVKYglEkfWRIb8QiyJxKx/xfC0IMp25kBH3Ntj4blkkApCQNWMiLEKMZfvOBgL43Nu2omaZtCKBfLTyKw5JbB03FZquArD24geovnJYHXTjxYIXQk3CSdDfdcxCRGlSsBr7pJjdy4/QvE1hnnPIgkhst4a4T2f/4U9wORpUvNpFMcrkdRMAAfNczS7c11vXy8CFEgw6QwuoW3xvutiEAbXSZLIq9uLz0ggSmSu4JMmAyaxxi7OdT5MqPyHMffrVkOMdqOJfe3ZtK1khdhLbCX2DIvH8N2rcELsKwNWtGBWBgxg37GVSbAMs01/bNN8XrlnePbjlKyLNqnx/XuCfql54/Kt4hzqjyVDsooG4sNqlDh6jMUAB4wJ8tcAKvo9KtgQpmmqSEdibmY2Rq+OxrEvnIgB/A2XceAfu3EzuolO19X+TIyNLsZ7Z0dJLjodR049lNHnxkwMu7QSx44eDBPNLk0vxNDgcIzfHIt3zpzhbEUGeThyYCTzy5x99UxMT03H/kP7YuTYMKtFnikESj5nH1xlx6fWTlNNi3MlrJvF1M99osS/0joPDB3EJ+oIUc+Iyrl6LlZ7LmMGvYyplPAUH0rmS+ZS38SVWZg7zfHaZghGcSOaa2Oc21I7YKufQqETMqSFFqSoXwK9D6bJqHALq+R62r6P6IZ71JQLTcxBboGck+Ic5eRQjUIx8985L+W1hCvO4X2UhHcInjQdL9+//ZoCOBkjGR5rVfi0pZFHIOc6CFc9PCY6TxyUTxX4Q8b/VqF7qZFBG8Uj2ZZ1CcOzbT75M4V0VQLttMkYIfxqdX3Zl0vsvzqCCov9SDNUBCbm+EsGhr3c4IAmj1Y8hIDB/YwWlr0uLttZvJfwBEZqezGNxCoMkvkP1TwLpRTu+fxeebBnYI9BerDX/3M1euHwO5c34l//cDUeP7wZ/8PfbIuTI4BEITFA9lcebo7rk2txcEAJknbt6wQ56I+vH3ouro9fyjDf6zgaN6oihtXoIcJTV0sf33kSk7p2fGYGWw9GdwWziUYVJqQeIz3DRI9DLbWB6ZlAFdM6PZYnieg2vz7P3yA4AK7ZvyuVA2iblIStRj/ht8FEAHvN5zT302EWxgbEcGbiQozjByWR0Em9EvkT9FUHcYkqEZvIlor5vonmxEARmO1B4GnoJ3O0xK/I0OKnmqM2EBGxrxP4N2DuZGyKEK/FM86TCPjK7A3CLTcID45fEaGXjRonI6XGyV/r2kQLs0h4cANMaKo3DxF2HXO/ArNns/SN8YGM19G2FSuALwJzaaShVZBtdo+F2GSMiu6acOh1PkTOaoqUZCr9FlFpdqLTtkjQeht1IpnxswlSSwKBFqyvgfahqak7Q4x38ryhAxaQJGdADcbmpGlTX0EzQFiOjIwlMfWBQl1Zb06h/4ncbz+VVxhDsQi3r+/2zbVSW7lTI7bbs7/Qa8yrUtlPsySBxZo7B4Y8l/iScHJDSOS5N3VQX+Rzu1TcuV9Bcr1bsU6JM4l+CSm1SDyede9H63mCc9CnVgwmRxp0g/OlVpbXsk2JNL76yu1C+9KMPQg2GjAQPtnFHpyFGptHe2HxHYnaNTURH6OUGqT7qSI1x3Qsc9BAyJWMZjJq7x/BrtXpw1IyVc5panWpxznQtFIBjT4dLsnc3FxcePccRxH/i7lF8hlNxP6+fTEzsRTf/8HrMQ0T1IL2+MboJP5I5EG6cDFGx2/E3zzwN2J6dCrOvXsmvvD4E/H97/+AaHeEkgY21GcW4m9/73vx45+9FJcvXyFACsFc3n43vvOb34m+wz1p6qcpU7EiBQOqIEOtS+5NJl2GQC2GcKEJDUul+yqwAOGP4n4AahOmuSqbN3mmYMIR/DBGF2xznTDqDcyel9qiaQHCuXowWvvfi0rXBfbEp8ckubfcz2ozmrbOmPPvuIw4qomje99z4X7Os0CfGWH2W7+l9MMDR7jvvChsVpPoBc32krmFyXTsjtvca1R5x+La+5tN2KYHYlvxL4Vh/hS3YI6AW11oY1ewYnC7GSVUQDjfoP9eoLKs0+kG12WdZbV8trBPfG57WyYL91XxSGd7DXNMNKcwLczErd649pqiMzSu2qamr/oDakGBVlUmKOfWV4p2q5x5193w/sUrt+srKi7qyTkvLuT/jrWZc0+F6TOc0TGZSCNZ7pUHewb2GKQHe/0/V6PXouwv3lmFoN+If/irbXHqgNsbkAqwa6BBEuofgDkSx6yAVVTrNy2uxtBL70bjJz+MJky0mob3R3z1uaicOgHhsBLdIIS26Z/E2uQrIApksK1HY3jw12I/JnPzi9MwDH3x7sXWuDBKMlhaOzSMZJv8O8cP4L/TBUCnTR1rTX7aSUju+l98P+L8RYiw9lh7jMzx33ghmrqIlGWn6OI0ZiRT9enMdyRy2ID5MHt5mw67EPS3io3xvO9NLs3HAgTDPD4FvSvdJIJdyDH7rAgztWXkYjI0+QbhkzWHW6hDWIost0oSqmIKGpXonMAs7vXJt+OpnkfxRzBIA32gDgl98x3Nz04gdZ4hmhBMGwTcNAh0FaGvQSzkaOweHCG+SRC+ILNEolzyjgTCGhEA7b/MZxM5Slq6rkVzO8ljab8gGPJhvvMQbbbTvu8pkdWZNiOl8azEn+uqL1OFOaoS0EJ34v2aWJn7iWt1mKYZiNw6G6QBQbWERkDGTYMcDDlksyCkqSM7bccpfJeJMkGwfZawNxmvjxX99pntL/jS7sXxiOw/Hlm9e90f56rjl2CT6Pg4ZWu131fFzjpTy/m+J4o/nBv70EaQAon+Qiq9y4PbL9FdCcXUEMgcUVyfNvbS4UpHDGmixTOePfdmC58W/zdE8KyaLB7o5bltPC/7WnNM8vHUyH/CQjdY8KmYhXkr/dWymvxvtzHfvnv3b7m/t/q0/cmizp0zV/RbbVcGjGH/S8CtJfF9e90gk9Ey3XZeL+t1HiRyJT4VPiRjxafnURd0CcoGZ1ip/OzsXJw7fR4TNqKPEQRmcmwqmh5titOY3t1EK/TNX3sh+oYPx3/8938Sb77+Bn6M5CObns0zaC61uWl03XVyR10fjYcefzhOPDSM9olADQtz8UNCeo+gaTo6ciRe+ulLcQZG7IsHn86+7WSDi/Gh7QJ+uGYmJC3NMF2X5s7LJOi+wsQ4fgEGn5pz8VfCg3LwfBYBVaiFm7AnCGtIlj1l7i32XfcFaP33a9m3vfqxvibOgZAXxMpTWFx3YesSwqVb+5x7Bzr2M0+daPzXYxDzQbI1RDd78XDLkejC1i6ZLNeMZ90HJkJNE1YYf9uRUVB7rt+Nf1tkJi3591b77ixN3jyLmljanyzW6w9/21eFcL6nmZtt1Qi/z4U8YzIX1rMIrkxtk39xz71lbQYT2s7oOOv25NY1H3IN+dRML/fmNskT1VAfZxtBXgPYW75v32qa9XlP1W7WysdWcUwd4Acj6qlZYtbKW9s+xT3AGkPb59i35ohF2uzQesSUHAQvAjcZOa+XICbOxV55cGdgj0F6cNf+czdyJWlnrm3EQHdzPHFEvwoAH8Cvjknb7/7FWizAOOnvo6S4vzvit76ChOqP/zCWfudfRh8ht5eMJPfW6Wg9czHiv/uv4HYORNv134vuG78Dc9EPeiVz/OyrJBs9G20n/5cYbzke/+m15vjTl4yQRyQc4O47l6pEcKrGb31jOZ58DMk5faog+ao2IMT/w/8Xa//h/42WYeznNcn7+YuxiclJ7e/9/QTny0SGujY5muYqVYA95BymKYTZhvhpagXkbyUdFSH5K1JQoj2/gsYIIujVsbdiuWspekkQW4QohTBHqlerwVw4NpASMjIQDEEenCxKIkXqKT9BtalVETmOEq1uAB+pZwa/mIyYmqJ1TJbWMHWZn1NbBFKCuaM2AiSMp3bIekrclHXChLYQgCLDpUst0G+RezPaInGljE1TdS6qA2+BlGDs0JqJrJdggiR5UtoOY9eGxFSTICWldcZrsli1X/zJ066zphkmBFRzsB4H4Zt6QKaNtnU0fjUi7BE9i4SAC4zvMnmu5iHGJaoTUdKnlE7Tv2YIAiWzmnQ0U6cMlKFn9Xmy70rajStR+lk5hLsVxyJT+T7zk7u98Au4l8QQ/cqkig5oW/Ees7ntyvu/br+v5X/OydYj7kle558E0P0TFu4T/W9MHKtpjO/fq6itvUUE0g/rGGadD+ODUKXtcgy5H7cqa7AfrrF/z2Ke2ckaP0HgkH72VJ6E3LeMCEIzmXm6UOWZfgMOrLSgDS78MO7Vr/u5LwxKgj8ZgGK+Jfz0o7O/7r07FefVPe5vSvqTapYx0NxoMc9H+a5zoIZIsygJWPMI3TY90vRUczvMmiAGDU7R198Xj37xsTj6yLGozy/E9CQMEvMwM0sku652TOnIZbT/QPT29cQC9yWyDfgi0Z6mZACYTnIcff2bz8f4+FiMXr8RJ46eiMnp6WS+Bhv70sTu2KljsX9oMGFU2dfy07VP7eDWfDsXDc0tmZ9kEnlQczl3GadSTsBduPuekRCvERRn5SI54wY5x11omdR+A6gJeKMC6tOifx2HZqNqkWQCXFfnf4qgPXXgfJ4VOm4wgiPdB2O4Cy0XMKu2ehBYzVrQuePRhzDHwbG/k6lQkygDwtnaOiIyhILVDEDBo2VxVjLKqmeSorCAV/2Sa5pnbKsO90euYT7p2fWuAh3nF0ES/bdBaswnPPfuI/dUtkMTxSowHurMum0qn+Zv285niu/uFU3ZuEyhXtZW9ipr8xwwINe7LL5f4DP2uXB7q67i7aKdYgyFiWD53q6ftNmBcFLm20is2W87CuNoL2T6VlwI+tMOQk9fvV0r2rv4IMzAnSHxgzD6vTF+ZmdAzYlmXwl8AfACPIvAM7UOBfQFcUAYYE721oVVwsgW+PD65CZhtZvj2yPYo//OP49N1Pzd/81/H7OtyFT/8p1o/xf/MtZP/Fls/qNfj9ZLvxNrbYNRe+x/hUkh+/j4D2P93f+dnB5fjLnqfxt//OImzNZq/MZXJ6IZ07yX3hmIH77STmhpcEsBfiFeALyXrkT93/5eVB56KGq/+Tei8eabsfTqy1H/0z+K1V99Hmq+LyYJc3tjaowoeGi4YAAS7SBBXNZJW98oNFgpwWPsIgoDOlQMPgBPYLSo04Qon16ei5Pth3Gm7iHCUzX24U9QIwmkBmUF4WfoVBIvQvQ7Z+W85TwyZ2qXjPDm9LVTsUEpKphEGJJcM8Bkkpj3Wjf+WeTrkEBaXybsd+NSMfe5CsV/tme9VRi0ZnJKbRI1ISW8vN+sZJQfTWZa+07jH3DTv8THEBVqiESQXKFtTSv0m5AgVHu0yNys6l+Cw1kThDW9KxrEJsK1d280o1VbRzpcJ//RCuMdwWeqBrFFT9ACdsVFou2ZIycZMGoQSStnb0HjpOkHMwPSZA1h7jYIWlEQNNRdYd9BvND6tpHe+avEwm1i4M7Pfdp3HI+amvQBgDjxR+LZvy2Oz59kFLmUDE4SIq5KsVYSrv6691zH4g1XibUqn2W9NQ9qxyG/JJTuNjafcV01D0ot6t0e3rq31VObvFU60QYdhfAZlEHefoMnHOEC4zvPvj6zhoYWwrWDvdDLbyeRF02ama84PpjvZvz6AsZIiNJPNLYhzGHN/6UP0P2M6Van7vBF7aeBSiRKrc/Q1oWJFIEGWKMacydj4Dh3K54pS+7R4ivrqBCBCF6M0/WxWHc+CkGqP6BEZ+5j7mmqqqlpMlucL6vp6uqKA+Q+Gnx4X/TM9ET/K/08D7He1xGXzy3FpWsT0bOC2SH+SgcQ8mzilzI+OY6v0hhmdzeSqVoi4bX9fuyJx+K9d9+LH/3gR/F3/s5vZd3dvd1x7ORxQF1PHD52BI0s2nyCQexWZCwSxrGXPJtK/V0lzdUyGh8vpQ8a41JztrOUc1epjQK/8Bld6cXUboDPfgLrTKE9uoSgg+iGOfKdb38CfzOhgL/ci66XfZwmYMgC0T/zHAnoKO4A/UFdB7WiSegD1zVzlDFp2dIgyVTI0KqhSTkZeyc1hvJK+d4HSbmMvugCUrIvzh9tbR35vO4uUfBUmp16EXaG/jjv9Ju9VJxQZ9QTAY7ApNs0FArozM3n+riXZfpXV4Hnmqvxd64BzW8A71vwPXX9ZHQc4xrPsZQpPOJt6ihWbA0Ynow3zxR9AZ7wvQlYtYKAiyOY+MhrySBvbR9ht18NurJb2XoscaBtGVW2CL7CHQ9J0Rx9EwGBe6nfOvfKgz0DHzxVD/Z87I3+MzID8/PzSVBp9iWRb2QbAe9DhyrxynmDMazF1x9HUgjYbG/djN/+NgAWmha4HP/nf1TayvNj16Jx4UJ0/U//czQ9/3zMXn8P84aTEX/251F56bVo/huHkR6fj7UT/3U0D/06YBxzlfajsXL599D8/DxuVP7HGJtdi19/bilOHVkgb8JafOPJ9nj9TAdYAWkWWMl8SiswGY2L52Md05PKFx+PlZdehtG6EdUXXoiNx78QUxBljYWVuDk7ThJKmDeCOiQhquZC0ZvIlNxIazAHCej5z88NrmF7liZ0dk7idrQ+njmd9sEQHOobjHa0IPvQKEmEproFRNMGY6NWoyS0lAZKnEr0LhHYwezp2Ctl4tkaDIoSbxuUcdBcT58h81QoedY0pwsk+jDhxS+gcZpHQp/ITqQj4uTdZpgoAyVssA6tmNMtY4LYRL+SOK8QAavjGkiKNhiEr63yjnMt8ZKkPJi0tL+XOcoAFBJiPNfWzpM+jFpnBYftTUJaaEaVMkDWozMl62idcHRv3fJX6mLte2n/GslwJbJa1miF/rUwPh2FJVINybtmGDPo7bT1p3uwBbkurk2xELR7r6L0V2ROO66ZXf1FF9fZsNlGhXNOJUVcIwks/TsknmRQlJ6yCzhHhFrmWQluO2zfcz543jnwe64xdews1q2G0CiIfvr3bsV+uCdlDKxP3xrr9vq9im3b15xTvkucDeF7dNCoi6ytggmLNSnlnmJvYdQKgzRPMlKFDPj60eZFNEmD9HOEuSkXdJP9tQ5zbbCGDfZCF/Nwqn0ft5vwsZsmSMvHJ6qdk8wTZU4WSskc5R/8l/vr3tNQPp6frrFauHWc4jOfzPZ531oCGeKcG/5u5RxLGOck8Xetsxb9A2jJOe/CAAn03l6ST/d0xuOPHo2p0Qvxlz97HTPYMwmfnnzqi+RQW46LVy/FD/70B1FfJB8bZmLCrhuvj8bU1AQ53Rpx8PDBOHz4MFqlr8eVK1fi3HvnUrB16tTJPHslM/e+wfBHrrF7kh8ZiE7WyGvbNZOtcAqt+B81SNyrr6L7wXmQwBZusGQ5t5utsxDV/HZcBwYAI8zNhCluseYfcqJ3dvROfzOn7exHfWkUKhmxbxa/VJmg/BEuAhdyAXiWLRyXL1yK0TNvxW98+Ymo7UPjxTjOnj5L4t7ReOpLT8e+/ftS+CDsNTXbqmaFDpJ6HIXnWJj7vgKcN+3B1QuXYw6ceezkUSwKwE9ZClhgLrzRa6Nx8qETKTQRVnumhHimpssamXuB880bo/yOb40BuV5PVxw6cjjmZmfizdfeiHk0i51dHfHUs89kcKK3X3srpjDP7GNvPckYTLr89utvY45J/ixw15PPfgkGHJtCGJvxmxNx5q1345mvPpvpJVxrzWMNyX2OeTh37ixCMXxhEfw9+sSjse/AUI7boA4eartYDj/7z6TklNCmn4lvmCsFXEKyd2iro7Mjjh4/DMwrmM+Ea8lBptinmKa9/x/YGdhjkB7Ypf9sD1ykI1Ev0S5SVC1vMINvfKEl/v2LK/G7RLEb6a/E8eFmNB0EaHioGROHiJ+d3ojpuc341jMt0dVBviRArLkc6pmfgtCsZFvXeMPIVpriCViNLGQRAIvgkj72BndtW0mdJgwSPoXZlmiPH5GX1+EiJNRw2Im1s+ej+cv7ou27343KsROxAhHSqJDPaH42x6ApGVRKEmgSUeaL0GRMDEAqu2QUNmGcRIjWXUlpnX8UhUuxRNJFfZyWIAqXIPhWCV+a0j3yLFXQQrViy13Om285j/6uLBMFbkvK2U0oX1EkskUkhssp0ZY5So0ThEsTWi2du9eQcLYxAafI/9QJgXZztR51iF1nUW3WLOZ8FRBUOuHaOSEOzGMLyTgtmyB5Qw9vUIfz1Cqzy7slYe00Szz7t2tsEAsZJF5MJk8TFTVTmzBIG0t9rM/NNDt0Xbt4vsh/wxyi+THykskVXYoeGKQZLk8p3ZQpkmBESi1D28BPS4ZM0kDfIWX1XncOZSBc89IMyrsSnc5f2Wcu3SqSamZxN3y5z/5VFPsq41cSl47DtdHW3oiGMrlec3Rq/RQ0LMIY1IjuqDN4aoxY8zSp2ToLd2JkvC6h6t5NomPbqMt3yvr0NUlNgfNaUjY7Jsg6JHbL4nxqGpPBP1jPJJq5XYERld50DAWRzDmgzuvsnbMkdh3Hp2GZ9pQ32CU/xgnecYk56IXA0uSuOOWcBRzQ1cg0oX2ViB1QmwQ8MILW5cZUOoE7lt3Wu+znvT4drz5U1mFdH7c+27Ov7fw4XzJdEuKup5/OYwe/Js+VXDRAg/NkMara0OHh6OvtQ5trAAHyUCHxf+JXvogmcDOG+zbiO197NF67oBCoOQ6fPBI9RwaiA/Pfr33763Fz9CbEcFsMQsDvOzoUX2n7CgEcLqWG69gjx4kwtxFPvvBUdJ3uitmJ2ejb1x9N3a2cv6ncK2U/sjPb/nNOtpedz3lfE0EZvxbMbR2zbzSz382N5D6sI0S6tbfkKlrmt2r1yffXv72tj/tdgV0NAYMMwSwwcZoANrfMG918lBwP+9aiEMagFz/6wx/GYZjSJ8ELCg5effGluHTuYpw6+VAMDgzEBCbZwrTevt6Ec6Ze0JJileicPb09aGrUtBVFnLSIP6q+YufOniPYxkwMjQyz+kYtnM+56xvsiSuXL8dP/vwvor+/P4b3D8XExCSRRokG2t9DvimFjJwp9pbRCd995z0ShROgAaChOfIMgTwsRjS8evFK9LO2b7/6NkwYqTG6e+ItBI1DI0Px2kuvY37ZxZgjmZ2B/f1xFj80+/7N7347tZE//f6P4y2YrMee+gL59TqSOaownrME//jhn/0gunvwKe3uiLGb4zFOhMXv/tZv5pjVaC7Tp27mrEZYehmh+Rm0dYy9E62lTJBzPQNTpuWBCdfXa2vx1utvxhA+x0eOHQKn6EM3mwnhq5iTOknClr3yYM/AHoP0YK//Z3b0hqyWKE3CdotJUvDz+NFK/IMXWuPf/ng1/o8/aBDmuyURvHzGhZub8ccvr+F8GfG9r+h8eiTaTp2K5T/8o1ga7iNc976ovno6AoS/8Z1fjUbv4yCIx6J19N9Eo+9R2JP9UZ35I+KIXorWI78VxzG/OtC/Ej9/tz0laSbYe/10BxnlCxJfQsU+pqP4yVNROXUy1nF+bn300WgaOhhrP/85RDsMxHe+RR+HSbDYGufGLscUTs3tMBsNEP1Ss/5ClWQ++ltwIDW8tUEP8CHaZMCa2L2/oIGCORqCuJO0VJIPKss6JCyXIf5aYJKcNwMvWOyjv4b2vbwwSpLd5ejc7MgEm6MLk3G4aSE6MEM0aayYA+OOJFDXYDL0ZVrDbKTC+4fb+oh6hzkS9ysgF+JlxOQyvgouDEyRSFYtl8EmCpMOyF0QVzuEhISypkdGudtOeGq+YXyNxFig/nXG7pgNsMEAYdgg+IjuJ0Jba/QxBgh5zCQu8nc3SW1JWxt1nhmgCzK+6XvFdyW7HSQBXoBPS2YRX60kWiGa7Yu4sWPLmTebtwcQlxr03S5qYSB0fd4O7FIkT1eo7BaRtsszn+Yl+yWiX3Kf8SNRKfMyQ1TGDJ5B40xHUba+pJO8jvowk23JWDFH7CPNWrY9Xb71gU/blKlVQCBh4q9nwU/ZsCTo3EPbGCP7tb3YVwlftVgydt6X0F+BEKxrbqrmiz1nkVG/SSCFUST2x8nVY+APmaNLnJWzJFtmpLQlocwabTXjBzXEPPdWeLaTd8o9xuHCmR9CmvaJtJL97mOvPFQzx1jExaUp9gjENt8/LhG1c9yO56PWaV0yQrUmNakF064GxnlyriW4NUHyhJXt+py52+CrotbVhpaDJNho0CTue4YI5b8yE7PTb8dwrYJW4OGYaR/Oeq4R4t817Xt4MLpP9SmvyPm9tnYTH0sEU0MPZyRKcxG9O3c2z9q+x0di3+YI8xpxbfFm7kHH6r74OMWxuE8JAp1zV+wX9gX7phm/n2KXlC18vLbKWu79qR9lIWipswedf/eLxXnzn6Vch/wDZnYQpuT85atx8snHYwLTZQl3NUDCjzdefiOuXb2WDM/woZE4gjbotVdfj2WiBa6gDd8PI/L0rzwTXd0gOMY+PT0Rr/74JRiFety8diN6BvpiBgbrystXYmFunnO4Gl948om4fOkSQTPOxo2ro8noXIRRk5Ho6u6Mr/7q19OvTNPlt994O9dYU+uTx4/H0jJh1bFGOI0m5uChg/GN77wQB44ejn/3r34PrddEXDx7KYYJ8f6d3/y1+P4ffz9OE73w6V/5UtZ5/OTx+LP/+Kdx9fIo60Pdr78VMzMwf+4H4EyaJYM31jjrP/nRjzHR7Ixv/bVvwxj2xdTkZLz8ly/zLFq38xfizVffxCpuhfQSNfrwjdRivfbiK+C6ZbRNbfH1b30D4V8jXvyLFzkfmA0ytscZt9YD4oPJKbRfL7+W77kij6GdOogJ6F7Zm4Ht2H5vNvZm4DMzAzJIlpIA87vIllgL8feex9QGJPxDEsX+6x9sYPoBMQTyWcTjdbC7Kf7Z863x+CGIro2h6Pin/0VM/N//V7T8i38VPV0DUUV6Fi98JQJgvFEdjjj5X8bm5f8nFvE7amwazvsiBMCvxcbw346jnJ5/8EJL/P6Ltfijn+yDcEdiSYCGtIYGGZrLp59Q2b1tvdF+jHwc/+SfxPLv/m4s//7vI8mETCEKXMuXn4su8ijVuvtgFFri0OAIJi4NpL3tBI7ojJkVfGgA7hVsprsY3CLaIQkdcz1oZqQWYBlEnPMAcBf59te6qCttw0joSt4gAjw0wzS1oB0TuUmgLoPc/C6j5Lt+ryPpvDh/1alMAnB0Hr8LtEqDG/viVBwGsfA8JjiSuRl9jjEasGEFbYTRKIwQ1IlUsYY2yDa61/GJ0KwR5A7vl8SARK6S1JIw0BTC3CVNJumDWC19orITW//RDEUCGXIOAk+pZqkN4RK3YJB4aH2lC6SIprBSj/M0PASirSPJXMIUZwHzKs2vtBmRKdtkgyzyrgR4jh+NmLl3lEJbamhOMiaYhM0divtNv5S7MT9JlPPcX1VxVt0vrofFnsgIp98G01HMbd669V+uDTfS9ItcJDKzVdfXQBmuFT8S1ncrEoSLJGu0AfdkuT99Tw2Sc2Y92daOijTNc10M616us+8bAWwaxm4OAr5cp6JeJOLsgfPsnzVMp4yyOA0TeAMGqcHa18hj5t5RsKAmjwey/0a9G6CdGudu5xJtqHlFm2rOrWaILIfbw7NH2wh7D0M2vgprRV33mocdQ7vnn85L/tJj5+3D1p/zmevqmdePAkAIMW6dMq1pysj8l8XnJeSXMc31u3vaMypMmSEUdffaXBxYG08hwPhye4x1uWNYv9RMFfmqZLjdDfZVZiwZFB7TTDH3EO0trC3E+PKUXaEPRBpFCGMd7Qghqvx6Jj9OKfeR+8Fif9T6pbks8Ma+lc/kA3f5r5zz+31+t6r095on15H9yfq2D4/vmQto24vFaVqLxx85GbNYE4zPod28djMGBgfYh8wVjMLY6A2YkqWYJHjGBZiY1va2OP3Gu3Hk+JE0v5PJkEk69ehDwOnmOP3au0QfHEdDciQmbk7m+OdmZ2NuEkaEPlx470JqGPejRRkcHMTUrR8m5p3Md7eM+eSrMCEnHz0VnaeOw6jgbzY2EYeOHSS64UqcoI0GjJlmcqffeTfbPXj4QFwnMMcS1x8hiuGLP3wxoxnKuBw8cgAG5VocwuSyE02QAUCmYXROoWG8dulqMlPPwDylFod1Y0Owd9iH4ELN/773W9+L4aF9aLuup79bZwcCPPbQz77/09QaHQG/vk5/ZZauXyYiKnjqyNGj8QYMpNem6bsRVw8/fDJ+9Cf/KfoG8UVj0rXAeP2lV+NnP/wp2q+BmGS+JunX3/ntv5u4btsS7X19AGdgj0F6ABf98zDkwn57l5EA9Pb1Ncdvf6saTxxribMkh52YRYaIecVQTzPJY5tiaP9CvDd7NZmX5he+GnMbRFF792JUCetbef5Lsfbss7EyMhAzi/gE9X8jhlpPRGX65wS7xu+p+p1oGvl6VDqP49+zGc89AvGIJmZshuSlaGdWNpbij15Ew4FyZrB9IP7xo383njrweDShfen47l+PSk9/rL39BhJqpPMnTkbrc78Sdcwlzo2D8CBmatWWGAFRDXT2RAfSuQWkXYUVBmi2qgER5AljlDiTMHlr7Ey8feNM2mXLvGhyImN2Y2ErVDjR+gxdKqEu8SID4mdK8UG6fnpN7dINJOMzRHhrq0lQYooIIdpYbMSra5hHQMQMt+9Hgq/pGcQXjIYmjRsQipppNaEhSrMniNMGpjer/LYxPy2rhiXG3EptDH02+IKEUVk055KgakOD04pGqiSmJeg+UHjNcZRE8/vvQ4gQpWq1PpThexdgeM4RpKEHB/tlbM4XMJtTet6kjRXUQYXPNHukkmWYzmWIR+dAOkaHcIaT0bN27cf2hm8PZfvVX6rvjkmKUTLR6H8SxAUJee9uStxppqUmQMYGt/6cn/sh3n3Xf2ox/CyLhKc/uxUDPNTQ1uhPk1Rc+RB90BSsvlxP80e1kv4IByRC9VOZRUBxDv2lxmWGCW6CCdasLPcL+0an9wqaJxklnc8N1NBPO+ioHGXZUn4m80tba8msDXCu1LuglUTQoMndBFqBD+4NtTO0gblnmtdu1Slz5gQkg+++42e34niSkWGuKxtFKOfdnvsw13KemWo1pprfWRr4CW6PEua1cizFrBaaqFaZR3z3NPuVvXbXOLfNzKXLBxjZgkO3/bJ8333ikB2nhLj+gUsLaPzXgCsIT7J9tNLRMpdwpEpS3/etNa98EsW+ZM411l2G3TXO+dhRebH27CU6W8IWrwkny3u77dbinlNx+67XZMyyHurLiIW0l88yJ+6E8mn3mBryosDAL66QhqIPuLMS56+MxvWrY5in7cc0bgqYyr4F9spu9RA5dGJsDGaJaIxoi55+7uk4dupEXLp0OQNoJExn76ttOgzz9LUXnkfj3pqmkIswW3ZCzUqHAjcsGgb7B2Lk0IE0hXv9FXxv6b+RClfBDUuLRcQ9+6xmR7M9B7BMPf4y2JwnfVovX7gSr/z85TiAduuRxx+Ll3/6cpoYAtYTN3Bk0R42EQb+erzyk5eiC5O4Lzz9ZPzh7/8BzNIcwYQw0R7FjO/t0/EMmrAKuBC0kPOZubrQ4M/D4N24fg1G7gzDIK/htWvx9//pb8cjjz2CT1w9Lpy5GKNXrsbf/2f/MB7G39f39F+agPH5u7/9n8XjTz1BdMXRNN9zLSzn3jufTNbBI+Q4BBdrjpwLpUBtrzzQM7DHID3Qy//5HLyIp6u9El97rBLPPVyJBXIdSfFCqhOFbDV+OP5aXJ67ToLXPpA/OU8ePxQ9p56Lvi6S4sFQECw3rk9fiItT16KvYzBeOPxVkMfXIAyQlGJCZtjuJhBbvb4Rf/IqOVLQzHz7aRD/akv84atEjAMhHBsCkaHJ+c2T387M9PqhbMI1NT//jah+6VkQN8QUUaOMAreGGZq26uZwGCD3wkGSM3apctkkUW0V8xGQWRNEfqAtIqwb0jV+QQ6LmLatzq+iLbkI0Yh5GghFU6KxmUkCNdRTenqpczRq6x0QJlsIn08JSpG/xU9/bfvy8rXYbMMsD0ZLhC560Jzt5up0vDpzOr6+r0byXEyO6LtM1SYagiaYC6WhZiLPQAp8iqAbjHeSvEybaB6a8BOySGjrdyHzJVEhcdtDjo2Uc1On/kQyfuZ9krjKKE2JqQp8lZqHrX5nhTv+24SYW5v+AlMD89ZxNUYh6VrgLjN621Y95SsFuVT0x7wkaQJDnySi9QdISTtE1Xbip3z3s/Ipke5cZ9AK5jWZatalJIY/7DhcD/eRURnb8WOTELyfcr9z6L5sT+YIjc022iT3KjT3Ooy+yyghqymZz/iOzJLapgwK4Xv0sQpD472ybb/jrULQE0w2TbjM3KywvhNoDQe53gPx9b7C81BXEKFzscK57a31JrFm25r/SPgWZ+R2R82b1blBWHAYEe/6bLbPHpQOXoVpqzctYhK6O4NUtq/WRW1mM1qAu0WzK5+/30/PW3vT7kxSOU8yUjKDVcwVK5zDGlqQVtbbkM8rChic9K3iN9ehZcPgDyWh77Lww5gNhLOy2AlzNBzLs0OcZ85WBa1i282o1NB6c95liJ3qT6O4PiacZjskbNKE173kdRvVcFNmQLOrAgYVpl0AuDwjmqAKF3P/0cF8j0/3vZpvu11o3ApSO+viuqahmgo7rvTbczcIYz2D4gF+3H/CQ1w48zw1c68JAY1l5MjRePnl18FFWB/AMCn4mp6aSr8utUUGLTD1QEZHRYA2NUE+PnCEkU7FFTYsI9OBlmV2cgam40Zqf/RnvU401eX5pThOQIZmtMHiHeGBjJJtnH7ndJqY1To6uceqbgUS8dlDMD5zs3VMrWtx4ew5/H5g5OFgevFd0r/npZ/+HC2UTM8XM7rdPjRT+qLZ1oWz59FyDZJ8eCp+/Oc/giHpiGe+/DTPtSKwHI5uBIIyYytYNtQX1BAjzGNabevEQ6fwYXo165ZxO8z8vPTTV+gbcL61LW6gYTJE/eT4JEwX1hNTtdQ69RPoYor2emDElvDVGiO4xOAQpp3MV5fjY/7dHDUEgpvAguMPn4KRGiv2hvtaRL5XHugZqPxvlAd6BvYG/7mZARGZhND24l8tECRqDAzscL0xET+68XKaP0xB/IzXSXhKhviVTZxiu2bwu0EKNYGE6uYFErBijoBpyArahwNdBwiLWzhtp/SaihuExHv1fMSfv74Wl25ukAMJs4arzfHsyeb4689BkBEeul0pNmp8neCXlzDjwqa8CeanA1tqpW4FMdcc3WiLBrrw4enZx/M6WoNEYYSE4Wl2pq0ayBqWBuSnxoeEpyCUFiTNRrqbXMNsAoAuwjbSm4yS0jNzBslwdOGbYXF+St+jNHXjbwmnDRixifXp6O/EURtWcm4JCS8EkSZ4ZhnXTKuFz/2dAzB+PSAu2oV4WtNsh3lN0z2QdQOiQhOkm8zbRRzaV5HqV9sNOkEbjGlJAoE+GszCKE8j1OeSNUOgtkPMJKPHd0N7p/ka47DIrpkc0/DIjCKv5X+8vLnSE2vzx/mTNtYZJyF9o4VIVdX5NOExetv2IgEns6UZ0TIaP5kjr9lHQx9DvXCvcPje+d62lrff+qX6LkGYvlsQXWoZXRPNmmSQPipzVA7Q9/11z2QUtPLGx/x0/o20Z4jrW2eYcbg2GZWNg7CCZkUTUwlMCfP0Y4O4tR9dBJTItaMe18/6/CmLjJ17x7mQ+HJHMRsxx76GViVQA2Z9rP/24hyqVTTnVZV90cKelMi9TjSyyTW0ydS5vY0aPm9dG53RqiaavYj8O5mpVjQkfudirBBxLTVq2xva8d3x+eM8yNyrrfskiufOcSdscNz8bC+2p2ljjXxSaqJZ5Ggnct/+1TE0aU0xVhmM9VYijm2959g1o3MtZAazdgU5lLXljliYORALUydjaWYk57yJ8NpNndcRXtzkbM4gqYc4JRhEMtq8/2kU+2gQGOexCLjCfuFvI7XJVOu7VH5mWG2YG7Xa/sroyDA6NoGU/VS77PNpGkgdwmZDpvuumjYTWuffXM86uO49mU4ZKKsSDlok0GWSDvcciAP4sy7AyDTx/sjDj+DXczZN54wCqPZj5MABtEMz6c9qdECDLxw9fiyu4D8kc3Lt8tVkOh4nwEEXkeWcTdu7dJ7IeFevJ+FvEIce8M4qZmue3xnqk6E69fBDGV2wB9M3kwW3ESWuASyfIADDY198NIaGSJ5Oaafeed6x8vk5vTsVujURUe6RePu1NzH3eweGrjeDOegjO0zfz6O9GcX/aRY/n+ee/wqmdOfRMr2SDM0EDE0D8/Fnv/wspnwPxT7amRgfj298+1e3xuBaoeWFSbx+9Rq/jANTOYNIdCNIfPYrXwLHVuL82Qtx/co1tEvz8eWvf4WIeb1x/swF/K6uswfn4ytc68ekTk2STNLbb7zF3B1nDproR38cP3k8tWsmR54YG6cfQ0TmOxSdCO96q9234VHOwt5/D9IM7DFID9Jqf47HKvJvbAF+gX9ZCmIL5J3EDAQXSHm6MRML2NdvQKyr+WggAZVsaTRNxFR9Nq5MkdOjsZTO+yKDqfo01W3Goa6RRJrWqZakGULs2FAz2ip8XbA/aQHgPn084m8RAOJgH4gTCan+DShYeB4zLx6yHyKlNhDh7UJeIRBqrdoJEjY08lb/QbxiIwG5juOiVsSuaKwgFpEGyhA2Q93t7x3E+G8xphiXfcvcSDBmSmjrRJGbxxyokwSaA2jMakjkygh2vi8DZHShDnx1BjpAFt2EPCVS1XtjZ0HeNAlRp49AB31ebiJpLQTFwe79KLPwBZmfTDOLlf+/vTOBrbLa9vgqHU4HWlpaWsotQxmkCorcXAPi8J4+NZIIGl94xuSpxJHEGKcYh2gccSYqQb0oIiZOgIanURGHxPgcIxF9gqBeL6BBxgKlpS0U6fv/13e+4zk9nYBypef8t9Lzjfvb+/ftb++99lp7bZjT0VFBHTrj237fbRtgdreptd6a4TkuAuGIHS32DLgAn3uHQ3bYcSmAUFhZUOIj/1zfhPnkr0uJtgAAGNxJREFUxFn+x44IO3LsXHA+VS46sE3o4PJffKfU+xr7sYZIQzXSG/Da3wKNWQuF2Ra4Ja6zQq4Ej7vCwE43nRaww01BifGxM5ELQSqC90XzIwqXoRtkpiPQnlA4RYcLaT1iA/pe1NLRlK4Zvy0YIaZGIugc90yqWcbIhp3MngrkXwAhhx3SMLB8UmtE801+EtT8NME8zEP0dTIt1DpRQOJ3zwVTXQ6IRsLLuE8mjVi/he8+9DTJS7gcMT26VUA464tvK+i68h4IEujkZeBbo7CeE0HaoDWrxbdEJw0NSEd8OfQyFP1um/tAEMO3sicD7wFaTLpj3p8FwRLrpO3HsDj/60xQZVx+Df6Si2vLovk5mB/mhQMcLiyjzPNbbe/5ZOmBuPFc1CSWvW8n5iBuhyY407ZlYT4MNOiBKMRPOvhumD7O2cvHgMc+rDu2c0eZNWyrtsb6MnxLmFcIN/5ZxT9ZVtFay8rbijqlEYIFFpnG6D+1frHnHkzmunFP+H27oMR3iWdSw8hns36h4MM0xKcjuAcEUKZ8MV38cvFuX5MtKhAx3/wOXOOGeBm/cws5RtPmcaFs8Fkso/wv0MSigkX9XYX6dCjm6RTnwT1+aYWVwIEPNUdVw4a4tzq6Wx9SPQRe5ko9xgpoZoaPHoV5NMXuOY5CFOceHTNujFXgl9otaoYKi+jVDYNtqOOHVA+1wYijelS1FRUWer1fBe9tg3l8CLwSQuAoxRyfkSNHotRh7SsIDjU1oyHkDMQ6dnCxjmN0r90XXuHIjucLi4owJ+kv7r2QaxSV4dlcSysbnOipcEj1YHidw+K8uHck5iRRk/Q72q0BFeW4F9ehDewP998Vgyp8mwN3XCurEvkhS9bZbAn7QmtUMXCgvwvy4z3H/W2cVQ6qdKGKHlJzYD1RM+ZoPGMY4kOaKfhiUOO4sWNsZA2ci8DT3QZomqhJqq/fDbfpY616RLV7sRsCzhQOKayWV1bYqJqRlgtveHlog+jNNb5cIDkKaUQATkPim5M0yrmy2qsJtC22FI7o8pSVLCvptoHX+z2ocdfv2mD/89N7Vlu3A5UiOuM5JVCzYxQQnRjO12GH2BtNVMZowVwu4Rof/1410Wr6j/Co/3BygIocHStYLcBmez8ECXas0ZHGbYX5HDUMnlu3uwWTXwOnCMUYxaOQEuSBnRJohtCxwwqV2I52UvwpQUeN7W0rBQOewrP4nNjaRWgIOeK3rmmjLVv3EbxQwWucNyvRCNAGs1M4INLf/lY+1kaXDEcHH+lCB4Vx+AgomDFqNmTM17raX+31H5dCuGpEQ5EPU498byg4op4NM6Kj8oda2T52njgW3mp1MD3cjgnxO6GNaUCHqAUmbozXR5Yh9NDMhKvHc5FXpoWBaawsLLWqvsFilPsQL7UDDRBMueJ8YaQAY+59bCjmcUUwAp+JTuaaht/sn/Vb3PsYOx1haG0ptMYNZ1hrc3/wYS6C3GRGdlq/yv+zvwzc46PiNAMKzZfYWWQnMey8cCSZAhJHi2keyPRSSKNrZzoH2A6vZjnozAzMLsDaOblWh5xjeVw8i887cgJHpRtg2rinhZq2ng/suOPNunDLuULc74lAwagwUghhhQMEQZxexrHIMzVFNDdrgBOR2iasReRzqALyNI/qF4GAj3lBFI7azq1hSYgvf34XDvK98/vj+z46s9DG52DwAGkIn03hjPM+eE1eEcogNLsZKB//bK61lSiHjRA0AiOrP3IfXyb/OEoNdha8uGFgAuWJz6ew3QwBi4MFEJXiL03cRjojEDp4r6/1kni223v85vg8flccfOgoncy7fw/oYLtWJRPffstWO6YF8zPBdnXWMKsrGIxPLDnN3umHk5Qtm4ttwxZoxzNR1xWusz4w8bU+1HwEniGZaGqLKVDRTJMCxREfYkUchFh2+Ich+kNurO9ZHryuDs4m/GVdyHJALTg+US/DdVhaYj+WXjhx0Fg7AWbVeSjLWzHHby/+cSCG9RPLn2sRUQ/xcXyOa05xns4EPoNr7HF/Pc6FAl5AwcuXleC7xDbfp88b8jRyGQVoW3MxgIQyEZj8YZkFpKsggkEkJgxpwKWeN9b39ZhX6wNpeD7XZfJRM/5g8IDX8r1T+Eai/Fm8Hf/zaWhfgrRyQIL5oGUp2x0Xe1Df02ycc0IZP/PFwO8Re0EacCUXrPX8+n3BNxsKLK1of5rxLbG9Zrxss4M6ndptaPRQp9OUnXN2V6xYAfPBf/jzmOZJp0yyUszvCtLKNCNuMNmDPNMUkQJaIb73QbAcCZ8XpFB/04kAh1wVRKBXE2BHqgmmazTz4jY1NBRAPERrXlZy/g8VYTkEoqyWPr4yN81m8gtgWgLzMapLqFFhI8M6OmygWmFnTTO2VTt+sAH5/a0sr78LAIxvN9TyHNXKhbYmF9e0YrR7LwQYzuNhG8IBcf62YBEmXs+08RlsMKIJ9Od6w+TVdfRw9CdoPNiIoPHAcxgofDAuarGC/SyryquwmuIR9uXGFXBzTR0UGyBU/7iFnc9tMMFbXrvShZYxZUd5GpgWBqaF62jQpp1me5yIXwaBahdc/vKRdPFMFvWY19QEl7GbMEF4cKTUakoqMaqOTiNM6TB1HvOz0KAhb7kQIDiKyaaQ7pD3QRhhZ5DCCRsiBk4aLoSHPbaMWegUM43UdjXvhgkVRtlbsjECig74MHgNy8Ekb06sx1giGrhG+wFmkBARY3FlYB2prGx4FWvGgp44HrSuaBibi61p12BrLF3p15IlJ+/TaQTfL9PC5/qoMDRuOdgegA5pCwTDenQaMFsCI+fQAiId/VG2KpGOIXCh3A/ppZPjBmifMIUZsRxJIeiMHEkp6k5aKCiwI++mXdEbvKzg+/FOFcoyOy3UWgXzOKhdDEybQm9pLKMHEvgF4mu0EpiVBeZ14TeJbx/fArW+/q1RsEGHi8I3vxWmtb13zjPthUBjFd5Bs6FAa8IqgGWxw/twARfwhf6JBnodxN7eExOPhVoo1gexzn3iJb4XfpvUqrqbdnwPLfAAiIUB4KwBHv1aOcE/mTFzvashYts2lcEl+ADLjGCux8BfLSNvI7633W6KzE4q42caODJPE7XeIBwF7waJZwWMH+63ohyybuN/7Mw3e91Js9NAu+yaJFa80VfOeyj450LQ3YtBIL4DmpJyEIMaUZpw0rQ4H8ILKkm4J+cdf3BmvUXBgZwZqOmg0MN5PH+dCC+ocIHNQQAfG2JS8Vy2FKyDPXi6g03+bcUz9uNitpU+1wcLYnOb+XFpwi/COmJ0XIPy5znF81gGfZYUBSnsM0EckGBa3HEH4457Vjg4yOuo0eIvk9T6OwRAzIvNyIIZN+rjKCY+NWh7fSvxjy9rET2EaDwEcyuRFzSwfC6aby9T+PE40QziHB9qNvKoo1zjtad5LzRQxb5wLQVIjwt/WObJgm2UggiEBKRBCknot1cR4OrfYQg6+Byh9OrOO//s2HiIHvMKPXoDzac2QhPBkWgKHdQ6BY01Kkxc76NwqDrD+Hibm0egISiGy26O6DJ4AxMVUrjvAgl+Gad3RlAxc0TN04dGicE1K2Ha/Ejnf9g4MjCOMP4gbjTOOMfjfB5/6fJ7K8x/vNbHc8Pr/X78wSFPe1leSTS/PBPEHUw6D/LEjiYXEm2AOZFPOIbQw7AXeWVDx2dxRLQYZkecRxWYG9EUCE0pWkA+JwxMIzt4NJ0j1/Ac76fpHEf9eAfP0PRnL2zfOZeKJjgcPaTXMDbzNHeC3RzMIeHCGY0qOyZhXNxqxbyjVpjWxQ56AnAGI9k5eXX+HDaHQQkJ/n75yRf2K1aYn/Kf52L1d2qsMLEZghHsulwztgediH3Rxp+LM3LpXJ+gj1gw8AuzRjSq3isJc3sE/CJdnIzOd3Q4AmMld9cOegesp55DYZWjwNTihIHfIMsx91HevRNDDS+F4KAzFH5nfqCjP4iDHbm2AhSfQy0lHTRQexR8OEEkPoEe75zlmaZ1fdh5RRqaUAa5EDLLdHfCqm9X2Wq4Xz7trP/weSS8h9nhs5mfQOPFvfYDvw1+Y/xKOr6q/Xvjj7Lku/nhAcRCZyWZ4JaHNaYi0BI3YnBgL7RKQQ7iY0fHeW825pPAOQU0A1kRaFtzaApLAS/49pn24HtFRztaPybGcITuhdBREMPNWL0aZMjrtuB7w7tifYEyEy2ysUyxXPN4GAuFDnqrY4e8CJrTvhT+ce9eCE+/+3UhL/6yXo1FFdvwTxwnfv7HT/bJx5/axEkTbRQEAQ/R68PbwuqA8fA7Y174PfB4mOZYxNENF36iN/IahjD90Uv8/iCzf6Q3PBf+8ln8nhioDcJoIw5gABMm0LCfDW/3823/dJR3Xscow3aL+65pjsbGdxTfEnl7gWPMRTAAGqTHDzAeHGfe/BzjwrWs60sKsbSHQtoSCHo+aZt9Zby3EqCHnkMJRfAQlGqhL7rw5cXBhNpDzVt/g7naERoGHnC6Atv9trc9/b9z7O2337aL/uu/raq0qu3pLvepr1JILwIHWmu8vfJNWzD3efu3iafasLEHXsaOJLrF3U4MXIEqHBSBwJXOgd368boNNvepv9ugikqbdMKJB3azrhYBEeiQQFQH2+F5nRABERABERABERABERABERCBtCEgASltXrUyKgIiIAIiIAIiIAIiIAIi0BUBCUhdEdJ5ERABERABERABERABERCBtCEgJw1p86qVUREQgXgCDVhskZ4P6XY99BAYf17bInCoBOhdk/8KsfZMzLPmoUaq+0UgjgDrMNZlBQUF7iU17pQ2RUAEDoGABKRDgKdbRUAEREAEREAEREAEREAEUouATOxS630qNyIgAiIgAiIgAiIgAiIgAodAQALSIcDTrSIgAiIgAiIgAiIgAiIgAqlFQAJSar1P5UYERKAdAhs2bLDFixcnneFCtt9++6298MIL9u6779qePXuSrgkPLF++3D744INwV78ikECgozLGi3777TdbuHChvfbaa76dcGM3zre9XvvpSYCLk7Ou2rVrVxKArspYfX2913GsB3/55Zek+3VABEQgkYAEpEQe2hMBEUgxApzAfMstt9iyZcsScrZt2zY7//zz7f777zd2bp988kmbPn16u52PzZs32+23327vv/9+QhzaEQES6KiM8dwdd9zh5erHH3+0d955xy666CL7/PPPecpDV+fD6/QrAk899ZTNmzfPy1s8ja7K0Nq1a+3cc891AX3lypV26aWX2hdffBEfhbZFQATaEMhqs69dERABEUgZAl9++aU9/PDDtnPnTquurk7IF0fzBw0aZOx0MNDbGAUmjvRfccUVsWupZbr33nstIyMjdkwbIhAS6KyM/fDDD/bxxx+79rK8vNxvufvuu2327Nl24oknWlfnw2foN70JcIDm0Ucfta+//joJRHfK0AMPPGBTp061a6+91usxaqEee+wxe/XVV1WvJRHVAREICEiDpJIgAiKQkgRoUnLbbbfZ5MmT7cILL0zKY35+vl188cWx43l5eVZTU5NkAvXKK694J+L000+PXasNESCBrsrYjh077LLLLrNQOOI948ePt02bNllra6t1dZ7XK4jAgw8+6OXloYceSoLRVRmqra211atXuwYpHOQ555xzvJ77/vvvk+LTAREQgYCANEgqCSIgAilJgALPokWLrLS01BYsWJCUx3jhiCe3b99uK1assKuvvjp2LUdnKSDRrOXFF1+MHdeGCJBAV2Vs4sSJxn/x4cMPP7Sjjz7ahe6uzsffp+30JUAT4YqKClu/fn0ShK7KEIVxBmrLw8A6MScnx7Zs2WJjxowJD+tXBEQgjoAEpDgY2hQBEUgdAllZWS4cdSdHXGzxrrvusqFDh9p5553nt9BhA03rKDANHDiwO9HomjQjcCBljGhovkmnIHPnzm2XVFfn271JB1OeAIWj7oa2ZWjjxo2+gGwkEkmIgosXU/ukIAIi0D4BCUjtc9FRERCBXkKAmp/33nsvllqaMx2IORw9Qt16663unIF2+dnZ2R4XnTZQYKKJnoIIvPXWWwmT4ylI5+bmdhvM/Pnz7aWXXrKZM2fa6NGjk+7r6nzSDTqQcgQORxljfbZv374kVvSIRzNjBREQgfYJSEBqn4uOioAI9BICdXV19uabb8ZSy3lE3RWQ6Mnuuuuus4KCApszZ47169fP4+Gk6CVLltixxx5rN998sx/7+eefjZom7lOgKi4ujj1TG6lPgC7eaZIUhrPPPrtbAhKdfMyaNctdxHOiPecgxYeuzsdfq+3UJnA4ylhZWZlRGGpsbEwQiDgwVFlZmdpAlTsROAQCEpAOAZ5uFQER+PMJ0Dvdyy+/fMAJoRB0zTXX2IgRI9y8Lt4EhXNLLr/88oQ4qanavXu3HXPMMTEtU8IF2klpAo8//vhB5Y9mmjSre/rpp2348OFJcXR1PukGHUhZAoejjFVVVRlNQVetWmUnnHCCs6PTBgrm8fOSUhaqMiYCB0lAAtJBgtNtIiACvZsAR/U5sjpt2jRbs2ZNLDNFRUXuEvySSy6JHePG1q1b/V/b4wkXaUcE4ggsXbrUNUc33XSTe7yjoBSGsWPHumkotQYdnc/MzAwv168ItEugqzJGrfhZZ51lzz//vDsHobBEpzPUgA4YMKDdOHVQBETATAKSSoEIiEDaEeCq8+FinVwbJD5MmDDB1xyJP6ZtETgYAlxri+GRRx5Jup0LF3d1XnNEkrDpQBsC3SlDM2bMMK6/NWXKFHfYMG7cONeet4lKuyIgAnEEMrAWQ2vcvjZFQAREQAREQAREQARSjADnHVEryTmXCiIgAp0TkIDUOR+dFQEREAEREAEREAEREAERSCMCfdIor8qqCIiACIiACIiACIiACIiACHRKQAJSp3h0UgREQAREQAREQAREQAREIJ0ISEBKp7etvIqACIiACIiACIiACIiACHRKQAJSp3h0UgREQAREQAREQAREQAREIJ0ISEBKp7etvIqACIiACIiACIiACIiACHRKQAJSp3h0UgREQARE4Egk0NjYaOvXr7fm5uYjMXlKkwiIgAiIQC8mIAGpF788JV0EREAE0pXA0qVLbdiwYfbRRx+lKwLlWwREQARE4DARkIB0mMAqWhEQAREQAREQAREQAREQgd5HQAJS73tnSrEIiIAIiIAIiIAIiIAIiMBhIpB1mOJVtCIgAiIgAiLwLyfw1Vdf2cKFC23t2rVugjd58mQ744wzEtLxzDPPWElJiZ122mm2YMECW758uVVWVtq0adNs0qRJCddqRwREQAREIP0ISIOUfu9cORYBERCBlCRw33332YQJE2zJkiWWmZlpy5YtszPPPNNmzJiRkN958+bZ7Nmz7eSTT7Z77rnHNm3aZM8++6ydeuqp9vrrrydcqx0REAEREIH0IyABKf3euXIsAiIgAilH4LPPPrM777zTLrjgAluzZo0tWrTIvvvuO7vhhhts7ty5rlWKz/Qnn3xiU6dOtc2bN7ujhxUrVlheXp7NmjUr/jJti4AIiIAIpCEBCUhp+NKVZREQARFINQLz5893rdETTzxh2dnZnr2MjAybOXOmlZeX25w5cxKyHIlEjBonCkUMo0aNsnHjxrnr8IQLtSMCIiACIpB2BCQgpd0rV4ZFQAREIPUIrF692oYOHerCUHzucnNzXfChVik+DB482HJycuIP+b1NTU0Jx7QjAiIgAiKQfgQkIKXfO1eORUAERCDlCNTW1lpRUVG7+erbt6+1tLQknMvPz0/Y5w41Tq2trUnHdUAEREAERCC9CEhASq/3rdyKgAiIQEoSGDFiRIfmcevWrbPjjz8+JfOtTImACIiACPQ8AQlIPc9UMYqACIiACPyLCZx00klGLdIbb7yR8GQ6X/jmm29s/PjxCce1IwIiIAIiIAIdEZCA1BEZHRcBERABEeg1BK6//nqfgzR9+nR77rnnjHOSFi9ebFOmTLHq6mq78cYbe01elFAREAEREIE/l4AWiv1z+evpIiACIiACPUCA3ug+/fRTu+qqq+zKK6+0/fv3W0FBgZ1yyinu5ruqqqoHnqIoREAEREAE0oFABiakakZqOrxp5VEEREAE0oQAPdFx3tHIkSNjLr/TJOvKpgiIgAiIQA8QkIDUAxAVhQiIgAiIgAiIgAiIgAiIQGoQ0Byk1HiPyoUIiIAIiIAIiIAIiIAIiEAPEJCA1AMQFYUIiIAIiIAIiIAIiIAIiEBqEJCAlBrvUbkQAREQAREQAREQAREQARHoAQISkHoAoqIQAREQAREQAREQAREQARFIDQISkFLjPSoXIiACIiACIiACIiACIiACPUBAAlIPQFQUIiACIiACIiACIiACIiACqUFAAlJqvEflQgREQAREQAREQAREQAREoAcISEDqAYiKQgREQAREQAREQAREQAREIDUISEBKjfeoXIiACIiACIiACIiACIiACPQAAQlIPQBRUYiACIiACIiACIiACIiACKQGgf8HTJbl2Kxg1jsAAAAASUVORK5CYII=" alt="Location of potential sample sites." width="100%" />
<p class="caption">
Figure 1: Location of potential sample sites.
</p>
</div>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites1">Table 2: </span>Potential sampling locations.
</caption>
<thead>
<tr>
<th style="text-align:right;">
id
</th>
<th style="text-align:left;">
stream_name
</th>
<th style="text-align:left;">
wsc_code
</th>
<th style="text-align:right;">
utm_zone
</th>
<th style="text-align:right;">
utm_easting
</th>
<th style="text-align:right;">
utm_northing
</th>
<th style="text-align:left;">
watershed_group_code
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right;">
5400202
</td>
<td style="text-align:left;">
Tributary to Fraser Lake
</td>
<td style="text-align:left;">
180-374000-33800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388986
</td>
<td style="text-align:right;">
5997007
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
<tr>
<td style="text-align:right;">
5400203
</td>
<td style="text-align:left;">
Scotch Creek
</td>
<td style="text-align:left;">
180-374000-36600-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
388277
</td>
<td style="text-align:right;">
5996946
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
<tr>
<td style="text-align:right;">
5401774
</td>
<td style="text-align:left;">
Sheraton Creek
</td>
<td style="text-align:left;">
180-374000-95200-01900-6160-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
337849
</td>
<td style="text-align:right;">
6006826
</td>
<td style="text-align:left;">
FRAN
</td>
</tr>
<tr>
<td style="text-align:right;">
9902577
</td>
<td style="text-align:left;">
Beaverley Creek
</td>
<td style="text-align:left;">
180-069000-07200-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
502369
</td>
<td style="text-align:right;">
5962508
</td>
<td style="text-align:left;">
LCHL
</td>
</tr>
<tr>
<td style="text-align:right;">
13900077
</td>
<td style="text-align:left;">
Hankins Creek
</td>
<td style="text-align:left;">
100-842800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
691820
</td>
<td style="text-align:right;">
5904863
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:right;">
13900100
</td>
<td style="text-align:left;">
Snowshoe Creek
</td>
<td style="text-align:left;">
100-770300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
650785
</td>
<td style="text-align:right;">
5934862
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:right;">
13900201
</td>
<td style="text-align:left;">
Driscoll Creek
</td>
<td style="text-align:left;">
100-698700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
606373
</td>
<td style="text-align:right;">
5965783
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:right;">
13900260
</td>
<td style="text-align:left;">
Tributary to Sugarbowl Creek
</td>
<td style="text-align:left;">
100-683800-01900-12800-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
587920
</td>
<td style="text-align:right;">
5972459
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:right;">
13900308
</td>
<td style="text-align:left;">
Tributary to Fraser River
</td>
<td style="text-align:left;">
100-705400-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
607112
</td>
<td style="text-align:right;">
5971290
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:right;">
13900309
</td>
<td style="text-align:left;">
Tributary to Fraser River
</td>
<td style="text-align:left;">
100-706300-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
608028
</td>
<td style="text-align:right;">
5970651
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:right;">
13903184
</td>
<td style="text-align:left;">
Kenneth Creek
</td>
<td style="text-align:left;">
100-683800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
582280
</td>
<td style="text-align:right;">
5975076
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:right;">
13903452
</td>
<td style="text-align:left;">
Tributary to Fraser River
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
604850
</td>
<td style="text-align:right;">
5973075
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
<tr>
<td style="text-align:right;">
15600119
</td>
<td style="text-align:left;">
Clear Creek
</td>
<td style="text-align:left;">
180-296000-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
425559
</td>
<td style="text-align:right;">
5996140
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:right;">
15600122
</td>
<td style="text-align:left;">
Redmond Creek
</td>
<td style="text-align:left;">
180-305100-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
420920
</td>
<td style="text-align:right;">
5993688
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:right;">
15600277
</td>
<td style="text-align:left;">
Tributary to Nechako River
</td>
<td style="text-align:left;">
180-364700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
399102
</td>
<td style="text-align:right;">
5996464
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:right;">
15600285
</td>
<td style="text-align:left;">
Nine Mile Creek
</td>
<td style="text-align:left;">
180-350800-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
403917
</td>
<td style="text-align:right;">
5998779
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:right;">
15602716
</td>
<td style="text-align:left;">
Tatsutnai Creek
</td>
<td style="text-align:left;">
180-360100-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
400817
</td>
<td style="text-align:right;">
5997662
</td>
<td style="text-align:left;">
NECR
</td>
</tr>
<tr>
<td style="text-align:right;">
19702017
</td>
<td style="text-align:left;">
Bittner Creek
</td>
<td style="text-align:left;">
100-572700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
521562
</td>
<td style="text-align:right;">
5976182
</td>
<td style="text-align:left;">
TABR
</td>
</tr>
<tr>
<td style="text-align:right;">
22201176
</td>
<td style="text-align:left;">
Teepee Creek
</td>
<td style="text-align:left;">
100-907400-42800-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
11
</td>
<td style="text-align:right;">
344030
</td>
<td style="text-align:right;">
5862738
</td>
<td style="text-align:left;">
UFRA
</td>
</tr>
<tr>
<td style="text-align:right;">
22201229
</td>
<td style="text-align:left;">
Holliday Creek
</td>
<td style="text-align:left;">
100-864700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
11
</td>
<td style="text-align:right;">
305966
</td>
<td style="text-align:right;">
5896003
</td>
<td style="text-align:left;">
UFRA
</td>
</tr>
<tr>
<td style="text-align:right;">
24715754
</td>
<td style="text-align:left;">
Tributary to Fraser River
</td>
<td style="text-align:left;">
100-654700-00000-00000-0000-0000-000-000-000-000-000-000
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
576133
</td>
<td style="text-align:right;">
5992812
</td>
<td style="text-align:left;">
MORK
</td>
</tr>
</tbody>
</table>
<div class="page-break">

</div>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-sites3">Table 3: </span>Potential sample site details
</caption>
<thead>
<tr>
<th style="text-align:right;">
id
</th>
<th style="text-align:left;">
stream_name
</th>
<th style="text-align:left;">
sp_upstr
</th>
<th style="text-align:right;">
fish_tags
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right;">
5400202
</td>
<td style="text-align:left;">
Tributary to Fraser Lake
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
5400203
</td>
<td style="text-align:left;">
Scotch Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
5401774
</td>
<td style="text-align:left;">
Sheraton Creek
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
9902577
</td>
<td style="text-align:left;">
Beaverley Creek
</td>
<td style="text-align:left;">
BB;CAS;CBC;CH;CSU;DV;KO;LNC;LSU;MW;NSC;PCC;RB;RSC;SU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
13900077
</td>
<td style="text-align:left;">
Hankins Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
13900100
</td>
<td style="text-align:left;">
Snowshoe Creek
</td>
<td style="text-align:left;">
EB;LKC;RB;RSC;ST
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
13900201
</td>
<td style="text-align:left;">
Driscoll Creek
</td>
<td style="text-align:left;">
CCG;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
13900260
</td>
<td style="text-align:left;">
Tributary to Sugarbowl Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
13900308
</td>
<td style="text-align:left;">
Tributary to Fraser River
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
13900309
</td>
<td style="text-align:left;">
Tributary to Fraser River
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
13903184
</td>
<td style="text-align:left;">
Kenneth Creek
</td>
<td style="text-align:left;">
BT;CC;CCG;CH;LSU;RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
13903452
</td>
<td style="text-align:left;">
Tributary to Fraser River
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
15600119
</td>
<td style="text-align:left;">
Clear Creek
</td>
<td style="text-align:left;">
LKC;LSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
15600122
</td>
<td style="text-align:left;">
Redmond Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
15600277
</td>
<td style="text-align:left;">
Tributary to Nechako River
</td>
<td style="text-align:left;">
SP
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
15600285
</td>
<td style="text-align:left;">
Nine Mile Creek
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
15602716
</td>
<td style="text-align:left;">
Tatsutnai Creek
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
19702017
</td>
<td style="text-align:left;">
Bittner Creek
</td>
<td style="text-align:left;">
CCG;CH;CSU;LSU;RB;RSC;SP;SU;WSU
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
22201176
</td>
<td style="text-align:left;">
Teepee Creek
</td>
<td style="text-align:left;">
SA
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
22201229
</td>
<td style="text-align:left;">
Holliday Creek
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:right;">
150
</td>
</tr>
<tr>
<td style="text-align:right;">
24715754
</td>
<td style="text-align:left;">
Tributary to Fraser River
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:right;">
150
</td>
</tr>
</tbody>
</table>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-fish">Table 4: </span>Fish species recorded in the Fisheries Information Summary System within the freshwater atlas watershed group areas where the potential sample sites are located.
</caption>
<thead>
<tr>
<th style="text-align:left;">
Scientific Name
</th>
<th style="text-align:left;">
Species Name
</th>
<th style="text-align:left;">
Species Code
</th>
<th style="text-align:left;">
BC List
</th>
<th style="text-align:left;">
COSEWIC
</th>
<th style="text-align:left;">
SARA
</th>
<th style="text-align:left;">
Francois Lake
</th>
<th style="text-align:left;">
Lower Chilako
</th>
<th style="text-align:left;">
Nechako
</th>
<th style="text-align:left;">
Upper Fraser
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Acipenser transmontanus
</td>
<td style="text-align:left;">
White Sturgeon
</td>
<td style="text-align:left;">
WSG
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
E/T (Nov 2012)
</td>
<td style="text-align:left;">
1-E
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Carassius auratus
</td>
<td style="text-align:left;">
Goldfish
</td>
<td style="text-align:left;">
GC
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus bondi
</td>
<td style="text-align:left;">
Northern Mountain Sucker
</td>
<td style="text-align:left;">
MSU
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
T (Dec 2022)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus catostomus
</td>
<td style="text-align:left;">
Longnose Sucker
</td>
<td style="text-align:left;">
LSU
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus columbianus
</td>
<td style="text-align:left;">
Bridgelip Sucker
</td>
<td style="text-align:left;">
BSU
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus commersonii
</td>
<td style="text-align:left;">
White Sucker
</td>
<td style="text-align:left;">
WSU
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Catostomus macrocheilus
</td>
<td style="text-align:left;">
Largescale Sucker
</td>
<td style="text-align:left;">
CSU
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Chrosomus neogaeus
</td>
<td style="text-align:left;">
Finescale Dace
</td>
<td style="text-align:left;">
FDC
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Coregonus clupeaformis
</td>
<td style="text-align:left;">
Lake Whitefish
</td>
<td style="text-align:left;">
LW
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus asper
</td>
<td style="text-align:left;">
Prickly Sculpin
</td>
<td style="text-align:left;">
CAS
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus cognatus
</td>
<td style="text-align:left;">
Slimy Sculpin
</td>
<td style="text-align:left;">
CCG
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cottus ricei
</td>
<td style="text-align:left;">
Spoonhead Sculpin
</td>
<td style="text-align:left;">
CRI
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1989)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Couesius plumbeus
</td>
<td style="text-align:left;">
Lake Chub
</td>
<td style="text-align:left;">
LKC
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
DD
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Cyprinus carpio
</td>
<td style="text-align:left;">
Carp
</td>
<td style="text-align:left;">
CP
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Hybognathus hankinsoni
</td>
<td style="text-align:left;">
Brassy Minnow
</td>
<td style="text-align:left;">
BMC
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Lota lota
</td>
<td style="text-align:left;">
Burbot
</td>
<td style="text-align:left;">
BB
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Micropterus salmoides
</td>
<td style="text-align:left;">
Largemouth Bass
</td>
<td style="text-align:left;">
LMB
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Mylocheilus caurinus
</td>
<td style="text-align:left;">
Peamouth Chub
</td>
<td style="text-align:left;">
PCC
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus clarkii
</td>
<td style="text-align:left;">
Cutthroat Trout
</td>
<td style="text-align:left;">
CT
</td>
<td style="text-align:left;">
No Status
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus gorbuscha
</td>
<td style="text-align:left;">
Pink Salmon
</td>
<td style="text-align:left;">
PK
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus kisutch
</td>
<td style="text-align:left;">
Coho Salmon
</td>
<td style="text-align:left;">
CO
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus mykiss
</td>
<td style="text-align:left;">
Rainbow Trout
</td>
<td style="text-align:left;">
RB
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Kokanee
</td>
<td style="text-align:left;">
KO
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus nerka
</td>
<td style="text-align:left;">
Sockeye Salmon
</td>
<td style="text-align:left;">
SK
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Oncorhynchus tshawytscha
</td>
<td style="text-align:left;">
Chinook Salmon
</td>
<td style="text-align:left;">
CH
</td>
<td style="text-align:left;">
Not Reviewed
</td>
<td style="text-align:left;">
E/T/SC/DD/NAR (Nov 2020)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium coulterii
</td>
<td style="text-align:left;">
Pygmy Whitefish
</td>
<td style="text-align:left;">
PW
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (Nov 2016)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Prosopium williamsoni
</td>
<td style="text-align:left;">
Mountain Whitefish
</td>
<td style="text-align:left;">
MW
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Ptychocheilus oregonensis
</td>
<td style="text-align:left;">
Northern Pikeminnow
</td>
<td style="text-align:left;">
NSC
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys cataractae
</td>
<td style="text-align:left;">
Longnose Dace
</td>
<td style="text-align:left;">
LNC
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Rhinichthys falcatus
</td>
<td style="text-align:left;">
Leopard Dace
</td>
<td style="text-align:left;">
LDC
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
NAR (May 1990)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Richardsonius balteatus
</td>
<td style="text-align:left;">
Redside Shiner
</td>
<td style="text-align:left;">
RSC
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus
</td>
<td style="text-align:left;">
Anadromous Bull Trout
</td>
<td style="text-align:left;">
ABT
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
SC (Nov 2012)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus confluentus pop. 26
</td>
<td style="text-align:left;">
Bull Trout
</td>
<td style="text-align:left;">
BT
</td>
<td style="text-align:left;">
Blue
</td>
<td style="text-align:left;">
NAR (Nov 2012)
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus fontinalis
</td>
<td style="text-align:left;">
Brook Trout
</td>
<td style="text-align:left;">
EB
</td>
<td style="text-align:left;">
Exotic
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus malma
</td>
<td style="text-align:left;">
Dolly Varden
</td>
<td style="text-align:left;">
DV
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
Salvelinus namaycush
</td>
<td style="text-align:left;">
Lake Trout
</td>
<td style="text-align:left;">
LT
</td>
<td style="text-align:left;">
Yellow
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
All Salmon
</td>
<td style="text-align:left;">
AO
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Char, General
</td>
<td style="text-align:left;">
SLV
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Chub (General)
</td>
<td style="text-align:left;">
CBC
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Dace (General)
</td>
<td style="text-align:left;">
DC
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Minnow (General)
</td>
<td style="text-align:left;">
C
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Northern Pearl Dace
</td>
<td style="text-align:left;">
PDC
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Salmon (General)
</td>
<td style="text-align:left;">
SA
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sculpin (General)
</td>
<td style="text-align:left;">
CC
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Sucker (General)
</td>
<td style="text-align:left;">
SU
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Whitefish (General)
</td>
<td style="text-align:left;">
WF
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
<td style="text-align:left;">
Yes
</td>
</tr>
</tbody>
</table>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
